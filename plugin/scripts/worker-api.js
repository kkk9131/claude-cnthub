// @bun
var Sk = Object.create;
var {
  getPrototypeOf: Tk,
  defineProperty: p$,
  getOwnPropertyNames: bk,
} = Object;
var vk = Object.prototype.hasOwnProperty;
var AY = (X, Y, Q) => {
  Q = X != null ? Sk(Tk(X)) : {};
  let G =
    Y || !X || !X.__esModule
      ? p$(Q, "default", { value: X, enumerable: !0 })
      : Q;
  for (let J of bk(X))
    if (!vk.call(G, J)) p$(G, J, { get: () => X[J], enumerable: !0 });
  return G;
};
var s = (X, Y) => () => (Y || X((Y = { exports: {} }).exports, Y), Y.exports);
var wD = (X, Y) => {
  for (var Q in Y)
    p$(X, Q, {
      get: Y[Q],
      enumerable: !0,
      configurable: !0,
      set: (G) => (Y[Q] = () => G),
    });
};
var U8 = (X, Y) => () => (X && (Y = X((X = 0))), Y);
var k1 = import.meta.require;
var TG = s((LG0, Tz) => {
  var __dirname =
      "/Users/kazuto/Desktop/claude-cnthub/node_modules/.bun/sqlite-vec@0.1.7-alpha.2/node_modules/sqlite-vec",
    { join: C_ } = k1("path"),
    { fileURLToPath: UG0 } = k1("url"),
    { arch: VU, platform: SG } = k1("process"),
    { statSync: I_ } = k1("fs"),
    Pz = [
      ["macos", "aarch64"],
      ["linux", "aarch64"],
      ["windows", "x86_64"],
      ["linux", "x86_64"],
      ["macos", "x86_64"],
    ],
    P_ = `Unsupported platform for sqlite-vec, on a ${SG}-${VU} machine. Supported platforms are (${Pz.map(([X, Y]) => `${X}-${Y}`).join(",")}). Consult the sqlite-vec NPM package README for details.`,
    S_ = (X) =>
      `Loadble extension for sqlite-vec not found. Was the ${X} package installed?`;
  function T_(X, Y) {
    return Pz.find(([Q, G]) => X == Q && Y === G) !== null;
  }
  function b_(X) {
    if (X === "win32") return "dll";
    if (X === "darwin") return "dylib";
    return "so";
  }
  function v_(X, Y) {
    return `sqlite-vec-${X === "win32" ? "windows" : X}-${Y}`;
  }
  function Sz() {
    if (!T_(SG, VU)) throw Error(P_);
    let X = v_(SG, VU),
      Y = C_(__dirname, "..", X, `vec0.${b_(SG)}`);
    if (!I_(Y, { throwIfNoEntry: !1 })) throw Error(S_(X));
    return Y;
  }
  function k_(X) {
    X.loadExtension(Sz());
  }
  Tz.exports = { getLoadablePath: Sz, load: k_ };
});
var _Z = s((yZ) => {
  Object.defineProperty(yZ, "__esModule", { value: !0 });
});
var hZ = s((fZ) => {
  Object.defineProperty(fZ, "__esModule", { value: !0 });
  fZ.EmbedRequestInputType = void 0;
  fZ.EmbedRequestInputType = { Query: "query", Document: "document" };
});
var lZ = s((gZ) => {
  Object.defineProperty(gZ, "__esModule", { value: !0 });
  gZ.EmbedRequestOutputDtype = void 0;
  gZ.EmbedRequestOutputDtype = {
    Float: "float",
    Int8: "int8",
    Uint8: "uint8",
    Binary: "binary",
    Ubinary: "ubinary",
  };
});
var cZ = s((mZ) => {
  Object.defineProperty(mZ, "__esModule", { value: !0 });
});
var pZ = s((dZ) => {
  Object.defineProperty(dZ, "__esModule", { value: !0 });
});
var nZ = s((iZ) => {
  Object.defineProperty(iZ, "__esModule", { value: !0 });
});
var rZ = s((aZ) => {
  Object.defineProperty(aZ, "__esModule", { value: !0 });
});
var sZ = s((oZ) => {
  Object.defineProperty(oZ, "__esModule", { value: !0 });
});
var eZ = s((tZ) => {
  Object.defineProperty(tZ, "__esModule", { value: !0 });
});
var Y2 = s((X2) => {
  Object.defineProperty(X2, "__esModule", { value: !0 });
});
var G2 = s((Q2) => {
  Object.defineProperty(Q2, "__esModule", { value: !0 });
});
var H2 = s((J2) => {
  Object.defineProperty(J2, "__esModule", { value: !0 });
  J2.MultimodalEmbedRequestInputType = void 0;
  J2.MultimodalEmbedRequestInputType = { Query: "query", Document: "document" };
});
var U2 = s(($2) => {
  Object.defineProperty($2, "__esModule", { value: !0 });
});
var B2 = s((L2) => {
  Object.defineProperty(L2, "__esModule", { value: !0 });
});
var V2 = s((K2) => {
  Object.defineProperty(K2, "__esModule", { value: !0 });
});
var M2 = s((F2) => {
  Object.defineProperty(F2, "__esModule", { value: !0 });
  F2.ContextualizedEmbedRequestInputType = void 0;
  F2.ContextualizedEmbedRequestInputType = {
    Query: "query",
    Document: "document",
  };
});
var R2 = s((A2) => {
  Object.defineProperty(A2, "__esModule", { value: !0 });
  A2.ContextualizedEmbedRequestOutputDtype = void 0;
  A2.ContextualizedEmbedRequestOutputDtype = {
    Float: "float",
    Int8: "int8",
    Uint8: "uint8",
    Binary: "binary",
    Ubinary: "ubinary",
  };
});
var z2 = s((D2) => {
  Object.defineProperty(D2, "__esModule", { value: !0 });
});
var O2 = s((E2) => {
  Object.defineProperty(E2, "__esModule", { value: !0 });
});
var j2 = s((Z2) => {
  Object.defineProperty(Z2, "__esModule", { value: !0 });
});
var C2 = s((w2) => {
  Object.defineProperty(w2, "__esModule", { value: !0 });
});
var I2 = s((r1) => {
  var ei =
      (r1 && r1.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    z5 =
      (r1 && r1.__exportStar) ||
      function (X, Y) {
        for (var Q in X)
          if (Q !== "default" && !Object.prototype.hasOwnProperty.call(Y, Q))
            ei(Y, X, Q);
      };
  Object.defineProperty(r1, "__esModule", { value: !0 });
  z5(_Z(), r1);
  z5(hZ(), r1);
  z5(lZ(), r1);
  z5(cZ(), r1);
  z5(pZ(), r1);
  z5(nZ(), r1);
  z5(rZ(), r1);
  z5(sZ(), r1);
  z5(eZ(), r1);
  z5(Y2(), r1);
  z5(G2(), r1);
  z5(H2(), r1);
  z5(U2(), r1);
  z5(B2(), r1);
  z5(V2(), r1);
  z5(M2(), r1);
  z5(R2(), r1);
  z5(z2(), r1);
  z5(O2(), r1);
  z5(j2(), r1);
  z5(C2(), r1);
});
var S2 = s((P2) => {
  Object.defineProperty(P2, "__esModule", { value: !0 });
});
var T2 = s((g9) => {
  var Xn =
      (g9 && g9.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    Yn =
      (g9 && g9.__exportStar) ||
      function (X, Y) {
        for (var Q in X)
          if (Q !== "default" && !Object.prototype.hasOwnProperty.call(Y, Q))
            Xn(Y, X, Q);
      };
  Object.defineProperty(g9, "__esModule", { value: !0 });
  Yn(S2(), g9);
});
var v2 = s((d4) => {
  var Qn =
      (d4 && d4.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    b2 =
      (d4 && d4.__exportStar) ||
      function (X, Y) {
        for (var Q in X)
          if (Q !== "default" && !Object.prototype.hasOwnProperty.call(Y, Q))
            Qn(Y, X, Q);
      };
  Object.defineProperty(d4, "__esModule", { value: !0 });
  b2(I2(), d4);
  b2(T2(), d4);
});
var BL = s((k2) => {
  Object.defineProperty(k2, "__esModule", { value: !0 });
  k2.VoyageAIEnvironment = void 0;
  k2.VoyageAIEnvironment = { Default: "https://api.voyageai.com/v1" };
});
var u9 = s((lH0, _2) => {
  _2.exports = TypeError;
});
var x2 = s((mH0, f2) => {
  f2.exports = k1("util").inspect;
});
var UQ = s((cH0, Gj) => {
  var zL = typeof Map === "function" && Map.prototype,
    KL =
      Object.getOwnPropertyDescriptor && zL
        ? Object.getOwnPropertyDescriptor(Map.prototype, "size")
        : null,
    bJ = zL && KL && typeof KL.get === "function" ? KL.get : null,
    h2 = zL && Map.prototype.forEach,
    EL = typeof Set === "function" && Set.prototype,
    VL =
      Object.getOwnPropertyDescriptor && EL
        ? Object.getOwnPropertyDescriptor(Set.prototype, "size")
        : null,
    vJ = EL && VL && typeof VL.get === "function" ? VL.get : null,
    g2 = EL && Set.prototype.forEach,
    Gn = typeof WeakMap === "function" && WeakMap.prototype,
    WQ = Gn ? WeakMap.prototype.has : null,
    Jn = typeof WeakSet === "function" && WeakSet.prototype,
    HQ = Jn ? WeakSet.prototype.has : null,
    Wn = typeof WeakRef === "function" && WeakRef.prototype,
    u2 = Wn ? WeakRef.prototype.deref : null,
    Hn = Boolean.prototype.valueOf,
    $n = Object.prototype.toString,
    Un = Function.prototype.toString,
    Ln = String.prototype.match,
    OL = String.prototype.slice,
    p4 = String.prototype.replace,
    Bn = String.prototype.toUpperCase,
    l2 = String.prototype.toLowerCase,
    o2 = RegExp.prototype.test,
    m2 = Array.prototype.concat,
    K6 = Array.prototype.join,
    Kn = Array.prototype.slice,
    c2 = Math.floor,
    ML = typeof BigInt === "function" ? BigInt.prototype.valueOf : null,
    FL = Object.getOwnPropertySymbols,
    AL =
      typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
        ? Symbol.prototype.toString
        : null,
    M7 = typeof Symbol === "function" && typeof Symbol.iterator === "object",
    $Q =
      typeof Symbol === "function" &&
      Symbol.toStringTag &&
      (typeof Symbol.toStringTag === M7 ? "object" : "symbol")
        ? Symbol.toStringTag
        : null,
    s2 = Object.prototype.propertyIsEnumerable,
    d2 =
      (typeof Reflect === "function"
        ? Reflect.getPrototypeOf
        : Object.getPrototypeOf) ||
      ([].__proto__ === Array.prototype
        ? function (X) {
            return X.__proto__;
          }
        : null);
  function p2(X, Y) {
    if (
      X === 1 / 0 ||
      X === -1 / 0 ||
      X !== X ||
      (X && X > -1000 && X < 1000) ||
      o2.call(/e/, Y)
    )
      return Y;
    var Q = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof X === "number") {
      var G = X < 0 ? -c2(-X) : c2(X);
      if (G !== X) {
        var J = String(G),
          U = OL.call(Y, J.length + 1);
        return (
          p4.call(J, Q, "$&_") +
          "." +
          p4.call(p4.call(U, /([0-9]{3})/g, "$&_"), /_$/, "")
        );
      }
    }
    return p4.call(Y, Q, "$&_");
  }
  var qL = x2(),
    i2 = qL.custom,
    n2 = Xj(i2) ? i2 : null,
    t2 = { __proto__: null, double: '"', single: "'" },
    Vn = { __proto__: null, double: /(["\\])/g, single: /(['\\])/g };
  Gj.exports = function X(Y, Q, G, J) {
    var U = Q || {};
    if (B4(U, "quoteStyle") && !B4(t2, U.quoteStyle))
      throw TypeError('option "quoteStyle" must be "single" or "double"');
    if (
      B4(U, "maxStringLength") &&
      (typeof U.maxStringLength === "number"
        ? U.maxStringLength < 0 && U.maxStringLength !== 1 / 0
        : U.maxStringLength !== null)
    )
      throw TypeError(
        'option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`'
      );
    var $ = B4(U, "customInspect") ? U.customInspect : !0;
    if (typeof $ !== "boolean" && $ !== "symbol")
      throw TypeError(
        "option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`"
      );
    if (
      B4(U, "indent") &&
      U.indent !== null &&
      U.indent !== "\t" &&
      !(parseInt(U.indent, 10) === U.indent && U.indent > 0)
    )
      throw TypeError(
        'option "indent" must be "\\t", an integer > 0, or `null`'
      );
    if (B4(U, "numericSeparator") && typeof U.numericSeparator !== "boolean")
      throw TypeError(
        'option "numericSeparator", if provided, must be `true` or `false`'
      );
    var B = U.numericSeparator;
    if (typeof Y > "u") return "undefined";
    if (Y === null) return "null";
    if (typeof Y === "boolean") return Y ? "true" : "false";
    if (typeof Y === "string") return Qj(Y, U);
    if (typeof Y === "number") {
      if (Y === 0) return 1 / 0 / Y > 0 ? "0" : "-0";
      var K = String(Y);
      return B ? p2(Y, K) : K;
    }
    if (typeof Y === "bigint") {
      var V = String(Y) + "n";
      return B ? p2(Y, V) : V;
    }
    var W = typeof U.depth > "u" ? 5 : U.depth;
    if (typeof G > "u") G = 0;
    if (G >= W && W > 0 && typeof Y === "object")
      return RL(Y) ? "[Array]" : "[Object]";
    var L = Tn(U, G);
    if (typeof J > "u") J = [];
    else if (Yj(J, Y) >= 0) return "[Circular]";
    function H(_, f, l) {
      if (f) ((J = Kn.call(J)), J.push(f));
      if (l) {
        var h = { depth: U.depth };
        if (B4(U, "quoteStyle")) h.quoteStyle = U.quoteStyle;
        return X(_, h, G + 1, J);
      }
      return X(_, U, G + 1, J);
    }
    if (typeof Y === "function" && !a2(Y)) {
      var F = En(Y),
        N = TJ(Y, H);
      return (
        "[Function" +
        (F ? ": " + F : " (anonymous)") +
        "]" +
        (N.length > 0 ? " { " + K6.call(N, ", ") + " }" : "")
      );
    }
    if (Xj(Y)) {
      var q = M7
        ? p4.call(String(Y), /^(Symbol\(.*\))_[^)]*$/, "$1")
        : AL.call(Y);
      return typeof Y === "object" && !M7 ? JQ(q) : q;
    }
    if (In(Y)) {
      var M = "<" + l2.call(String(Y.nodeName)),
        A = Y.attributes || [];
      for (var D = 0; D < A.length; D++)
        M += " " + A[D].name + "=" + e2(Fn(A[D].value), "double", U);
      if (((M += ">"), Y.childNodes && Y.childNodes.length)) M += "...";
      return ((M += "</" + l2.call(String(Y.nodeName)) + ">"), M);
    }
    if (RL(Y)) {
      if (Y.length === 0) return "[]";
      var R = TJ(Y, H);
      if (L && !Sn(R)) return "[" + DL(R, L) + "]";
      return "[ " + K6.call(R, ", ") + " ]";
    }
    if (Mn(Y)) {
      var z = TJ(Y, H);
      if (!("cause" in Error.prototype) && "cause" in Y && !s2.call(Y, "cause"))
        return (
          "{ [" +
          String(Y) +
          "] " +
          K6.call(m2.call("[cause]: " + H(Y.cause), z), ", ") +
          " }"
        );
      if (z.length === 0) return "[" + String(Y) + "]";
      return "{ [" + String(Y) + "] " + K6.call(z, ", ") + " }";
    }
    if (typeof Y === "object" && $) {
      if (n2 && typeof Y[n2] === "function" && qL)
        return qL(Y, { depth: W - G });
      else if ($ !== "symbol" && typeof Y.inspect === "function")
        return Y.inspect();
    }
    if (On(Y)) {
      var E = [];
      if (h2)
        h2.call(Y, function (_, f) {
          E.push(H(f, Y, !0) + " => " + H(_, Y));
        });
      return r2("Map", bJ.call(Y), E, L);
    }
    if (wn(Y)) {
      var O = [];
      if (g2)
        g2.call(Y, function (_) {
          O.push(H(_, Y));
        });
      return r2("Set", vJ.call(Y), O, L);
    }
    if (Zn(Y)) return NL("WeakMap");
    if (Cn(Y)) return NL("WeakSet");
    if (jn(Y)) return NL("WeakRef");
    if (qn(Y)) return JQ(H(Number(Y)));
    if (Dn(Y)) return JQ(H(ML.call(Y)));
    if (Rn(Y)) return JQ(Hn.call(Y));
    if (An(Y)) return JQ(H(String(Y)));
    if (typeof window < "u" && Y === window) return "{ [object Window] }";
    if (
      (typeof globalThis < "u" && Y === globalThis) ||
      (typeof global < "u" && Y === global)
    )
      return "{ [object globalThis] }";
    if (!Nn(Y) && !a2(Y)) {
      var Z = TJ(Y, H),
        j = d2
          ? d2(Y) === Object.prototype
          : Y instanceof Object || Y.constructor === Object,
        w = Y instanceof Object ? "" : "null prototype",
        I =
          !j && $Q && Object(Y) === Y && $Q in Y
            ? OL.call(i4(Y), 8, -1)
            : w
              ? "Object"
              : "",
        T =
          j || typeof Y.constructor !== "function"
            ? ""
            : Y.constructor.name
              ? Y.constructor.name + " "
              : "",
        y =
          T +
          (I || w
            ? "[" + K6.call(m2.call([], I || [], w || []), ": ") + "] "
            : "");
      if (Z.length === 0) return y + "{}";
      if (L) return y + "{" + DL(Z, L) + "}";
      return y + "{ " + K6.call(Z, ", ") + " }";
    }
    return String(Y);
  };
  function e2(X, Y, Q) {
    var G = Q.quoteStyle || Y,
      J = t2[G];
    return J + X + J;
  }
  function Fn(X) {
    return p4.call(String(X), /"/g, "&quot;");
  }
  function l9(X) {
    return !$Q || !(typeof X === "object" && ($Q in X || typeof X[$Q] < "u"));
  }
  function RL(X) {
    return i4(X) === "[object Array]" && l9(X);
  }
  function Nn(X) {
    return i4(X) === "[object Date]" && l9(X);
  }
  function a2(X) {
    return i4(X) === "[object RegExp]" && l9(X);
  }
  function Mn(X) {
    return i4(X) === "[object Error]" && l9(X);
  }
  function An(X) {
    return i4(X) === "[object String]" && l9(X);
  }
  function qn(X) {
    return i4(X) === "[object Number]" && l9(X);
  }
  function Rn(X) {
    return i4(X) === "[object Boolean]" && l9(X);
  }
  function Xj(X) {
    if (M7) return X && typeof X === "object" && X instanceof Symbol;
    if (typeof X === "symbol") return !0;
    if (!X || typeof X !== "object" || !AL) return !1;
    try {
      return (AL.call(X), !0);
    } catch (Y) {}
    return !1;
  }
  function Dn(X) {
    if (!X || typeof X !== "object" || !ML) return !1;
    try {
      return (ML.call(X), !0);
    } catch (Y) {}
    return !1;
  }
  var zn =
    Object.prototype.hasOwnProperty ||
    function (X) {
      return X in this;
    };
  function B4(X, Y) {
    return zn.call(X, Y);
  }
  function i4(X) {
    return $n.call(X);
  }
  function En(X) {
    if (X.name) return X.name;
    var Y = Ln.call(Un.call(X), /^function\s*([\w$]+)/);
    if (Y) return Y[1];
    return null;
  }
  function Yj(X, Y) {
    if (X.indexOf) return X.indexOf(Y);
    for (var Q = 0, G = X.length; Q < G; Q++) if (X[Q] === Y) return Q;
    return -1;
  }
  function On(X) {
    if (!bJ || !X || typeof X !== "object") return !1;
    try {
      bJ.call(X);
      try {
        vJ.call(X);
      } catch (Y) {
        return !0;
      }
      return X instanceof Map;
    } catch (Y) {}
    return !1;
  }
  function Zn(X) {
    if (!WQ || !X || typeof X !== "object") return !1;
    try {
      WQ.call(X, WQ);
      try {
        HQ.call(X, HQ);
      } catch (Y) {
        return !0;
      }
      return X instanceof WeakMap;
    } catch (Y) {}
    return !1;
  }
  function jn(X) {
    if (!u2 || !X || typeof X !== "object") return !1;
    try {
      return (u2.call(X), !0);
    } catch (Y) {}
    return !1;
  }
  function wn(X) {
    if (!vJ || !X || typeof X !== "object") return !1;
    try {
      vJ.call(X);
      try {
        bJ.call(X);
      } catch (Y) {
        return !0;
      }
      return X instanceof Set;
    } catch (Y) {}
    return !1;
  }
  function Cn(X) {
    if (!HQ || !X || typeof X !== "object") return !1;
    try {
      HQ.call(X, HQ);
      try {
        WQ.call(X, WQ);
      } catch (Y) {
        return !0;
      }
      return X instanceof WeakSet;
    } catch (Y) {}
    return !1;
  }
  function In(X) {
    if (!X || typeof X !== "object") return !1;
    if (typeof HTMLElement < "u" && X instanceof HTMLElement) return !0;
    return (
      typeof X.nodeName === "string" && typeof X.getAttribute === "function"
    );
  }
  function Qj(X, Y) {
    if (X.length > Y.maxStringLength) {
      var Q = X.length - Y.maxStringLength,
        G = "... " + Q + " more character" + (Q > 1 ? "s" : "");
      return Qj(OL.call(X, 0, Y.maxStringLength), Y) + G;
    }
    var J = Vn[Y.quoteStyle || "single"];
    J.lastIndex = 0;
    var U = p4.call(p4.call(X, J, "\\$1"), /[\x00-\x1f]/g, Pn);
    return e2(U, "single", Y);
  }
  function Pn(X) {
    var Y = X.charCodeAt(0),
      Q = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[Y];
    if (Q) return "\\" + Q;
    return "\\x" + (Y < 16 ? "0" : "") + Bn.call(Y.toString(16));
  }
  function JQ(X) {
    return "Object(" + X + ")";
  }
  function NL(X) {
    return X + " { ? }";
  }
  function r2(X, Y, Q, G) {
    var J = G ? DL(Q, G) : K6.call(Q, ", ");
    return X + " (" + Y + ") {" + J + "}";
  }
  function Sn(X) {
    for (var Y = 0; Y < X.length; Y++)
      if (
        Yj(
          X[Y],
          `
`
        ) >= 0
      )
        return !1;
    return !0;
  }
  function Tn(X, Y) {
    var Q;
    if (X.indent === "\t") Q = "\t";
    else if (typeof X.indent === "number" && X.indent > 0)
      Q = K6.call(Array(X.indent + 1), " ");
    else return null;
    return { base: Q, prev: K6.call(Array(Y + 1), Q) };
  }
  function DL(X, Y) {
    if (X.length === 0) return "";
    var Q =
      `
` +
      Y.prev +
      Y.base;
    return (
      Q +
      K6.call(X, "," + Q) +
      `
` +
      Y.prev
    );
  }
  function TJ(X, Y) {
    var Q = RL(X),
      G = [];
    if (Q) {
      G.length = X.length;
      for (var J = 0; J < X.length; J++) G[J] = B4(X, J) ? Y(X[J], X) : "";
    }
    var U = typeof FL === "function" ? FL(X) : [],
      $;
    if (M7) {
      $ = {};
      for (var B = 0; B < U.length; B++) $["$" + U[B]] = U[B];
    }
    for (var K in X) {
      if (!B4(X, K)) continue;
      if (Q && String(Number(K)) === K && K < X.length) continue;
      if (M7 && $["$" + K] instanceof Symbol) continue;
      else if (o2.call(/[^\w$]/, K)) G.push(Y(K, X) + ": " + Y(X[K], X));
      else G.push(K + ": " + Y(X[K], X));
    }
    if (typeof FL === "function") {
      for (var V = 0; V < U.length; V++)
        if (s2.call(X, U[V])) G.push("[" + Y(U[V]) + "]: " + Y(X[U[V]], X));
    }
    return G;
  }
});
var Wj = s((dH0, Jj) => {
  var bn = UQ(),
    vn = u9(),
    kJ = function (X, Y, Q) {
      var G = X,
        J;
      for (; (J = G.next) != null; G = J)
        if (J.key === Y) {
          if (((G.next = J.next), !Q)) ((J.next = X.next), (X.next = J));
          return J;
        }
    },
    kn = function (X, Y) {
      if (!X) return;
      var Q = kJ(X, Y);
      return Q && Q.value;
    },
    yn = function (X, Y, Q) {
      var G = kJ(X, Y);
      if (G) G.value = Q;
      else X.next = { key: Y, next: X.next, value: Q };
    },
    _n = function (X, Y) {
      if (!X) return !1;
      return !!kJ(X, Y);
    },
    fn = function (X, Y) {
      if (X) return kJ(X, Y, !0);
    };
  Jj.exports = function () {
    var Y,
      Q = {
        assert: function (G) {
          if (!Q.has(G)) throw new vn("Side channel does not contain " + bn(G));
        },
        delete: function (G) {
          var J = Y && Y.next,
            U = fn(Y, G);
          if (U && J && J === U) Y = void 0;
          return !!U;
        },
        get: function (G) {
          return kn(Y, G);
        },
        has: function (G) {
          return _n(Y, G);
        },
        set: function (G, J) {
          if (!Y) Y = { next: void 0 };
          yn(Y, G, J);
        },
      };
    return Q;
  };
});
var ZL = s((pH0, Hj) => {
  Hj.exports = Object;
});
var Uj = s((iH0, $j) => {
  $j.exports = Error;
});
var Bj = s((nH0, Lj) => {
  Lj.exports = EvalError;
});
var Vj = s((aH0, Kj) => {
  Kj.exports = RangeError;
});
var Nj = s((rH0, Fj) => {
  Fj.exports = ReferenceError;
});
var Aj = s((oH0, Mj) => {
  Mj.exports = SyntaxError;
});
var Rj = s((sH0, qj) => {
  qj.exports = URIError;
});
var zj = s((tH0, Dj) => {
  Dj.exports = Math.abs;
});
var Oj = s((eH0, Ej) => {
  Ej.exports = Math.floor;
});
var jj = s((X$0, Zj) => {
  Zj.exports = Math.max;
});
var Cj = s((Y$0, wj) => {
  wj.exports = Math.min;
});
var Pj = s((Q$0, Ij) => {
  Ij.exports = Math.pow;
});
var Tj = s((G$0, Sj) => {
  Sj.exports = Math.round;
});
var vj = s((J$0, bj) => {
  bj.exports =
    Number.isNaN ||
    function (Y) {
      return Y !== Y;
    };
});
var yj = s((W$0, kj) => {
  var xn = vj();
  kj.exports = function (Y) {
    if (xn(Y) || Y === 0) return Y;
    return Y < 0 ? -1 : 1;
  };
});
var fj = s((H$0, _j) => {
  _j.exports = Object.getOwnPropertyDescriptor;
});
var jL = s(($$0, xj) => {
  var yJ = fj();
  if (yJ)
    try {
      yJ([], "length");
    } catch (X) {
      yJ = null;
    }
  xj.exports = yJ;
});
var gj = s((U$0, hj) => {
  var _J = Object.defineProperty || !1;
  if (_J)
    try {
      _J({}, "a", { value: 1 });
    } catch (X) {
      _J = !1;
    }
  hj.exports = _J;
});
var lj = s((L$0, uj) => {
  uj.exports = function () {
    if (
      typeof Symbol !== "function" ||
      typeof Object.getOwnPropertySymbols !== "function"
    )
      return !1;
    if (typeof Symbol.iterator === "symbol") return !0;
    var Y = {},
      Q = Symbol("test"),
      G = Object(Q);
    if (typeof Q === "string") return !1;
    if (Object.prototype.toString.call(Q) !== "[object Symbol]") return !1;
    if (Object.prototype.toString.call(G) !== "[object Symbol]") return !1;
    var J = 42;
    Y[Q] = J;
    for (var U in Y) return !1;
    if (typeof Object.keys === "function" && Object.keys(Y).length !== 0)
      return !1;
    if (
      typeof Object.getOwnPropertyNames === "function" &&
      Object.getOwnPropertyNames(Y).length !== 0
    )
      return !1;
    var $ = Object.getOwnPropertySymbols(Y);
    if ($.length !== 1 || $[0] !== Q) return !1;
    if (!Object.prototype.propertyIsEnumerable.call(Y, Q)) return !1;
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var B = Object.getOwnPropertyDescriptor(Y, Q);
      if (B.value !== J || B.enumerable !== !0) return !1;
    }
    return !0;
  };
});
var dj = s((B$0, cj) => {
  var mj = typeof Symbol < "u" && Symbol,
    hn = lj();
  cj.exports = function () {
    if (typeof mj !== "function") return !1;
    if (typeof Symbol !== "function") return !1;
    if (typeof mj("foo") !== "symbol") return !1;
    if (typeof Symbol("bar") !== "symbol") return !1;
    return hn();
  };
});
var wL = s((K$0, pj) => {
  pj.exports = (typeof Reflect < "u" && Reflect.getPrototypeOf) || null;
});
var CL = s((V$0, ij) => {
  var gn = ZL();
  ij.exports = gn.getPrototypeOf || null;
});
var rj = s((F$0, aj) => {
  var un = "Function.prototype.bind called on incompatible ",
    ln = Object.prototype.toString,
    mn = Math.max,
    cn = "[object Function]",
    nj = function (Y, Q) {
      var G = [];
      for (var J = 0; J < Y.length; J += 1) G[J] = Y[J];
      for (var U = 0; U < Q.length; U += 1) G[U + Y.length] = Q[U];
      return G;
    },
    dn = function (Y, Q) {
      var G = [];
      for (var J = Q || 0, U = 0; J < Y.length; J += 1, U += 1) G[U] = Y[J];
      return G;
    },
    pn = function (X, Y) {
      var Q = "";
      for (var G = 0; G < X.length; G += 1)
        if (((Q += X[G]), G + 1 < X.length)) Q += Y;
      return Q;
    };
  aj.exports = function (Y) {
    var Q = this;
    if (typeof Q !== "function" || ln.apply(Q) !== cn) throw TypeError(un + Q);
    var G = dn(arguments, 1),
      J,
      U = function () {
        if (this instanceof J) {
          var W = Q.apply(this, nj(G, arguments));
          if (Object(W) === W) return W;
          return this;
        }
        return Q.apply(Y, nj(G, arguments));
      },
      $ = mn(0, Q.length - G.length),
      B = [];
    for (var K = 0; K < $; K++) B[K] = "$" + K;
    if (
      ((J = Function(
        "binder",
        "return function (" +
          pn(B, ",") +
          "){ return binder.apply(this,arguments); }"
      )(U)),
      Q.prototype)
    ) {
      var V = function () {};
      ((V.prototype = Q.prototype),
        (J.prototype = new V()),
        (V.prototype = null));
    }
    return J;
  };
});
var LQ = s((N$0, oj) => {
  var nn = rj();
  oj.exports = Function.prototype.bind || nn;
});
var fJ = s((M$0, sj) => {
  sj.exports = Function.prototype.call;
});
var IL = s((A$0, tj) => {
  tj.exports = Function.prototype.apply;
});
var X3 = s((q$0, ej) => {
  ej.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
});
var Q3 = s((R$0, Y3) => {
  var an = LQ(),
    rn = IL(),
    on = fJ(),
    sn = X3();
  Y3.exports = sn || an.call(on, rn);
});
var PL = s((D$0, G3) => {
  var tn = LQ(),
    en = u9(),
    Xa = fJ(),
    Ya = Q3();
  G3.exports = function (Y) {
    if (Y.length < 1 || typeof Y[0] !== "function")
      throw new en("a function is required");
    return Ya(tn, Xa, Y);
  };
});
var L3 = s((z$0, U3) => {
  var Qa = PL(),
    J3 = jL(),
    H3;
  try {
    H3 = [].__proto__ === Array.prototype;
  } catch (X) {
    if (
      !X ||
      typeof X !== "object" ||
      !("code" in X) ||
      X.code !== "ERR_PROTO_ACCESS"
    )
      throw X;
  }
  var SL = !!H3 && J3 && J3(Object.prototype, "__proto__"),
    $3 = Object,
    W3 = $3.getPrototypeOf;
  U3.exports =
    SL && typeof SL.get === "function"
      ? Qa([SL.get])
      : typeof W3 === "function"
        ? function (Y) {
            return W3(Y == null ? Y : $3(Y));
          }
        : !1;
});
var N3 = s((E$0, F3) => {
  var B3 = wL(),
    K3 = CL(),
    V3 = L3();
  F3.exports = B3
    ? function (Y) {
        return B3(Y);
      }
    : K3
      ? function (Y) {
          if (!Y || (typeof Y !== "object" && typeof Y !== "function"))
            throw TypeError("getProto: not an object");
          return K3(Y);
        }
      : V3
        ? function (Y) {
            return V3(Y);
          }
        : null;
});
var A3 = s((O$0, M3) => {
  var Ga = Function.prototype.call,
    Ja = Object.prototype.hasOwnProperty,
    Wa = LQ();
  M3.exports = Wa.call(Ga, Ja);
});
var gJ = s((Z$0, E3) => {
  var P1,
    Ha = ZL(),
    $a = Uj(),
    Ua = Bj(),
    La = Vj(),
    Ba = Nj(),
    D7 = Aj(),
    R7 = u9(),
    Ka = Rj(),
    Va = zj(),
    Fa = Oj(),
    Na = jj(),
    Ma = Cj(),
    Aa = Pj(),
    qa = Tj(),
    Ra = yj(),
    D3 = Function,
    TL = function (X) {
      try {
        return D3('"use strict"; return (' + X + ").constructor;")();
      } catch (Y) {}
    },
    BQ = jL(),
    Da = gj(),
    bL = function () {
      throw new R7();
    },
    za = BQ
      ? (function () {
          try {
            return (arguments.callee, bL);
          } catch (X) {
            try {
              return BQ(arguments, "callee").get;
            } catch (Y) {
              return bL;
            }
          }
        })()
      : bL,
    A7 = dj()(),
    k5 = N3(),
    Ea = CL(),
    Oa = wL(),
    z3 = IL(),
    KQ = fJ(),
    q7 = {},
    Za = typeof Uint8Array > "u" || !k5 ? P1 : k5(Uint8Array),
    m9 = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError > "u" ? P1 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer > "u" ? P1 : ArrayBuffer,
      "%ArrayIteratorPrototype%": A7 && k5 ? k5([][Symbol.iterator]()) : P1,
      "%AsyncFromSyncIteratorPrototype%": P1,
      "%AsyncFunction%": q7,
      "%AsyncGenerator%": q7,
      "%AsyncGeneratorFunction%": q7,
      "%AsyncIteratorPrototype%": q7,
      "%Atomics%": typeof Atomics > "u" ? P1 : Atomics,
      "%BigInt%": typeof BigInt > "u" ? P1 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array > "u" ? P1 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array > "u" ? P1 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView > "u" ? P1 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $a,
      "%eval%": eval,
      "%EvalError%": Ua,
      "%Float16Array%": typeof Float16Array > "u" ? P1 : Float16Array,
      "%Float32Array%": typeof Float32Array > "u" ? P1 : Float32Array,
      "%Float64Array%": typeof Float64Array > "u" ? P1 : Float64Array,
      "%FinalizationRegistry%":
        typeof FinalizationRegistry > "u" ? P1 : FinalizationRegistry,
      "%Function%": D3,
      "%GeneratorFunction%": q7,
      "%Int8Array%": typeof Int8Array > "u" ? P1 : Int8Array,
      "%Int16Array%": typeof Int16Array > "u" ? P1 : Int16Array,
      "%Int32Array%": typeof Int32Array > "u" ? P1 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": A7 && k5 ? k5(k5([][Symbol.iterator]())) : P1,
      "%JSON%": typeof JSON === "object" ? JSON : P1,
      "%Map%": typeof Map > "u" ? P1 : Map,
      "%MapIteratorPrototype%":
        typeof Map > "u" || !A7 || !k5 ? P1 : k5(new Map()[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Ha,
      "%Object.getOwnPropertyDescriptor%": BQ,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise > "u" ? P1 : Promise,
      "%Proxy%": typeof Proxy > "u" ? P1 : Proxy,
      "%RangeError%": La,
      "%ReferenceError%": Ba,
      "%Reflect%": typeof Reflect > "u" ? P1 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set > "u" ? P1 : Set,
      "%SetIteratorPrototype%":
        typeof Set > "u" || !A7 || !k5 ? P1 : k5(new Set()[Symbol.iterator]()),
      "%SharedArrayBuffer%":
        typeof SharedArrayBuffer > "u" ? P1 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": A7 && k5 ? k5(""[Symbol.iterator]()) : P1,
      "%Symbol%": A7 ? Symbol : P1,
      "%SyntaxError%": D7,
      "%ThrowTypeError%": za,
      "%TypedArray%": Za,
      "%TypeError%": R7,
      "%Uint8Array%": typeof Uint8Array > "u" ? P1 : Uint8Array,
      "%Uint8ClampedArray%":
        typeof Uint8ClampedArray > "u" ? P1 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array > "u" ? P1 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array > "u" ? P1 : Uint32Array,
      "%URIError%": Ka,
      "%WeakMap%": typeof WeakMap > "u" ? P1 : WeakMap,
      "%WeakRef%": typeof WeakRef > "u" ? P1 : WeakRef,
      "%WeakSet%": typeof WeakSet > "u" ? P1 : WeakSet,
      "%Function.prototype.call%": KQ,
      "%Function.prototype.apply%": z3,
      "%Object.defineProperty%": Da,
      "%Object.getPrototypeOf%": Ea,
      "%Math.abs%": Va,
      "%Math.floor%": Fa,
      "%Math.max%": Na,
      "%Math.min%": Ma,
      "%Math.pow%": Aa,
      "%Math.round%": qa,
      "%Math.sign%": Ra,
      "%Reflect.getPrototypeOf%": Oa,
    };
  if (k5)
    try {
      null.error;
    } catch (X) {
      ((vL = k5(k5(X))), (m9["%Error.prototype%"] = vL));
    }
  var vL,
    ja = function X(Y) {
      var Q;
      if (Y === "%AsyncFunction%") Q = TL("async function () {}");
      else if (Y === "%GeneratorFunction%") Q = TL("function* () {}");
      else if (Y === "%AsyncGeneratorFunction%")
        Q = TL("async function* () {}");
      else if (Y === "%AsyncGenerator%") {
        var G = X("%AsyncGeneratorFunction%");
        if (G) Q = G.prototype;
      } else if (Y === "%AsyncIteratorPrototype%") {
        var J = X("%AsyncGenerator%");
        if (J && k5) Q = k5(J.prototype);
      }
      return ((m9[Y] = Q), Q);
    },
    q3 = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": [
        "AsyncGeneratorFunction",
        "prototype",
        "prototype",
      ],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"],
    },
    VQ = LQ(),
    xJ = A3(),
    wa = VQ.call(KQ, Array.prototype.concat),
    Ca = VQ.call(z3, Array.prototype.splice),
    R3 = VQ.call(KQ, String.prototype.replace),
    hJ = VQ.call(KQ, String.prototype.slice),
    Ia = VQ.call(KQ, RegExp.prototype.exec),
    Pa =
      /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    Sa = /\\(\\)?/g,
    Ta = function (Y) {
      var Q = hJ(Y, 0, 1),
        G = hJ(Y, -1);
      if (Q === "%" && G !== "%")
        throw new D7("invalid intrinsic syntax, expected closing `%`");
      else if (G === "%" && Q !== "%")
        throw new D7("invalid intrinsic syntax, expected opening `%`");
      var J = [];
      return (
        R3(Y, Pa, function (U, $, B, K) {
          J[J.length] = B ? R3(K, Sa, "$1") : $ || U;
        }),
        J
      );
    },
    ba = function (Y, Q) {
      var G = Y,
        J;
      if (xJ(q3, G)) ((J = q3[G]), (G = "%" + J[0] + "%"));
      if (xJ(m9, G)) {
        var U = m9[G];
        if (U === q7) U = ja(G);
        if (typeof U > "u" && !Q)
          throw new R7(
            "intrinsic " +
              Y +
              " exists, but is not available. Please file an issue!"
          );
        return { alias: J, name: G, value: U };
      }
      throw new D7("intrinsic " + Y + " does not exist!");
    };
  E3.exports = function (Y, Q) {
    if (typeof Y !== "string" || Y.length === 0)
      throw new R7("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof Q !== "boolean")
      throw new R7('"allowMissing" argument must be a boolean');
    if (Ia(/^%?[^%]*%?$/, Y) === null)
      throw new D7(
        "`%` may not be present anywhere but at the beginning and end of the intrinsic name"
      );
    var G = Ta(Y),
      J = G.length > 0 ? G[0] : "",
      U = ba("%" + J + "%", Q),
      $ = U.name,
      B = U.value,
      K = !1,
      V = U.alias;
    if (V) ((J = V[0]), Ca(G, wa([0, 1], V)));
    for (var W = 1, L = !0; W < G.length; W += 1) {
      var H = G[W],
        F = hJ(H, 0, 1),
        N = hJ(H, -1);
      if (
        (F === '"' ||
          F === "'" ||
          F === "`" ||
          N === '"' ||
          N === "'" ||
          N === "`") &&
        F !== N
      )
        throw new D7("property names with quotes must have matching quotes");
      if (H === "constructor" || !L) K = !0;
      if (((J += "." + H), ($ = "%" + J + "%"), xJ(m9, $))) B = m9[$];
      else if (B != null) {
        if (!(H in B)) {
          if (!Q)
            throw new R7(
              "base intrinsic for " +
                Y +
                " exists, but the property is not available."
            );
          return;
        }
        if (BQ && W + 1 >= G.length) {
          var q = BQ(B, H);
          if (((L = !!q), L && "get" in q && !("originalValue" in q.get)))
            B = q.get;
          else B = B[H];
        } else ((L = xJ(B, H)), (B = B[H]));
        if (L && !K) m9[$] = B;
      }
    }
    return B;
  };
});
var kL = s((j$0, j3) => {
  var O3 = gJ(),
    Z3 = PL(),
    va = Z3([O3("%String.prototype.indexOf%")]);
  j3.exports = function (Y, Q) {
    var G = O3(Y, !!Q);
    if (typeof G === "function" && va(Y, ".prototype.") > -1) return Z3([G]);
    return G;
  };
});
var yL = s((w$0, C3) => {
  var ka = gJ(),
    FQ = kL(),
    ya = UQ(),
    _a = u9(),
    w3 = ka("%Map%", !0),
    fa = FQ("Map.prototype.get", !0),
    xa = FQ("Map.prototype.set", !0),
    ha = FQ("Map.prototype.has", !0),
    ga = FQ("Map.prototype.delete", !0),
    ua = FQ("Map.prototype.size", !0);
  C3.exports =
    !!w3 &&
    function () {
      var Y,
        Q = {
          assert: function (G) {
            if (!Q.has(G))
              throw new _a("Side channel does not contain " + ya(G));
          },
          delete: function (G) {
            if (Y) {
              var J = ga(Y, G);
              if (ua(Y) === 0) Y = void 0;
              return J;
            }
            return !1;
          },
          get: function (G) {
            if (Y) return fa(Y, G);
          },
          has: function (G) {
            if (Y) return ha(Y, G);
            return !1;
          },
          set: function (G, J) {
            if (!Y) Y = new w3();
            xa(Y, G, J);
          },
        };
      return Q;
    };
});
var P3 = s((C$0, I3) => {
  var la = gJ(),
    lJ = kL(),
    ma = UQ(),
    uJ = yL(),
    ca = u9(),
    z7 = la("%WeakMap%", !0),
    da = lJ("WeakMap.prototype.get", !0),
    pa = lJ("WeakMap.prototype.set", !0),
    ia = lJ("WeakMap.prototype.has", !0),
    na = lJ("WeakMap.prototype.delete", !0);
  I3.exports = z7
    ? function () {
        var Y,
          Q,
          G = {
            assert: function (J) {
              if (!G.has(J))
                throw new ca("Side channel does not contain " + ma(J));
            },
            delete: function (J) {
              if (
                z7 &&
                J &&
                (typeof J === "object" || typeof J === "function")
              ) {
                if (Y) return na(Y, J);
              } else if (uJ) {
                if (Q) return Q.delete(J);
              }
              return !1;
            },
            get: function (J) {
              if (
                z7 &&
                J &&
                (typeof J === "object" || typeof J === "function")
              ) {
                if (Y) return da(Y, J);
              }
              return Q && Q.get(J);
            },
            has: function (J) {
              if (
                z7 &&
                J &&
                (typeof J === "object" || typeof J === "function")
              ) {
                if (Y) return ia(Y, J);
              }
              return !!Q && Q.has(J);
            },
            set: function (J, U) {
              if (
                z7 &&
                J &&
                (typeof J === "object" || typeof J === "function")
              ) {
                if (!Y) Y = new z7();
                pa(Y, J, U);
              } else if (uJ) {
                if (!Q) Q = uJ();
                Q.set(J, U);
              }
            },
          };
        return G;
      }
    : uJ;
});
var T3 = s((I$0, S3) => {
  var aa = u9(),
    ra = UQ(),
    oa = Wj(),
    sa = yL(),
    ta = P3(),
    ea = ta || sa || oa;
  S3.exports = function () {
    var Y,
      Q = {
        assert: function (G) {
          if (!Q.has(G)) throw new aa("Side channel does not contain " + ra(G));
        },
        delete: function (G) {
          return !!Y && Y.delete(G);
        },
        get: function (G) {
          return Y && Y.get(G);
        },
        has: function (G) {
          return !!Y && Y.has(G);
        },
        set: function (G, J) {
          if (!Y) Y = ea();
          Y.set(G, J);
        },
      };
    return Q;
  };
});
var mJ = s((P$0, b3) => {
  var Xr = String.prototype.replace,
    Yr = /%20/g,
    _L = { RFC1738: "RFC1738", RFC3986: "RFC3986" };
  b3.exports = {
    default: _L.RFC3986,
    formatters: {
      RFC1738: function (X) {
        return Xr.call(X, Yr, "+");
      },
      RFC3986: function (X) {
        return String(X);
      },
    },
    RFC1738: _L.RFC1738,
    RFC3986: _L.RFC3986,
  };
});
var xL = s((S$0, k3) => {
  var Qr = mJ(),
    fL = Object.prototype.hasOwnProperty,
    c9 = Array.isArray,
    V6 = (function () {
      var X = [];
      for (var Y = 0; Y < 256; ++Y)
        X.push("%" + ((Y < 16 ? "0" : "") + Y.toString(16)).toUpperCase());
      return X;
    })(),
    Gr = function (Y) {
      while (Y.length > 1) {
        var Q = Y.pop(),
          G = Q.obj[Q.prop];
        if (c9(G)) {
          var J = [];
          for (var U = 0; U < G.length; ++U)
            if (typeof G[U] < "u") J.push(G[U]);
          Q.obj[Q.prop] = J;
        }
      }
    },
    v3 = function (Y, Q) {
      var G = Q && Q.plainObjects ? Object.create(null) : {};
      for (var J = 0; J < Y.length; ++J) if (typeof Y[J] < "u") G[J] = Y[J];
      return G;
    },
    Jr = function X(Y, Q, G) {
      if (!Q) return Y;
      if (typeof Q !== "object") {
        if (c9(Y)) Y.push(Q);
        else if (Y && typeof Y === "object") {
          if (
            (G && (G.plainObjects || G.allowPrototypes)) ||
            !fL.call(Object.prototype, Q)
          )
            Y[Q] = !0;
        } else return [Y, Q];
        return Y;
      }
      if (!Y || typeof Y !== "object") return [Y].concat(Q);
      var J = Y;
      if (c9(Y) && !c9(Q)) J = v3(Y, G);
      if (c9(Y) && c9(Q))
        return (
          Q.forEach(function (U, $) {
            if (fL.call(Y, $)) {
              var B = Y[$];
              if (B && typeof B === "object" && U && typeof U === "object")
                Y[$] = X(B, U, G);
              else Y.push(U);
            } else Y[$] = U;
          }),
          Y
        );
      return Object.keys(Q).reduce(function (U, $) {
        var B = Q[$];
        if (fL.call(U, $)) U[$] = X(U[$], B, G);
        else U[$] = B;
        return U;
      }, J);
    },
    Wr = function (Y, Q) {
      return Object.keys(Q).reduce(function (G, J) {
        return ((G[J] = Q[J]), G);
      }, Y);
    },
    Hr = function (X, Y, Q) {
      var G = X.replace(/\+/g, " ");
      if (Q === "iso-8859-1") return G.replace(/%[0-9a-f]{2}/gi, unescape);
      try {
        return decodeURIComponent(G);
      } catch (J) {
        return G;
      }
    },
    $r = function (Y, Q, G, J, U) {
      if (Y.length === 0) return Y;
      var $ = Y;
      if (typeof Y === "symbol") $ = Symbol.prototype.toString.call(Y);
      else if (typeof Y !== "string") $ = String(Y);
      if (G === "iso-8859-1")
        return escape($).replace(/%u[0-9a-f]{4}/gi, function (W) {
          return "%26%23" + parseInt(W.slice(2), 16) + "%3B";
        });
      var B = "";
      for (var K = 0; K < $.length; ++K) {
        var V = $.charCodeAt(K);
        if (
          V === 45 ||
          V === 46 ||
          V === 95 ||
          V === 126 ||
          (V >= 48 && V <= 57) ||
          (V >= 65 && V <= 90) ||
          (V >= 97 && V <= 122) ||
          (U === Qr.RFC1738 && (V === 40 || V === 41))
        ) {
          B += $.charAt(K);
          continue;
        }
        if (V < 128) {
          B = B + V6[V];
          continue;
        }
        if (V < 2048) {
          B = B + (V6[192 | (V >> 6)] + V6[128 | (V & 63)]);
          continue;
        }
        if (V < 55296 || V >= 57344) {
          B =
            B +
            (V6[224 | (V >> 12)] +
              V6[128 | ((V >> 6) & 63)] +
              V6[128 | (V & 63)]);
          continue;
        }
        ((K += 1),
          (V = 65536 + (((V & 1023) << 10) | ($.charCodeAt(K) & 1023))),
          (B +=
            V6[240 | (V >> 18)] +
            V6[128 | ((V >> 12) & 63)] +
            V6[128 | ((V >> 6) & 63)] +
            V6[128 | (V & 63)]));
      }
      return B;
    },
    Ur = function (Y) {
      var Q = [{ obj: { o: Y }, prop: "o" }],
        G = [];
      for (var J = 0; J < Q.length; ++J) {
        var U = Q[J],
          $ = U.obj[U.prop],
          B = Object.keys($);
        for (var K = 0; K < B.length; ++K) {
          var V = B[K],
            W = $[V];
          if (typeof W === "object" && W !== null && G.indexOf(W) === -1)
            (Q.push({ obj: $, prop: V }), G.push(W));
        }
      }
      return (Gr(Q), Y);
    },
    Lr = function (Y) {
      return Object.prototype.toString.call(Y) === "[object RegExp]";
    },
    Br = function (Y) {
      if (!Y || typeof Y !== "object") return !1;
      return !!(
        Y.constructor &&
        Y.constructor.isBuffer &&
        Y.constructor.isBuffer(Y)
      );
    },
    Kr = function (Y, Q) {
      return [].concat(Y, Q);
    },
    Vr = function (Y, Q) {
      if (c9(Y)) {
        var G = [];
        for (var J = 0; J < Y.length; J += 1) G.push(Q(Y[J]));
        return G;
      }
      return Q(Y);
    };
  k3.exports = {
    arrayToObject: v3,
    assign: Wr,
    combine: Kr,
    compact: Ur,
    decode: Hr,
    encode: $r,
    isBuffer: Br,
    isRegExp: Lr,
    maybeMap: Vr,
    merge: Jr,
  };
});
var g3 = s((T$0, h3) => {
  var f3 = T3(),
    cJ = xL(),
    NQ = mJ(),
    Fr = Object.prototype.hasOwnProperty,
    y3 = {
      brackets: function (Y) {
        return Y + "[]";
      },
      comma: "comma",
      indices: function (Y, Q) {
        return Y + "[" + Q + "]";
      },
      repeat: function (Y) {
        return Y;
      },
    },
    K4 = Array.isArray,
    Nr = Array.prototype.push,
    x3 = function (X, Y) {
      Nr.apply(X, K4(Y) ? Y : [Y]);
    },
    Mr = Date.prototype.toISOString,
    _3 = NQ.default,
    G8 = {
      addQueryPrefix: !1,
      allowDots: !1,
      charset: "utf-8",
      charsetSentinel: !1,
      delimiter: "&",
      encode: !0,
      encoder: cJ.encode,
      encodeValuesOnly: !1,
      format: _3,
      formatter: NQ.formatters[_3],
      indices: !1,
      serializeDate: function (Y) {
        return Mr.call(Y);
      },
      skipNulls: !1,
      strictNullHandling: !1,
    },
    Ar = function (Y) {
      return (
        typeof Y === "string" ||
        typeof Y === "number" ||
        typeof Y === "boolean" ||
        typeof Y === "symbol" ||
        typeof Y === "bigint"
      );
    },
    hL = {},
    qr = function X(Y, Q, G, J, U, $, B, K, V, W, L, H, F, N, q, M) {
      var A = Y,
        D = M,
        R = 0,
        z = !1;
      while ((D = D.get(hL)) !== void 0 && !z) {
        var E = D.get(Y);
        if (((R += 1), typeof E < "u"))
          if (E === R) throw RangeError("Cyclic object value");
          else z = !0;
        if (typeof D.get(hL) > "u") R = 0;
      }
      if (typeof K === "function") A = K(Q, A);
      else if (A instanceof Date) A = L(A);
      else if (G === "comma" && K4(A))
        A = cJ.maybeMap(A, function (h) {
          if (h instanceof Date) return L(h);
          return h;
        });
      if (A === null) {
        if (U) return B && !N ? B(Q, G8.encoder, q, "key", H) : Q;
        A = "";
      }
      if (Ar(A) || cJ.isBuffer(A)) {
        if (B) {
          var O = N ? Q : B(Q, G8.encoder, q, "key", H);
          return [F(O) + "=" + F(B(A, G8.encoder, q, "value", H))];
        }
        return [F(Q) + "=" + F(String(A))];
      }
      var Z = [];
      if (typeof A > "u") return Z;
      var j;
      if (G === "comma" && K4(A)) {
        if (N && B) A = cJ.maybeMap(A, B);
        j = [{ value: A.length > 0 ? A.join(",") || null : void 0 }];
      } else if (K4(K)) j = K;
      else {
        var w = Object.keys(A);
        j = V ? w.sort(V) : w;
      }
      var I = J && K4(A) && A.length === 1 ? Q + "[]" : Q;
      for (var T = 0; T < j.length; ++T) {
        var y = j[T],
          _ = typeof y === "object" && typeof y.value < "u" ? y.value : A[y];
        if ($ && _ === null) continue;
        var f = K4(A)
          ? typeof G === "function"
            ? G(I, y)
            : I
          : I + (W ? "." + y : "[" + y + "]");
        M.set(Y, R);
        var l = f3();
        (l.set(hL, M),
          x3(
            Z,
            X(
              _,
              f,
              G,
              J,
              U,
              $,
              G === "comma" && N && K4(A) ? null : B,
              K,
              V,
              W,
              L,
              H,
              F,
              N,
              q,
              l
            )
          ));
      }
      return Z;
    },
    Rr = function (Y) {
      if (!Y) return G8;
      if (
        Y.encoder !== null &&
        typeof Y.encoder < "u" &&
        typeof Y.encoder !== "function"
      )
        throw TypeError("Encoder has to be a function.");
      var Q = Y.charset || G8.charset;
      if (
        typeof Y.charset < "u" &&
        Y.charset !== "utf-8" &&
        Y.charset !== "iso-8859-1"
      )
        throw TypeError(
          "The charset option must be either utf-8, iso-8859-1, or undefined"
        );
      var G = NQ.default;
      if (typeof Y.format < "u") {
        if (!Fr.call(NQ.formatters, Y.format))
          throw TypeError("Unknown format option provided.");
        G = Y.format;
      }
      var J = NQ.formatters[G],
        U = G8.filter;
      if (typeof Y.filter === "function" || K4(Y.filter)) U = Y.filter;
      return {
        addQueryPrefix:
          typeof Y.addQueryPrefix === "boolean"
            ? Y.addQueryPrefix
            : G8.addQueryPrefix,
        allowDots: typeof Y.allowDots > "u" ? G8.allowDots : !!Y.allowDots,
        charset: Q,
        charsetSentinel:
          typeof Y.charsetSentinel === "boolean"
            ? Y.charsetSentinel
            : G8.charsetSentinel,
        delimiter: typeof Y.delimiter > "u" ? G8.delimiter : Y.delimiter,
        encode: typeof Y.encode === "boolean" ? Y.encode : G8.encode,
        encoder: typeof Y.encoder === "function" ? Y.encoder : G8.encoder,
        encodeValuesOnly:
          typeof Y.encodeValuesOnly === "boolean"
            ? Y.encodeValuesOnly
            : G8.encodeValuesOnly,
        filter: U,
        format: G,
        formatter: J,
        serializeDate:
          typeof Y.serializeDate === "function"
            ? Y.serializeDate
            : G8.serializeDate,
        skipNulls:
          typeof Y.skipNulls === "boolean" ? Y.skipNulls : G8.skipNulls,
        sort: typeof Y.sort === "function" ? Y.sort : null,
        strictNullHandling:
          typeof Y.strictNullHandling === "boolean"
            ? Y.strictNullHandling
            : G8.strictNullHandling,
      };
    };
  h3.exports = function (X, Y) {
    var Q = X,
      G = Rr(Y),
      J,
      U;
    if (typeof G.filter === "function") ((U = G.filter), (Q = U("", Q)));
    else if (K4(G.filter)) ((U = G.filter), (J = U));
    var $ = [];
    if (typeof Q !== "object" || Q === null) return "";
    var B;
    if (Y && Y.arrayFormat in y3) B = Y.arrayFormat;
    else if (Y && "indices" in Y) B = Y.indices ? "indices" : "repeat";
    else B = "indices";
    var K = y3[B];
    if (Y && "commaRoundTrip" in Y && typeof Y.commaRoundTrip !== "boolean")
      throw TypeError("`commaRoundTrip` must be a boolean, or absent");
    var V = K === "comma" && Y && Y.commaRoundTrip;
    if (!J) J = Object.keys(Q);
    if (G.sort) J.sort(G.sort);
    var W = f3();
    for (var L = 0; L < J.length; ++L) {
      var H = J[L];
      if (G.skipNulls && Q[H] === null) continue;
      x3(
        $,
        qr(
          Q[H],
          H,
          K,
          V,
          G.strictNullHandling,
          G.skipNulls,
          G.encode ? G.encoder : null,
          G.filter,
          G.sort,
          G.allowDots,
          G.serializeDate,
          G.format,
          G.formatter,
          G.encodeValuesOnly,
          G.charset,
          W
        )
      );
    }
    var F = $.join(G.delimiter),
      N = G.addQueryPrefix === !0 ? "?" : "";
    if (G.charsetSentinel)
      if (G.charset === "iso-8859-1") N += "utf8=%26%2310003%3B&";
      else N += "utf8=%E2%9C%93&";
    return F.length > 0 ? N + F : "";
  };
});
var m3 = s((b$0, l3) => {
  var E7 = xL(),
    gL = Object.prototype.hasOwnProperty,
    Dr = Array.isArray,
    y5 = {
      allowDots: !1,
      allowPrototypes: !1,
      allowSparse: !1,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: !1,
      comma: !1,
      decoder: E7.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: !1,
      interpretNumericEntities: !1,
      parameterLimit: 1000,
      parseArrays: !0,
      plainObjects: !1,
      strictNullHandling: !1,
    },
    zr = function (X) {
      return X.replace(/&#(\d+);/g, function (Y, Q) {
        return String.fromCharCode(parseInt(Q, 10));
      });
    },
    u3 = function (X, Y) {
      if (X && typeof X === "string" && Y.comma && X.indexOf(",") > -1)
        return X.split(",");
      return X;
    },
    Er = "utf8=%26%2310003%3B",
    Or = "utf8=%E2%9C%93",
    Zr = function (Y, Q) {
      var G = { __proto__: null },
        J = Q.ignoreQueryPrefix ? Y.replace(/^\?/, "") : Y,
        U = Q.parameterLimit === 1 / 0 ? void 0 : Q.parameterLimit,
        $ = J.split(Q.delimiter, U),
        B = -1,
        K,
        V = Q.charset;
      if (Q.charsetSentinel) {
        for (K = 0; K < $.length; ++K)
          if ($[K].indexOf("utf8=") === 0) {
            if ($[K] === Or) V = "utf-8";
            else if ($[K] === Er) V = "iso-8859-1";
            ((B = K), (K = $.length));
          }
      }
      for (K = 0; K < $.length; ++K) {
        if (K === B) continue;
        var W = $[K],
          L = W.indexOf("]="),
          H = L === -1 ? W.indexOf("=") : L + 1,
          F,
          N;
        if (H === -1)
          ((F = Q.decoder(W, y5.decoder, V, "key")),
            (N = Q.strictNullHandling ? null : ""));
        else
          ((F = Q.decoder(W.slice(0, H), y5.decoder, V, "key")),
            (N = E7.maybeMap(u3(W.slice(H + 1), Q), function (q) {
              return Q.decoder(q, y5.decoder, V, "value");
            })));
        if (N && Q.interpretNumericEntities && V === "iso-8859-1") N = zr(N);
        if (W.indexOf("[]=") > -1) N = Dr(N) ? [N] : N;
        if (gL.call(G, F)) G[F] = E7.combine(G[F], N);
        else G[F] = N;
      }
      return G;
    },
    jr = function (X, Y, Q, G) {
      var J = G ? Y : u3(Y, Q);
      for (var U = X.length - 1; U >= 0; --U) {
        var $,
          B = X[U];
        if (B === "[]" && Q.parseArrays) $ = [].concat(J);
        else {
          $ = Q.plainObjects ? Object.create(null) : {};
          var K =
              B.charAt(0) === "[" && B.charAt(B.length - 1) === "]"
                ? B.slice(1, -1)
                : B,
            V = parseInt(K, 10);
          if (!Q.parseArrays && K === "") $ = { 0: J };
          else if (
            !isNaN(V) &&
            B !== K &&
            String(V) === K &&
            V >= 0 &&
            Q.parseArrays &&
            V <= Q.arrayLimit
          )
            (($ = []), ($[V] = J));
          else if (K !== "__proto__") $[K] = J;
        }
        J = $;
      }
      return J;
    },
    wr = function (Y, Q, G, J) {
      if (!Y) return;
      var U = G.allowDots ? Y.replace(/\.([^.[]+)/g, "[$1]") : Y,
        $ = /(\[[^[\]]*])/,
        B = /(\[[^[\]]*])/g,
        K = G.depth > 0 && $.exec(U),
        V = K ? U.slice(0, K.index) : U,
        W = [];
      if (V) {
        if (!G.plainObjects && gL.call(Object.prototype, V)) {
          if (!G.allowPrototypes) return;
        }
        W.push(V);
      }
      var L = 0;
      while (G.depth > 0 && (K = B.exec(U)) !== null && L < G.depth) {
        if (
          ((L += 1),
          !G.plainObjects && gL.call(Object.prototype, K[1].slice(1, -1)))
        ) {
          if (!G.allowPrototypes) return;
        }
        W.push(K[1]);
      }
      if (K) W.push("[" + U.slice(K.index) + "]");
      return jr(W, Q, G, J);
    },
    Cr = function (Y) {
      if (!Y) return y5;
      if (
        Y.decoder !== null &&
        Y.decoder !== void 0 &&
        typeof Y.decoder !== "function"
      )
        throw TypeError("Decoder has to be a function.");
      if (
        typeof Y.charset < "u" &&
        Y.charset !== "utf-8" &&
        Y.charset !== "iso-8859-1"
      )
        throw TypeError(
          "The charset option must be either utf-8, iso-8859-1, or undefined"
        );
      var Q = typeof Y.charset > "u" ? y5.charset : Y.charset;
      return {
        allowDots: typeof Y.allowDots > "u" ? y5.allowDots : !!Y.allowDots,
        allowPrototypes:
          typeof Y.allowPrototypes === "boolean"
            ? Y.allowPrototypes
            : y5.allowPrototypes,
        allowSparse:
          typeof Y.allowSparse === "boolean" ? Y.allowSparse : y5.allowSparse,
        arrayLimit:
          typeof Y.arrayLimit === "number" ? Y.arrayLimit : y5.arrayLimit,
        charset: Q,
        charsetSentinel:
          typeof Y.charsetSentinel === "boolean"
            ? Y.charsetSentinel
            : y5.charsetSentinel,
        comma: typeof Y.comma === "boolean" ? Y.comma : y5.comma,
        decoder: typeof Y.decoder === "function" ? Y.decoder : y5.decoder,
        delimiter:
          typeof Y.delimiter === "string" || E7.isRegExp(Y.delimiter)
            ? Y.delimiter
            : y5.delimiter,
        depth:
          typeof Y.depth === "number" || Y.depth === !1 ? +Y.depth : y5.depth,
        ignoreQueryPrefix: Y.ignoreQueryPrefix === !0,
        interpretNumericEntities:
          typeof Y.interpretNumericEntities === "boolean"
            ? Y.interpretNumericEntities
            : y5.interpretNumericEntities,
        parameterLimit:
          typeof Y.parameterLimit === "number"
            ? Y.parameterLimit
            : y5.parameterLimit,
        parseArrays: Y.parseArrays !== !1,
        plainObjects:
          typeof Y.plainObjects === "boolean"
            ? Y.plainObjects
            : y5.plainObjects,
        strictNullHandling:
          typeof Y.strictNullHandling === "boolean"
            ? Y.strictNullHandling
            : y5.strictNullHandling,
      };
    };
  l3.exports = function (X, Y) {
    var Q = Cr(Y);
    if (X === "" || X === null || typeof X > "u")
      return Q.plainObjects ? Object.create(null) : {};
    var G = typeof X === "string" ? Zr(X, Q) : X,
      J = Q.plainObjects ? Object.create(null) : {},
      U = Object.keys(G);
    for (var $ = 0; $ < U.length; ++$) {
      var B = U[$],
        K = wr(B, G[B], Q, typeof X === "string");
      J = E7.merge(J, K, Q);
    }
    if (Q.allowSparse === !0) return J;
    return E7.compact(J);
  };
});
var d3 = s((v$0, c3) => {
  var Ir = g3(),
    Pr = m3(),
    Sr = mJ();
  c3.exports = { formats: Sr, parse: Pr, stringify: Ir };
});
var p3 = s((O7) => {
  var Tr =
    (O7 && O7.__importDefault) ||
    function (X) {
      return X && X.__esModule ? X : { default: X };
    };
  Object.defineProperty(O7, "__esModule", { value: !0 });
  O7.createRequestUrl = void 0;
  var br = Tr(d3());
  function vr(X, Y) {
    return Object.keys(Y !== null && Y !== void 0 ? Y : {}).length > 0
      ? `${X}?${br.default.stringify(Y, { arrayFormat: "repeat" })}`
      : X;
  }
  O7.createRequestUrl = vr;
});
var o3 = s((a3) => {
  var uL, lL, mL, cL, dL;
  Object.defineProperty(a3, "__esModule", { value: !0 });
  a3.RUNTIME = void 0;
  var kr = typeof window < "u" && typeof window.document < "u",
    yr =
      typeof self === "object" &&
      typeof (self === null || self === void 0
        ? void 0
        : self.importScripts) === "function" &&
      (((uL = self.constructor) === null || uL === void 0
        ? void 0
        : uL.name) === "DedicatedWorkerGlobalScope" ||
        ((lL = self.constructor) === null || lL === void 0
          ? void 0
          : lL.name) === "ServiceWorkerGlobalScope" ||
        ((mL = self.constructor) === null || mL === void 0
          ? void 0
          : mL.name) === "SharedWorkerGlobalScope"),
    i3 =
      typeof Deno < "u" &&
      typeof Deno.version < "u" &&
      typeof Deno.version.deno < "u",
    n3 = typeof Bun < "u" && typeof Bun.version < "u",
    _r =
      typeof process < "u" &&
      Boolean(process.version) &&
      Boolean(
        (cL = process.versions) === null || cL === void 0 ? void 0 : cL.node
      ) &&
      !i3 &&
      !n3,
    fr =
      typeof navigator < "u" &&
      (navigator === null || navigator === void 0
        ? void 0
        : navigator.product) === "ReactNative",
    xr =
      typeof globalThis < "u" &&
      ((dL =
        globalThis === null || globalThis === void 0
          ? void 0
          : globalThis.navigator) === null || dL === void 0
        ? void 0
        : dL.userAgent) === "Cloudflare-Workers";
  a3.RUNTIME = hr();
  function hr() {
    if (kr) return { type: "browser", version: window.navigator.userAgent };
    if (xr) return { type: "workerd" };
    if (yr) return { type: "web-worker" };
    if (i3) return { type: "deno", version: Deno.version.deno };
    if (n3) return { type: "bun", version: Bun.version };
    if (_r)
      return {
        type: "node",
        version: process.versions.node,
        parsedVersion: Number(process.versions.node.split(".")[0]),
      };
    if (fr) return { type: "react-native" };
    return { type: "unknown" };
  }
});
var dJ = s((pL) => {
  Object.defineProperty(pL, "__esModule", { value: !0 });
  pL.RUNTIME = void 0;
  var gr = o3();
  Object.defineProperty(pL, "RUNTIME", {
    enumerable: !0,
    get: function () {
      return gr.RUNTIME;
    },
  });
});
var t3 = s((b8) => {
  var lr =
      (b8 && b8.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    mr =
      (b8 && b8.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    s3 =
      (b8 && b8.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              lr(Y, X, Q);
        }
        return (mr(Y, X), Y);
      },
    cr =
      (b8 && b8.__awaiter) ||
      function (X, Y, Q, G) {
        function J(U) {
          return U instanceof Q
            ? U
            : new Q(function ($) {
                $(U);
              });
        }
        return new (Q || (Q = Promise))(function (U, $) {
          function B(W) {
            try {
              V(G.next(W));
            } catch (L) {
              $(L);
            }
          }
          function K(W) {
            try {
              V(G.throw(W));
            } catch (L) {
              $(L);
            }
          }
          function V(W) {
            W.done ? U(W.value) : J(W.value).then(B, K);
          }
          V((G = G.apply(X, Y || [])).next());
        });
      };
  Object.defineProperty(b8, "__esModule", { value: !0 });
  b8.getFetchFn = void 0;
  var pJ = dJ();
  function dr() {
    return cr(this, void 0, void 0, function* () {
      if (
        pJ.RUNTIME.type === "node" &&
        pJ.RUNTIME.parsedVersion != null &&
        pJ.RUNTIME.parsedVersion >= 18
      )
        return fetch;
      if (pJ.RUNTIME.type === "node")
        return (yield Promise.resolve().then(() => s3(k1("node-fetch"))))
          .default;
      if (typeof fetch == "function") return fetch;
      return (yield Promise.resolve().then(() => s3(k1("node-fetch")))).default;
    });
  }
  b8.getFetchFn = dr;
});
var e3 = s((Z7) => {
  var pr =
    (Z7 && Z7.__awaiter) ||
    function (X, Y, Q, G) {
      function J(U) {
        return U instanceof Q
          ? U
          : new Q(function ($) {
              $(U);
            });
      }
      return new (Q || (Q = Promise))(function (U, $) {
        function B(W) {
          try {
            V(G.next(W));
          } catch (L) {
            $(L);
          }
        }
        function K(W) {
          try {
            V(G.throw(W));
          } catch (L) {
            $(L);
          }
        }
        function V(W) {
          W.done ? U(W.value) : J(W.value).then(B, K);
        }
        V((G = G.apply(X, Y || [])).next());
      });
    };
  Object.defineProperty(Z7, "__esModule", { value: !0 });
  Z7.getRequestBody = void 0;
  function ir({ body: X, type: Y }) {
    return pr(this, void 0, void 0, function* () {
      if (Y.includes("json")) return JSON.stringify(X);
      else return X;
    });
  }
  Z7.getRequestBody = ir;
});
var Xw = s((j7) => {
  var i8 =
    (j7 && j7.__awaiter) ||
    function (X, Y, Q, G) {
      function J(U) {
        return U instanceof Q
          ? U
          : new Q(function ($) {
              $(U);
            });
      }
      return new (Q || (Q = Promise))(function (U, $) {
        function B(W) {
          try {
            V(G.next(W));
          } catch (L) {
            $(L);
          }
        }
        function K(W) {
          try {
            V(G.throw(W));
          } catch (L) {
            $(L);
          }
        }
        function V(W) {
          W.done ? U(W.value) : J(W.value).then(B, K);
        }
        V((G = G.apply(X, Y || [])).next());
      });
    };
  Object.defineProperty(j7, "__esModule", { value: !0 });
  j7.Node18UniversalStreamWrapper = void 0;
  class n4 {
    constructor(X) {
      ((this.readableStream = X),
        (this.reader = this.readableStream.getReader()),
        (this.events = {
          data: [],
          end: [],
          error: [],
          readable: [],
          close: [],
          pause: [],
          resume: [],
        }),
        (this.paused = !1),
        (this.resumeCallback = null),
        (this.encoding = null));
    }
    on(X, Y) {
      var Q;
      (Q = this.events[X]) === null || Q === void 0 || Q.push(Y);
    }
    off(X, Y) {
      var Q;
      this.events[X] =
        (Q = this.events[X]) === null || Q === void 0
          ? void 0
          : Q.filter((G) => G !== Y);
    }
    pipe(X) {
      return (
        this.on("data", (Y) =>
          i8(this, void 0, void 0, function* () {
            if (X instanceof n4) X._write(Y);
            else if (X instanceof WritableStream) {
              let Q = X.getWriter();
              Q.write(Y).then(() => Q.releaseLock());
            } else X.write(Y);
          })
        ),
        this.on("end", () =>
          i8(this, void 0, void 0, function* () {
            if (X instanceof n4) X._end();
            else if (X instanceof WritableStream) X.getWriter().close();
            else X.end();
          })
        ),
        this.on("error", (Y) =>
          i8(this, void 0, void 0, function* () {
            if (X instanceof n4) X._error(Y);
            else if (X instanceof WritableStream) X.getWriter().abort(Y);
            else X.destroy(Y);
          })
        ),
        this._startReading(),
        X
      );
    }
    pipeTo(X) {
      return this.pipe(X);
    }
    unpipe(X) {
      (this.off("data", (Y) =>
        i8(this, void 0, void 0, function* () {
          if (X instanceof n4) X._write(Y);
          else if (X instanceof WritableStream) {
            let Q = X.getWriter();
            Q.write(Y).then(() => Q.releaseLock());
          } else X.write(Y);
        })
      ),
        this.off("end", () =>
          i8(this, void 0, void 0, function* () {
            if (X instanceof n4) X._end();
            else if (X instanceof WritableStream) X.getWriter().close();
            else X.end();
          })
        ),
        this.off("error", (Y) =>
          i8(this, void 0, void 0, function* () {
            if (X instanceof n4) X._error(Y);
            else if (X instanceof WritableStream) X.getWriter().abort(Y);
            else X.destroy(Y);
          })
        ));
    }
    destroy(X) {
      this.reader
        .cancel(X)
        .then(() => {
          this._emit("close");
        })
        .catch((Y) => {
          this._emit("error", Y);
        });
    }
    pause() {
      ((this.paused = !0), this._emit("pause"));
    }
    resume() {
      if (this.paused) {
        if (((this.paused = !1), this._emit("resume"), this.resumeCallback))
          (this.resumeCallback(), (this.resumeCallback = null));
      }
    }
    get isPaused() {
      return this.paused;
    }
    read() {
      return i8(this, void 0, void 0, function* () {
        if (this.paused)
          yield new Promise((Q) => {
            this.resumeCallback = Q;
          });
        let { done: X, value: Y } = yield this.reader.read();
        if (X) return;
        return Y;
      });
    }
    setEncoding(X) {
      this.encoding = X;
    }
    text() {
      return i8(this, void 0, void 0, function* () {
        let X = [];
        while (!0) {
          let { done: Q, value: G } = yield this.reader.read();
          if (Q) break;
          if (G) X.push(G);
        }
        return new TextDecoder(this.encoding || "utf-8").decode(
          yield new Blob(X).arrayBuffer()
        );
      });
    }
    json() {
      return i8(this, void 0, void 0, function* () {
        let X = yield this.text();
        return JSON.parse(X);
      });
    }
    _write(X) {
      this._emit("data", X);
    }
    _end() {
      this._emit("end");
    }
    _error(X) {
      this._emit("error", X);
    }
    _emit(X, Y) {
      if (this.events[X]) for (let Q of this.events[X] || []) Q(Y);
    }
    _startReading() {
      return i8(this, void 0, void 0, function* () {
        try {
          this._emit("readable");
          while (!0) {
            if (this.paused)
              yield new Promise((Q) => {
                this.resumeCallback = Q;
              });
            let { done: X, value: Y } = yield this.reader.read();
            if (X) {
              (this._emit("end"), this._emit("close"));
              break;
            }
            if (Y) this._emit("data", Y);
          }
        } catch (X) {
          this._emit("error", X);
        }
      });
    }
    [Symbol.asyncIterator]() {
      return {
        next: () =>
          i8(this, void 0, void 0, function* () {
            if (this.paused)
              yield new Promise((Q) => {
                this.resumeCallback = Q;
              });
            let { done: X, value: Y } = yield this.reader.read();
            if (X) return { done: !0, value: void 0 };
            return { done: !1, value: Y };
          }),
        [Symbol.asyncIterator]() {
          return this;
        },
      };
    }
  }
  j7.Node18UniversalStreamWrapper = n4;
});
var Yw = s((w7) => {
  var MQ =
    (w7 && w7.__awaiter) ||
    function (X, Y, Q, G) {
      function J(U) {
        return U instanceof Q
          ? U
          : new Q(function ($) {
              $(U);
            });
      }
      return new (Q || (Q = Promise))(function (U, $) {
        function B(W) {
          try {
            V(G.next(W));
          } catch (L) {
            $(L);
          }
        }
        function K(W) {
          try {
            V(G.throw(W));
          } catch (L) {
            $(L);
          }
        }
        function V(W) {
          W.done ? U(W.value) : J(W.value).then(B, K);
        }
        V((G = G.apply(X, Y || [])).next());
      });
    };
  Object.defineProperty(w7, "__esModule", { value: !0 });
  w7.UndiciStreamWrapper = void 0;
  class a4 {
    constructor(X) {
      ((this.readableStream = X),
        (this.reader = this.readableStream.getReader()),
        (this.events = {
          data: [],
          end: [],
          error: [],
          readable: [],
          close: [],
          pause: [],
          resume: [],
        }),
        (this.paused = !1),
        (this.resumeCallback = null),
        (this.encoding = null));
    }
    on(X, Y) {
      var Q;
      (Q = this.events[X]) === null || Q === void 0 || Q.push(Y);
    }
    off(X, Y) {
      var Q;
      this.events[X] =
        (Q = this.events[X]) === null || Q === void 0
          ? void 0
          : Q.filter((G) => G !== Y);
    }
    pipe(X) {
      return (
        this.on("data", (Y) => {
          if (X instanceof a4) X._write(Y);
          else {
            let Q = X.getWriter();
            Q.write(Y).then(() => Q.releaseLock());
          }
        }),
        this.on("end", () => {
          if (X instanceof a4) X._end();
          else X.getWriter().close();
        }),
        this.on("error", (Y) => {
          if (X instanceof a4) X._error(Y);
          else X.getWriter().abort(Y);
        }),
        this._startReading(),
        X
      );
    }
    pipeTo(X) {
      return this.pipe(X);
    }
    unpipe(X) {
      (this.off("data", (Y) => {
        if (X instanceof a4) X._write(Y);
        else {
          let Q = X.getWriter();
          Q.write(Y).then(() => Q.releaseLock());
        }
      }),
        this.off("end", () => {
          if (X instanceof a4) X._end();
          else X.getWriter().close();
        }),
        this.off("error", (Y) => {
          if (X instanceof a4) X._error(Y);
          else X.getWriter().abort(Y);
        }));
    }
    destroy(X) {
      this.reader
        .cancel(X)
        .then(() => {
          this._emit("close");
        })
        .catch((Y) => {
          this._emit("error", Y);
        });
    }
    pause() {
      ((this.paused = !0), this._emit("pause"));
    }
    resume() {
      if (this.paused) {
        if (((this.paused = !1), this._emit("resume"), this.resumeCallback))
          (this.resumeCallback(), (this.resumeCallback = null));
      }
    }
    get isPaused() {
      return this.paused;
    }
    read() {
      return MQ(this, void 0, void 0, function* () {
        if (this.paused)
          yield new Promise((Q) => {
            this.resumeCallback = Q;
          });
        let { done: X, value: Y } = yield this.reader.read();
        if (X) return;
        return Y;
      });
    }
    setEncoding(X) {
      this.encoding = X;
    }
    text() {
      return MQ(this, void 0, void 0, function* () {
        let X = [];
        while (!0) {
          let { done: Q, value: G } = yield this.reader.read();
          if (Q) break;
          if (G) X.push(G);
        }
        return new TextDecoder(this.encoding || "utf-8").decode(
          yield new Blob(X).arrayBuffer()
        );
      });
    }
    json() {
      return MQ(this, void 0, void 0, function* () {
        let X = yield this.text();
        return JSON.parse(X);
      });
    }
    _write(X) {
      this._emit("data", X);
    }
    _end() {
      this._emit("end");
    }
    _error(X) {
      this._emit("error", X);
    }
    _emit(X, Y) {
      if (this.events[X]) for (let Q of this.events[X] || []) Q(Y);
    }
    _startReading() {
      return MQ(this, void 0, void 0, function* () {
        try {
          this._emit("readable");
          while (!0) {
            if (this.paused)
              yield new Promise((Q) => {
                this.resumeCallback = Q;
              });
            let { done: X, value: Y } = yield this.reader.read();
            if (X) {
              (this._emit("end"), this._emit("close"));
              break;
            }
            if (Y) this._emit("data", Y);
          }
        } catch (X) {
          this._emit("error", X);
        }
      });
    }
    [Symbol.asyncIterator]() {
      return {
        next: () =>
          MQ(this, void 0, void 0, function* () {
            if (this.paused)
              yield new Promise((Q) => {
                this.resumeCallback = Q;
              });
            let { done: X, value: Y } = yield this.reader.read();
            if (X) return { done: !0, value: void 0 };
            return { done: !1, value: Y };
          }),
        [Symbol.asyncIterator]() {
          return this;
        },
      };
    }
  }
  w7.UndiciStreamWrapper = a4;
});
var Gw = s((r4) => {
  var iJ =
      (r4 && r4.__awaiter) ||
      function (X, Y, Q, G) {
        function J(U) {
          return U instanceof Q
            ? U
            : new Q(function ($) {
                $(U);
              });
        }
        return new (Q || (Q = Promise))(function (U, $) {
          function B(W) {
            try {
              V(G.next(W));
            } catch (L) {
              $(L);
            }
          }
          function K(W) {
            try {
              V(G.throw(W));
            } catch (L) {
              $(L);
            }
          }
          function V(W) {
            W.done ? U(W.value) : J(W.value).then(B, K);
          }
          V((G = G.apply(X, Y || [])).next());
        });
      },
    nr =
      (r4 && r4.__asyncValues) ||
      function (X) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var Y = X[Symbol.asyncIterator],
          Q;
        return Y
          ? Y.call(X)
          : ((X =
              typeof __values === "function"
                ? __values(X)
                : X[Symbol.iterator]()),
            (Q = {}),
            G("next"),
            G("throw"),
            G("return"),
            (Q[Symbol.asyncIterator] = function () {
              return this;
            }),
            Q);
        function G(U) {
          Q[U] =
            X[U] &&
            function ($) {
              return new Promise(function (B, K) {
                (($ = X[U]($)), J(B, K, $.done, $.value));
              });
            };
        }
        function J(U, $, B, K) {
          Promise.resolve(K).then(function (V) {
            U({ value: V, done: B });
          }, $);
        }
      };
  Object.defineProperty(r4, "__esModule", { value: !0 });
  r4.NodePre18StreamWrapper = void 0;
  class Qw {
    constructor(X) {
      this.readableStream = X;
    }
    on(X, Y) {
      this.readableStream.on(X, Y);
    }
    off(X, Y) {
      this.readableStream.off(X, Y);
    }
    pipe(X) {
      return (this.readableStream.pipe(X), X);
    }
    pipeTo(X) {
      return this.pipe(X);
    }
    unpipe(X) {
      if (X) this.readableStream.unpipe(X);
      else this.readableStream.unpipe();
    }
    destroy(X) {
      this.readableStream.destroy(X);
    }
    pause() {
      this.readableStream.pause();
    }
    resume() {
      this.readableStream.resume();
    }
    get isPaused() {
      return this.readableStream.isPaused();
    }
    read() {
      return iJ(this, void 0, void 0, function* () {
        return new Promise((X, Y) => {
          let Q = this.readableStream.read();
          if (Q) X(Q);
          else
            (this.readableStream.once("readable", () => {
              let G = this.readableStream.read();
              X(G);
            }),
              this.readableStream.once("error", Y));
        });
      });
    }
    setEncoding(X) {
      (this.readableStream.setEncoding(X), (this.encoding = X));
    }
    text() {
      var X, Y;
      return iJ(this, void 0, void 0, function* () {
        let Q = [],
          G = new TextEncoder();
        this.readableStream.setEncoding(this.encoding || "utf-8");
        try {
          for (
            var J = nr(this.readableStream), U;
            (U = yield J.next()), !U.done;
          ) {
            let B = U.value;
            Q.push(G.encode(B));
          }
        } catch (B) {
          X = { error: B };
        } finally {
          try {
            if (U && !U.done && (Y = J.return)) yield Y.call(J);
          } finally {
            if (X) throw X.error;
          }
        }
        return new TextDecoder(this.encoding || "utf-8").decode(
          Buffer.concat(Q)
        );
      });
    }
    json() {
      return iJ(this, void 0, void 0, function* () {
        let X = yield this.text();
        return JSON.parse(X);
      });
    }
    [Symbol.asyncIterator]() {
      let Y = this.readableStream[Symbol.asyncIterator]();
      return {
        next() {
          return iJ(this, void 0, void 0, function* () {
            let { value: Q, done: G } = yield Y.next();
            return { value: Q, done: G };
          });
        },
        [Symbol.asyncIterator]() {
          return this;
        },
      };
    }
  }
  r4.NodePre18StreamWrapper = Qw;
});
var Jw = s((v8) => {
  var ar =
      (v8 && v8.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    rr =
      (v8 && v8.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    iL =
      (v8 && v8.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              ar(Y, X, Q);
        }
        return (rr(Y, X), Y);
      },
    or =
      (v8 && v8.__awaiter) ||
      function (X, Y, Q, G) {
        function J(U) {
          return U instanceof Q
            ? U
            : new Q(function ($) {
                $(U);
              });
        }
        return new (Q || (Q = Promise))(function (U, $) {
          function B(W) {
            try {
              V(G.next(W));
            } catch (L) {
              $(L);
            }
          }
          function K(W) {
            try {
              V(G.throw(W));
            } catch (L) {
              $(L);
            }
          }
          function V(W) {
            W.done ? U(W.value) : J(W.value).then(B, K);
          }
          V((G = G.apply(X, Y || [])).next());
        });
      };
  Object.defineProperty(v8, "__esModule", { value: !0 });
  v8.chooseStreamWrapper = void 0;
  var nJ = dJ();
  function sr(X) {
    return or(this, void 0, void 0, function* () {
      if (
        nJ.RUNTIME.type === "node" &&
        nJ.RUNTIME.parsedVersion != null &&
        nJ.RUNTIME.parsedVersion >= 18
      )
        return new (yield Promise.resolve().then(() =>
          iL(Xw())
        )).Node18UniversalStreamWrapper(X);
      else if (nJ.RUNTIME.type !== "node" && typeof fetch === "function")
        return new (yield Promise.resolve().then(() =>
          iL(Yw())
        )).UndiciStreamWrapper(X);
      else
        return new (yield Promise.resolve().then(() =>
          iL(Gw())
        )).NodePre18StreamWrapper(X);
    });
  }
  v8.chooseStreamWrapper = sr;
});
var Ww = s((C7) => {
  var tr =
    (C7 && C7.__awaiter) ||
    function (X, Y, Q, G) {
      function J(U) {
        return U instanceof Q
          ? U
          : new Q(function ($) {
              $(U);
            });
      }
      return new (Q || (Q = Promise))(function (U, $) {
        function B(W) {
          try {
            V(G.next(W));
          } catch (L) {
            $(L);
          }
        }
        function K(W) {
          try {
            V(G.throw(W));
          } catch (L) {
            $(L);
          }
        }
        function V(W) {
          W.done ? U(W.value) : J(W.value).then(B, K);
        }
        V((G = G.apply(X, Y || [])).next());
      });
    };
  Object.defineProperty(C7, "__esModule", { value: !0 });
  C7.getResponseBody = void 0;
  var er = Jw();
  function Xo(X, Y) {
    return tr(this, void 0, void 0, function* () {
      if (X.body != null && Y === "blob") return yield X.blob();
      else if (X.body != null && Y === "sse") return X.body;
      else if (X.body != null && Y === "streaming")
        return (0, er.chooseStreamWrapper)(X.body);
      else if (X.body != null && Y === "text") return yield X.text();
      else {
        let Q = yield X.text();
        if (Q.length > 0)
          try {
            return JSON.parse(Q);
          } catch (G) {
            return {
              ok: !1,
              error: { reason: "non-json", statusCode: X.status, rawBody: Q },
            };
          }
        else return;
      }
    });
  }
  C7.getResponseBody = Xo;
});
var Uw = s((Hw) => {
  Object.defineProperty(Hw, "__esModule", { value: !0 });
  Hw.anySignal = Hw.getTimeoutSignal = void 0;
  var Yo = "timeout";
  function Qo(X) {
    let Y = new AbortController(),
      Q = setTimeout(() => Y.abort(Yo), X);
    return { signal: Y.signal, abortId: Q };
  }
  Hw.getTimeoutSignal = Qo;
  function Go(...X) {
    let Y = X.length === 1 && Array.isArray(X[0]) ? X[0] : X,
      Q = new AbortController();
    for (let G of Y) {
      if (G.aborted) {
        Q.abort(G === null || G === void 0 ? void 0 : G.reason);
        break;
      }
      G.addEventListener(
        "abort",
        () => Q.abort(G === null || G === void 0 ? void 0 : G.reason),
        { signal: Q.signal }
      );
    }
    return Q.signal;
  }
  Hw.anySignal = Go;
});
var Bw = s((I7) => {
  var Wo =
    (I7 && I7.__awaiter) ||
    function (X, Y, Q, G) {
      function J(U) {
        return U instanceof Q
          ? U
          : new Q(function ($) {
              $(U);
            });
      }
      return new (Q || (Q = Promise))(function (U, $) {
        function B(W) {
          try {
            V(G.next(W));
          } catch (L) {
            $(L);
          }
        }
        function K(W) {
          try {
            V(G.throw(W));
          } catch (L) {
            $(L);
          }
        }
        function V(W) {
          W.done ? U(W.value) : J(W.value).then(B, K);
        }
        V((G = G.apply(X, Y || [])).next());
      });
    };
  Object.defineProperty(I7, "__esModule", { value: !0 });
  I7.makeRequest = void 0;
  var Lw = Uw(),
    Ho = (X, Y, Q, G, J, U, $, B, K) =>
      Wo(void 0, void 0, void 0, function* () {
        let V = [],
          W = void 0;
        if (U != null) {
          let { signal: F, abortId: N } = (0, Lw.getTimeoutSignal)(U);
          ((W = N), V.push(F));
        }
        if ($ != null) V.push($);
        let L = (0, Lw.anySignal)(V),
          H = yield X(Y, {
            method: Q,
            headers: G,
            body: J,
            signal: L,
            credentials: B ? "include" : void 0,
            duplex: K,
          });
        if (W != null) clearTimeout(W);
        return H;
      });
  I7.makeRequest = Ho;
});
var Kw = s((P7) => {
  var $o =
    (P7 && P7.__awaiter) ||
    function (X, Y, Q, G) {
      function J(U) {
        return U instanceof Q
          ? U
          : new Q(function ($) {
              $(U);
            });
      }
      return new (Q || (Q = Promise))(function (U, $) {
        function B(W) {
          try {
            V(G.next(W));
          } catch (L) {
            $(L);
          }
        }
        function K(W) {
          try {
            V(G.throw(W));
          } catch (L) {
            $(L);
          }
        }
        function V(W) {
          W.done ? U(W.value) : J(W.value).then(B, K);
        }
        V((G = G.apply(X, Y || [])).next());
      });
    };
  Object.defineProperty(P7, "__esModule", { value: !0 });
  P7.requestWithRetries = void 0;
  var Uo = 1,
    Lo = 60,
    Bo = 2;
  function Ko(X, Y = Bo) {
    return $o(this, void 0, void 0, function* () {
      let Q = yield X();
      for (let G = 0; G < Y; ++G)
        if ([408, 409, 429].includes(Q.status) || Q.status >= 500) {
          let J = Math.min(Uo * Math.pow(2, G), Lo);
          (yield new Promise((U) => setTimeout(U, J)), (Q = yield X()));
        } else break;
      return Q;
    });
  }
  P7.requestWithRetries = Ko;
});
var Nw = s((o4) => {
  var Vw =
    (o4 && o4.__awaiter) ||
    function (X, Y, Q, G) {
      function J(U) {
        return U instanceof Q
          ? U
          : new Q(function ($) {
              $(U);
            });
      }
      return new (Q || (Q = Promise))(function (U, $) {
        function B(W) {
          try {
            V(G.next(W));
          } catch (L) {
            $(L);
          }
        }
        function K(W) {
          try {
            V(G.throw(W));
          } catch (L) {
            $(L);
          }
        }
        function V(W) {
          W.done ? U(W.value) : J(W.value).then(B, K);
        }
        V((G = G.apply(X, Y || [])).next());
      });
    };
  Object.defineProperty(o4, "__esModule", { value: !0 });
  o4.fetcher = o4.fetcherImpl = void 0;
  var Vo = p3(),
    Fo = t3(),
    No = e3(),
    Mo = Ww(),
    Ao = Bw(),
    qo = Kw();
  function Fw(X) {
    return Vw(this, void 0, void 0, function* () {
      let Y = {};
      if (X.body !== void 0 && X.contentType != null)
        Y["Content-Type"] = X.contentType;
      if (X.headers != null) {
        for (let [U, $] of Object.entries(X.headers)) if ($ != null) Y[U] = $;
      }
      let Q = (0, Vo.createRequestUrl)(X.url, X.queryParameters),
        G = yield (0, No.getRequestBody)({
          body: X.body,
          type: X.requestType === "json" ? "json" : "other",
        }),
        J = yield (0, Fo.getFetchFn)();
      try {
        let U = yield (0, qo.requestWithRetries)(
            () =>
              Vw(this, void 0, void 0, function* () {
                return (0, Ao.makeRequest)(
                  J,
                  Q,
                  X.method,
                  Y,
                  G,
                  X.timeoutMs,
                  X.abortSignal,
                  X.withCredentials,
                  X.duplex
                );
              }),
            X.maxRetries
          ),
          $ = yield (0, Mo.getResponseBody)(U, X.responseType);
        if (U.status >= 200 && U.status < 400)
          return { ok: !0, body: $, headers: U.headers };
        else
          return {
            ok: !1,
            error: { reason: "status-code", statusCode: U.status, body: $ },
          };
      } catch (U) {
        if (X.abortSignal != null && X.abortSignal.aborted)
          return {
            ok: !1,
            error: {
              reason: "unknown",
              errorMessage: "The user aborted a request",
            },
          };
        else if (U instanceof Error && U.name === "AbortError")
          return { ok: !1, error: { reason: "timeout" } };
        else if (U instanceof Error)
          return {
            ok: !1,
            error: { reason: "unknown", errorMessage: U.message },
          };
        return {
          ok: !1,
          error: { reason: "unknown", errorMessage: JSON.stringify(U) },
        };
      }
    });
  }
  o4.fetcherImpl = Fw;
  o4.fetcher = Fw;
});
var qw = s((Mw) => {
  Object.defineProperty(Mw, "__esModule", { value: !0 });
  Mw.getHeader = void 0;
  function Ro(X, Y) {
    for (let [Q, G] of Object.entries(X))
      if (Q.toLowerCase() === Y.toLowerCase()) return G;
    return;
  }
  Mw.getHeader = Ro;
});
var Rw = s((S7) => {
  var Do =
    (S7 && S7.__awaiter) ||
    function (X, Y, Q, G) {
      function J(U) {
        return U instanceof Q
          ? U
          : new Q(function ($) {
              $(U);
            });
      }
      return new (Q || (Q = Promise))(function (U, $) {
        function B(W) {
          try {
            V(G.next(W));
          } catch (L) {
            $(L);
          }
        }
        function K(W) {
          try {
            V(G.throw(W));
          } catch (L) {
            $(L);
          }
        }
        function V(W) {
          W.done ? U(W.value) : J(W.value).then(B, K);
        }
        V((G = G.apply(X, Y || [])).next());
      });
    };
  Object.defineProperty(S7, "__esModule", { value: !0 });
  S7.Supplier = void 0;
  S7.Supplier = {
    get: (X) =>
      Do(void 0, void 0, void 0, function* () {
        if (typeof X === "function") return X();
        else return X;
      }),
  };
});
var Dw = s((AQ) => {
  Object.defineProperty(AQ, "__esModule", { value: !0 });
  AQ.Supplier = AQ.getHeader = AQ.fetcher = void 0;
  var zo = Nw();
  Object.defineProperty(AQ, "fetcher", {
    enumerable: !0,
    get: function () {
      return zo.fetcher;
    },
  });
  var Eo = qw();
  Object.defineProperty(AQ, "getHeader", {
    enumerable: !0,
    get: function () {
      return Eo.getHeader;
    },
  });
  var Oo = Rw();
  Object.defineProperty(AQ, "Supplier", {
    enumerable: !0,
    get: function () {
      return Oo.Supplier;
    },
  });
});
var zw = s((nL, aL) => {
  (function (X, Y) {
    typeof nL === "object" && typeof aL < "u"
      ? (aL.exports = Y())
      : typeof define === "function" && define.amd
        ? define(Y)
        : (function () {
            var Q = X.Base64,
              G = Y();
            if (
              ((G.noConflict = function () {
                return ((X.Base64 = Q), G);
              }),
              X.Meteor)
            )
              Base64 = G;
            X.Base64 = G;
          })();
  })(
    typeof self < "u"
      ? self
      : typeof window < "u"
        ? window
        : typeof global < "u"
          ? global
          : nL,
    function () {
      var X = "3.7.2",
        Y = X,
        Q = typeof atob === "function",
        G = typeof btoa === "function",
        J = typeof Buffer === "function",
        U = typeof TextDecoder === "function" ? new TextDecoder() : void 0,
        $ = typeof TextEncoder === "function" ? new TextEncoder() : void 0,
        B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        K = Array.prototype.slice.call(B),
        V = (function (k) {
          var o = {};
          return (
            k.forEach(function (J0, z0) {
              return (o[J0] = z0);
            }),
            o
          );
        })(K),
        W =
          /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/,
        L = String.fromCharCode.bind(String),
        H =
          typeof Uint8Array.from === "function"
            ? Uint8Array.from.bind(Uint8Array)
            : function (k, o) {
                if (o === void 0)
                  o = function (J0) {
                    return J0;
                  };
                return new Uint8Array(Array.prototype.slice.call(k, 0).map(o));
              },
        F = function (k) {
          return k.replace(/=/g, "").replace(/[+\/]/g, function (o) {
            return o == "+" ? "-" : "_";
          });
        },
        N = function (k) {
          return k.replace(/[^A-Za-z0-9\+\/]/g, "");
        },
        q = function (k) {
          var o,
            J0,
            z0,
            A0,
            w0 = "",
            Y1 = k.length % 3;
          for (var b = 0; b < k.length; ) {
            if (
              (J0 = k.charCodeAt(b++)) > 255 ||
              (z0 = k.charCodeAt(b++)) > 255 ||
              (A0 = k.charCodeAt(b++)) > 255
            )
              throw TypeError("invalid character found");
            ((o = (J0 << 16) | (z0 << 8) | A0),
              (w0 +=
                K[(o >> 18) & 63] +
                K[(o >> 12) & 63] +
                K[(o >> 6) & 63] +
                K[o & 63]));
          }
          return Y1 ? w0.slice(0, Y1 - 3) + "===".substring(Y1) : w0;
        },
        M = G
          ? function (k) {
              return btoa(k);
            }
          : J
            ? function (k) {
                return Buffer.from(k, "binary").toString("base64");
              }
            : q,
        A = J
          ? function (k) {
              return Buffer.from(k).toString("base64");
            }
          : function (k) {
              var o = 4096,
                J0 = [];
              for (var z0 = 0, A0 = k.length; z0 < A0; z0 += o)
                J0.push(L.apply(null, k.subarray(z0, z0 + o)));
              return M(J0.join(""));
            },
        D = function (k, o) {
          if (o === void 0) o = !1;
          return o ? F(A(k)) : A(k);
        },
        R = function (k) {
          if (k.length < 2) {
            var o = k.charCodeAt(0);
            return o < 128
              ? k
              : o < 2048
                ? L(192 | (o >>> 6)) + L(128 | (o & 63))
                : L(224 | ((o >>> 12) & 15)) +
                  L(128 | ((o >>> 6) & 63)) +
                  L(128 | (o & 63));
          } else {
            var o =
              65536 +
              (k.charCodeAt(0) - 55296) * 1024 +
              (k.charCodeAt(1) - 56320);
            return (
              L(240 | ((o >>> 18) & 7)) +
              L(128 | ((o >>> 12) & 63)) +
              L(128 | ((o >>> 6) & 63)) +
              L(128 | (o & 63))
            );
          }
        },
        z = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g,
        E = function (k) {
          return k.replace(z, R);
        },
        O = J
          ? function (k) {
              return Buffer.from(k, "utf8").toString("base64");
            }
          : $
            ? function (k) {
                return A($.encode(k));
              }
            : function (k) {
                return M(E(k));
              },
        Z = function (k, o) {
          if (o === void 0) o = !1;
          return o ? F(O(k)) : O(k);
        },
        j = function (k) {
          return Z(k, !0);
        },
        w =
          /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g,
        I = function (k) {
          switch (k.length) {
            case 4:
              var o =
                  ((7 & k.charCodeAt(0)) << 18) |
                  ((63 & k.charCodeAt(1)) << 12) |
                  ((63 & k.charCodeAt(2)) << 6) |
                  (63 & k.charCodeAt(3)),
                J0 = o - 65536;
              return L((J0 >>> 10) + 55296) + L((J0 & 1023) + 56320);
            case 3:
              return L(
                ((15 & k.charCodeAt(0)) << 12) |
                  ((63 & k.charCodeAt(1)) << 6) |
                  (63 & k.charCodeAt(2))
              );
            default:
              return L(((31 & k.charCodeAt(0)) << 6) | (63 & k.charCodeAt(1)));
          }
        },
        T = function (k) {
          return k.replace(w, I);
        },
        y = function (k) {
          if (((k = k.replace(/\s+/g, "")), !W.test(k)))
            throw TypeError("malformed base64.");
          k += "==".slice(2 - (k.length & 3));
          var o,
            J0 = "",
            z0,
            A0;
          for (var w0 = 0; w0 < k.length; )
            ((o =
              (V[k.charAt(w0++)] << 18) |
              (V[k.charAt(w0++)] << 12) |
              ((z0 = V[k.charAt(w0++)]) << 6) |
              (A0 = V[k.charAt(w0++)])),
              (J0 +=
                z0 === 64
                  ? L((o >> 16) & 255)
                  : A0 === 64
                    ? L((o >> 16) & 255, (o >> 8) & 255)
                    : L((o >> 16) & 255, (o >> 8) & 255, o & 255)));
          return J0;
        },
        _ = Q
          ? function (k) {
              return atob(N(k));
            }
          : J
            ? function (k) {
                return Buffer.from(k, "base64").toString("binary");
              }
            : y,
        f = J
          ? function (k) {
              return H(Buffer.from(k, "base64"));
            }
          : function (k) {
              return H(_(k), function (o) {
                return o.charCodeAt(0);
              });
            },
        l = function (k) {
          return f(p(k));
        },
        h = J
          ? function (k) {
              return Buffer.from(k, "base64").toString("utf8");
            }
          : U
            ? function (k) {
                return U.decode(f(k));
              }
            : function (k) {
                return T(_(k));
              },
        p = function (k) {
          return N(
            k.replace(/[-_]/g, function (o) {
              return o == "-" ? "+" : "/";
            })
          );
        },
        N0 = function (k) {
          return h(p(k));
        },
        e = function (k) {
          if (typeof k !== "string") return !1;
          var o = k.replace(/\s+/g, "").replace(/={0,2}$/, "");
          return !/[^\s0-9a-zA-Z\+/]/.test(o) || !/[^\s0-9a-zA-Z\-_]/.test(o);
        },
        P = function (k) {
          return { value: k, enumerable: !1, writable: !0, configurable: !0 };
        },
        x = function () {
          var k = function (o, J0) {
            return Object.defineProperty(String.prototype, o, P(J0));
          };
          (k("fromBase64", function () {
            return N0(this);
          }),
            k("toBase64", function (o) {
              return Z(this, o);
            }),
            k("toBase64URI", function () {
              return Z(this, !0);
            }),
            k("toBase64URL", function () {
              return Z(this, !0);
            }),
            k("toUint8Array", function () {
              return l(this);
            }));
        },
        r = function () {
          var k = function (o, J0) {
            return Object.defineProperty(Uint8Array.prototype, o, P(J0));
          };
          (k("toBase64", function (o) {
            return D(this, o);
          }),
            k("toBase64URI", function () {
              return D(this, !0);
            }),
            k("toBase64URL", function () {
              return D(this, !0);
            }));
        },
        C = function () {
          (x(), r());
        },
        v = {
          version: X,
          VERSION: Y,
          atob: _,
          atobPolyfill: y,
          btoa: M,
          btoaPolyfill: q,
          fromBase64: N0,
          toBase64: Z,
          encode: Z,
          encodeURI: j,
          encodeURL: j,
          utob: E,
          btou: T,
          decode: N0,
          isValid: e,
          fromUint8Array: D,
          toUint8Array: l,
          extendString: x,
          extendUint8Array: r,
          extendBuiltins: C,
        };
      return (
        (v.Base64 = {}),
        Object.keys(v).forEach(function (k) {
          return (v.Base64[k] = v[k]);
        }),
        v
      );
    }
  );
});
var jw = s((Ow) => {
  Object.defineProperty(Ow, "__esModule", { value: !0 });
  Ow.BasicAuth = void 0;
  var Ew = zw(),
    jo = /^Basic /i;
  Ow.BasicAuth = {
    toAuthorizationHeader: (X) => {
      if (X == null) return;
      return `Basic ${Ew.Base64.encode(`${X.username}:${X.password}`)}`;
    },
    fromAuthorizationHeader: (X) => {
      let Y = X.replace(jo, ""),
        Q = Ew.Base64.decode(Y),
        [G, J] = Q.split(":", 2);
      if (G == null || J == null) throw Error("Invalid basic auth");
      return { username: G, password: J };
    },
  };
});
var Iw = s((ww) => {
  Object.defineProperty(ww, "__esModule", { value: !0 });
  ww.BearerToken = void 0;
  var wo = /^Bearer /i;
  ww.BearerToken = {
    toAuthorizationHeader: (X) => {
      if (X == null) return;
      return `Bearer ${X}`;
    },
    fromAuthorizationHeader: (X) => {
      return X.replace(wo, "").trim();
    },
  };
});
var Pw = s((aJ) => {
  Object.defineProperty(aJ, "__esModule", { value: !0 });
  aJ.BearerToken = aJ.BasicAuth = void 0;
  var Co = jw();
  Object.defineProperty(aJ, "BasicAuth", {
    enumerable: !0,
    get: function () {
      return Co.BasicAuth;
    },
  });
  var Io = Iw();
  Object.defineProperty(aJ, "BearerToken", {
    enumerable: !0,
    get: function () {
      return Io.BearerToken;
    },
  });
});
var p5 = s((Sw) => {
  Object.defineProperty(Sw, "__esModule", { value: !0 });
  Sw.SchemaType = void 0;
  Sw.SchemaType = {
    DATE: "date",
    ENUM: "enum",
    LIST: "list",
    STRING_LITERAL: "stringLiteral",
    BOOLEAN_LITERAL: "booleanLiteral",
    OBJECT: "object",
    ANY: "any",
    BOOLEAN: "boolean",
    NUMBER: "number",
    STRING: "string",
    UNKNOWN: "unknown",
    RECORD: "record",
    SET: "set",
    UNION: "union",
    UNDISCRIMINATED_UNION: "undiscriminatedUnion",
    OPTIONAL: "optional",
  };
});
var F8 = s((bw) => {
  Object.defineProperty(bw, "__esModule", { value: !0 });
  bw.getErrorMessageForIncorrectType = void 0;
  function So(X, Y) {
    return `Expected ${Y}. Received ${To(X)}.`;
  }
  bw.getErrorMessageForIncorrectType = So;
  function To(X) {
    if (Array.isArray(X)) return "list";
    if (X === null) return "null";
    switch (typeof X) {
      case "string":
        return `"${X}"`;
      case "number":
      case "boolean":
      case "undefined":
        return `${X}`;
    }
    return typeof X;
  }
});
var V4 = s((yw) => {
  Object.defineProperty(yw, "__esModule", { value: !0 });
  yw.maybeSkipValidation = void 0;
  function bo(X) {
    return Object.assign(Object.assign({}, X), {
      json: kw(X.json),
      parse: kw(X.parse),
    });
  }
  yw.maybeSkipValidation = bo;
  function kw(X) {
    return (Y, Q) => {
      let G = X(Y, Q),
        { skipValidation: J = !1 } = Q !== null && Q !== void 0 ? Q : {};
      if (!G.ok && J)
        return (
          console.warn(
            [
              "Failed to validate.",
              ...G.errors.map(
                (U) =>
                  "  - " +
                  (U.path.length > 0
                    ? `${U.path.join(".")}: ${U.message}`
                    : U.message)
              ),
            ].join(`
`)
          ),
          { ok: !0, value: Y }
        );
      else return G;
    };
  }
});
var rL = s((fw) => {
  Object.defineProperty(fw, "__esModule", { value: !0 });
  fw.stringifyValidationError = void 0;
  function vo(X) {
    if (X.path.length === 0) return X.message;
    return `${X.path.join(" -> ")}: ${X.message}`;
  }
  fw.stringifyValidationError = vo;
});
var sL = s((hw) => {
  Object.defineProperty(hw, "__esModule", { value: !0 });
  hw.JsonError = void 0;
  var ko = rL();
  class oL extends Error {
    constructor(X) {
      super(X.map(ko.stringifyValidationError).join("; "));
      ((this.errors = X), Object.setPrototypeOf(this, oL.prototype));
    }
  }
  hw.JsonError = oL;
});
var eL = s((uw) => {
  Object.defineProperty(uw, "__esModule", { value: !0 });
  uw.ParseError = void 0;
  var yo = rL();
  class tL extends Error {
    constructor(X) {
      super(X.map(yo.stringifyValidationError).join("; "));
      ((this.errors = X), Object.setPrototypeOf(this, tL.prototype));
    }
  }
  uw.ParseError = tL;
});
var iw = s((dw) => {
  Object.defineProperty(dw, "__esModule", { value: !0 });
  dw.transform = dw.optional = dw.getSchemaUtils = void 0;
  var _o = p5(),
    fo = sL(),
    xo = eL();
  function XB(X) {
    return {
      optional: () => mw(X),
      transform: (Y) => cw(X, Y),
      parseOrThrow: (Y, Q) => {
        let G = X.parse(Y, Q);
        if (G.ok) return G.value;
        throw new xo.ParseError(G.errors);
      },
      jsonOrThrow: (Y, Q) => {
        let G = X.json(Y, Q);
        if (G.ok) return G.value;
        throw new fo.JsonError(G.errors);
      },
    };
  }
  dw.getSchemaUtils = XB;
  function mw(X) {
    let Y = {
      parse: (Q, G) => {
        if (Q == null) return { ok: !0, value: void 0 };
        return X.parse(Q, G);
      },
      json: (Q, G) => {
        if (
          (G === null || G === void 0 ? void 0 : G.omitUndefined) &&
          Q === void 0
        )
          return { ok: !0, value: void 0 };
        if (Q == null) return { ok: !0, value: null };
        return X.json(Q, G);
      },
      getType: () => _o.SchemaType.OPTIONAL,
    };
    return Object.assign(Object.assign({}, Y), XB(Y));
  }
  dw.optional = mw;
  function cw(X, Y) {
    let Q = {
      parse: (G, J) => {
        let U = X.parse(G, J);
        if (!U.ok) return U;
        return { ok: !0, value: Y.transform(U.value) };
      },
      json: (G, J) => {
        let U = Y.untransform(G);
        return X.json(U, J);
      },
      getType: () => X.getType(),
    };
    return Object.assign(Object.assign({}, Q), XB(Q));
  }
  dw.transform = cw;
});
var D8 = s((d9) => {
  Object.defineProperty(d9, "__esModule", { value: !0 });
  d9.ParseError =
    d9.JsonError =
    d9.transform =
    d9.optional =
    d9.getSchemaUtils =
      void 0;
  var YB = iw();
  Object.defineProperty(d9, "getSchemaUtils", {
    enumerable: !0,
    get: function () {
      return YB.getSchemaUtils;
    },
  });
  Object.defineProperty(d9, "optional", {
    enumerable: !0,
    get: function () {
      return YB.optional;
    },
  });
  Object.defineProperty(d9, "transform", {
    enumerable: !0,
    get: function () {
      return YB.transform;
    },
  });
  var uo = sL();
  Object.defineProperty(d9, "JsonError", {
    enumerable: !0,
    get: function () {
      return uo.JsonError;
    },
  });
  var lo = eL();
  Object.defineProperty(d9, "ParseError", {
    enumerable: !0,
    get: function () {
      return lo.ParseError;
    },
  });
});
var rw = s((nw) => {
  Object.defineProperty(nw, "__esModule", { value: !0 });
  nw.date = void 0;
  var co = p5(),
    QB = F8(),
    po = V4(),
    io = D8(),
    no =
      /^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([.,]\d+(?!:))?)?(\17[0-5]\d([.,]\d+)?)?([zZ]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
  function ao() {
    let X = {
      parse: (Y, { breadcrumbsPrefix: Q = [] } = {}) => {
        if (typeof Y !== "string")
          return {
            ok: !1,
            errors: [
              {
                path: Q,
                message: (0, QB.getErrorMessageForIncorrectType)(Y, "string"),
              },
            ],
          };
        if (!no.test(Y))
          return {
            ok: !1,
            errors: [
              {
                path: Q,
                message: (0, QB.getErrorMessageForIncorrectType)(
                  Y,
                  "ISO 8601 date string"
                ),
              },
            ],
          };
        return { ok: !0, value: new Date(Y) };
      },
      json: (Y, { breadcrumbsPrefix: Q = [] } = {}) => {
        if (Y instanceof Date) return { ok: !0, value: Y.toISOString() };
        else
          return {
            ok: !1,
            errors: [
              {
                path: Q,
                message: (0, QB.getErrorMessageForIncorrectType)(
                  Y,
                  "Date object"
                ),
              },
            ],
          };
      },
      getType: () => co.SchemaType.DATE,
    };
    return Object.assign(
      Object.assign({}, (0, po.maybeSkipValidation)(X)),
      (0, io.getSchemaUtils)(X)
    );
  }
  nw.date = ao;
});
var ow = s((GB) => {
  Object.defineProperty(GB, "__esModule", { value: !0 });
  GB.date = void 0;
  var ro = rw();
  Object.defineProperty(GB, "date", {
    enumerable: !0,
    get: function () {
      return ro.date;
    },
  });
});
var F4 = s((sw) => {
  Object.defineProperty(sw, "__esModule", { value: !0 });
  sw.createIdentitySchemaCreator = void 0;
  var so = D8(),
    to = V4();
  function eo(X, Y) {
    return () => {
      let Q = { parse: Y, json: Y, getType: () => X };
      return Object.assign(
        Object.assign({}, (0, to.maybeSkipValidation)(Q)),
        (0, so.getSchemaUtils)(Q)
      );
    };
  }
  sw.createIdentitySchemaCreator = eo;
});
var QC = s((XC) => {
  Object.defineProperty(XC, "__esModule", { value: !0 });
  XC.enum_ = void 0;
  var Xs = p5(),
    Ys = F4(),
    ew = F8();
  function Qs(X) {
    let Y = new Set(X);
    return (0, Ys.createIdentitySchemaCreator)(
      Xs.SchemaType.ENUM,
      (
        G,
        { allowUnrecognizedEnumValues: J, breadcrumbsPrefix: U = [] } = {}
      ) => {
        if (typeof G !== "string")
          return {
            ok: !1,
            errors: [
              {
                path: U,
                message: (0, ew.getErrorMessageForIncorrectType)(G, "string"),
              },
            ],
          };
        if (!Y.has(G) && !J)
          return {
            ok: !1,
            errors: [
              {
                path: U,
                message: (0, ew.getErrorMessageForIncorrectType)(G, "enum"),
              },
            ],
          };
        return { ok: !0, value: G };
      }
    )();
  }
  XC.enum_ = Qs;
});
var WB = s((JB) => {
  Object.defineProperty(JB, "__esModule", { value: !0 });
  JB.enum_ = void 0;
  var Gs = QC();
  Object.defineProperty(JB, "enum_", {
    enumerable: !0,
    get: function () {
      return Gs.enum_;
    },
  });
});
var HB = s((JC) => {
  Object.defineProperty(JC, "__esModule", { value: !0 });
  JC.getMemoizedSchema = JC.constructLazyBaseSchema = JC.lazy = void 0;
  var Ws = D8();
  function Hs(X) {
    let Y = GC(X);
    return Object.assign(Object.assign({}, Y), (0, Ws.getSchemaUtils)(Y));
  }
  JC.lazy = Hs;
  function GC(X) {
    return {
      parse: (Y, Q) => rJ(X).parse(Y, Q),
      json: (Y, Q) => rJ(X).json(Y, Q),
      getType: () => rJ(X).getType(),
    };
  }
  JC.constructLazyBaseSchema = GC;
  function rJ(X) {
    let Y = X;
    if (Y.__zurg_memoized == null) Y.__zurg_memoized = X();
    return Y.__zurg_memoized;
  }
  JC.getMemoizedSchema = rJ;
});
var $B = s((HC) => {
  Object.defineProperty(HC, "__esModule", { value: !0 });
  HC.entries = void 0;
  function Ls(X) {
    return Object.entries(X);
  }
  HC.entries = Ls;
});
var UB = s((UC) => {
  Object.defineProperty(UC, "__esModule", { value: !0 });
  UC.filterObject = void 0;
  function Bs(X, Y) {
    let Q = new Set(Y);
    return Object.entries(X).reduce((G, [J, U]) => {
      if (Q.has(J)) G[J] = U;
      return G;
    }, {});
  }
  UC.filterObject = Bs;
});
var qQ = s((BC) => {
  Object.defineProperty(BC, "__esModule", { value: !0 });
  BC.isPlainObject = void 0;
  function Ks(X) {
    if (typeof X !== "object" || X === null) return !1;
    if (Object.getPrototypeOf(X) === null) return !0;
    let Y = X;
    while (Object.getPrototypeOf(Y) !== null) Y = Object.getPrototypeOf(Y);
    return Object.getPrototypeOf(X) === Y;
  }
  BC.isPlainObject = Ks;
});
var LB = s((VC) => {
  Object.defineProperty(VC, "__esModule", { value: !0 });
  VC.keys = void 0;
  function Vs(X) {
    return Object.keys(X);
  }
  VC.keys = Vs;
});
var AC = s((NC) => {
  Object.defineProperty(NC, "__esModule", { value: !0 });
  NC.partition = void 0;
  function Fs(X, Y) {
    let Q = [],
      G = [];
    for (let J of X)
      if (Y(J)) Q.push(J);
      else G.push(J);
    return [Q, G];
  }
  NC.partition = Fs;
});
var EC = s((DC) => {
  Object.defineProperty(DC, "__esModule", { value: !0 });
  DC.withParsedProperties = DC.getObjectLikeUtils = void 0;
  var Ns = UB(),
    Ms = F8(),
    As = qQ(),
    qs = D8();
  function qC(X) {
    return { withParsedProperties: (Y) => RC(X, Y) };
  }
  DC.getObjectLikeUtils = qC;
  function RC(X, Y) {
    let Q = {
      parse: (G, J) => {
        let U = X.parse(G, J);
        if (!U.ok) return U;
        let $ = Object.entries(Y).reduce((B, [K, V]) => {
          return Object.assign(Object.assign({}, B), {
            [K]: typeof V === "function" ? V(U.value) : V,
          });
        }, {});
        return { ok: !0, value: Object.assign(Object.assign({}, U.value), $) };
      },
      json: (G, J) => {
        var U;
        if (!(0, As.isPlainObject)(G))
          return {
            ok: !1,
            errors: [
              {
                path:
                  (U =
                    J === null || J === void 0
                      ? void 0
                      : J.breadcrumbsPrefix) !== null && U !== void 0
                    ? U
                    : [],
                message: (0, Ms.getErrorMessageForIncorrectType)(G, "object"),
              },
            ],
          };
        let $ = new Set(Object.keys(Y)),
          B = (0, Ns.filterObject)(
            G,
            Object.keys(G).filter((K) => !$.has(K))
          );
        return X.json(B, J);
      },
      getType: () => X.getType(),
    };
    return Object.assign(
      Object.assign(Object.assign({}, Q), (0, qs.getSchemaUtils)(Q)),
      qC(Q)
    );
  }
  DC.withParsedProperties = RC;
});
var RQ = s((oJ) => {
  Object.defineProperty(oJ, "__esModule", { value: !0 });
  oJ.withParsedProperties = oJ.getObjectLikeUtils = void 0;
  var OC = EC();
  Object.defineProperty(oJ, "getObjectLikeUtils", {
    enumerable: !0,
    get: function () {
      return OC.getObjectLikeUtils;
    },
  });
  Object.defineProperty(oJ, "withParsedProperties", {
    enumerable: !0,
    get: function () {
      return OC.withParsedProperties;
    },
  });
});
var BB = s((ZC) => {
  Object.defineProperty(ZC, "__esModule", { value: !0 });
  ZC.isProperty = ZC.property = void 0;
  function zs(X, Y) {
    return { rawKey: X, valueSchema: Y, isProperty: !0 };
  }
  ZC.property = zs;
  function Es(X) {
    return X.isProperty;
  }
  ZC.isProperty = Es;
});
var VB = s((kC) => {
  Object.defineProperty(kC, "__esModule", { value: !0 });
  kC.getObjectUtils = kC.object = void 0;
  var zQ = p5(),
    wC = $B(),
    CC = UB(),
    Zs = F8(),
    js = qQ(),
    TC = LB(),
    ws = V4(),
    Cs = AC(),
    bC = RQ(),
    vC = D8(),
    DQ = BB();
  function Is(X) {
    let Y = {
      _getRawProperties: () =>
        Object.entries(X).map(([Q, G]) =>
          (0, DQ.isProperty)(G) ? G.rawKey : Q
        ),
      _getParsedProperties: () => (0, TC.keys)(X),
      parse: (Q, G) => {
        let J = {},
          U = [];
        for (let [$, B] of (0, wC.entries)(X)) {
          let K = (0, DQ.isProperty)(B) ? B.rawKey : $,
            V = (0, DQ.isProperty)(B) ? B.valueSchema : B,
            W = { rawKey: K, parsedKey: $, valueSchema: V };
          if (((J[K] = W), SC(V))) U.push(K);
        }
        return IC({
          value: Q,
          requiredKeys: U,
          getProperty: ($) => {
            let B = J[$];
            if (B == null) return;
            return {
              transformedKey: B.parsedKey,
              transform: (K) => {
                var V;
                return B.valueSchema.parse(
                  K,
                  Object.assign(Object.assign({}, G), {
                    breadcrumbsPrefix: [
                      ...((V =
                        G === null || G === void 0
                          ? void 0
                          : G.breadcrumbsPrefix) !== null && V !== void 0
                        ? V
                        : []),
                      $,
                    ],
                  })
                );
              },
            };
          },
          unrecognizedObjectKeys:
            G === null || G === void 0 ? void 0 : G.unrecognizedObjectKeys,
          skipValidation:
            G === null || G === void 0 ? void 0 : G.skipValidation,
          breadcrumbsPrefix:
            G === null || G === void 0 ? void 0 : G.breadcrumbsPrefix,
          omitUndefined: G === null || G === void 0 ? void 0 : G.omitUndefined,
        });
      },
      json: (Q, G) => {
        let J = [];
        for (let [U, $] of (0, wC.entries)(X)) {
          let B = (0, DQ.isProperty)($) ? $.valueSchema : $;
          if (SC(B)) J.push(U);
        }
        return IC({
          value: Q,
          requiredKeys: J,
          getProperty: (U) => {
            let $ = X[U];
            if ($ == null) return;
            if ((0, DQ.isProperty)($))
              return {
                transformedKey: $.rawKey,
                transform: (B) => {
                  var K;
                  return $.valueSchema.json(
                    B,
                    Object.assign(Object.assign({}, G), {
                      breadcrumbsPrefix: [
                        ...((K =
                          G === null || G === void 0
                            ? void 0
                            : G.breadcrumbsPrefix) !== null && K !== void 0
                          ? K
                          : []),
                        U,
                      ],
                    })
                  );
                },
              };
            else
              return {
                transformedKey: U,
                transform: (B) => {
                  var K;
                  return $.json(
                    B,
                    Object.assign(Object.assign({}, G), {
                      breadcrumbsPrefix: [
                        ...((K =
                          G === null || G === void 0
                            ? void 0
                            : G.breadcrumbsPrefix) !== null && K !== void 0
                          ? K
                          : []),
                        U,
                      ],
                    })
                  );
                },
              };
          },
          unrecognizedObjectKeys:
            G === null || G === void 0 ? void 0 : G.unrecognizedObjectKeys,
          skipValidation:
            G === null || G === void 0 ? void 0 : G.skipValidation,
          breadcrumbsPrefix:
            G === null || G === void 0 ? void 0 : G.breadcrumbsPrefix,
          omitUndefined: G === null || G === void 0 ? void 0 : G.omitUndefined,
        });
      },
      getType: () => zQ.SchemaType.OBJECT,
    };
    return Object.assign(
      Object.assign(
        Object.assign(
          Object.assign({}, (0, ws.maybeSkipValidation)(Y)),
          (0, vC.getSchemaUtils)(Y)
        ),
        (0, bC.getObjectLikeUtils)(Y)
      ),
      KB(Y)
    );
  }
  kC.object = Is;
  function IC({
    value: X,
    requiredKeys: Y,
    getProperty: Q,
    unrecognizedObjectKeys: G = "fail",
    skipValidation: J = !1,
    breadcrumbsPrefix: U = [],
  }) {
    if (!(0, js.isPlainObject)(X))
      return {
        ok: !1,
        errors: [
          {
            path: U,
            message: (0, Zs.getErrorMessageForIncorrectType)(X, "object"),
          },
        ],
      };
    let $ = new Set(Y),
      B = [],
      K = {};
    for (let [V, W] of Object.entries(X)) {
      let L = Q(V);
      if (L != null) {
        $.delete(V);
        let H = L.transform(W);
        if (H.ok) K[L.transformedKey] = H.value;
        else ((K[V] = W), B.push(...H.errors));
      } else
        switch (G) {
          case "fail":
            B.push({ path: [...U, V], message: `Unexpected key "${V}"` });
            break;
          case "strip":
            break;
          case "passthrough":
            K[V] = W;
            break;
        }
    }
    if (
      (B.push(
        ...Y.filter((V) => $.has(V)).map((V) => ({
          path: U,
          message: `Missing required key "${V}"`,
        }))
      ),
      B.length === 0 || J)
    )
      return { ok: !0, value: K };
    else return { ok: !1, errors: B };
  }
  function KB(X) {
    return {
      extend: (Y) => {
        let Q = {
          _getParsedProperties: () => [
            ...X._getParsedProperties(),
            ...Y._getParsedProperties(),
          ],
          _getRawProperties: () => [
            ...X._getRawProperties(),
            ...Y._getRawProperties(),
          ],
          parse: (G, J) => {
            return PC({
              extensionKeys: Y._getRawProperties(),
              value: G,
              transformBase: (U) => X.parse(U, J),
              transformExtension: (U) => Y.parse(U, J),
            });
          },
          json: (G, J) => {
            return PC({
              extensionKeys: Y._getParsedProperties(),
              value: G,
              transformBase: (U) => X.json(U, J),
              transformExtension: (U) => Y.json(U, J),
            });
          },
          getType: () => zQ.SchemaType.OBJECT,
        };
        return Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, Q), (0, vC.getSchemaUtils)(Q)),
            (0, bC.getObjectLikeUtils)(Q)
          ),
          KB(Q)
        );
      },
    };
  }
  kC.getObjectUtils = KB;
  function PC({
    extensionKeys: X,
    value: Y,
    transformBase: Q,
    transformExtension: G,
  }) {
    let J = new Set(X),
      [U, $] = (0, Cs.partition)((0, TC.keys)(Y), (V) => J.has(V)),
      B = Q((0, CC.filterObject)(Y, $)),
      K = G((0, CC.filterObject)(Y, U));
    if (B.ok && K.ok)
      return {
        ok: !0,
        value: Object.assign(Object.assign({}, B.value), K.value),
      };
    else
      return {
        ok: !1,
        errors: [...(B.ok ? [] : B.errors), ...(K.ok ? [] : K.errors)],
      };
  }
  function SC(X) {
    return !Ps(X);
  }
  function Ps(X) {
    switch (X.getType()) {
      case zQ.SchemaType.ANY:
      case zQ.SchemaType.UNKNOWN:
      case zQ.SchemaType.OPTIONAL:
        return !0;
      default:
        return !1;
    }
  }
});
var xC = s((_C) => {
  Object.defineProperty(_C, "__esModule", { value: !0 });
  _C.objectWithoutOptionalProperties = void 0;
  var Ts = VB();
  function bs(X) {
    return (0, Ts.object)(X);
  }
  _C.objectWithoutOptionalProperties = bs;
});
var FB = s((p9) => {
  Object.defineProperty(p9, "__esModule", { value: !0 });
  p9.property =
    p9.isProperty =
    p9.objectWithoutOptionalProperties =
    p9.object =
    p9.getObjectUtils =
      void 0;
  var hC = VB();
  Object.defineProperty(p9, "getObjectUtils", {
    enumerable: !0,
    get: function () {
      return hC.getObjectUtils;
    },
  });
  Object.defineProperty(p9, "object", {
    enumerable: !0,
    get: function () {
      return hC.object;
    },
  });
  var vs = xC();
  Object.defineProperty(p9, "objectWithoutOptionalProperties", {
    enumerable: !0,
    get: function () {
      return vs.objectWithoutOptionalProperties;
    },
  });
  var gC = BB();
  Object.defineProperty(p9, "isProperty", {
    enumerable: !0,
    get: function () {
      return gC.isProperty;
    },
  });
  Object.defineProperty(p9, "property", {
    enumerable: !0,
    get: function () {
      return gC.property;
    },
  });
});
var mC = s((uC) => {
  Object.defineProperty(uC, "__esModule", { value: !0 });
  uC.lazyObject = void 0;
  var ys = FB(),
    _s = RQ(),
    fs = D8(),
    NB = HB();
  function xs(X) {
    let Y = Object.assign(
      Object.assign({}, (0, NB.constructLazyBaseSchema)(X)),
      {
        _getRawProperties: () =>
          (0, NB.getMemoizedSchema)(X)._getRawProperties(),
        _getParsedProperties: () =>
          (0, NB.getMemoizedSchema)(X)._getParsedProperties(),
      }
    );
    return Object.assign(
      Object.assign(
        Object.assign(Object.assign({}, Y), (0, fs.getSchemaUtils)(Y)),
        (0, _s.getObjectLikeUtils)(Y)
      ),
      (0, ys.getObjectUtils)(Y)
    );
  }
  uC.lazyObject = xs;
});
var cC = s((sJ) => {
  Object.defineProperty(sJ, "__esModule", { value: !0 });
  sJ.lazyObject = sJ.lazy = void 0;
  var hs = HB();
  Object.defineProperty(sJ, "lazy", {
    enumerable: !0,
    get: function () {
      return hs.lazy;
    },
  });
  var gs = mC();
  Object.defineProperty(sJ, "lazyObject", {
    enumerable: !0,
    get: function () {
      return gs.lazyObject;
    },
  });
});
var nC = s((pC) => {
  Object.defineProperty(pC, "__esModule", { value: !0 });
  pC.list = void 0;
  var ls = p5(),
    ms = F8(),
    cs = V4(),
    ds = D8();
  function ps(X) {
    let Y = {
      parse: (Q, G) =>
        dC(Q, (J, U) => {
          var $;
          return X.parse(
            J,
            Object.assign(Object.assign({}, G), {
              breadcrumbsPrefix: [
                ...(($ =
                  G === null || G === void 0 ? void 0 : G.breadcrumbsPrefix) !==
                  null && $ !== void 0
                  ? $
                  : []),
                `[${U}]`,
              ],
            })
          );
        }),
      json: (Q, G) =>
        dC(Q, (J, U) => {
          var $;
          return X.json(
            J,
            Object.assign(Object.assign({}, G), {
              breadcrumbsPrefix: [
                ...(($ =
                  G === null || G === void 0 ? void 0 : G.breadcrumbsPrefix) !==
                  null && $ !== void 0
                  ? $
                  : []),
                `[${U}]`,
              ],
            })
          );
        }),
      getType: () => ls.SchemaType.LIST,
    };
    return Object.assign(
      Object.assign({}, (0, cs.maybeSkipValidation)(Y)),
      (0, ds.getSchemaUtils)(Y)
    );
  }
  pC.list = ps;
  function dC(X, Y) {
    if (!Array.isArray(X))
      return {
        ok: !1,
        errors: [
          {
            message: (0, ms.getErrorMessageForIncorrectType)(X, "list"),
            path: [],
          },
        ],
      };
    return X.map((G, J) => Y(G, J)).reduce(
      (G, J) => {
        if (G.ok && J.ok) return { ok: !0, value: [...G.value, J.value] };
        let U = [];
        if (!G.ok) U.push(...G.errors);
        if (!J.ok) U.push(...J.errors);
        return { ok: !1, errors: U };
      },
      { ok: !0, value: [] }
    );
  }
});
var AB = s((MB) => {
  Object.defineProperty(MB, "__esModule", { value: !0 });
  MB.list = void 0;
  var is = nC();
  Object.defineProperty(MB, "list", {
    enumerable: !0,
    get: function () {
      return is.list;
    },
  });
});
var oC = s((aC) => {
  Object.defineProperty(aC, "__esModule", { value: !0 });
  aC.stringLiteral = void 0;
  var as = p5(),
    rs = F4(),
    os = F8();
  function ss(X) {
    return (0, rs.createIdentitySchemaCreator)(
      as.SchemaType.STRING_LITERAL,
      (Q, { breadcrumbsPrefix: G = [] } = {}) => {
        if (Q === X) return { ok: !0, value: X };
        else
          return {
            ok: !1,
            errors: [
              {
                path: G,
                message: (0, os.getErrorMessageForIncorrectType)(Q, `"${X}"`),
              },
            ],
          };
      }
    )();
  }
  aC.stringLiteral = ss;
});
var eC = s((sC) => {
  Object.defineProperty(sC, "__esModule", { value: !0 });
  sC.booleanLiteral = void 0;
  var ts = p5(),
    es = F4(),
    Xt = F8();
  function Yt(X) {
    return (0, es.createIdentitySchemaCreator)(
      ts.SchemaType.BOOLEAN_LITERAL,
      (Q, { breadcrumbsPrefix: G = [] } = {}) => {
        if (Q === X) return { ok: !0, value: X };
        else
          return {
            ok: !1,
            errors: [
              {
                path: G,
                message: (0, Xt.getErrorMessageForIncorrectType)(
                  Q,
                  `${X.toString()}`
                ),
              },
            ],
          };
      }
    )();
  }
  sC.booleanLiteral = Yt;
});
var XI = s((tJ) => {
  Object.defineProperty(tJ, "__esModule", { value: !0 });
  tJ.booleanLiteral = tJ.stringLiteral = void 0;
  var Qt = oC();
  Object.defineProperty(tJ, "stringLiteral", {
    enumerable: !0,
    get: function () {
      return Qt.stringLiteral;
    },
  });
  var Gt = eC();
  Object.defineProperty(tJ, "booleanLiteral", {
    enumerable: !0,
    get: function () {
      return Gt.booleanLiteral;
    },
  });
});
var GI = s((YI) => {
  Object.defineProperty(YI, "__esModule", { value: !0 });
  YI.any = void 0;
  var Wt = p5(),
    Ht = F4();
  YI.any = (0, Ht.createIdentitySchemaCreator)(Wt.SchemaType.ANY, (X) => ({
    ok: !0,
    value: X,
  }));
});
var HI = s((JI) => {
  Object.defineProperty(JI, "__esModule", { value: !0 });
  JI.boolean = void 0;
  var $t = p5(),
    Ut = F4(),
    Lt = F8();
  JI.boolean = (0, Ut.createIdentitySchemaCreator)(
    $t.SchemaType.BOOLEAN,
    (X, { breadcrumbsPrefix: Y = [] } = {}) => {
      if (typeof X === "boolean") return { ok: !0, value: X };
      else
        return {
          ok: !1,
          errors: [
            {
              path: Y,
              message: (0, Lt.getErrorMessageForIncorrectType)(X, "boolean"),
            },
          ],
        };
    }
  );
});
var LI = s(($I) => {
  Object.defineProperty($I, "__esModule", { value: !0 });
  $I.number = void 0;
  var Bt = p5(),
    Kt = F4(),
    Vt = F8();
  $I.number = (0, Kt.createIdentitySchemaCreator)(
    Bt.SchemaType.NUMBER,
    (X, { breadcrumbsPrefix: Y = [] } = {}) => {
      if (typeof X === "number") return { ok: !0, value: X };
      else
        return {
          ok: !1,
          errors: [
            {
              path: Y,
              message: (0, Vt.getErrorMessageForIncorrectType)(X, "number"),
            },
          ],
        };
    }
  );
});
var VI = s((BI) => {
  Object.defineProperty(BI, "__esModule", { value: !0 });
  BI.string = void 0;
  var Ft = p5(),
    Nt = F4(),
    Mt = F8();
  BI.string = (0, Nt.createIdentitySchemaCreator)(
    Ft.SchemaType.STRING,
    (X, { breadcrumbsPrefix: Y = [] } = {}) => {
      if (typeof X === "string") return { ok: !0, value: X };
      else
        return {
          ok: !1,
          errors: [
            {
              path: Y,
              message: (0, Mt.getErrorMessageForIncorrectType)(X, "string"),
            },
          ],
        };
    }
  );
});
var MI = s((FI) => {
  Object.defineProperty(FI, "__esModule", { value: !0 });
  FI.unknown = void 0;
  var At = p5(),
    qt = F4();
  FI.unknown = (0, qt.createIdentitySchemaCreator)(
    At.SchemaType.UNKNOWN,
    (X) => ({ ok: !0, value: X })
  );
});
var AI = s((i9) => {
  Object.defineProperty(i9, "__esModule", { value: !0 });
  i9.unknown = i9.string = i9.number = i9.boolean = i9.any = void 0;
  var Rt = GI();
  Object.defineProperty(i9, "any", {
    enumerable: !0,
    get: function () {
      return Rt.any;
    },
  });
  var Dt = HI();
  Object.defineProperty(i9, "boolean", {
    enumerable: !0,
    get: function () {
      return Dt.boolean;
    },
  });
  var zt = LI();
  Object.defineProperty(i9, "number", {
    enumerable: !0,
    get: function () {
      return zt.number;
    },
  });
  var Et = VI();
  Object.defineProperty(i9, "string", {
    enumerable: !0,
    get: function () {
      return Et.string;
    },
  });
  var Ot = MI();
  Object.defineProperty(i9, "unknown", {
    enumerable: !0,
    get: function () {
      return Ot.unknown;
    },
  });
});
var zI = s((RI) => {
  Object.defineProperty(RI, "__esModule", { value: !0 });
  RI.record = void 0;
  var qB = p5(),
    jt = $B(),
    wt = F8(),
    Ct = qQ(),
    It = V4(),
    Pt = D8();
  function St(X, Y) {
    let Q = {
      parse: (G, J) => {
        return qI({
          value: G,
          isKeyNumeric: X.getType() === qB.SchemaType.NUMBER,
          transformKey: (U) => {
            var $;
            return X.parse(
              U,
              Object.assign(Object.assign({}, J), {
                breadcrumbsPrefix: [
                  ...(($ =
                    J === null || J === void 0
                      ? void 0
                      : J.breadcrumbsPrefix) !== null && $ !== void 0
                    ? $
                    : []),
                  `${U} (key)`,
                ],
              })
            );
          },
          transformValue: (U, $) => {
            var B;
            return Y.parse(
              U,
              Object.assign(Object.assign({}, J), {
                breadcrumbsPrefix: [
                  ...((B =
                    J === null || J === void 0
                      ? void 0
                      : J.breadcrumbsPrefix) !== null && B !== void 0
                    ? B
                    : []),
                  `${$}`,
                ],
              })
            );
          },
          breadcrumbsPrefix:
            J === null || J === void 0 ? void 0 : J.breadcrumbsPrefix,
        });
      },
      json: (G, J) => {
        return qI({
          value: G,
          isKeyNumeric: X.getType() === qB.SchemaType.NUMBER,
          transformKey: (U) => {
            var $;
            return X.json(
              U,
              Object.assign(Object.assign({}, J), {
                breadcrumbsPrefix: [
                  ...(($ =
                    J === null || J === void 0
                      ? void 0
                      : J.breadcrumbsPrefix) !== null && $ !== void 0
                    ? $
                    : []),
                  `${U} (key)`,
                ],
              })
            );
          },
          transformValue: (U, $) => {
            var B;
            return Y.json(
              U,
              Object.assign(Object.assign({}, J), {
                breadcrumbsPrefix: [
                  ...((B =
                    J === null || J === void 0
                      ? void 0
                      : J.breadcrumbsPrefix) !== null && B !== void 0
                    ? B
                    : []),
                  `${$}`,
                ],
              })
            );
          },
          breadcrumbsPrefix:
            J === null || J === void 0 ? void 0 : J.breadcrumbsPrefix,
        });
      },
      getType: () => qB.SchemaType.RECORD,
    };
    return Object.assign(
      Object.assign({}, (0, It.maybeSkipValidation)(Q)),
      (0, Pt.getSchemaUtils)(Q)
    );
  }
  RI.record = St;
  function qI({
    value: X,
    isKeyNumeric: Y,
    transformKey: Q,
    transformValue: G,
    breadcrumbsPrefix: J = [],
  }) {
    if (!(0, Ct.isPlainObject)(X))
      return {
        ok: !1,
        errors: [
          {
            path: J,
            message: (0, wt.getErrorMessageForIncorrectType)(X, "object"),
          },
        ],
      };
    return (0, jt.entries)(X).reduce(
      (U, [$, B]) => {
        if (B == null) return U;
        let K = U,
          V = $;
        if (Y) {
          let F = $.length > 0 ? Number($) : NaN;
          if (!isNaN(F)) V = F;
        }
        let W = Q(V),
          L = G(B, V);
        if (K.ok && W.ok && L.ok)
          return {
            ok: !0,
            value: Object.assign(Object.assign({}, K.value), {
              [W.value]: L.value,
            }),
          };
        let H = [];
        if (!K.ok) H.push(...K.errors);
        if (!W.ok) H.push(...W.errors);
        if (!L.ok) H.push(...L.errors);
        return { ok: !1, errors: H };
      },
      { ok: !0, value: {} }
    );
  }
});
var EI = s((RB) => {
  Object.defineProperty(RB, "__esModule", { value: !0 });
  RB.record = void 0;
  var Tt = zI();
  Object.defineProperty(RB, "record", {
    enumerable: !0,
    get: function () {
      return Tt.record;
    },
  });
});
var jI = s((OI) => {
  Object.defineProperty(OI, "__esModule", { value: !0 });
  OI.set = void 0;
  var vt = p5(),
    kt = F8(),
    yt = V4(),
    _t = AB(),
    ft = D8();
  function xt(X) {
    let Y = (0, _t.list)(X),
      Q = {
        parse: (G, J) => {
          let U = Y.parse(G, J);
          if (U.ok) return { ok: !0, value: new Set(U.value) };
          else return U;
        },
        json: (G, J) => {
          var U;
          if (!(G instanceof Set))
            return {
              ok: !1,
              errors: [
                {
                  path:
                    (U =
                      J === null || J === void 0
                        ? void 0
                        : J.breadcrumbsPrefix) !== null && U !== void 0
                      ? U
                      : [],
                  message: (0, kt.getErrorMessageForIncorrectType)(G, "Set"),
                },
              ],
            };
          return Y.json([...G], J);
        },
        getType: () => vt.SchemaType.SET,
      };
    return Object.assign(
      Object.assign({}, (0, yt.maybeSkipValidation)(Q)),
      (0, ft.getSchemaUtils)(Q)
    );
  }
  OI.set = xt;
});
var wI = s((DB) => {
  Object.defineProperty(DB, "__esModule", { value: !0 });
  DB.set = void 0;
  var ht = jI();
  Object.defineProperty(DB, "set", {
    enumerable: !0,
    get: function () {
      return ht.set;
    },
  });
});
var SI = s((II) => {
  Object.defineProperty(II, "__esModule", { value: !0 });
  II.undiscriminatedUnion = void 0;
  var ut = p5(),
    lt = V4(),
    mt = D8();
  function ct(X) {
    let Y = {
      parse: (Q, G) => {
        return CI((J, U) => J.parse(Q, U), X, G);
      },
      json: (Q, G) => {
        return CI((J, U) => J.json(Q, U), X, G);
      },
      getType: () => ut.SchemaType.UNDISCRIMINATED_UNION,
    };
    return Object.assign(
      Object.assign({}, (0, lt.maybeSkipValidation)(Y)),
      (0, mt.getSchemaUtils)(Y)
    );
  }
  II.undiscriminatedUnion = ct;
  function CI(X, Y, Q) {
    let G = [];
    for (let [J, U] of Y.entries()) {
      let $ = X(U, Object.assign(Object.assign({}, Q), { skipValidation: !1 }));
      if ($.ok) return $;
      else
        for (let B of $.errors)
          G.push({ path: B.path, message: `[Variant ${J}] ${B.message}` });
    }
    return { ok: !1, errors: G };
  }
});
var TI = s((zB) => {
  Object.defineProperty(zB, "__esModule", { value: !0 });
  zB.undiscriminatedUnion = void 0;
  var dt = SI();
  Object.defineProperty(zB, "undiscriminatedUnion", {
    enumerable: !0,
    get: function () {
      return dt.undiscriminatedUnion;
    },
  });
});
var kI = s((bI) => {
  Object.defineProperty(bI, "__esModule", { value: !0 });
  bI.discriminant = void 0;
  function it(X, Y) {
    return { parsedDiscriminant: X, rawDiscriminant: Y };
  }
  bI.discriminant = it;
});
var _I = s((T7) => {
  var nt =
    (T7 && T7.__rest) ||
    function (X, Y) {
      var Q = {};
      for (var G in X)
        if (Object.prototype.hasOwnProperty.call(X, G) && Y.indexOf(G) < 0)
          Q[G] = X[G];
      if (X != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var J = 0, G = Object.getOwnPropertySymbols(X); J < G.length; J++)
          if (
            Y.indexOf(G[J]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(X, G[J])
          )
            Q[G[J]] = X[G[J]];
      }
      return Q;
    };
  Object.defineProperty(T7, "__esModule", { value: !0 });
  T7.union = void 0;
  var at = p5(),
    rt = F8(),
    ot = qQ(),
    st = LB(),
    tt = V4(),
    et = WB(),
    Xe = RQ(),
    Ye = D8();
  function Qe(X, Y) {
    let Q = typeof X === "string" ? X : X.rawDiscriminant,
      G = typeof X === "string" ? X : X.parsedDiscriminant,
      J = (0, et.enum_)((0, st.keys)(Y)),
      U = {
        parse: ($, B) => {
          return yI({
            value: $,
            discriminant: Q,
            transformedDiscriminant: G,
            transformDiscriminantValue: (K) => {
              var V;
              return J.parse(K, {
                allowUnrecognizedEnumValues:
                  B === null || B === void 0
                    ? void 0
                    : B.allowUnrecognizedUnionMembers,
                breadcrumbsPrefix: [
                  ...((V =
                    B === null || B === void 0
                      ? void 0
                      : B.breadcrumbsPrefix) !== null && V !== void 0
                    ? V
                    : []),
                  Q,
                ],
              });
            },
            getAdditionalPropertiesSchema: (K) => Y[K],
            allowUnrecognizedUnionMembers:
              B === null || B === void 0
                ? void 0
                : B.allowUnrecognizedUnionMembers,
            transformAdditionalProperties: (K, V) => V.parse(K, B),
            breadcrumbsPrefix:
              B === null || B === void 0 ? void 0 : B.breadcrumbsPrefix,
          });
        },
        json: ($, B) => {
          return yI({
            value: $,
            discriminant: G,
            transformedDiscriminant: Q,
            transformDiscriminantValue: (K) => {
              var V;
              return J.json(K, {
                allowUnrecognizedEnumValues:
                  B === null || B === void 0
                    ? void 0
                    : B.allowUnrecognizedUnionMembers,
                breadcrumbsPrefix: [
                  ...((V =
                    B === null || B === void 0
                      ? void 0
                      : B.breadcrumbsPrefix) !== null && V !== void 0
                    ? V
                    : []),
                  G,
                ],
              });
            },
            getAdditionalPropertiesSchema: (K) => Y[K],
            allowUnrecognizedUnionMembers:
              B === null || B === void 0
                ? void 0
                : B.allowUnrecognizedUnionMembers,
            transformAdditionalProperties: (K, V) => V.json(K, B),
            breadcrumbsPrefix:
              B === null || B === void 0 ? void 0 : B.breadcrumbsPrefix,
          });
        },
        getType: () => at.SchemaType.UNION,
      };
    return Object.assign(
      Object.assign(
        Object.assign({}, (0, tt.maybeSkipValidation)(U)),
        (0, Ye.getSchemaUtils)(U)
      ),
      (0, Xe.getObjectLikeUtils)(U)
    );
  }
  T7.union = Qe;
  function yI({
    value: X,
    discriminant: Y,
    transformedDiscriminant: Q,
    transformDiscriminantValue: G,
    getAdditionalPropertiesSchema: J,
    allowUnrecognizedUnionMembers: U = !1,
    transformAdditionalProperties: $,
    breadcrumbsPrefix: B = [],
  }) {
    if (!(0, ot.isPlainObject)(X))
      return {
        ok: !1,
        errors: [
          {
            path: B,
            message: (0, rt.getErrorMessageForIncorrectType)(X, "object"),
          },
        ],
      };
    let K = X,
      V = Y,
      W = K[V],
      L = nt(K, [typeof V === "symbol" ? V : V + ""]);
    if (W == null)
      return {
        ok: !1,
        errors: [{ path: B, message: `Missing discriminant ("${Y}")` }],
      };
    let H = G(W);
    if (!H.ok) return { ok: !1, errors: H.errors };
    let F = J(H.value);
    if (F == null)
      if (U) return { ok: !0, value: Object.assign({ [Q]: H.value }, L) };
      else
        return {
          ok: !1,
          errors: [
            { path: [...B, Y], message: "Unexpected discriminant value" },
          ],
        };
    let N = $(L, F);
    if (!N.ok) return N;
    return { ok: !0, value: Object.assign({ [Q]: W }, N.value) };
  }
});
var fI = s((eJ) => {
  Object.defineProperty(eJ, "__esModule", { value: !0 });
  eJ.union = eJ.discriminant = void 0;
  var Ge = kI();
  Object.defineProperty(eJ, "discriminant", {
    enumerable: !0,
    get: function () {
      return Ge.discriminant;
    },
  });
  var Je = _I();
  Object.defineProperty(eJ, "union", {
    enumerable: !0,
    get: function () {
      return Je.union;
    },
  });
});
var xI = s((P5) => {
  var He =
      (P5 && P5.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    z8 =
      (P5 && P5.__exportStar) ||
      function (X, Y) {
        for (var Q in X)
          if (Q !== "default" && !Object.prototype.hasOwnProperty.call(Y, Q))
            He(Y, X, Q);
      };
  Object.defineProperty(P5, "__esModule", { value: !0 });
  z8(ow(), P5);
  z8(WB(), P5);
  z8(cC(), P5);
  z8(AB(), P5);
  z8(XI(), P5);
  z8(FB(), P5);
  z8(RQ(), P5);
  z8(AI(), P5);
  z8(EI(), P5);
  z8(D8(), P5);
  z8(wI(), P5);
  z8(TI(), P5);
  z8(fI(), P5);
});
var hI = s((n9) => {
  var $e =
      (n9 && n9.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    Ue =
      (n9 && n9.__exportStar) ||
      function (X, Y) {
        for (var Q in X)
          if (Q !== "default" && !Object.prototype.hasOwnProperty.call(Y, Q))
            $e(Y, X, Q);
      };
  Object.defineProperty(n9, "__esModule", { value: !0 });
  Ue(xI(), n9);
});
var o1 = s((W8) => {
  var gI =
      (W8 && W8.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    Le =
      (W8 && W8.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    EB =
      (W8 && W8.__exportStar) ||
      function (X, Y) {
        for (var Q in X)
          if (Q !== "default" && !Object.prototype.hasOwnProperty.call(Y, Q))
            gI(Y, X, Q);
      },
    Be =
      (W8 && W8.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              gI(Y, X, Q);
        }
        return (Le(Y, X), Y);
      };
  Object.defineProperty(W8, "__esModule", { value: !0 });
  W8.serialization = void 0;
  EB(Dw(), W8);
  EB(Pw(), W8);
  EB(dJ(), W8);
  W8.serialization = Be(hI());
});
var OB = s((F6) => {
  var Ke =
      (F6 && F6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    Ve =
      (F6 && F6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    Fe =
      (F6 && F6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              Ke(Y, X, Q);
        }
        return (Ve(Y, X), Y);
      };
  Object.defineProperty(F6, "__esModule", { value: !0 });
  F6.EmbedRequestInput = void 0;
  var XW = Fe(o1());
  F6.EmbedRequestInput = XW.serialization.undiscriminatedUnion([
    XW.serialization.string(),
    XW.serialization.list(XW.serialization.string()),
  ]);
});
var ZB = s((N6) => {
  var Ne =
      (N6 && N6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    Me =
      (N6 && N6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    Ae =
      (N6 && N6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              Ne(Y, X, Q);
        }
        return (Me(Y, X), Y);
      };
  Object.defineProperty(N6, "__esModule", { value: !0 });
  N6.EmbedRequestInputType = void 0;
  var qe = Ae(o1());
  N6.EmbedRequestInputType = qe.serialization.enum_(["query", "document"]);
});
var jB = s((M6) => {
  var Re =
      (M6 && M6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    De =
      (M6 && M6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    ze =
      (M6 && M6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              Re(Y, X, Q);
        }
        return (De(Y, X), Y);
      };
  Object.defineProperty(M6, "__esModule", { value: !0 });
  M6.EmbedRequestOutputDtype = void 0;
  var Ee = ze(o1());
  M6.EmbedRequestOutputDtype = Ee.serialization.enum_([
    "float",
    "int8",
    "uint8",
    "binary",
    "ubinary",
  ]);
});
var wB = s((A6) => {
  var Oe =
      (A6 && A6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    Ze =
      (A6 && A6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    je =
      (A6 && A6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              Oe(Y, X, Q);
        }
        return (Ze(Y, X), Y);
      };
  Object.defineProperty(A6, "__esModule", { value: !0 });
  A6.EmbedResponseDataItem = void 0;
  var EQ = je(o1());
  A6.EmbedResponseDataItem = EQ.serialization.object({
    object: EQ.serialization.string().optional(),
    embedding: EQ.serialization.list(EQ.serialization.number()).optional(),
    index: EQ.serialization.number().optional(),
  });
});
var IB = s((q6) => {
  var we =
      (q6 && q6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    Ce =
      (q6 && q6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    Ie =
      (q6 && q6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              we(Y, X, Q);
        }
        return (Ce(Y, X), Y);
      };
  Object.defineProperty(q6, "__esModule", { value: !0 });
  q6.EmbedResponseUsage = void 0;
  var CB = Ie(o1());
  q6.EmbedResponseUsage = CB.serialization.object({
    totalTokens: CB.serialization.property(
      "total_tokens",
      CB.serialization.number().optional()
    ),
  });
});
var uI = s((R6) => {
  var Pe =
      (R6 && R6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    Se =
      (R6 && R6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    Te =
      (R6 && R6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              Pe(Y, X, Q);
        }
        return (Se(Y, X), Y);
      };
  Object.defineProperty(R6, "__esModule", { value: !0 });
  R6.EmbedResponse = void 0;
  var YW = Te(o1()),
    be = wB(),
    ve = IB();
  R6.EmbedResponse = YW.serialization.object({
    object: YW.serialization.string().optional(),
    data: YW.serialization.list(be.EmbedResponseDataItem).optional(),
    model: YW.serialization.string().optional(),
    usage: ve.EmbedResponseUsage.optional(),
  });
});
var PB = s((D6) => {
  var ke =
      (D6 && D6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    ye =
      (D6 && D6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    _e =
      (D6 && D6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              ke(Y, X, Q);
        }
        return (ye(Y, X), Y);
      };
  Object.defineProperty(D6, "__esModule", { value: !0 });
  D6.RerankResponseDataItem = void 0;
  var OQ = _e(o1());
  D6.RerankResponseDataItem = OQ.serialization.object({
    index: OQ.serialization.number().optional(),
    relevanceScore: OQ.serialization.property(
      "relevance_score",
      OQ.serialization.number().optional()
    ),
    document: OQ.serialization.string().optional(),
  });
});
var TB = s((z6) => {
  var fe =
      (z6 && z6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    xe =
      (z6 && z6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    he =
      (z6 && z6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              fe(Y, X, Q);
        }
        return (xe(Y, X), Y);
      };
  Object.defineProperty(z6, "__esModule", { value: !0 });
  z6.RerankResponseUsage = void 0;
  var SB = he(o1());
  z6.RerankResponseUsage = SB.serialization.object({
    totalTokens: SB.serialization.property(
      "total_tokens",
      SB.serialization.number().optional()
    ),
  });
});
var lI = s((E6) => {
  var ge =
      (E6 && E6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    ue =
      (E6 && E6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    le =
      (E6 && E6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              ge(Y, X, Q);
        }
        return (ue(Y, X), Y);
      };
  Object.defineProperty(E6, "__esModule", { value: !0 });
  E6.RerankResponse = void 0;
  var QW = le(o1()),
    me = PB(),
    ce = TB();
  E6.RerankResponse = QW.serialization.object({
    object: QW.serialization.string().optional(),
    data: QW.serialization.list(me.RerankResponseDataItem).optional(),
    model: QW.serialization.string().optional(),
    usage: ce.RerankResponseUsage.optional(),
  });
});
var bB = s((O6) => {
  var de =
      (O6 && O6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    pe =
      (O6 && O6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    ie =
      (O6 && O6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              de(Y, X, Q);
        }
        return (pe(Y, X), Y);
      };
  Object.defineProperty(O6, "__esModule", { value: !0 });
  O6.MultimodalEmbedRequestInputsItemContentItem = void 0;
  var n8 = ie(o1());
  O6.MultimodalEmbedRequestInputsItemContentItem = n8.serialization.object({
    type: n8.serialization.string(),
    text: n8.serialization.string().optional(),
    imageBase64: n8.serialization.property(
      "image_base64",
      n8.serialization.string().optional()
    ),
    imageUrl: n8.serialization.property(
      "image_url",
      n8.serialization.string().optional()
    ),
    videoBase64: n8.serialization.property(
      "video_base64",
      n8.serialization.string().optional()
    ),
    videoUrl: n8.serialization.property(
      "video_url",
      n8.serialization.string().optional()
    ),
  });
});
var vB = s((Z6) => {
  var ne =
      (Z6 && Z6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    ae =
      (Z6 && Z6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    re =
      (Z6 && Z6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              ne(Y, X, Q);
        }
        return (ae(Y, X), Y);
      };
  Object.defineProperty(Z6, "__esModule", { value: !0 });
  Z6.MultimodalEmbedRequestInputsItem = void 0;
  var mI = re(o1()),
    oe = bB();
  Z6.MultimodalEmbedRequestInputsItem = mI.serialization.object({
    content: mI.serialization
      .list(oe.MultimodalEmbedRequestInputsItemContentItem)
      .optional(),
  });
});
var kB = s((j6) => {
  var se =
      (j6 && j6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    te =
      (j6 && j6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    ee =
      (j6 && j6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              se(Y, X, Q);
        }
        return (te(Y, X), Y);
      };
  Object.defineProperty(j6, "__esModule", { value: !0 });
  j6.MultimodalEmbedRequestInputType = void 0;
  var X00 = ee(o1());
  j6.MultimodalEmbedRequestInputType = X00.serialization.enum_([
    "query",
    "document",
  ]);
});
var yB = s((w6) => {
  var Y00 =
      (w6 && w6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    Q00 =
      (w6 && w6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    G00 =
      (w6 && w6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              Y00(Y, X, Q);
        }
        return (Q00(Y, X), Y);
      };
  Object.defineProperty(w6, "__esModule", { value: !0 });
  w6.MultimodalEmbedResponseDataItem = void 0;
  var ZQ = G00(o1());
  w6.MultimodalEmbedResponseDataItem = ZQ.serialization.object({
    object: ZQ.serialization.string().optional(),
    embedding: ZQ.serialization.list(ZQ.serialization.number()).optional(),
    index: ZQ.serialization.number().optional(),
  });
});
var fB = s((C6) => {
  var J00 =
      (C6 && C6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    W00 =
      (C6 && C6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    H00 =
      (C6 && C6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              J00(Y, X, Q);
        }
        return (W00(Y, X), Y);
      };
  Object.defineProperty(C6, "__esModule", { value: !0 });
  C6.MultimodalEmbedResponseUsage = void 0;
  var _B = H00(o1());
  C6.MultimodalEmbedResponseUsage = _B.serialization.object({
    totalTokens: _B.serialization.property(
      "total_tokens",
      _B.serialization.number().optional()
    ),
  });
});
var cI = s((I6) => {
  var $00 =
      (I6 && I6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    U00 =
      (I6 && I6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    L00 =
      (I6 && I6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              $00(Y, X, Q);
        }
        return (U00(Y, X), Y);
      };
  Object.defineProperty(I6, "__esModule", { value: !0 });
  I6.MultimodalEmbedResponse = void 0;
  var GW = L00(o1()),
    B00 = yB(),
    K00 = fB();
  I6.MultimodalEmbedResponse = GW.serialization.object({
    object: GW.serialization.string().optional(),
    data: GW.serialization.list(B00.MultimodalEmbedResponseDataItem).optional(),
    model: GW.serialization.string().optional(),
    usage: K00.MultimodalEmbedResponseUsage.optional(),
  });
});
var xB = s((P6) => {
  var V00 =
      (P6 && P6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    F00 =
      (P6 && P6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    N00 =
      (P6 && P6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              V00(Y, X, Q);
        }
        return (F00(Y, X), Y);
      };
  Object.defineProperty(P6, "__esModule", { value: !0 });
  P6.ContextualizedEmbedRequestInputType = void 0;
  var M00 = N00(o1());
  P6.ContextualizedEmbedRequestInputType = M00.serialization.enum_([
    "query",
    "document",
  ]);
});
var hB = s((S6) => {
  var A00 =
      (S6 && S6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    q00 =
      (S6 && S6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    R00 =
      (S6 && S6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              A00(Y, X, Q);
        }
        return (q00(Y, X), Y);
      };
  Object.defineProperty(S6, "__esModule", { value: !0 });
  S6.ContextualizedEmbedRequestOutputDtype = void 0;
  var D00 = R00(o1());
  S6.ContextualizedEmbedRequestOutputDtype = D00.serialization.enum_([
    "float",
    "int8",
    "uint8",
    "binary",
    "ubinary",
  ]);
});
var gB = s((T6) => {
  var z00 =
      (T6 && T6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    E00 =
      (T6 && T6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    O00 =
      (T6 && T6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              z00(Y, X, Q);
        }
        return (E00(Y, X), Y);
      };
  Object.defineProperty(T6, "__esModule", { value: !0 });
  T6.ContextualizedEmbedResponseDataItemDataItem = void 0;
  var jQ = O00(o1());
  T6.ContextualizedEmbedResponseDataItemDataItem = jQ.serialization.object({
    object: jQ.serialization.string().optional(),
    embedding: jQ.serialization.list(jQ.serialization.number()).optional(),
    index: jQ.serialization.number().optional(),
  });
});
var uB = s((b6) => {
  var Z00 =
      (b6 && b6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    j00 =
      (b6 && b6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    w00 =
      (b6 && b6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              Z00(Y, X, Q);
        }
        return (j00(Y, X), Y);
      };
  Object.defineProperty(b6, "__esModule", { value: !0 });
  b6.ContextualizedEmbedResponseDataItem = void 0;
  var JW = w00(o1()),
    C00 = gB();
  b6.ContextualizedEmbedResponseDataItem = JW.serialization.object({
    object: JW.serialization.string().optional(),
    data: JW.serialization
      .list(C00.ContextualizedEmbedResponseDataItemDataItem)
      .optional(),
    index: JW.serialization.number().optional(),
  });
});
var mB = s((v6) => {
  var I00 =
      (v6 && v6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    P00 =
      (v6 && v6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    S00 =
      (v6 && v6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              I00(Y, X, Q);
        }
        return (P00(Y, X), Y);
      };
  Object.defineProperty(v6, "__esModule", { value: !0 });
  v6.ContextualizedEmbedResponseUsage = void 0;
  var lB = S00(o1());
  v6.ContextualizedEmbedResponseUsage = lB.serialization.object({
    totalTokens: lB.serialization.property(
      "total_tokens",
      lB.serialization.number().optional()
    ),
  });
});
var dI = s((k6) => {
  var T00 =
      (k6 && k6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    b00 =
      (k6 && k6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    v00 =
      (k6 && k6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              T00(Y, X, Q);
        }
        return (b00(Y, X), Y);
      };
  Object.defineProperty(k6, "__esModule", { value: !0 });
  k6.ContextualizedEmbedResponse = void 0;
  var WW = v00(o1()),
    k00 = uB(),
    y00 = mB();
  k6.ContextualizedEmbedResponse = WW.serialization.object({
    object: WW.serialization.string().optional(),
    data: WW.serialization
      .list(k00.ContextualizedEmbedResponseDataItem)
      .optional(),
    model: WW.serialization.string().optional(),
    usage: y00.ContextualizedEmbedResponseUsage.optional(),
  });
});
var pI = s((s1) => {
  var _00 =
      (s1 && s1.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    E5 =
      (s1 && s1.__exportStar) ||
      function (X, Y) {
        for (var Q in X)
          if (Q !== "default" && !Object.prototype.hasOwnProperty.call(Y, Q))
            _00(Y, X, Q);
      };
  Object.defineProperty(s1, "__esModule", { value: !0 });
  E5(OB(), s1);
  E5(ZB(), s1);
  E5(jB(), s1);
  E5(wB(), s1);
  E5(IB(), s1);
  E5(uI(), s1);
  E5(PB(), s1);
  E5(TB(), s1);
  E5(lI(), s1);
  E5(bB(), s1);
  E5(vB(), s1);
  E5(kB(), s1);
  E5(yB(), s1);
  E5(fB(), s1);
  E5(cI(), s1);
  E5(xB(), s1);
  E5(hB(), s1);
  E5(gB(), s1);
  E5(uB(), s1);
  E5(mB(), s1);
  E5(dI(), s1);
});
var iI = s((y6) => {
  var f00 =
      (y6 && y6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    x00 =
      (y6 && y6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    h00 =
      (y6 && y6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              f00(Y, X, Q);
        }
        return (x00(Y, X), Y);
      };
  Object.defineProperty(y6, "__esModule", { value: !0 });
  y6.EmbedRequest = void 0;
  var N4 = h00(o1()),
    g00 = OB(),
    u00 = ZB(),
    l00 = jB();
  y6.EmbedRequest = N4.serialization.object({
    input: g00.EmbedRequestInput,
    model: N4.serialization.string(),
    inputType: N4.serialization.property(
      "input_type",
      u00.EmbedRequestInputType.optional()
    ),
    truncation: N4.serialization.boolean().optional(),
    encodingFormat: N4.serialization.property(
      "encoding_format",
      N4.serialization.stringLiteral("base64").optional()
    ),
    outputDimension: N4.serialization.property(
      "output_dimension",
      N4.serialization.number().optional()
    ),
    outputDtype: N4.serialization.property(
      "output_dtype",
      l00.EmbedRequestOutputDtype.optional()
    ),
  });
});
var nI = s((f6) => {
  var m00 =
      (f6 && f6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    c00 =
      (f6 && f6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    d00 =
      (f6 && f6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              m00(Y, X, Q);
        }
        return (c00(Y, X), Y);
      };
  Object.defineProperty(f6, "__esModule", { value: !0 });
  f6.RerankRequest = void 0;
  var _6 = d00(o1());
  f6.RerankRequest = _6.serialization.object({
    query: _6.serialization.string(),
    documents: _6.serialization.list(_6.serialization.string()),
    model: _6.serialization.string(),
    topK: _6.serialization.property(
      "top_k",
      _6.serialization.number().optional()
    ),
    returnDocuments: _6.serialization.property(
      "return_documents",
      _6.serialization.boolean().optional()
    ),
    truncation: _6.serialization.boolean().optional(),
  });
});
var aI = s((x6) => {
  var p00 =
      (x6 && x6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    i00 =
      (x6 && x6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    n00 =
      (x6 && x6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              p00(Y, X, Q);
        }
        return (i00(Y, X), Y);
      };
  Object.defineProperty(x6, "__esModule", { value: !0 });
  x6.MultimodalEmbedRequest = void 0;
  var a9 = n00(o1()),
    a00 = vB(),
    r00 = kB();
  x6.MultimodalEmbedRequest = a9.serialization.object({
    inputs: a9.serialization.list(a00.MultimodalEmbedRequestInputsItem),
    model: a9.serialization.string(),
    inputType: a9.serialization.property(
      "input_type",
      r00.MultimodalEmbedRequestInputType.optional()
    ),
    truncation: a9.serialization.boolean().optional(),
    encodingFormat: a9.serialization.property(
      "encoding_format",
      a9.serialization.stringLiteral("base64").optional()
    ),
  });
});
var rI = s((h6) => {
  var o00 =
      (h6 && h6.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    s00 =
      (h6 && h6.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    t00 =
      (h6 && h6.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              o00(Y, X, Q);
        }
        return (s00(Y, X), Y);
      };
  Object.defineProperty(h6, "__esModule", { value: !0 });
  h6.ContextualizedEmbedRequest = void 0;
  var M4 = t00(o1()),
    e00 = xB(),
    X10 = hB();
  h6.ContextualizedEmbedRequest = M4.serialization.object({
    inputs: M4.serialization.list(
      M4.serialization.list(M4.serialization.string())
    ),
    model: M4.serialization.string(),
    inputType: M4.serialization.property(
      "input_type",
      e00.ContextualizedEmbedRequestInputType.optional()
    ),
    outputDimension: M4.serialization.property(
      "output_dimension",
      M4.serialization.number().optional()
    ),
    outputDtype: M4.serialization.property(
      "output_dtype",
      X10.ContextualizedEmbedRequestOutputDtype.optional()
    ),
  });
});
var oI = s((b7) => {
  Object.defineProperty(b7, "__esModule", { value: !0 });
  b7.ContextualizedEmbedRequest =
    b7.MultimodalEmbedRequest =
    b7.RerankRequest =
    b7.EmbedRequest =
      void 0;
  var Y10 = iI();
  Object.defineProperty(b7, "EmbedRequest", {
    enumerable: !0,
    get: function () {
      return Y10.EmbedRequest;
    },
  });
  var Q10 = nI();
  Object.defineProperty(b7, "RerankRequest", {
    enumerable: !0,
    get: function () {
      return Q10.RerankRequest;
    },
  });
  var G10 = aI();
  Object.defineProperty(b7, "MultimodalEmbedRequest", {
    enumerable: !0,
    get: function () {
      return G10.MultimodalEmbedRequest;
    },
  });
  var J10 = rI();
  Object.defineProperty(b7, "ContextualizedEmbedRequest", {
    enumerable: !0,
    get: function () {
      return J10.ContextualizedEmbedRequest;
    },
  });
});
var sI = s((r9) => {
  var H10 =
      (r9 && r9.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    $10 =
      (r9 && r9.__exportStar) ||
      function (X, Y) {
        for (var Q in X)
          if (Q !== "default" && !Object.prototype.hasOwnProperty.call(Y, Q))
            H10(Y, X, Q);
      };
  Object.defineProperty(r9, "__esModule", { value: !0 });
  $10(oI(), r9);
});
var eI = s((s4) => {
  var U10 =
      (s4 && s4.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    tI =
      (s4 && s4.__exportStar) ||
      function (X, Y) {
        for (var Q in X)
          if (Q !== "default" && !Object.prototype.hasOwnProperty.call(Y, Q))
            U10(Y, X, Q);
      };
  Object.defineProperty(s4, "__esModule", { value: !0 });
  tI(pI(), s4);
  tI(sI(), s4);
});
var YP = s((XP, HW) => {
  (function (X, Y, Q) {
    if (typeof HW < "u" && HW.exports) HW.exports = Q();
    else if (typeof define === "function" && define.amd) define(Q);
    else Y[X] = Q();
  })("urljoin", XP, function () {
    function X(Y) {
      var Q = [];
      if (Y.length === 0) return "";
      if (typeof Y[0] !== "string")
        throw TypeError("Url must be a string. Received " + Y[0]);
      if (Y[0].match(/^[^/:]+:\/*$/) && Y.length > 1) {
        var G = Y.shift();
        Y[0] = G + Y[0];
      }
      if (Y[0].match(/^file:\/\/\//))
        Y[0] = Y[0].replace(/^([^/:]+):\/*/, "$1:///");
      else Y[0] = Y[0].replace(/^([^/:]+):\/*/, "$1://");
      for (var J = 0; J < Y.length; J++) {
        var U = Y[J];
        if (typeof U !== "string")
          throw TypeError("Url must be a string. Received " + U);
        if (U === "") continue;
        if (J > 0) U = U.replace(/^[\/]+/, "");
        if (J < Y.length - 1) U = U.replace(/[\/]+$/, "");
        else U = U.replace(/[\/]+$/, "/");
        Q.push(U);
      }
      var $ = Q.join("/");
      $ = $.replace(/\/(\?|&|#[^!])/g, "$1");
      var B = $.split("?");
      return (($ = B.shift() + (B.length > 0 ? "?" : "") + B.join("&")), $);
    }
    return function () {
      var Y;
      if (typeof arguments[0] === "object") Y = arguments[0];
      else Y = [].slice.call(arguments);
      return X(Y);
    };
  });
});
var JP = s((QP) => {
  Object.defineProperty(QP, "__esModule", { value: !0 });
  QP.VoyageAIError = void 0;
  class cB extends Error {
    constructor({ message: X, statusCode: Y, body: Q }) {
      super(L10({ message: X, statusCode: Y, body: Q }));
      if ((Object.setPrototypeOf(this, cB.prototype), Y != null))
        this.statusCode = Y;
      if (Q !== void 0) this.body = Q;
    }
  }
  QP.VoyageAIError = cB;
  function L10({ message: X, statusCode: Y, body: Q }) {
    let G = [];
    if (X != null) G.push(X);
    if (Y != null) G.push(`Status code: ${Y.toString()}`);
    if (Q != null) G.push(`Body: ${JSON.stringify(Q, void 0, 2)}`);
    return G.join(`
`);
  }
});
var $P = s((WP) => {
  Object.defineProperty(WP, "__esModule", { value: !0 });
  WP.VoyageAITimeoutError = void 0;
  class dB extends Error {
    constructor() {
      super("Timeout");
      Object.setPrototypeOf(this, dB.prototype);
    }
  }
  WP.VoyageAITimeoutError = dB;
});
var pB = s(($W) => {
  Object.defineProperty($W, "__esModule", { value: !0 });
  $W.VoyageAITimeoutError = $W.VoyageAIError = void 0;
  var B10 = JP();
  Object.defineProperty($W, "VoyageAIError", {
    enumerable: !0,
    get: function () {
      return B10.VoyageAIError;
    },
  });
  var K10 = $P();
  Object.defineProperty($W, "VoyageAITimeoutError", {
    enumerable: !0,
    get: function () {
      return K10.VoyageAITimeoutError;
    },
  });
});
var LP = s((N8) => {
  var F10 =
      (N8 && N8.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    N10 =
      (N8 && N8.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    BW =
      (N8 && N8.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              F10(Y, X, Q);
        }
        return (N10(Y, X), Y);
      },
    wQ =
      (N8 && N8.__awaiter) ||
      function (X, Y, Q, G) {
        function J(U) {
          return U instanceof Q
            ? U
            : new Q(function ($) {
                $(U);
              });
        }
        return new (Q || (Q = Promise))(function (U, $) {
          function B(W) {
            try {
              V(G.next(W));
            } catch (L) {
              $(L);
            }
          }
          function K(W) {
            try {
              V(G.throw(W));
            } catch (L) {
              $(L);
            }
          }
          function V(W) {
            W.done ? U(W.value) : J(W.value).then(B, K);
          }
          V((G = G.apply(X, Y || [])).next());
        });
      },
    M10 =
      (N8 && N8.__importDefault) ||
      function (X) {
        return X && X.__esModule ? X : { default: X };
      };
  Object.defineProperty(N8, "__esModule", { value: !0 });
  N8.VoyageAIClient = void 0;
  var UW = BW(BL()),
    i5 = BW(o1()),
    t4 = BW(eI()),
    LW = M10(YP()),
    n5 = BW(pB());
  class UP {
    constructor(X = {}) {
      this._options = X;
    }
    embed(X, Y) {
      var Q, G;
      return wQ(this, void 0, void 0, function* () {
        let J = yield (
          (Q = this._options.fetcher) !== null && Q !== void 0 ? Q : i5.fetcher
        )({
          url: (0, LW.default)(
            (G = yield i5.Supplier.get(this._options.environment)) !== null &&
              G !== void 0
              ? G
              : UW.VoyageAIEnvironment.Default,
            "embeddings"
          ),
          method: "POST",
          headers: {
            Authorization: yield this._getAuthorizationHeader(),
            "X-Fern-Language": "JavaScript",
            "X-Fern-SDK-Name": "voyageai",
            "X-Fern-SDK-Version": "0.1.0",
            "User-Agent": "voyageai/0.1.0",
            "X-Fern-Runtime": i5.RUNTIME.type,
            "X-Fern-Runtime-Version": i5.RUNTIME.version,
          },
          contentType: "application/json",
          requestType: "json",
          body: t4.EmbedRequest.jsonOrThrow(X, {
            unrecognizedObjectKeys: "strip",
          }),
          timeoutMs:
            (Y === null || Y === void 0 ? void 0 : Y.timeoutInSeconds) != null
              ? Y.timeoutInSeconds * 1000
              : 60000,
          maxRetries: Y === null || Y === void 0 ? void 0 : Y.maxRetries,
          abortSignal: Y === null || Y === void 0 ? void 0 : Y.abortSignal,
        });
        if (J.ok)
          return t4.EmbedResponse.parseOrThrow(J.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: !0,
            allowUnrecognizedEnumValues: !0,
            skipValidation: !0,
            breadcrumbsPrefix: ["response"],
          });
        if (J.error.reason === "status-code")
          throw new n5.VoyageAIError({
            statusCode: J.error.statusCode,
            body: J.error.body,
          });
        switch (J.error.reason) {
          case "non-json":
            throw new n5.VoyageAIError({
              statusCode: J.error.statusCode,
              body: J.error.rawBody,
            });
          case "timeout":
            throw new n5.VoyageAITimeoutError();
          case "unknown":
            throw new n5.VoyageAIError({ message: J.error.errorMessage });
        }
      });
    }
    rerank(X, Y) {
      var Q, G;
      return wQ(this, void 0, void 0, function* () {
        let J = yield (
          (Q = this._options.fetcher) !== null && Q !== void 0 ? Q : i5.fetcher
        )({
          url: (0, LW.default)(
            (G = yield i5.Supplier.get(this._options.environment)) !== null &&
              G !== void 0
              ? G
              : UW.VoyageAIEnvironment.Default,
            "rerank"
          ),
          method: "POST",
          headers: {
            Authorization: yield this._getAuthorizationHeader(),
            "X-Fern-Language": "JavaScript",
            "X-Fern-SDK-Name": "voyageai",
            "X-Fern-SDK-Version": "0.1.0",
            "User-Agent": "voyageai/0.1.0",
            "X-Fern-Runtime": i5.RUNTIME.type,
            "X-Fern-Runtime-Version": i5.RUNTIME.version,
          },
          contentType: "application/json",
          requestType: "json",
          body: t4.RerankRequest.jsonOrThrow(X, {
            unrecognizedObjectKeys: "strip",
          }),
          timeoutMs:
            (Y === null || Y === void 0 ? void 0 : Y.timeoutInSeconds) != null
              ? Y.timeoutInSeconds * 1000
              : 60000,
          maxRetries: Y === null || Y === void 0 ? void 0 : Y.maxRetries,
          abortSignal: Y === null || Y === void 0 ? void 0 : Y.abortSignal,
        });
        if (J.ok)
          return t4.RerankResponse.parseOrThrow(J.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: !0,
            allowUnrecognizedEnumValues: !0,
            skipValidation: !0,
            breadcrumbsPrefix: ["response"],
          });
        if (J.error.reason === "status-code")
          throw new n5.VoyageAIError({
            statusCode: J.error.statusCode,
            body: J.error.body,
          });
        switch (J.error.reason) {
          case "non-json":
            throw new n5.VoyageAIError({
              statusCode: J.error.statusCode,
              body: J.error.rawBody,
            });
          case "timeout":
            throw new n5.VoyageAITimeoutError();
          case "unknown":
            throw new n5.VoyageAIError({ message: J.error.errorMessage });
        }
      });
    }
    multimodalEmbed(X, Y) {
      var Q, G;
      return wQ(this, void 0, void 0, function* () {
        let J = yield (
          (Q = this._options.fetcher) !== null && Q !== void 0 ? Q : i5.fetcher
        )({
          url: (0, LW.default)(
            (G = yield i5.Supplier.get(this._options.environment)) !== null &&
              G !== void 0
              ? G
              : UW.VoyageAIEnvironment.Default,
            "multimodalembeddings"
          ),
          method: "POST",
          headers: {
            Authorization: yield this._getAuthorizationHeader(),
            "X-Fern-Language": "JavaScript",
            "X-Fern-SDK-Name": "voyageai",
            "X-Fern-SDK-Version": "0.1.0",
            "User-Agent": "voyageai/0.1.0",
            "X-Fern-Runtime": i5.RUNTIME.type,
            "X-Fern-Runtime-Version": i5.RUNTIME.version,
          },
          contentType: "application/json",
          requestType: "json",
          body: t4.MultimodalEmbedRequest.jsonOrThrow(X, {
            unrecognizedObjectKeys: "strip",
          }),
          timeoutMs:
            (Y === null || Y === void 0 ? void 0 : Y.timeoutInSeconds) != null
              ? Y.timeoutInSeconds * 1000
              : 60000,
          maxRetries: Y === null || Y === void 0 ? void 0 : Y.maxRetries,
          abortSignal: Y === null || Y === void 0 ? void 0 : Y.abortSignal,
        });
        if (J.ok)
          return t4.MultimodalEmbedResponse.parseOrThrow(J.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: !0,
            allowUnrecognizedEnumValues: !0,
            skipValidation: !0,
            breadcrumbsPrefix: ["response"],
          });
        if (J.error.reason === "status-code")
          throw new n5.VoyageAIError({
            statusCode: J.error.statusCode,
            body: J.error.body,
          });
        switch (J.error.reason) {
          case "non-json":
            throw new n5.VoyageAIError({
              statusCode: J.error.statusCode,
              body: J.error.rawBody,
            });
          case "timeout":
            throw new n5.VoyageAITimeoutError();
          case "unknown":
            throw new n5.VoyageAIError({ message: J.error.errorMessage });
        }
      });
    }
    contextualizedEmbed(X, Y) {
      var Q, G;
      return wQ(this, void 0, void 0, function* () {
        let J = yield (
          (Q = this._options.fetcher) !== null && Q !== void 0 ? Q : i5.fetcher
        )({
          url: (0, LW.default)(
            (G = yield i5.Supplier.get(this._options.environment)) !== null &&
              G !== void 0
              ? G
              : UW.VoyageAIEnvironment.Default,
            "contextualizedembeddings"
          ),
          method: "POST",
          headers: {
            Authorization: yield this._getAuthorizationHeader(),
            "X-Fern-Language": "JavaScript",
            "X-Fern-SDK-Name": "voyageai",
            "X-Fern-SDK-Version": "0.1.0",
            "User-Agent": "voyageai/0.1.0",
            "X-Fern-Runtime": i5.RUNTIME.type,
            "X-Fern-Runtime-Version": i5.RUNTIME.version,
          },
          contentType: "application/json",
          requestType: "json",
          body: t4.ContextualizedEmbedRequest.jsonOrThrow(X, {
            unrecognizedObjectKeys: "strip",
          }),
          timeoutMs:
            (Y === null || Y === void 0 ? void 0 : Y.timeoutInSeconds) != null
              ? Y.timeoutInSeconds * 1000
              : 60000,
          maxRetries: Y === null || Y === void 0 ? void 0 : Y.maxRetries,
          abortSignal: Y === null || Y === void 0 ? void 0 : Y.abortSignal,
        });
        if (J.ok)
          return t4.ContextualizedEmbedResponse.parseOrThrow(J.body, {
            unrecognizedObjectKeys: "passthrough",
            allowUnrecognizedUnionMembers: !0,
            allowUnrecognizedEnumValues: !0,
            skipValidation: !0,
            breadcrumbsPrefix: ["response"],
          });
        if (J.error.reason === "status-code")
          throw new n5.VoyageAIError({
            statusCode: J.error.statusCode,
            body: J.error.body,
          });
        switch (J.error.reason) {
          case "non-json":
            throw new n5.VoyageAIError({
              statusCode: J.error.statusCode,
              body: J.error.rawBody,
            });
          case "timeout":
            throw new n5.VoyageAITimeoutError();
          case "unknown":
            throw new n5.VoyageAIError({ message: J.error.errorMessage });
        }
      });
    }
    _getAuthorizationHeader() {
      var X;
      return wQ(this, void 0, void 0, function* () {
        let Y =
          (X = yield i5.Supplier.get(this._options.apiKey)) !== null &&
          X !== void 0
            ? X
            : process === null || process === void 0
              ? void 0
              : process.env.VOYAGE_API_KEY;
        if (Y == null)
          throw new n5.VoyageAIError({
            message:
              "Please specify VOYAGE_API_KEY when instantiating the client.",
          });
        return `Bearer ${Y}`;
      });
    }
  }
  N8.VoyageAIClient = UP;
});
var KP = s((_5) => {
  var A10 =
      (_5 && _5.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    q10 =
      (_5 && _5.__setModuleDefault) ||
      (Object.create
        ? function (X, Y) {
            Object.defineProperty(X, "default", { enumerable: !0, value: Y });
          }
        : function (X, Y) {
            X.default = Y;
          }),
    R10 =
      (_5 && _5.__importStar) ||
      function (X) {
        if (X && X.__esModule) return X;
        var Y = {};
        if (X != null) {
          for (var Q in X)
            if (Q !== "default" && Object.prototype.hasOwnProperty.call(X, Q))
              A10(Y, X, Q);
        }
        return (q10(Y, X), Y);
      };
  Object.defineProperty(_5, "__esModule", { value: !0 });
  _5.VoyageAITimeoutError =
    _5.VoyageAIError =
    _5.VoyageAIEnvironment =
    _5.VoyageAIClient =
    _5.VoyageAI =
      void 0;
  _5.VoyageAI = R10(v2());
  var D10 = LP();
  Object.defineProperty(_5, "VoyageAIClient", {
    enumerable: !0,
    get: function () {
      return D10.VoyageAIClient;
    },
  });
  var z10 = BL();
  Object.defineProperty(_5, "VoyageAIEnvironment", {
    enumerable: !0,
    get: function () {
      return z10.VoyageAIEnvironment;
    },
  });
  var BP = pB();
  Object.defineProperty(_5, "VoyageAIError", {
    enumerable: !0,
    get: function () {
      return BP.VoyageAIError;
    },
  });
  Object.defineProperty(_5, "VoyageAITimeoutError", {
    enumerable: !0,
    get: function () {
      return BP.VoyageAITimeoutError;
    },
  });
});
function e4(X, Y) {
  if (X) X(Y);
}
function VP(X) {
  return Object.fromEntries(Object.entries(X).map(([Y, Q]) => [Q, Y]));
}
function iB(X) {
  return X.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function FP(X) {
  return X?.prototype?.__proto__?.constructor?.name === "TypedArray";
}
function KW(X) {
  return Number.isInteger(X) || typeof X === "bigint";
}
function NP(X) {
  return X !== void 0 && X !== null;
}
function nB(X) {
  let Y = [],
    Q = X;
  while (Array.isArray(Q)) (Y.push(Q.length), (Q = Q[0]));
  return Y;
}
function aB(X, Y, Q = void 0) {
  let G = X[Y];
  if (G !== void 0) return (delete X[Y], G);
  if (Q === void 0) throw Error(`Key ${Y} does not exist in object.`);
  return Q;
}
function S5(...X) {
  return Array.prototype.concat.apply([], X);
}
function MP(...X) {
  return X.reduce((Y, Q) => Y.flatMap((G) => Q.map((J) => [G, J])));
}
function v7(X, Y) {
  return Math.abs(((X + Y) % (2 * Y)) - Y);
}
var f5 = class {
  constructor() {
    let X = function (...Y) {
      return X._call(...Y);
    };
    return Object.setPrototypeOf(X, new.target.prototype);
  }
  _call(...X) {
    throw Error("Must implement _call method in subclass");
  }
};
var VW = s((AP) => {
  /*!
   * ONNX Runtime Common v1.14.0
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   */ (() => {
    var X = {
        d: (M, A) => {
          for (var D in A)
            X.o(A, D) &&
              !X.o(M, D) &&
              Object.defineProperty(M, D, { enumerable: !0, get: A[D] });
        },
        o: (M, A) => Object.prototype.hasOwnProperty.call(M, A),
        r: (M) => {
          (typeof Symbol < "u" &&
            Symbol.toStringTag &&
            Object.defineProperty(M, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(M, "__esModule", { value: !0 }));
        },
      },
      Y = {};
    (X.r(Y),
      X.d(Y, {
        InferenceSession: () => F,
        Tensor: () => L,
        env: () => U,
        registerBackend: () => J,
      }));
    let Q = {},
      G = [],
      J = (M, A, D) => {
        if (
          !A ||
          typeof A.init != "function" ||
          typeof A.createSessionHandler != "function"
        )
          throw TypeError("not a valid backend");
        {
          let R = Q[M];
          if (R === void 0) Q[M] = { backend: A, priority: D };
          else {
            if (R.priority > D) return;
            if (R.priority === D && R.backend !== A)
              throw Error(`cannot register backend "${M}" using priority ${D}`);
          }
          if (D >= 0) {
            let z = G.indexOf(M);
            z !== -1 && G.splice(z, 1);
            for (let E = 0; E < G.length; E++)
              if (Q[G[E]].priority <= D) return void G.splice(E, 0, M);
            G.push(M);
          }
        }
      },
      U = new (class {
        constructor() {
          ((this.wasm = {}),
            (this.webgl = {}),
            (this.logLevelInternal = "warning"));
        }
        set logLevel(M) {
          if (M !== void 0) {
            if (
              typeof M != "string" ||
              ["verbose", "info", "warning", "error", "fatal"].indexOf(M) === -1
            )
              throw Error(`Unsupported logging level: ${M}`);
            this.logLevelInternal = M;
          }
        }
        get logLevel() {
          return this.logLevelInternal;
        }
      })(),
      $ = typeof BigInt64Array < "u" && typeof BigInt64Array.from == "function",
      B =
        typeof BigUint64Array < "u" && typeof BigUint64Array.from == "function",
      K = new Map([
        ["float32", Float32Array],
        ["uint8", Uint8Array],
        ["int8", Int8Array],
        ["uint16", Uint16Array],
        ["int16", Int16Array],
        ["int32", Int32Array],
        ["bool", Uint8Array],
        ["float64", Float64Array],
        ["uint32", Uint32Array],
      ]),
      V = new Map([
        [Float32Array, "float32"],
        [Uint8Array, "uint8"],
        [Int8Array, "int8"],
        [Uint16Array, "uint16"],
        [Int16Array, "int16"],
        [Int32Array, "int32"],
        [Float64Array, "float64"],
        [Uint32Array, "uint32"],
      ]);
    ($ && (K.set("int64", BigInt64Array), V.set(BigInt64Array, "int64")),
      B && (K.set("uint64", BigUint64Array), V.set(BigUint64Array, "uint64")));
    class W {
      constructor(M, A, D) {
        let R, z, E;
        if (typeof M == "string")
          if (((R = M), (E = D), M === "string")) {
            if (!Array.isArray(A))
              throw TypeError("A string tensor's data must be a string array.");
            z = A;
          } else {
            let Z = K.get(M);
            if (Z === void 0) throw TypeError(`Unsupported tensor type: ${M}.`);
            if (Array.isArray(A)) z = Z.from(A);
            else {
              if (!(A instanceof Z))
                throw TypeError(`A ${R} tensor's data must be type of ${Z}`);
              z = A;
            }
          }
        else if (((E = A), Array.isArray(M))) {
          if (M.length === 0)
            throw TypeError(
              "Tensor type cannot be inferred from an empty array."
            );
          let Z = typeof M[0];
          if (Z === "string") ((R = "string"), (z = M));
          else {
            if (Z !== "boolean")
              throw TypeError(`Invalid element type of data array: ${Z}.`);
            ((R = "bool"), (z = Uint8Array.from(M)));
          }
        } else {
          let Z = V.get(M.constructor);
          if (Z === void 0)
            throw TypeError(
              `Unsupported type for tensor data: ${M.constructor}.`
            );
          ((R = Z), (z = M));
        }
        if (E === void 0) E = [z.length];
        else if (!Array.isArray(E))
          throw TypeError("A tensor's dims must be a number array");
        let O = ((Z) => {
          let j = 1;
          for (let w = 0; w < Z.length; w++) {
            let I = Z[w];
            if (typeof I != "number" || !Number.isSafeInteger(I))
              throw TypeError(`dims[${w}] must be an integer, got: ${I}`);
            if (I < 0)
              throw RangeError(
                `dims[${w}] must be a non-negative integer, got: ${I}`
              );
            j *= I;
          }
          return j;
        })(E);
        if (O !== z.length)
          throw Error(
            `Tensor's size(${O}) does not match data length(${z.length}).`
          );
        ((this.dims = E), (this.type = R), (this.data = z), (this.size = O));
      }
      static bufferToTensor(M, A) {
        if (M === void 0) throw Error("Image buffer must be defined");
        if (A.height === void 0 || A.width === void 0)
          throw Error("Image height and width must be defined");
        let { height: D, width: R } = A,
          z = A.norm,
          E,
          O;
        ((E = z === void 0 || z.mean === void 0 ? 255 : z.mean),
          (O = z === void 0 || z.bias === void 0 ? 0 : z.bias));
        let Z = A.bitmapFormat !== void 0 ? A.bitmapFormat : "RGBA",
          j =
            A.tensorFormat !== void 0 && A.tensorFormat !== void 0
              ? A.tensorFormat
              : "RGB",
          w = D * R,
          I = j === "RGBA" ? new Float32Array(4 * w) : new Float32Array(3 * w),
          T = 4,
          y = 0,
          _ = 1,
          f = 2,
          l = 3,
          h = 0,
          p = w,
          N0 = 2 * w,
          e = -1;
        (Z === "RGB" && ((T = 3), (y = 0), (_ = 1), (f = 2), (l = -1)),
          j === "RGBA"
            ? (e = 3 * w)
            : j === "RBG"
              ? ((h = 0), (N0 = w), (p = 2 * w))
              : j === "BGR" && ((N0 = 0), (p = w), (h = 2 * w)));
        for (let P = 0; P < w; P++, y += T, f += T, _ += T, l += T)
          ((I[h++] = (M[y] + O) / E),
            (I[p++] = (M[_] + O) / E),
            (I[N0++] = (M[f] + O) / E),
            e !== -1 && l !== -1 && (I[e++] = (M[l] + O) / E));
        return new W("float32", I, j === "RGBA" ? [1, 4, D, R] : [1, 3, D, R]);
      }
      static async fromImage(M, A) {
        let D = typeof HTMLImageElement < "u" && M instanceof HTMLImageElement,
          R = typeof ImageData < "u" && M instanceof ImageData,
          z = typeof ImageBitmap < "u" && M instanceof ImageBitmap,
          E =
            typeof String < "u" &&
            (M instanceof String || typeof M == "string"),
          O,
          Z = {};
        if (D) {
          let j = document.createElement("canvas"),
            w = j.getContext("2d");
          if (w == null) throw Error("Can not access image data");
          {
            let { naturalHeight: I, naturalWidth: T } = M;
            if (
              (A !== void 0 &&
                A.resizedHeight !== void 0 &&
                A.resizedWidth !== void 0 &&
                ((I = A.resizedHeight), (T = A.resizedWidth)),
              A !== void 0)
            ) {
              if (((Z = A), A.tensorFormat !== void 0))
                throw Error(
                  "Image input config format must be RGBA for HTMLImageElement"
                );
              if (
                ((Z.tensorFormat = "RGBA"),
                A.height !== void 0 && A.height !== I)
              )
                throw Error(
                  "Image input config height doesn't match HTMLImageElement height"
                );
              if (((Z.height = I), A.width !== void 0 && A.width !== T))
                throw Error(
                  "Image input config width doesn't match HTMLImageElement width"
                );
              Z.width = T;
            } else ((Z.tensorFormat = "RGBA"), (Z.height = I), (Z.width = T));
            ((j.width = T),
              (j.height = I),
              w.drawImage(M, 0, 0, T, I),
              (O = w.getImageData(0, 0, T, I).data));
          }
        } else {
          if (!R) {
            if (z) {
              if (A === void 0)
                throw Error(
                  "Please provide image config with format for Imagebitmap"
                );
              if (A.bitmapFormat !== void 0)
                throw Error(
                  "Image input config format must be defined for ImageBitmap"
                );
              let j = document.createElement("canvas").getContext("2d");
              if (j != null) {
                let { height: w, width: I } = M;
                if (
                  (j.drawImage(M, 0, 0, I, w),
                  (O = j.getImageData(0, 0, I, w).data),
                  A !== void 0)
                ) {
                  if (A.height !== void 0 && A.height !== w)
                    throw Error(
                      "Image input config height doesn't match ImageBitmap height"
                    );
                  if (((Z.height = w), A.width !== void 0 && A.width !== I))
                    throw Error(
                      "Image input config width doesn't match ImageBitmap width"
                    );
                  Z.width = I;
                } else ((Z.height = w), (Z.width = I));
                return W.bufferToTensor(O, Z);
              }
              throw Error("Can not access image data");
            }
            if (E)
              return new Promise((j, w) => {
                let I = document.createElement("canvas"),
                  T = I.getContext("2d");
                if (!M || !T) return w();
                let y = new Image();
                ((y.crossOrigin = "Anonymous"),
                  (y.src = M),
                  (y.onload = () => {
                    ((I.width = y.width),
                      (I.height = y.height),
                      T.drawImage(y, 0, 0, I.width, I.height));
                    let _ = T.getImageData(0, 0, I.width, I.height);
                    if (A !== void 0) {
                      if (A.height !== void 0 && A.height !== I.height)
                        throw Error(
                          "Image input config height doesn't match ImageBitmap height"
                        );
                      if (
                        ((Z.height = I.height),
                        A.width !== void 0 && A.width !== I.width)
                      )
                        throw Error(
                          "Image input config width doesn't match ImageBitmap width"
                        );
                      Z.width = I.width;
                    } else ((Z.height = I.height), (Z.width = I.width));
                    j(W.bufferToTensor(_.data, Z));
                  }));
              });
            throw Error(
              "Input data provided is not supported - aborted tensor creation"
            );
          }
          {
            let w, I;
            if (
              (A !== void 0 &&
              A.resizedWidth !== void 0 &&
              A.resizedHeight !== void 0
                ? ((w = A.resizedHeight), (I = A.resizedWidth))
                : ((w = M.height), (I = M.width)),
              A !== void 0)
            ) {
              if (
                ((Z = A),
                A.bitmapFormat !== void 0 && A.bitmapFormat !== "RGBA")
              )
                throw Error(
                  "Image input config format must be RGBA for ImageData"
                );
              Z.bitmapFormat = "RGBA";
            } else Z.bitmapFormat = "RGBA";
            if (((Z.height = w), (Z.width = I), A !== void 0)) {
              let T = document.createElement("canvas");
              ((T.width = I), (T.height = w));
              let y = T.getContext("2d");
              if (y == null) throw Error("Can not access image data");
              (y.putImageData(M, 0, 0), (O = y.getImageData(0, 0, I, w).data));
            } else O = M.data;
          }
        }
        if (O !== void 0) return W.bufferToTensor(O, Z);
        throw Error(
          "Input data provided is not supported - aborted tensor creation"
        );
      }
      toImageData(M) {
        var A, D;
        let R = document.createElement("canvas").getContext("2d"),
          z;
        if (R == null) throw Error("Can not access image data");
        {
          let E = this.dims[3],
            O = this.dims[2],
            Z = this.dims[1],
            j = M !== void 0 && M.format !== void 0 ? M.format : "RGB",
            w =
              M !== void 0 &&
              ((A = M.norm) === null || A === void 0 ? void 0 : A.mean) !==
                void 0
                ? M.norm.mean
                : 255,
            I =
              M !== void 0 &&
              ((D = M.norm) === null || D === void 0 ? void 0 : D.bias) !==
                void 0
                ? M.norm.bias
                : 0,
            T = O * E;
          if (M !== void 0) {
            if (M.height !== void 0 && M.height !== O)
              throw Error(
                "Image output config height doesn't match tensor height"
              );
            if (M.width !== void 0 && M.width !== E)
              throw Error(
                "Image output config width doesn't match tensor width"
              );
            if (
              (M.format !== void 0 && Z === 4 && M.format !== "RGBA") ||
              (Z === 3 && M.format !== "RGB" && M.format !== "BGR")
            )
              throw Error("Tensor format doesn't match input tensor dims");
          }
          let y = 4,
            _ = 0,
            f = 1,
            l = 2,
            h = 3,
            p = 0,
            N0 = T,
            e = 2 * T,
            P = -1;
          (j === "RGBA"
            ? ((p = 0), (N0 = T), (e = 2 * T), (P = 3 * T))
            : j === "RGB"
              ? ((p = 0), (N0 = T), (e = 2 * T))
              : j === "RBG" && ((p = 0), (e = T), (N0 = 2 * T)),
            (z = R.createImageData(E, O)));
          for (let x = 0; x < O * E; _ += y, f += y, l += y, h += y, x++)
            ((z.data[_] = (this.data[p++] - I) * w),
              (z.data[f] = (this.data[N0++] - I) * w),
              (z.data[l] = (this.data[e++] - I) * w),
              (z.data[h] = P === -1 ? 255 : (this.data[P++] - I) * w));
        }
        return z;
      }
      reshape(M) {
        return new W(this.type, this.data, M);
      }
    }
    let L = W;
    class H {
      constructor(M) {
        this.handler = M;
      }
      async run(M, A, D) {
        let R = {},
          z = {};
        if (
          typeof M != "object" ||
          M === null ||
          M instanceof L ||
          Array.isArray(M)
        )
          throw TypeError(
            "'feeds' must be an object that use input names as keys and OnnxValue as corresponding values."
          );
        let E = !0;
        if (typeof A == "object") {
          if (A === null)
            throw TypeError("Unexpected argument[1]: cannot be null.");
          if (A instanceof L) throw TypeError("'fetches' cannot be a Tensor");
          if (Array.isArray(A)) {
            if (A.length === 0)
              throw TypeError("'fetches' cannot be an empty array.");
            E = !1;
            for (let j of A) {
              if (typeof j != "string")
                throw TypeError(
                  "'fetches' must be a string array or an object."
                );
              if (this.outputNames.indexOf(j) === -1)
                throw RangeError(
                  `'fetches' contains invalid output name: ${j}.`
                );
              R[j] = null;
            }
            if (typeof D == "object" && D !== null) z = D;
            else if (D !== void 0)
              throw TypeError("'options' must be an object.");
          } else {
            let j = !1,
              w = Object.getOwnPropertyNames(A);
            for (let I of this.outputNames)
              if (w.indexOf(I) !== -1) {
                let T = A[I];
                (T === null || T instanceof L) &&
                  ((j = !0), (E = !1), (R[I] = T));
              }
            if (j) {
              if (typeof D == "object" && D !== null) z = D;
              else if (D !== void 0)
                throw TypeError("'options' must be an object.");
            } else z = A;
          }
        } else if (A !== void 0)
          throw TypeError(
            "Unexpected argument[1]: must be 'fetches' or 'options'."
          );
        for (let j of this.inputNames)
          if (M[j] === void 0)
            throw Error(`input '${j}' is missing in 'feeds'.`);
        if (E) for (let j of this.outputNames) R[j] = null;
        let O = await this.handler.run(M, R, z),
          Z = {};
        for (let j in O)
          Object.hasOwnProperty.call(O, j) &&
            (Z[j] = new L(O[j].type, O[j].data, O[j].dims));
        return Z;
      }
      static async create(M, A, D, R) {
        let z,
          E = {};
        if (typeof M == "string") {
          if (((z = M), typeof A == "object" && A !== null)) E = A;
          else if (A !== void 0)
            throw TypeError("'options' must be an object.");
        } else if (M instanceof Uint8Array) {
          if (((z = M), typeof A == "object" && A !== null)) E = A;
          else if (A !== void 0)
            throw TypeError("'options' must be an object.");
        } else {
          if (
            !(
              M instanceof ArrayBuffer ||
              (typeof SharedArrayBuffer < "u" && M instanceof SharedArrayBuffer)
            )
          )
            throw TypeError(
              "Unexpected argument[0]: must be 'path' or 'buffer'."
            );
          {
            let w = M,
              I = 0,
              T = M.byteLength;
            if (typeof A == "object" && A !== null) E = A;
            else if (typeof A == "number") {
              if (((I = A), !Number.isSafeInteger(I)))
                throw RangeError("'byteOffset' must be an integer.");
              if (I < 0 || I >= w.byteLength)
                throw RangeError(
                  `'byteOffset' is out of range [0, ${w.byteLength}).`
                );
              if (((T = M.byteLength - I), typeof D == "number")) {
                if (((T = D), !Number.isSafeInteger(T)))
                  throw RangeError("'byteLength' must be an integer.");
                if (T <= 0 || I + T > w.byteLength)
                  throw RangeError(
                    `'byteLength' is out of range (0, ${w.byteLength - I}].`
                  );
                if (typeof R == "object" && R !== null) E = R;
                else if (R !== void 0)
                  throw TypeError("'options' must be an object.");
              } else if (D !== void 0)
                throw TypeError("'byteLength' must be a number.");
            } else if (A !== void 0)
              throw TypeError("'options' must be an object.");
            z = new Uint8Array(w, I, T);
          }
        }
        let O = (E.executionProviders || []).map((w) =>
            typeof w == "string" ? w : w.name
          ),
          Z = await (async (w) => {
            let I = w.length === 0 ? G : w,
              T = [];
            for (let y of I) {
              let _ = Q[y];
              if (_) {
                if (_.initialized) return _.backend;
                if (_.aborted) continue;
                let f = !!_.initPromise;
                try {
                  return (
                    f || (_.initPromise = _.backend.init()),
                    await _.initPromise,
                    (_.initialized = !0),
                    _.backend
                  );
                } catch (l) {
                  (f || T.push({ name: y, err: l }), (_.aborted = !0));
                } finally {
                  delete _.initPromise;
                }
              }
            }
            throw Error(
              `no available backend found. ERR: ${T.map((y) => `[${y.name}] ${y.err}`).join(", ")}`
            );
          })(O),
          j = await Z.createSessionHandler(z, E);
        return new H(j);
      }
      startProfiling() {
        this.handler.startProfiling();
      }
      endProfiling() {
        this.handler.endProfiling();
      }
      get inputNames() {
        return this.handler.inputNames;
      }
      get outputNames() {
        return this.handler.outputNames;
      }
    }
    let F = H;
    var N = AP;
    for (var q in Y) N[q] = Y[q];
    Y.__esModule && Object.defineProperty(N, "__esModule", { value: !0 });
  })();
});
var DP = s((qP) => {
  Object.defineProperty(qP, "__esModule", { value: !0 });
  qP.binding = void 0;
  qP.binding = k1(
    `../bin/napi-v3/${process.platform}/${process.arch}/onnxruntime_binding.node`
  );
});
var OP = s((Y9) => {
  var E10 =
      (Y9 && Y9.__classPrivateFieldSet) ||
      function (X, Y, Q, G, J) {
        if (G === "m") throw TypeError("Private method is not writable");
        if (G === "a" && !J)
          throw TypeError("Private accessor was defined without a setter");
        if (typeof Y === "function" ? X !== Y || !J : !Y.has(X))
          throw TypeError(
            "Cannot write private member to an object whose class did not declare it"
          );
        return (G === "a" ? J.call(X, Q) : J ? (J.value = Q) : Y.set(X, Q), Q);
      },
    IQ =
      (Y9 && Y9.__classPrivateFieldGet) ||
      function (X, Y, Q, G) {
        if (Q === "a" && !G)
          throw TypeError("Private accessor was defined without a getter");
        if (typeof Y === "function" ? X !== Y || !G : !Y.has(X))
          throw TypeError(
            "Cannot read private member from an object whose class did not declare it"
          );
        return Q === "m" ? G : Q === "a" ? G.call(X) : G ? G.value : Y.get(X);
      },
    X9;
  Object.defineProperty(Y9, "__esModule", { value: !0 });
  Y9.onnxruntimeBackend = void 0;
  var O10 = DP();
  class zP {
    constructor(X, Y) {
      if (
        (X9.set(this, void 0),
        E10(this, X9, new O10.binding.InferenceSession(), "f"),
        typeof X === "string")
      )
        IQ(this, X9, "f").loadModel(X, Y);
      else IQ(this, X9, "f").loadModel(X.buffer, X.byteOffset, X.byteLength, Y);
      ((this.inputNames = IQ(this, X9, "f").inputNames),
        (this.outputNames = IQ(this, X9, "f").outputNames));
    }
    async dispose() {
      return Promise.resolve();
    }
    startProfiling() {}
    endProfiling() {}
    async run(X, Y, Q) {
      return new Promise((G, J) => {
        process.nextTick(() => {
          try {
            G(IQ(this, X9, "f").run(X, Y, Q));
          } catch (U) {
            J(U);
          }
        });
      });
    }
  }
  X9 = new WeakMap();
  class EP {
    async init() {
      return Promise.resolve();
    }
    async createSessionHandler(X, Y) {
      return new Promise((Q, G) => {
        process.nextTick(() => {
          try {
            Q(new zP(X, Y || {}));
          } catch (J) {
            G(J);
          }
        });
      });
    }
  }
  Y9.onnxruntimeBackend = new EP();
});
var ZP = s((o9) => {
  var Z10 =
      (o9 && o9.__createBinding) ||
      (Object.create
        ? function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            var J = Object.getOwnPropertyDescriptor(Y, Q);
            if (
              !J ||
              ("get" in J ? !Y.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return Y[Q];
                },
              };
            Object.defineProperty(X, G, J);
          }
        : function (X, Y, Q, G) {
            if (G === void 0) G = Q;
            X[G] = Y[Q];
          }),
    j10 =
      (o9 && o9.__exportStar) ||
      function (X, Y) {
        for (var Q in X)
          if (Q !== "default" && !Object.prototype.hasOwnProperty.call(Y, Q))
            Z10(Y, X, Q);
      };
  Object.defineProperty(o9, "__esModule", { value: !0 });
  j10(VW(), o9);
  var w10 = VW(),
    C10 = OP();
  (0, w10.registerBackend)("cpu", C10.onnxruntimeBackend, 100);
});
var wP = s((rB, jP) => {
  var __dirname =
      "/Users/kazuto/Desktop/claude-cnthub/node_modules/.bun/onnxruntime-web@1.14.0/node_modules/onnxruntime-web/dist",
    __filename =
      "/Users/kazuto/Desktop/claude-cnthub/node_modules/.bun/onnxruntime-web@1.14.0/node_modules/onnxruntime-web/dist/ort-web.node.js";
  /*!
   * ONNX Runtime Web v1.14.0
   * Copyright (c) Microsoft Corporation. All rights reserved.
   * Licensed under the MIT License.
   */ (() => {
    var __webpack_modules__ = {
        3474: (X, Y, Q) => {
          var G,
            J =
              ((G =
                (G =
                  typeof document < "u" && document.currentScript
                    ? document.currentScript.src
                    : void 0) || __filename),
              function (U) {
                function $() {
                  return (e.buffer != x && m(e.buffer), r);
                }
                function B() {
                  return (e.buffer != x && m(e.buffer), C);
                }
                function K() {
                  return (e.buffer != x && m(e.buffer), v);
                }
                function V() {
                  return (e.buffer != x && m(e.buffer), k);
                }
                function W() {
                  return (e.buffer != x && m(e.buffer), o);
                }
                var L, H, F;
                ((U = U || {}),
                  L || (L = U !== void 0 ? U : {}),
                  (L.ready = new Promise(function (S, g) {
                    ((H = S), (F = g));
                  })));
                var N,
                  q,
                  M,
                  A,
                  D,
                  R,
                  z = Object.assign({}, L),
                  E = "./this.program",
                  O = (S, g) => {
                    throw g;
                  },
                  Z = typeof window == "object",
                  j = typeof importScripts == "function",
                  w =
                    typeof process == "object" &&
                    typeof process.versions == "object" &&
                    typeof process.versions.node == "string",
                  I = L.ENVIRONMENT_IS_PTHREAD || !1,
                  T = "";
                function y(S) {
                  return L.locateFile ? L.locateFile(S, T) : T + S;
                }
                if (w) {
                  let S;
                  ((T = j ? Q(1423).dirname(T) + "/" : __dirname + "/"),
                    (R = () => {
                      D || ((A = Q(6231)), (D = Q(1423)));
                    }),
                    (N = function (g, d) {
                      return (
                        R(),
                        (g = D.normalize(g)),
                        A.readFileSync(g, d ? void 0 : "utf8")
                      );
                    }),
                    (M = (g) => (
                      (g = N(g, !0)).buffer || (g = new Uint8Array(g)),
                      g
                    )),
                    (q = (g, d, t) => {
                      (R(),
                        (g = D.normalize(g)),
                        A.readFile(g, function (G0, U0) {
                          G0 ? t(G0) : d(U0.buffer);
                        }));
                    }),
                    1 < process.argv.length &&
                      (E = process.argv[1].replace(/\\/g, "/")),
                    process.argv.slice(2),
                    process.on("uncaughtException", function (g) {
                      if (!(g instanceof R8)) throw g;
                    }),
                    process.on("unhandledRejection", function (g) {
                      throw g;
                    }),
                    (O = (g, d) => {
                      if (v1()) throw ((process.exitCode = g), d);
                      (d instanceof R8 || p("exiting due to exception: " + d),
                        process.exit(g));
                    }),
                    (L.inspect = function () {
                      return "[Emscripten Module object]";
                    }));
                  try {
                    S = Q(4564);
                  } catch (g) {
                    throw (
                      console.error(
                        'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'
                      ),
                      g
                    );
                  }
                  global.Worker = S.Worker;
                } else
                  (Z || j) &&
                    (j
                      ? (T = self.location.href)
                      : typeof document < "u" &&
                        document.currentScript &&
                        (T = document.currentScript.src),
                    G && (T = G),
                    (T =
                      T.indexOf("blob:") !== 0
                        ? T.substr(
                            0,
                            T.replace(/[?#].*/, "").lastIndexOf("/") + 1
                          )
                        : ""),
                    w ||
                      ((N = (S) => {
                        var g = new XMLHttpRequest();
                        return (
                          g.open("GET", S, !1),
                          g.send(null),
                          g.responseText
                        );
                      }),
                      j &&
                        (M = (S) => {
                          var g = new XMLHttpRequest();
                          return (
                            g.open("GET", S, !1),
                            (g.responseType = "arraybuffer"),
                            g.send(null),
                            new Uint8Array(g.response)
                          );
                        }),
                      (q = (S, g, d) => {
                        var t = new XMLHttpRequest();
                        (t.open("GET", S, !0),
                          (t.responseType = "arraybuffer"),
                          (t.onload = () => {
                            t.status == 200 || (t.status == 0 && t.response)
                              ? g(t.response)
                              : d();
                          }),
                          (t.onerror = d),
                          t.send(null));
                      })));
                w &&
                  typeof performance > "u" &&
                  (global.performance = Q(498).performance);
                var _ = console.log.bind(console),
                  f = console.warn.bind(console);
                w &&
                  (R(),
                  (_ = (S) =>
                    A.writeSync(
                      1,
                      S +
                        `
`
                    )),
                  (f = (S) =>
                    A.writeSync(
                      2,
                      S +
                        `
`
                    )));
                var l,
                  h = L.print || _,
                  p = L.printErr || f;
                (Object.assign(L, z),
                  (z = null),
                  L.thisProgram && (E = L.thisProgram),
                  L.quit && (O = L.quit),
                  L.wasmBinary && (l = L.wasmBinary));
                var N0 = L.noExitRuntime || !1;
                typeof WebAssembly != "object" &&
                  r0("no native wasm support detected");
                var e,
                  P,
                  x,
                  r,
                  C,
                  v,
                  k,
                  o,
                  J0 = !1,
                  z0 =
                    typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
                function A0(S, g, d) {
                  var t = (g >>>= 0) + d;
                  for (d = g; S[d] && !(d >= t); ) ++d;
                  if (16 < d - g && S.buffer && z0)
                    return z0.decode(
                      S.buffer instanceof SharedArrayBuffer
                        ? S.slice(g, d)
                        : S.subarray(g, d)
                    );
                  for (t = ""; g < d; ) {
                    var G0 = S[g++];
                    if (128 & G0) {
                      var U0 = 63 & S[g++];
                      if ((224 & G0) == 192)
                        t += String.fromCharCode(((31 & G0) << 6) | U0);
                      else {
                        var S0 = 63 & S[g++];
                        65536 >
                        (G0 =
                          (240 & G0) == 224
                            ? ((15 & G0) << 12) | (U0 << 6) | S0
                            : ((7 & G0) << 18) |
                              (U0 << 12) |
                              (S0 << 6) |
                              (63 & S[g++]))
                          ? (t += String.fromCharCode(G0))
                          : ((G0 -= 65536),
                            (t += String.fromCharCode(
                              55296 | (G0 >> 10),
                              56320 | (1023 & G0)
                            )));
                      }
                    } else t += String.fromCharCode(G0);
                  }
                  return t;
                }
                function w0(S, g) {
                  return (S >>>= 0) ? A0(B(), S, g) : "";
                }
                function Y1(S, g, d, t) {
                  if (!(0 < t)) return 0;
                  var G0 = (d >>>= 0);
                  t = d + t - 1;
                  for (var U0 = 0; U0 < S.length; ++U0) {
                    var S0 = S.charCodeAt(U0);
                    if (
                      (55296 <= S0 &&
                        57343 >= S0 &&
                        (S0 =
                          (65536 + ((1023 & S0) << 10)) |
                          (1023 & S.charCodeAt(++U0))),
                      127 >= S0)
                    ) {
                      if (d >= t) break;
                      g[d++ >>> 0] = S0;
                    } else {
                      if (2047 >= S0) {
                        if (d + 1 >= t) break;
                        g[d++ >>> 0] = 192 | (S0 >> 6);
                      } else {
                        if (65535 >= S0) {
                          if (d + 2 >= t) break;
                          g[d++ >>> 0] = 224 | (S0 >> 12);
                        } else {
                          if (d + 3 >= t) break;
                          ((g[d++ >>> 0] = 240 | (S0 >> 18)),
                            (g[d++ >>> 0] = 128 | ((S0 >> 12) & 63)));
                        }
                        g[d++ >>> 0] = 128 | ((S0 >> 6) & 63);
                      }
                      g[d++ >>> 0] = 128 | (63 & S0);
                    }
                  }
                  return ((g[d >>> 0] = 0), d - G0);
                }
                function b(S) {
                  for (var g = 0, d = 0; d < S.length; ++d) {
                    var t = S.charCodeAt(d);
                    127 >= t
                      ? g++
                      : 2047 >= t
                        ? (g += 2)
                        : 55296 <= t && 57343 >= t
                          ? ((g += 4), ++d)
                          : (g += 3);
                  }
                  return g;
                }
                function m(S) {
                  ((x = S),
                    (L.HEAP8 = r = new Int8Array(S)),
                    (L.HEAP16 = new Int16Array(S)),
                    (L.HEAP32 = v = new Int32Array(S)),
                    (L.HEAPU8 = C = new Uint8Array(S)),
                    (L.HEAPU16 = new Uint16Array(S)),
                    (L.HEAPU32 = k = new Uint32Array(S)),
                    (L.HEAPF32 = new Float32Array(S)),
                    (L.HEAPF64 = o = new Float64Array(S)));
                }
                I && (x = L.buffer);
                var n = L.INITIAL_MEMORY || 16777216;
                if (I) ((e = L.wasmMemory), (x = L.buffer));
                else if (L.wasmMemory) e = L.wasmMemory;
                else if (
                  !(
                    (e = new WebAssembly.Memory({
                      initial: n / 65536,
                      maximum: 65536,
                      shared: !0,
                    })).buffer instanceof SharedArrayBuffer
                  )
                )
                  throw (
                    p(
                      "requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"
                    ),
                    w &&
                      console.log(
                        "(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"
                      ),
                    Error("bad memory")
                  );
                (e && (x = e.buffer), (n = x.byteLength), m(x));
                var M0,
                  D0 = [],
                  Z0 = [],
                  B1 = [],
                  j1 = [];
                function v1() {
                  return N0 || !1;
                }
                function M1() {
                  var S = L.preRun.shift();
                  D0.unshift(S);
                }
                var x0,
                  h1 = 0,
                  g1 = null,
                  b5 = null;
                function r0(S) {
                  throw (
                    I
                      ? postMessage({ cmd: "onAbort", arg: S })
                      : L.onAbort && L.onAbort(S),
                    p((S = "Aborted(" + S + ")")),
                    (J0 = !0),
                    (S = new WebAssembly.RuntimeError(
                      S + ". Build with -sASSERTIONS for more info."
                    )),
                    F(S),
                    S
                  );
                }
                function q8() {
                  return x0.startsWith("data:application/octet-stream;base64,");
                }
                function w8() {
                  var S = x0;
                  try {
                    if (S == x0 && l) return new Uint8Array(l);
                    if (M) return M(S);
                    throw "both async and sync fetching of the wasm failed";
                  } catch (g) {
                    r0(g);
                  }
                }
                ((x0 = "ort-wasm-threaded.wasm"), q8() || (x0 = y(x0)));
                var Y6 = {};
                function R8(S) {
                  ((this.name = "ExitStatus"),
                    (this.message = "Program terminated with exit(" + S + ")"),
                    (this.status = S));
                }
                function PX(S) {
                  ((S = Q1.Vb[S]) || r0(), Q1.mc(S));
                }
                function SX(S) {
                  var g = Q1.Cc();
                  if (!g) return 6;
                  (Q1.ac.push(g), (Q1.Vb[S.Ub] = g), (g.Ub = S.Ub));
                  var d = {
                    cmd: "run",
                    start_routine: S.Ic,
                    arg: S.zc,
                    pthread_ptr: S.Ub,
                  };
                  return (
                    (g.$b = () => {
                      ((d.time = performance.now()), g.postMessage(d, S.Nc));
                    }),
                    g.loaded && (g.$b(), delete g.$b),
                    0
                  );
                }
                function m5(S) {
                  if (I) return k0(1, 1, S);
                  (v1() || (Q1.oc(), L.onExit && L.onExit(S), (J0 = !0)),
                    O(S, new R8(S)));
                }
                function R9(S, g) {
                  if (!g && I) throw (VG(S), "unwind");
                  (v1() ||
                    I ||
                    ($D(),
                    I4(B1),
                    HD(0),
                    u$[1].length && l$(1, 10),
                    u$[2].length && l$(2, 10),
                    Q1.oc()),
                    m5(S));
                }
                var Q1 = {
                  Yb: [],
                  ac: [],
                  qc: [],
                  Vb: {},
                  fc: function () {
                    I && Q1.Ec();
                  },
                  Pc: function () {},
                  Ec: function () {
                    ((Q1.receiveObjectTransfer = Q1.Gc),
                      (Q1.threadInitTLS = Q1.pc),
                      (Q1.setExitStatus = Q1.nc),
                      (N0 = !1));
                  },
                  nc: function () {},
                  oc: function () {
                    for (var S of Object.values(Q1.Vb)) Q1.mc(S);
                    for (S of Q1.Yb) S.terminate();
                    Q1.Yb = [];
                  },
                  mc: function (S) {
                    var g = S.Ub;
                    (delete Q1.Vb[g],
                      Q1.Yb.push(S),
                      Q1.ac.splice(Q1.ac.indexOf(S), 1),
                      (S.Ub = 0),
                      c$(g));
                  },
                  Gc: function () {},
                  pc: function () {
                    Q1.qc.forEach((S) => S());
                  },
                  Fc: function (S, g) {
                    ((S.onmessage = (d) => {
                      var t = (d = d.data).cmd;
                      if (
                        (S.Ub && (Q1.Bc = S.Ub),
                        d.targetThread && d.targetThread != NG())
                      ) {
                        var G0 = Q1.Vb[d.Qc];
                        G0
                          ? G0.postMessage(d, d.transferList)
                          : p(
                              'Internal error! Worker sent a message "' +
                                t +
                                '" to target pthread ' +
                                d.targetThread +
                                ", but that thread no longer exists!"
                            );
                      } else
                        t === "processProxyingQueue"
                          ? Y0(d.queue)
                          : t === "spawnThread"
                            ? SX(d)
                            : t === "cleanupThread"
                              ? PX(d.thread)
                              : t === "killThread"
                                ? ((d = d.thread),
                                  (t = Q1.Vb[d]),
                                  delete Q1.Vb[d],
                                  t.terminate(),
                                  c$(d),
                                  Q1.ac.splice(Q1.ac.indexOf(t), 1),
                                  (t.Ub = 0))
                                : t === "cancelThread"
                                  ? Q1.Vb[d.thread].postMessage({
                                      cmd: "cancel",
                                    })
                                  : t === "loaded"
                                    ? ((S.loaded = !0),
                                      g && g(S),
                                      S.$b && (S.$b(), delete S.$b))
                                    : t === "print"
                                      ? h(
                                          "Thread " + d.threadId + ": " + d.text
                                        )
                                      : t === "printErr"
                                        ? p(
                                            "Thread " +
                                              d.threadId +
                                              ": " +
                                              d.text
                                          )
                                        : t === "alert"
                                          ? alert(
                                              "Thread " +
                                                d.threadId +
                                                ": " +
                                                d.text
                                            )
                                          : d.target === "setimmediate"
                                            ? S.postMessage(d)
                                            : t === "onAbort"
                                              ? L.onAbort && L.onAbort(d.arg)
                                              : t &&
                                                p(
                                                  "worker sent an unknown command " +
                                                    t
                                                );
                      Q1.Bc = void 0;
                    }),
                      (S.onerror = (d) => {
                        throw (
                          p(
                            "worker sent an error! " +
                              d.filename +
                              ":" +
                              d.lineno +
                              ": " +
                              d.message
                          ),
                          d
                        );
                      }),
                      w &&
                        (S.on("message", function (d) {
                          S.onmessage({ data: d });
                        }),
                        S.on("error", function (d) {
                          S.onerror(d);
                        }),
                        S.on("detachedExit", function () {})),
                      S.postMessage({
                        cmd: "load",
                        urlOrBlob: L.mainScriptUrlOrBlob || G,
                        wasmMemory: e,
                        wasmModule: P,
                      }));
                  },
                  yc: function () {
                    var S = y("ort-wasm-threaded.worker.js");
                    Q1.Yb.push(new Worker(S));
                  },
                  Cc: function () {
                    return (
                      Q1.Yb.length == 0 && (Q1.yc(), Q1.Fc(Q1.Yb[0])),
                      Q1.Yb.pop()
                    );
                  },
                };
                function I4(S) {
                  for (; 0 < S.length; ) S.shift()(L);
                }
                function KG(S) {
                  var g = A1();
                  return ((S = S()), F1(g), S);
                }
                function VG(S) {
                  if (I) return k0(2, 0, S);
                  try {
                    R9(S);
                  } catch (g) {
                    g instanceof R8 || g == "unwind" || O(1, g);
                  }
                }
                ((L.PThread = Q1),
                  (L.establishStackSpace = function () {
                    var S = NG(),
                      g = K()[((S + 44) >> 2) >>> 0];
                    ((S = K()[((S + 48) >> 2) >>> 0]), VD(g, g - S), F1(g));
                  }));
                var o6 = [];
                function u1(S) {
                  var g = o6[S];
                  return (
                    g ||
                      (S >= o6.length && (o6.length = S + 1),
                      (o6[S] = g = M0.get(S))),
                    g
                  );
                }
                L.invokeEntryPoint = function (S, g) {
                  ((S = u1(S)(g)), v1() ? Q1.nc(S) : KD(S));
                };
                var D9,
                  QY,
                  z9 = [],
                  H1 = 0,
                  G1 = 0;
                function J1(S) {
                  ((this.Zb = S),
                    (this.Sb = S - 24),
                    (this.xc = function (g) {
                      V()[((this.Sb + 4) >> 2) >>> 0] = g;
                    }),
                    (this.bc = function () {
                      return V()[((this.Sb + 4) >> 2) >>> 0];
                    }),
                    (this.wc = function (g) {
                      V()[((this.Sb + 8) >> 2) >>> 0] = g;
                    }),
                    (this.Dc = function () {
                      return V()[((this.Sb + 8) >> 2) >>> 0];
                    }),
                    (this.rc = function () {
                      K()[(this.Sb >> 2) >>> 0] = 0;
                    }),
                    (this.hc = function (g) {
                      ((g = g ? 1 : 0), ($()[((this.Sb + 12) >> 0) >>> 0] = g));
                    }),
                    (this.uc = function () {
                      return $()[((this.Sb + 12) >> 0) >>> 0] != 0;
                    }),
                    (this.ic = function (g) {
                      ((g = g ? 1 : 0), ($()[((this.Sb + 13) >> 0) >>> 0] = g));
                    }),
                    (this.kc = function () {
                      return $()[((this.Sb + 13) >> 0) >>> 0] != 0;
                    }),
                    (this.fc = function (g, d) {
                      (this.cc(0),
                        this.xc(g),
                        this.wc(d),
                        this.rc(),
                        this.hc(!1),
                        this.ic(!1));
                    }),
                    (this.sc = function () {
                      Atomics.add(K(), this.Sb >> 2, 1);
                    }),
                    (this.Hc = function () {
                      return Atomics.sub(K(), this.Sb >> 2, 1) === 1;
                    }),
                    (this.cc = function (g) {
                      V()[((this.Sb + 16) >> 2) >>> 0] = g;
                    }),
                    (this.tc = function () {
                      return V()[((this.Sb + 16) >> 2) >>> 0];
                    }),
                    (this.vc = function () {
                      if (FD(this.bc())) return V()[(this.Zb >> 2) >>> 0];
                      var g = this.tc();
                      return g !== 0 ? g : this.Zb;
                    }));
                }
                function GY(S) {
                  return WD(new J1(S).Sb);
                }
                function E9(S, g, d, t) {
                  return I ? k0(3, 1, S, g, d, t) : JY(S, g, d, t);
                }
                function JY(S, g, d, t) {
                  if (typeof SharedArrayBuffer > "u")
                    return (
                      p(
                        "Current environment does not support SharedArrayBuffer, pthreads are not available!"
                      ),
                      6
                    );
                  var G0 = [];
                  return I && G0.length === 0
                    ? E9(S, g, d, t)
                    : ((S = { Ic: d, Ub: S, zc: t, Nc: G0 }),
                      I
                        ? ((S.Oc = "spawnThread"), postMessage(S, G0), 0)
                        : SX(S));
                }
                function WY(S, g, d) {
                  return I ? k0(4, 1, S, g, d) : 0;
                }
                function HY(S, g) {
                  if (I) return k0(5, 1, S, g);
                }
                function $Y(S, g) {
                  if (I) return k0(6, 1, S, g);
                }
                function UY(S, g, d) {
                  if (I) return k0(7, 1, S, g, d);
                }
                function LY(S, g, d) {
                  return I ? k0(8, 1, S, g, d) : 0;
                }
                function BY(S, g) {
                  if (I) return k0(9, 1, S, g);
                }
                function KY(S, g, d) {
                  if (I) return k0(10, 1, S, g, d);
                }
                function VY(S, g, d, t) {
                  if (I) return k0(11, 1, S, g, d, t);
                }
                function FY(S, g, d, t) {
                  if (I) return k0(12, 1, S, g, d, t);
                }
                function NY(S, g, d, t) {
                  if (I) return k0(13, 1, S, g, d, t);
                }
                function MY(S) {
                  if (I) return k0(14, 1, S);
                }
                function u(S, g) {
                  if (I) return k0(15, 1, S, g);
                }
                function a(S, g, d) {
                  if (I) return k0(16, 1, S, g, d);
                }
                function Y0(S) {
                  (Atomics.store(K(), S >> 2, 1),
                    NG() && BD(S),
                    Atomics.compareExchange(K(), S >> 2, 1, 0));
                }
                function Q0(S) {
                  return V()[S >>> 2] + 4294967296 * K()[(S + 4) >>> 2];
                }
                function W0(S, g, d, t, G0, U0) {
                  return I ? k0(17, 1, S, g, d, t, G0, U0) : -52;
                }
                function V0(S, g, d, t, G0, U0) {
                  if (I) return k0(18, 1, S, g, d, t, G0, U0);
                }
                function P0(S) {
                  var g = b(S) + 1,
                    d = m$(g);
                  return (d && Y1(S, $(), d, g), d);
                }
                function m0(S, g, d) {
                  function t(w1) {
                    return (w1 = w1.toTimeString().match(/\(([A-Za-z ]+)\)$/))
                      ? w1[1]
                      : "GMT";
                  }
                  if (I) return k0(19, 1, S, g, d);
                  var G0 = new Date().getFullYear(),
                    U0 = new Date(G0, 0, 1),
                    S0 = new Date(G0, 6, 1);
                  G0 = U0.getTimezoneOffset();
                  var c0 = S0.getTimezoneOffset(),
                    E1 = Math.max(G0, c0);
                  ((K()[(S >> 2) >>> 0] = 60 * E1),
                    (K()[(g >> 2) >>> 0] = Number(G0 != c0)),
                    (S = t(U0)),
                    (g = t(S0)),
                    (S = P0(S)),
                    (g = P0(g)),
                    c0 < G0
                      ? ((V()[(d >> 2) >>> 0] = S),
                        (V()[((d + 4) >> 2) >>> 0] = g))
                      : ((V()[(d >> 2) >>> 0] = g),
                        (V()[((d + 4) >> 2) >>> 0] = S)));
                }
                function k0(S, g) {
                  var d = arguments.length - 2,
                    t = arguments;
                  return KG(() => {
                    for (
                      var G0 = d$(8 * d), U0 = G0 >> 3, S0 = 0;
                      S0 < d;
                      S0++
                    ) {
                      var c0 = t[2 + S0];
                      W()[(U0 + S0) >>> 0] = c0;
                    }
                    return LD(S, d, G0, g);
                  });
                }
                ((L.executeNotifiedProxyingQueue = Y0),
                  (QY = w
                    ? () => {
                        var S = process.hrtime();
                        return 1000 * S[0] + S[1] / 1e6;
                      }
                    : I
                      ? () =>
                          performance.now() - L.__performance_now_clock_drift
                      : () => performance.now()));
                var V1,
                  d1 = [],
                  v5 = {};
                function w5() {
                  if (!V1) {
                    var S,
                      g = {
                        USER: "web_user",
                        LOGNAME: "web_user",
                        PATH: "/",
                        PWD: "/",
                        HOME: "/home/web_user",
                        LANG:
                          (
                            (typeof navigator == "object" &&
                              navigator.languages &&
                              navigator.languages[0]) ||
                            "C"
                          ).replace("-", "_") + ".UTF-8",
                        _: E || "./this.program",
                      };
                    for (S in v5)
                      v5[S] === void 0 ? delete g[S] : (g[S] = v5[S]);
                    var d = [];
                    for (S in g) d.push(S + "=" + g[S]);
                    V1 = d;
                  }
                  return V1;
                }
                function B0(S, g) {
                  if (I) return k0(20, 1, S, g);
                  var d = 0;
                  return (
                    w5().forEach(function (t, G0) {
                      var U0 = g + d;
                      for (
                        G0 = V()[((S + 4 * G0) >> 2) >>> 0] = U0, U0 = 0;
                        U0 < t.length;
                        ++U0
                      )
                        $()[(G0++ >> 0) >>> 0] = t.charCodeAt(U0);
                      (($()[(G0 >> 0) >>> 0] = 0), (d += t.length + 1));
                    }),
                    0
                  );
                }
                function S1(S, g) {
                  if (I) return k0(21, 1, S, g);
                  var d = w5();
                  V()[(S >> 2) >>> 0] = d.length;
                  var t = 0;
                  return (
                    d.forEach(function (G0) {
                      t += G0.length + 1;
                    }),
                    (V()[(g >> 2) >>> 0] = t),
                    0
                  );
                }
                function t1(S) {
                  return I ? k0(22, 1, S) : 52;
                }
                function C8(S, g, d, t) {
                  return I ? k0(23, 1, S, g, d, t) : 52;
                }
                function s6(S, g, d, t, G0) {
                  return I ? k0(24, 1, S, g, d, t, G0) : 70;
                }
                var u$ = [null, [], []];
                function l$(S, g) {
                  var d = u$[S];
                  g === 0 || g === 10
                    ? ((S === 1 ? h : p)(A0(d, 0)), (d.length = 0))
                    : d.push(g);
                }
                function YD(S, g, d, t) {
                  if (I) return k0(25, 1, S, g, d, t);
                  for (var G0 = 0, U0 = 0; U0 < d; U0++) {
                    var S0 = V()[(g >> 2) >>> 0],
                      c0 = V()[((g + 4) >> 2) >>> 0];
                    g += 8;
                    for (var E1 = 0; E1 < c0; E1++) l$(S, B()[(S0 + E1) >>> 0]);
                    G0 += c0;
                  }
                  return ((V()[(t >> 2) >>> 0] = G0), 0);
                }
                var $8 = 0;
                function FG(S) {
                  return S % 4 == 0 && (S % 100 != 0 || S % 400 == 0);
                }
                var QD = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                  GD = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                function JD(S, g, d, t) {
                  function G0(K0, T1, L5) {
                    for (
                      K0 = typeof K0 == "number" ? K0.toString() : K0 || "";
                      K0.length < T1;
                    )
                      K0 = L5[0] + K0;
                    return K0;
                  }
                  function U0(K0, T1) {
                    return G0(K0, T1, "0");
                  }
                  function S0(K0, T1) {
                    function L5(TX) {
                      return 0 > TX ? -1 : 0 < TX ? 1 : 0;
                    }
                    var t6;
                    return (
                      (t6 = L5(K0.getFullYear() - T1.getFullYear())) === 0 &&
                        (t6 = L5(K0.getMonth() - T1.getMonth())) === 0 &&
                        (t6 = L5(K0.getDate() - T1.getDate())),
                      t6
                    );
                  }
                  function c0(K0) {
                    switch (K0.getDay()) {
                      case 0:
                        return new Date(K0.getFullYear() - 1, 11, 29);
                      case 1:
                        return K0;
                      case 2:
                        return new Date(K0.getFullYear(), 0, 3);
                      case 3:
                        return new Date(K0.getFullYear(), 0, 2);
                      case 4:
                        return new Date(K0.getFullYear(), 0, 1);
                      case 5:
                        return new Date(K0.getFullYear() - 1, 11, 31);
                      case 6:
                        return new Date(K0.getFullYear() - 1, 11, 30);
                    }
                  }
                  function E1(K0) {
                    var T1 = K0.Wb;
                    for (
                      K0 = new Date(new Date(K0.Xb + 1900, 0, 1).getTime());
                      0 < T1;
                    ) {
                      var L5 = K0.getMonth(),
                        t6 = (FG(K0.getFullYear()) ? QD : GD)[L5];
                      if (!(T1 > t6 - K0.getDate())) {
                        K0.setDate(K0.getDate() + T1);
                        break;
                      }
                      ((T1 -= t6 - K0.getDate() + 1),
                        K0.setDate(1),
                        11 > L5
                          ? K0.setMonth(L5 + 1)
                          : (K0.setMonth(0),
                            K0.setFullYear(K0.getFullYear() + 1)));
                    }
                    return (
                      (L5 = new Date(K0.getFullYear() + 1, 0, 4)),
                      (T1 = c0(new Date(K0.getFullYear(), 0, 4))),
                      (L5 = c0(L5)),
                      0 >= S0(T1, K0)
                        ? 0 >= S0(L5, K0)
                          ? K0.getFullYear() + 1
                          : K0.getFullYear()
                        : K0.getFullYear() - 1
                    );
                  }
                  var w1 = K()[((t + 40) >> 2) >>> 0];
                  for (var N5 in ((t = {
                    Lc: K()[(t >> 2) >>> 0],
                    Kc: K()[((t + 4) >> 2) >>> 0],
                    dc: K()[((t + 8) >> 2) >>> 0],
                    jc: K()[((t + 12) >> 2) >>> 0],
                    ec: K()[((t + 16) >> 2) >>> 0],
                    Xb: K()[((t + 20) >> 2) >>> 0],
                    Tb: K()[((t + 24) >> 2) >>> 0],
                    Wb: K()[((t + 28) >> 2) >>> 0],
                    Rc: K()[((t + 32) >> 2) >>> 0],
                    Jc: K()[((t + 36) >> 2) >>> 0],
                    Mc: w1 ? w0(w1) : "",
                  }),
                  (d = w0(d)),
                  (w1 = {
                    "%c": "%a %b %d %H:%M:%S %Y",
                    "%D": "%m/%d/%y",
                    "%F": "%Y-%m-%d",
                    "%h": "%b",
                    "%r": "%I:%M:%S %p",
                    "%R": "%H:%M",
                    "%T": "%H:%M:%S",
                    "%x": "%m/%d/%y",
                    "%X": "%H:%M:%S",
                    "%Ec": "%c",
                    "%EC": "%C",
                    "%Ex": "%m/%d/%y",
                    "%EX": "%H:%M:%S",
                    "%Ey": "%y",
                    "%EY": "%Y",
                    "%Od": "%d",
                    "%Oe": "%e",
                    "%OH": "%H",
                    "%OI": "%I",
                    "%Om": "%m",
                    "%OM": "%M",
                    "%OS": "%S",
                    "%Ou": "%u",
                    "%OU": "%U",
                    "%OV": "%V",
                    "%Ow": "%w",
                    "%OW": "%W",
                    "%Oy": "%y",
                  })))
                    d = d.replace(new RegExp(N5, "g"), w1[N5]);
                  var Q6 =
                      "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
                        " "
                      ),
                    I8 =
                      "January February March April May June July August September October November December".split(
                        " "
                      );
                  for (N5 in ((w1 = {
                    "%a": function (K0) {
                      return Q6[K0.Tb].substring(0, 3);
                    },
                    "%A": function (K0) {
                      return Q6[K0.Tb];
                    },
                    "%b": function (K0) {
                      return I8[K0.ec].substring(0, 3);
                    },
                    "%B": function (K0) {
                      return I8[K0.ec];
                    },
                    "%C": function (K0) {
                      return U0(((K0.Xb + 1900) / 100) | 0, 2);
                    },
                    "%d": function (K0) {
                      return U0(K0.jc, 2);
                    },
                    "%e": function (K0) {
                      return G0(K0.jc, 2, " ");
                    },
                    "%g": function (K0) {
                      return E1(K0).toString().substring(2);
                    },
                    "%G": function (K0) {
                      return E1(K0);
                    },
                    "%H": function (K0) {
                      return U0(K0.dc, 2);
                    },
                    "%I": function (K0) {
                      return (
                        (K0 = K0.dc) == 0 ? (K0 = 12) : 12 < K0 && (K0 -= 12),
                        U0(K0, 2)
                      );
                    },
                    "%j": function (K0) {
                      for (
                        var T1 = 0, L5 = 0;
                        L5 <= K0.ec - 1;
                        T1 += (FG(K0.Xb + 1900) ? QD : GD)[L5++]
                      );
                      return U0(K0.jc + T1, 3);
                    },
                    "%m": function (K0) {
                      return U0(K0.ec + 1, 2);
                    },
                    "%M": function (K0) {
                      return U0(K0.Kc, 2);
                    },
                    "%n": function () {
                      return `
`;
                    },
                    "%p": function (K0) {
                      return 0 <= K0.dc && 12 > K0.dc ? "AM" : "PM";
                    },
                    "%S": function (K0) {
                      return U0(K0.Lc, 2);
                    },
                    "%t": function () {
                      return "\t";
                    },
                    "%u": function (K0) {
                      return K0.Tb || 7;
                    },
                    "%U": function (K0) {
                      return U0(Math.floor((K0.Wb + 7 - K0.Tb) / 7), 2);
                    },
                    "%V": function (K0) {
                      var T1 = Math.floor((K0.Wb + 7 - ((K0.Tb + 6) % 7)) / 7);
                      if ((2 >= (K0.Tb + 371 - K0.Wb - 2) % 7 && T1++, T1))
                        T1 == 53 &&
                          ((L5 = (K0.Tb + 371 - K0.Wb) % 7) == 4 ||
                            (L5 == 3 && FG(K0.Xb)) ||
                            (T1 = 1));
                      else {
                        T1 = 52;
                        var L5 = (K0.Tb + 7 - K0.Wb - 1) % 7;
                        (L5 == 4 || (L5 == 5 && FG((K0.Xb % 400) - 1))) && T1++;
                      }
                      return U0(T1, 2);
                    },
                    "%w": function (K0) {
                      return K0.Tb;
                    },
                    "%W": function (K0) {
                      return U0(
                        Math.floor((K0.Wb + 7 - ((K0.Tb + 6) % 7)) / 7),
                        2
                      );
                    },
                    "%y": function (K0) {
                      return (K0.Xb + 1900).toString().substring(2);
                    },
                    "%Y": function (K0) {
                      return K0.Xb + 1900;
                    },
                    "%z": function (K0) {
                      var T1 = 0 <= (K0 = K0.Jc);
                      return (
                        (K0 = Math.abs(K0) / 60),
                        (T1 ? "+" : "-") +
                          String("0000" + ((K0 / 60) * 100 + (K0 % 60))).slice(
                            -4
                          )
                      );
                    },
                    "%Z": function (K0) {
                      return K0.Mc;
                    },
                    "%%": function () {
                      return "%";
                    },
                  }),
                  (d = d.replace(/%%/g, "\x00\x00")),
                  w1))
                    d.includes(N5) &&
                      (d = d.replace(new RegExp(N5, "g"), w1[N5](t)));
                  return (
                    (N5 = (function (K0) {
                      var T1 = Array(b(K0) + 1);
                      return (Y1(K0, T1, 0, T1.length), T1);
                    })((d = d.replace(/\0\0/g, "%")))),
                    N5.length > g
                      ? 0
                      : ((function (K0, T1) {
                          $().set(K0, T1 >>> 0);
                        })(N5, S),
                        N5.length - 1)
                  );
                }
                Q1.fc();
                var Ik = [
                    null,
                    m5,
                    VG,
                    E9,
                    WY,
                    HY,
                    $Y,
                    UY,
                    LY,
                    BY,
                    KY,
                    VY,
                    FY,
                    NY,
                    MY,
                    u,
                    a,
                    W0,
                    V0,
                    m0,
                    B0,
                    S1,
                    t1,
                    C8,
                    s6,
                    YD,
                  ],
                  Pk = {
                    b: function (S) {
                      return m$(S + 24) + 24;
                    },
                    n: function (S) {
                      return (
                        (S = new J1(S)).uc() || (S.hc(!0), H1--),
                        S.ic(!1),
                        z9.push(S),
                        S.sc(),
                        S.vc()
                      );
                    },
                    ma: function (S) {
                      throw (
                        p(
                          "Unexpected exception thrown, this is not properly supported - aborting"
                        ),
                        (J0 = !0),
                        S
                      );
                    },
                    x: function () {
                      z1(0);
                      var S = z9.pop();
                      if (S.Hc() && !S.kc()) {
                        var g = S.Dc();
                        (g && u1(g)(S.Zb), GY(S.Zb));
                      }
                      G1 = 0;
                    },
                    e: function () {
                      var S = G1;
                      if (!S) return ($8 = 0);
                      var g = new J1(S);
                      g.cc(S);
                      var d = g.bc();
                      if (!d) return (($8 = 0), S);
                      for (
                        var t = Array.prototype.slice.call(arguments), G0 = 0;
                        G0 < t.length;
                        G0++
                      ) {
                        var U0 = t[G0];
                        if (U0 === 0 || U0 === d) break;
                        if (AG(U0, d, g.Sb + 16)) return (($8 = U0), S);
                      }
                      return (($8 = d), S);
                    },
                    l: function () {
                      var S = G1;
                      if (!S) return ($8 = 0);
                      var g = new J1(S);
                      g.cc(S);
                      var d = g.bc();
                      if (!d) return (($8 = 0), S);
                      for (
                        var t = Array.prototype.slice.call(arguments), G0 = 0;
                        G0 < t.length;
                        G0++
                      ) {
                        var U0 = t[G0];
                        if (U0 === 0 || U0 === d) break;
                        if (AG(U0, d, g.Sb + 16)) return (($8 = U0), S);
                      }
                      return (($8 = d), S);
                    },
                    h: function () {
                      var S = G1;
                      if (!S) return ($8 = 0);
                      var g = new J1(S);
                      g.cc(S);
                      var d = g.bc();
                      if (!d) return (($8 = 0), S);
                      for (
                        var t = Array.prototype.slice.call(arguments), G0 = 0;
                        G0 < t.length;
                        G0++
                      ) {
                        var U0 = t[G0];
                        if (U0 === 0 || U0 === d) break;
                        if (AG(U0, d, g.Sb + 16)) return (($8 = U0), S);
                      }
                      return (($8 = d), S);
                    },
                    t: GY,
                    M: function () {
                      var S = z9.pop();
                      S || r0("no exception to throw");
                      var g = S.Zb;
                      throw (
                        S.kc() || (z9.push(S), S.ic(!0), S.hc(!1), H1++),
                        (G1 = g),
                        g
                      );
                    },
                    c: function (S, g, d) {
                      throw (new J1(S).fc(g, d), (G1 = S), H1++, S);
                    },
                    pa: function () {
                      return H1;
                    },
                    Fa: function (S) {
                      (UD(S, !j, 1, !Z), Q1.pc());
                    },
                    T: function (S) {
                      I
                        ? postMessage({ cmd: "cleanupThread", thread: S })
                        : PX(S);
                    },
                    xa: JY,
                    j: function (S) {
                      throw (G1 || (G1 = S), S);
                    },
                    H: WY,
                    Ma: HY,
                    ua: $Y,
                    wa: UY,
                    oa: LY,
                    Ka: BY,
                    Ca: KY,
                    Ja: VY,
                    V: FY,
                    va: NY,
                    sa: MY,
                    La: u,
                    ta: a,
                    Ta: function () {},
                    X: function () {
                      r0(
                        "To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking"
                      );
                    },
                    Ua: function () {
                      r0(
                        "To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking"
                      );
                    },
                    W: function () {
                      return Date.now();
                    },
                    ya: function () {
                      return 2097152;
                    },
                    Oa: function () {
                      return !0;
                    },
                    za: function (S, g, d, t) {
                      if (S == g) setTimeout(() => Y0(t));
                      else if (I)
                        postMessage({
                          targetThread: S,
                          cmd: "processProxyingQueue",
                          queue: t,
                        });
                      else {
                        if (!(S = Q1.Vb[S])) return;
                        S.postMessage({
                          cmd: "processProxyingQueue",
                          queue: t,
                        });
                      }
                      return 1;
                    },
                    Ea: function () {
                      return -1;
                    },
                    Pa: function (S, g) {
                      ((S = new Date(1000 * Q0(S))),
                        (K()[(g >> 2) >>> 0] = S.getUTCSeconds()),
                        (K()[((g + 4) >> 2) >>> 0] = S.getUTCMinutes()),
                        (K()[((g + 8) >> 2) >>> 0] = S.getUTCHours()),
                        (K()[((g + 12) >> 2) >>> 0] = S.getUTCDate()),
                        (K()[((g + 16) >> 2) >>> 0] = S.getUTCMonth()),
                        (K()[((g + 20) >> 2) >>> 0] =
                          S.getUTCFullYear() - 1900),
                        (K()[((g + 24) >> 2) >>> 0] = S.getUTCDay()),
                        (S =
                          ((S.getTime() -
                            Date.UTC(S.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) /
                            86400000) |
                          0),
                        (K()[((g + 28) >> 2) >>> 0] = S));
                    },
                    Qa: function (S, g) {
                      ((S = new Date(1000 * Q0(S))),
                        (K()[(g >> 2) >>> 0] = S.getSeconds()),
                        (K()[((g + 4) >> 2) >>> 0] = S.getMinutes()),
                        (K()[((g + 8) >> 2) >>> 0] = S.getHours()),
                        (K()[((g + 12) >> 2) >>> 0] = S.getDate()),
                        (K()[((g + 16) >> 2) >>> 0] = S.getMonth()),
                        (K()[((g + 20) >> 2) >>> 0] = S.getFullYear() - 1900),
                        (K()[((g + 24) >> 2) >>> 0] = S.getDay()));
                      var d = new Date(S.getFullYear(), 0, 1),
                        t = ((S.getTime() - d.getTime()) / 86400000) | 0;
                      ((K()[((g + 28) >> 2) >>> 0] = t),
                        (K()[((g + 36) >> 2) >>> 0] =
                          -60 * S.getTimezoneOffset()),
                        (t = new Date(
                          S.getFullYear(),
                          6,
                          1
                        ).getTimezoneOffset()),
                        (S =
                          0 |
                          (t != (d = d.getTimezoneOffset()) &&
                            S.getTimezoneOffset() == Math.min(d, t))),
                        (K()[((g + 32) >> 2) >>> 0] = S));
                    },
                    Ra: function (S) {
                      var g = new Date(
                          K()[((S + 20) >> 2) >>> 0] + 1900,
                          K()[((S + 16) >> 2) >>> 0],
                          K()[((S + 12) >> 2) >>> 0],
                          K()[((S + 8) >> 2) >>> 0],
                          K()[((S + 4) >> 2) >>> 0],
                          K()[(S >> 2) >>> 0],
                          0
                        ),
                        d = K()[((S + 32) >> 2) >>> 0],
                        t = g.getTimezoneOffset(),
                        G0 = new Date(g.getFullYear(), 0, 1),
                        U0 = new Date(
                          g.getFullYear(),
                          6,
                          1
                        ).getTimezoneOffset(),
                        S0 = G0.getTimezoneOffset(),
                        c0 = Math.min(S0, U0);
                      return (
                        0 > d
                          ? (K()[((S + 32) >> 2) >>> 0] = Number(
                              U0 != S0 && c0 == t
                            ))
                          : 0 < d != (c0 == t) &&
                            ((U0 = Math.max(S0, U0)),
                            g.setTime(
                              g.getTime() + 60000 * ((0 < d ? c0 : U0) - t)
                            )),
                        (K()[((S + 24) >> 2) >>> 0] = g.getDay()),
                        (d = ((g.getTime() - G0.getTime()) / 86400000) | 0),
                        (K()[((S + 28) >> 2) >>> 0] = d),
                        (K()[(S >> 2) >>> 0] = g.getSeconds()),
                        (K()[((S + 4) >> 2) >>> 0] = g.getMinutes()),
                        (K()[((S + 8) >> 2) >>> 0] = g.getHours()),
                        (K()[((S + 12) >> 2) >>> 0] = g.getDate()),
                        (K()[((S + 16) >> 2) >>> 0] = g.getMonth()),
                        (g.getTime() / 1000) | 0
                      );
                    },
                    Aa: W0,
                    Ba: V0,
                    Sa: function S(g, d, t) {
                      S.Ac || ((S.Ac = !0), m0(g, d, t));
                    },
                    y: function () {
                      r0("");
                    },
                    U: function () {
                      if (!w && !j) {
                        var S =
                          "Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";
                        (D9 || (D9 = {}),
                          D9[S] ||
                            ((D9[S] = 1), w && (S = "warning: " + S), p(S)));
                      }
                    },
                    ra: function () {
                      return 4294901760;
                    },
                    B: QY,
                    Ia: function (S, g, d) {
                      B().copyWithin(S >>> 0, g >>> 0, (g + d) >>> 0);
                    },
                    F: function () {
                      return w
                        ? Q(9719).cpus().length
                        : navigator.hardwareConcurrency;
                    },
                    Da: function (S, g, d) {
                      ((d1.length = g), (d >>= 3));
                      for (var t = 0; t < g; t++) d1[t] = W()[(d + t) >>> 0];
                      return (0 > S ? Y6[-S - 1] : Ik[S]).apply(null, d1);
                    },
                    qa: function (S) {
                      var g = B().length;
                      if ((S >>>= 0) <= g || 4294901760 < S) return !1;
                      for (var d = 1; 4 >= d; d *= 2) {
                        var t = g * (1 + 0.2 / d);
                        t = Math.min(t, S + 100663296);
                        var G0 = Math;
                        ((t = Math.max(S, t)),
                          (G0 = G0.min.call(
                            G0,
                            4294901760,
                            t + ((65536 - (t % 65536)) % 65536)
                          )));
                        X: {
                          try {
                            (e.grow((G0 - x.byteLength + 65535) >>> 16),
                              m(e.buffer));
                            var U0 = 1;
                            break X;
                          } catch (S0) {}
                          U0 = void 0;
                        }
                        if (U0) return !0;
                      }
                      return !1;
                    },
                    Na: function () {
                      throw "unwind";
                    },
                    Ga: B0,
                    Ha: S1,
                    J: R9,
                    I: t1,
                    S: C8,
                    ga: s6,
                    R: YD,
                    d: function () {
                      return $8;
                    },
                    na: function S(g, d) {
                      S.lc ||
                        (S.lc = (function () {
                          if (
                            typeof crypto == "object" &&
                            typeof crypto.getRandomValues == "function"
                          ) {
                            var G0 = new Uint8Array(1);
                            return () => (crypto.getRandomValues(G0), G0[0]);
                          }
                          if (w)
                            try {
                              var U0 = Q(6113);
                              return () => U0.randomBytes(1)[0];
                            } catch (S0) {}
                          return () => r0("randomDevice");
                        })());
                      for (var t = 0; t < d; t++)
                        $()[((g + t) >> 0) >>> 0] = S.lc();
                      return 0;
                    },
                    ia: function (S, g, d) {
                      var t = A1();
                      try {
                        return u1(S)(g, d);
                      } catch (G0) {
                        if ((F1(t), G0 !== G0 + 0)) throw G0;
                        z1(1, 0);
                      }
                    },
                    ja: function (S, g, d) {
                      var t = A1();
                      try {
                        return u1(S)(g, d);
                      } catch (G0) {
                        if ((F1(t), G0 !== G0 + 0)) throw G0;
                        z1(1, 0);
                      }
                    },
                    K: function (S) {
                      var g = A1();
                      try {
                        return u1(S)();
                      } catch (d) {
                        if ((F1(g), d !== d + 0)) throw d;
                        z1(1, 0);
                      }
                    },
                    f: function (S, g) {
                      var d = A1();
                      try {
                        return u1(S)(g);
                      } catch (t) {
                        if ((F1(d), t !== t + 0)) throw t;
                        z1(1, 0);
                      }
                    },
                    P: function (S, g, d) {
                      var t = A1();
                      try {
                        return u1(S)(g, d);
                      } catch (G0) {
                        if ((F1(t), G0 !== G0 + 0)) throw G0;
                        z1(1, 0);
                      }
                    },
                    Q: function (S, g, d) {
                      var t = A1();
                      try {
                        return u1(S)(g, d);
                      } catch (G0) {
                        if ((F1(t), G0 !== G0 + 0)) throw G0;
                        z1(1, 0);
                      }
                    },
                    k: function (S, g, d) {
                      var t = A1();
                      try {
                        return u1(S)(g, d);
                      } catch (G0) {
                        if ((F1(t), G0 !== G0 + 0)) throw G0;
                        z1(1, 0);
                      }
                    },
                    p: function (S, g, d, t) {
                      var G0 = A1();
                      try {
                        return u1(S)(g, d, t);
                      } catch (U0) {
                        if ((F1(G0), U0 !== U0 + 0)) throw U0;
                        z1(1, 0);
                      }
                    },
                    q: function (S, g, d, t, G0) {
                      var U0 = A1();
                      try {
                        return u1(S)(g, d, t, G0);
                      } catch (S0) {
                        if ((F1(U0), S0 !== S0 + 0)) throw S0;
                        z1(1, 0);
                      }
                    },
                    N: function (S, g, d, t, G0, U0) {
                      var S0 = A1();
                      try {
                        return u1(S)(g, d, t, G0, U0);
                      } catch (c0) {
                        if ((F1(S0), c0 !== c0 + 0)) throw c0;
                        z1(1, 0);
                      }
                    },
                    s: function (S, g, d, t, G0, U0) {
                      var S0 = A1();
                      try {
                        return u1(S)(g, d, t, G0, U0);
                      } catch (c0) {
                        if ((F1(S0), c0 !== c0 + 0)) throw c0;
                        z1(1, 0);
                      }
                    },
                    w: function (S, g, d, t, G0, U0, S0) {
                      var c0 = A1();
                      try {
                        return u1(S)(g, d, t, G0, U0, S0);
                      } catch (E1) {
                        if ((F1(c0), E1 !== E1 + 0)) throw E1;
                        z1(1, 0);
                      }
                    },
                    L: function (S, g, d, t, G0, U0, S0, c0) {
                      var E1 = A1();
                      try {
                        return u1(S)(g, d, t, G0, U0, S0, c0);
                      } catch (w1) {
                        if ((F1(E1), w1 !== w1 + 0)) throw w1;
                        z1(1, 0);
                      }
                    },
                    E: function (S, g, d, t, G0, U0, S0, c0, E1, w1, N5, Q6) {
                      var I8 = A1();
                      try {
                        return u1(S)(g, d, t, G0, U0, S0, c0, E1, w1, N5, Q6);
                      } catch (K0) {
                        if ((F1(I8), K0 !== K0 + 0)) throw K0;
                        z1(1, 0);
                      }
                    },
                    aa: function (S, g, d, t, G0, U0, S0, c0) {
                      var E1 = A1();
                      try {
                        return OD(S, g, d, t, G0, U0, S0, c0);
                      } catch (w1) {
                        if ((F1(E1), w1 !== w1 + 0)) throw w1;
                        z1(1, 0);
                      }
                    },
                    _: function (S, g, d, t, G0, U0, S0) {
                      var c0 = A1();
                      try {
                        return MD(S, g, d, t, G0, U0, S0);
                      } catch (E1) {
                        if ((F1(c0), E1 !== E1 + 0)) throw E1;
                        z1(1, 0);
                      }
                    },
                    Z: function (S, g, d, t, G0) {
                      var U0 = A1();
                      try {
                        return ZD(S, g, d, t, G0);
                      } catch (S0) {
                        if ((F1(U0), S0 !== S0 + 0)) throw S0;
                        z1(1, 0);
                      }
                    },
                    ca: function (S, g, d, t) {
                      var G0 = A1();
                      try {
                        return zD(S, g, d, t);
                      } catch (U0) {
                        if ((F1(G0), U0 !== U0 + 0)) throw U0;
                        z1(1, 0);
                      }
                    },
                    $: function (S) {
                      var g = A1();
                      try {
                        return ND(S);
                      } catch (d) {
                        if ((F1(g), d !== d + 0)) throw d;
                        z1(1, 0);
                      }
                    },
                    ba: function (S, g) {
                      var d = A1();
                      try {
                        return ED(S, g);
                      } catch (t) {
                        if ((F1(d), t !== t + 0)) throw t;
                        z1(1, 0);
                      }
                    },
                    Y: function (S, g, d) {
                      var t = A1();
                      try {
                        return AD(S, g, d);
                      } catch (G0) {
                        if ((F1(t), G0 !== G0 + 0)) throw G0;
                        z1(1, 0);
                      }
                    },
                    g: function (S) {
                      var g = A1();
                      try {
                        u1(S)();
                      } catch (d) {
                        if ((F1(g), d !== d + 0)) throw d;
                        z1(1, 0);
                      }
                    },
                    r: function (S, g) {
                      var d = A1();
                      try {
                        u1(S)(g);
                      } catch (t) {
                        if ((F1(d), t !== t + 0)) throw t;
                        z1(1, 0);
                      }
                    },
                    i: function (S, g, d) {
                      var t = A1();
                      try {
                        u1(S)(g, d);
                      } catch (G0) {
                        if ((F1(t), G0 !== G0 + 0)) throw G0;
                        z1(1, 0);
                      }
                    },
                    ha: function (S, g, d, t) {
                      var G0 = A1();
                      try {
                        u1(S)(g, d, t);
                      } catch (U0) {
                        if ((F1(G0), U0 !== U0 + 0)) throw U0;
                        z1(1, 0);
                      }
                    },
                    m: function (S, g, d, t) {
                      var G0 = A1();
                      try {
                        u1(S)(g, d, t);
                      } catch (U0) {
                        if ((F1(G0), U0 !== U0 + 0)) throw U0;
                        z1(1, 0);
                      }
                    },
                    v: function (S, g, d, t, G0) {
                      var U0 = A1();
                      try {
                        u1(S)(g, d, t, G0);
                      } catch (S0) {
                        if ((F1(U0), S0 !== S0 + 0)) throw S0;
                        z1(1, 0);
                      }
                    },
                    u: function (S, g, d, t, G0, U0) {
                      var S0 = A1();
                      try {
                        u1(S)(g, d, t, G0, U0);
                      } catch (c0) {
                        if ((F1(S0), c0 !== c0 + 0)) throw c0;
                        z1(1, 0);
                      }
                    },
                    O: function (S, g, d, t, G0, U0, S0) {
                      var c0 = A1();
                      try {
                        u1(S)(g, d, t, G0, U0, S0);
                      } catch (E1) {
                        if ((F1(c0), E1 !== E1 + 0)) throw E1;
                        z1(1, 0);
                      }
                    },
                    A: function (S, g, d, t, G0, U0, S0, c0) {
                      var E1 = A1();
                      try {
                        u1(S)(g, d, t, G0, U0, S0, c0);
                      } catch (w1) {
                        if ((F1(E1), w1 !== w1 + 0)) throw w1;
                        z1(1, 0);
                      }
                    },
                    ka: function (S, g, d, t, G0, U0, S0, c0, E1) {
                      var w1 = A1();
                      try {
                        u1(S)(g, d, t, G0, U0, S0, c0, E1);
                      } catch (N5) {
                        if ((F1(w1), N5 !== N5 + 0)) throw N5;
                        z1(1, 0);
                      }
                    },
                    C: function (S, g, d, t, G0, U0, S0, c0, E1, w1, N5) {
                      var Q6 = A1();
                      try {
                        u1(S)(g, d, t, G0, U0, S0, c0, E1, w1, N5);
                      } catch (I8) {
                        if ((F1(Q6), I8 !== I8 + 0)) throw I8;
                        z1(1, 0);
                      }
                    },
                    D: function (
                      S,
                      g,
                      d,
                      t,
                      G0,
                      U0,
                      S0,
                      c0,
                      E1,
                      w1,
                      N5,
                      Q6,
                      I8,
                      K0,
                      T1,
                      L5
                    ) {
                      var t6 = A1();
                      try {
                        u1(S)(
                          g,
                          d,
                          t,
                          G0,
                          U0,
                          S0,
                          c0,
                          E1,
                          w1,
                          N5,
                          Q6,
                          I8,
                          K0,
                          T1,
                          L5
                        );
                      } catch (TX) {
                        if ((F1(t6), TX !== TX + 0)) throw TX;
                        z1(1, 0);
                      }
                    },
                    fa: function (S, g, d, t, G0, U0, S0, c0) {
                      var E1 = A1();
                      try {
                        qD(S, g, d, t, G0, U0, S0, c0);
                      } catch (w1) {
                        if ((F1(E1), w1 !== w1 + 0)) throw w1;
                        z1(1, 0);
                      }
                    },
                    da: function (S, g, d, t, G0, U0, S0, c0, E1, w1, N5, Q6) {
                      var I8 = A1();
                      try {
                        DD(S, g, d, t, G0, U0, S0, c0, E1, w1, N5, Q6);
                      } catch (K0) {
                        if ((F1(I8), K0 !== K0 + 0)) throw K0;
                        z1(1, 0);
                      }
                    },
                    ea: function (S, g, d, t, G0, U0) {
                      var S0 = A1();
                      try {
                        RD(S, g, d, t, G0, U0);
                      } catch (c0) {
                        if ((F1(S0), c0 !== c0 + 0)) throw c0;
                        z1(1, 0);
                      }
                    },
                    o: function (S) {
                      return S;
                    },
                    a: e || L.wasmMemory,
                    G: function (S) {
                      $8 = S;
                    },
                    la: JD,
                    z: function (S, g, d, t) {
                      return JD(S, g, d, t);
                    },
                  };
                ((function () {
                  function S(G0, U0) {
                    ((L.asm = G0.exports),
                      Q1.qc.push(L.asm.sb),
                      (M0 = L.asm.ub),
                      Z0.unshift(L.asm.Va),
                      (P = U0),
                      I ||
                        (h1--,
                        L.monitorRunDependencies &&
                          L.monitorRunDependencies(h1),
                        h1 == 0 &&
                          (g1 !== null && (clearInterval(g1), (g1 = null)),
                          b5 && ((G0 = b5), (b5 = null), G0()))));
                  }
                  function g(G0) {
                    S(G0.instance, G0.module);
                  }
                  function d(G0) {
                    return (function () {
                      if (!l && (Z || j)) {
                        if (
                          typeof fetch == "function" &&
                          !x0.startsWith("file://")
                        )
                          return fetch(x0, { credentials: "same-origin" })
                            .then(function (U0) {
                              if (!U0.ok)
                                throw (
                                  "failed to load wasm binary file at '" +
                                  x0 +
                                  "'"
                                );
                              return U0.arrayBuffer();
                            })
                            .catch(function () {
                              return w8();
                            });
                        if (q)
                          return new Promise(function (U0, S0) {
                            q(
                              x0,
                              function (c0) {
                                U0(new Uint8Array(c0));
                              },
                              S0
                            );
                          });
                      }
                      return Promise.resolve().then(function () {
                        return w8();
                      });
                    })()
                      .then(function (U0) {
                        return WebAssembly.instantiate(U0, t);
                      })
                      .then(function (U0) {
                        return U0;
                      })
                      .then(G0, function (U0) {
                        (p("failed to asynchronously prepare wasm: " + U0),
                          r0(U0));
                      });
                  }
                  var t = { a: Pk };
                  if (
                    (I ||
                      (h1++,
                      L.monitorRunDependencies && L.monitorRunDependencies(h1)),
                    L.instantiateWasm)
                  )
                    try {
                      return L.instantiateWasm(t, S);
                    } catch (G0) {
                      return (
                        p(
                          "Module.instantiateWasm callback failed with error: " +
                            G0
                        ),
                        !1
                      );
                    }
                  (l ||
                  typeof WebAssembly.instantiateStreaming != "function" ||
                  q8() ||
                  x0.startsWith("file://") ||
                  w ||
                  typeof fetch != "function"
                    ? d(g)
                    : fetch(x0, { credentials: "same-origin" }).then(
                        function (G0) {
                          return WebAssembly.instantiateStreaming(G0, t).then(
                            g,
                            function (U0) {
                              return (
                                p("wasm streaming compile failed: " + U0),
                                p("falling back to ArrayBuffer instantiation"),
                                d(g)
                              );
                            }
                          );
                        }
                      )
                  ).catch(F);
                })(),
                  (L.___wasm_call_ctors = function () {
                    return (L.___wasm_call_ctors = L.asm.Va).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtInit = function () {
                    return (L._OrtInit = L.asm.Wa).apply(null, arguments);
                  }),
                  (L._OrtCreateSessionOptions = function () {
                    return (L._OrtCreateSessionOptions = L.asm.Xa).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtAppendExecutionProvider = function () {
                    return (L._OrtAppendExecutionProvider = L.asm.Ya).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtAddSessionConfigEntry = function () {
                    return (L._OrtAddSessionConfigEntry = L.asm.Za).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtReleaseSessionOptions = function () {
                    return (L._OrtReleaseSessionOptions = L.asm._a).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtCreateSession = function () {
                    return (L._OrtCreateSession = L.asm.$a).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtReleaseSession = function () {
                    return (L._OrtReleaseSession = L.asm.ab).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtGetInputCount = function () {
                    return (L._OrtGetInputCount = L.asm.bb).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtGetOutputCount = function () {
                    return (L._OrtGetOutputCount = L.asm.cb).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtGetInputName = function () {
                    return (L._OrtGetInputName = L.asm.db).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtGetOutputName = function () {
                    return (L._OrtGetOutputName = L.asm.eb).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtFree = function () {
                    return (L._OrtFree = L.asm.fb).apply(null, arguments);
                  }),
                  (L._OrtCreateTensor = function () {
                    return (L._OrtCreateTensor = L.asm.gb).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtGetTensorData = function () {
                    return (L._OrtGetTensorData = L.asm.hb).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtReleaseTensor = function () {
                    return (L._OrtReleaseTensor = L.asm.ib).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtCreateRunOptions = function () {
                    return (L._OrtCreateRunOptions = L.asm.jb).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtAddRunConfigEntry = function () {
                    return (L._OrtAddRunConfigEntry = L.asm.kb).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtReleaseRunOptions = function () {
                    return (L._OrtReleaseRunOptions = L.asm.lb).apply(
                      null,
                      arguments
                    );
                  }),
                  (L._OrtRun = function () {
                    return (L._OrtRun = L.asm.mb).apply(null, arguments);
                  }),
                  (L._OrtEndProfiling = function () {
                    return (L._OrtEndProfiling = L.asm.nb).apply(
                      null,
                      arguments
                    );
                  }));
                var NG = (L._pthread_self = function () {
                    return (NG = L._pthread_self = L.asm.ob).apply(
                      null,
                      arguments
                    );
                  }),
                  m$ = (L._malloc = function () {
                    return (m$ = L._malloc = L.asm.pb).apply(null, arguments);
                  }),
                  WD = (L._free = function () {
                    return (WD = L._free = L.asm.qb).apply(null, arguments);
                  }),
                  HD = (L._fflush = function () {
                    return (HD = L._fflush = L.asm.rb).apply(null, arguments);
                  });
                L.__emscripten_tls_init = function () {
                  return (L.__emscripten_tls_init = L.asm.sb).apply(
                    null,
                    arguments
                  );
                };
                var $D = (L.___funcs_on_exit = function () {
                    return ($D = L.___funcs_on_exit = L.asm.tb).apply(
                      null,
                      arguments
                    );
                  }),
                  UD = (L.__emscripten_thread_init = function () {
                    return (UD = L.__emscripten_thread_init = L.asm.vb).apply(
                      null,
                      arguments
                    );
                  });
                L.__emscripten_thread_crashed = function () {
                  return (L.__emscripten_thread_crashed = L.asm.wb).apply(
                    null,
                    arguments
                  );
                };
                var MG,
                  LD = (L._emscripten_run_in_main_runtime_thread_js =
                    function () {
                      return (LD = L._emscripten_run_in_main_runtime_thread_js =
                        L.asm.xb).apply(null, arguments);
                    }),
                  BD = (L.__emscripten_proxy_execute_task_queue = function () {
                    return (BD = L.__emscripten_proxy_execute_task_queue =
                      L.asm.yb).apply(null, arguments);
                  }),
                  c$ = (L.__emscripten_thread_free_data = function () {
                    return (c$ = L.__emscripten_thread_free_data =
                      L.asm.zb).apply(null, arguments);
                  }),
                  KD = (L.__emscripten_thread_exit = function () {
                    return (KD = L.__emscripten_thread_exit = L.asm.Ab).apply(
                      null,
                      arguments
                    );
                  }),
                  z1 = (L._setThrew = function () {
                    return (z1 = L._setThrew = L.asm.Bb).apply(null, arguments);
                  }),
                  VD = (L._emscripten_stack_set_limits = function () {
                    return (VD = L._emscripten_stack_set_limits =
                      L.asm.Cb).apply(null, arguments);
                  }),
                  A1 = (L.stackSave = function () {
                    return (A1 = L.stackSave = L.asm.Db).apply(null, arguments);
                  }),
                  F1 = (L.stackRestore = function () {
                    return (F1 = L.stackRestore = L.asm.Eb).apply(
                      null,
                      arguments
                    );
                  }),
                  d$ = (L.stackAlloc = function () {
                    return (d$ = L.stackAlloc = L.asm.Fb).apply(
                      null,
                      arguments
                    );
                  }),
                  AG = (L.___cxa_can_catch = function () {
                    return (AG = L.___cxa_can_catch = L.asm.Gb).apply(
                      null,
                      arguments
                    );
                  }),
                  FD = (L.___cxa_is_pointer_type = function () {
                    return (FD = L.___cxa_is_pointer_type = L.asm.Hb).apply(
                      null,
                      arguments
                    );
                  }),
                  ND = (L.dynCall_j = function () {
                    return (ND = L.dynCall_j = L.asm.Ib).apply(null, arguments);
                  }),
                  MD = (L.dynCall_iiiiij = function () {
                    return (MD = L.dynCall_iiiiij = L.asm.Jb).apply(
                      null,
                      arguments
                    );
                  }),
                  AD = (L.dynCall_jii = function () {
                    return (AD = L.dynCall_jii = L.asm.Kb).apply(
                      null,
                      arguments
                    );
                  }),
                  qD = (L.dynCall_viiiiij = function () {
                    return (qD = L.dynCall_viiiiij = L.asm.Lb).apply(
                      null,
                      arguments
                    );
                  }),
                  RD = (L.dynCall_vjji = function () {
                    return (RD = L.dynCall_vjji = L.asm.Mb).apply(
                      null,
                      arguments
                    );
                  }),
                  DD = (L.dynCall_viiijjjii = function () {
                    return (DD = L.dynCall_viiijjjii = L.asm.Nb).apply(
                      null,
                      arguments
                    );
                  }),
                  zD = (L.dynCall_iij = function () {
                    return (zD = L.dynCall_iij = L.asm.Ob).apply(
                      null,
                      arguments
                    );
                  }),
                  ED = (L.dynCall_ji = function () {
                    return (ED = L.dynCall_ji = L.asm.Pb).apply(
                      null,
                      arguments
                    );
                  }),
                  OD = (L.dynCall_iiiiiij = function () {
                    return (OD = L.dynCall_iiiiiij = L.asm.Qb).apply(
                      null,
                      arguments
                    );
                  }),
                  ZD = (L.dynCall_iiij = function () {
                    return (ZD = L.dynCall_iiij = L.asm.Rb).apply(
                      null,
                      arguments
                    );
                  });
                function jD() {
                  function S() {
                    if (
                      !MG &&
                      ((MG = !0), (L.calledRun = !0), !J0) &&
                      (I || I4(Z0),
                      H(L),
                      L.onRuntimeInitialized && L.onRuntimeInitialized(),
                      !I)
                    ) {
                      if (L.postRun)
                        for (
                          typeof L.postRun == "function" &&
                          (L.postRun = [L.postRun]);
                          L.postRun.length;
                        ) {
                          var g = L.postRun.shift();
                          j1.unshift(g);
                        }
                      I4(j1);
                    }
                  }
                  if (!(0 < h1))
                    if (I) (H(L), I || I4(Z0), postMessage({ cmd: "loaded" }));
                    else {
                      if (L.preRun)
                        for (
                          typeof L.preRun == "function" &&
                          (L.preRun = [L.preRun]);
                          L.preRun.length;
                        )
                          M1();
                      (I4(D0),
                        0 < h1 ||
                          (L.setStatus
                            ? (L.setStatus("Running..."),
                              setTimeout(function () {
                                (setTimeout(function () {
                                  L.setStatus("");
                                }, 1),
                                  S());
                              }, 1))
                            : S()));
                    }
                }
                if (
                  ((L.UTF8ToString = w0),
                  (L.stringToUTF8 = function (S, g, d) {
                    return Y1(S, B(), g, d);
                  }),
                  (L.lengthBytesUTF8 = b),
                  (L.keepRuntimeAlive = v1),
                  (L.wasmMemory = e),
                  (L.stackSave = A1),
                  (L.stackRestore = F1),
                  (L.stackAlloc = d$),
                  (L.ExitStatus = R8),
                  (L.PThread = Q1),
                  (b5 = function S() {
                    (MG || jD(), MG || (b5 = S));
                  }),
                  L.preInit)
                )
                  for (
                    typeof L.preInit == "function" && (L.preInit = [L.preInit]);
                    0 < L.preInit.length;
                  )
                    L.preInit.pop()();
                return (jD(), U.ready);
              });
          X.exports = J;
        },
        932: (X, Y, Q) => {
          var G,
            J =
              ((G =
                (G =
                  typeof document < "u" && document.currentScript
                    ? document.currentScript.src
                    : void 0) || __filename),
              function (U) {
                var $, B, K;
                ((U = U || {}),
                  $ || ($ = U !== void 0 ? U : {}),
                  ($.ready = new Promise(function (u, a) {
                    ((B = u), (K = a));
                  })));
                var V,
                  W,
                  L,
                  H,
                  F,
                  N,
                  q = Object.assign({}, $),
                  M = "./this.program",
                  A = (u, a) => {
                    throw a;
                  },
                  D = typeof window == "object",
                  R = typeof importScripts == "function",
                  z =
                    typeof process == "object" &&
                    typeof process.versions == "object" &&
                    typeof process.versions.node == "string",
                  E = "";
                z
                  ? ((E = R ? Q(1423).dirname(E) + "/" : __dirname + "/"),
                    (N = () => {
                      F || ((H = Q(6231)), (F = Q(1423)));
                    }),
                    (V = function (u, a) {
                      return (
                        N(),
                        (u = F.normalize(u)),
                        H.readFileSync(u, a ? void 0 : "utf8")
                      );
                    }),
                    (L = (u) => (
                      (u = V(u, !0)).buffer || (u = new Uint8Array(u)),
                      u
                    )),
                    (W = (u, a, Y0) => {
                      (N(),
                        (u = F.normalize(u)),
                        H.readFile(u, function (Q0, W0) {
                          Q0 ? Y0(Q0) : a(W0.buffer);
                        }));
                    }),
                    1 < process.argv.length &&
                      (M = process.argv[1].replace(/\\/g, "/")),
                    process.argv.slice(2),
                    process.on("uncaughtException", function (u) {
                      if (!(u instanceof B1)) throw u;
                    }),
                    process.on("unhandledRejection", function (u) {
                      throw u;
                    }),
                    (A = (u, a) => {
                      if (w || 0 < z0) throw ((process.exitCode = u), a);
                      (a instanceof B1 || j("exiting due to exception: " + a),
                        process.exit(u));
                    }),
                    ($.inspect = function () {
                      return "[Emscripten Module object]";
                    }))
                  : (D || R) &&
                    (R
                      ? (E = self.location.href)
                      : typeof document < "u" &&
                        document.currentScript &&
                        (E = document.currentScript.src),
                    G && (E = G),
                    (E =
                      E.indexOf("blob:") !== 0
                        ? E.substr(
                            0,
                            E.replace(/[?#].*/, "").lastIndexOf("/") + 1
                          )
                        : ""),
                    (V = (u) => {
                      var a = new XMLHttpRequest();
                      return (
                        a.open("GET", u, !1),
                        a.send(null),
                        a.responseText
                      );
                    }),
                    R &&
                      (L = (u) => {
                        var a = new XMLHttpRequest();
                        return (
                          a.open("GET", u, !1),
                          (a.responseType = "arraybuffer"),
                          a.send(null),
                          new Uint8Array(a.response)
                        );
                      }),
                    (W = (u, a, Y0) => {
                      var Q0 = new XMLHttpRequest();
                      (Q0.open("GET", u, !0),
                        (Q0.responseType = "arraybuffer"),
                        (Q0.onload = () => {
                          Q0.status == 200 || (Q0.status == 0 && Q0.response)
                            ? a(Q0.response)
                            : Y0();
                        }),
                        (Q0.onerror = Y0),
                        Q0.send(null));
                    }));
                var O,
                  Z = $.print || console.log.bind(console),
                  j = $.printErr || console.warn.bind(console);
                (Object.assign($, q),
                  (q = null),
                  $.thisProgram && (M = $.thisProgram),
                  $.quit && (A = $.quit),
                  $.wasmBinary && (O = $.wasmBinary));
                var w = $.noExitRuntime || !1;
                typeof WebAssembly != "object" &&
                  n("no native wasm support detected");
                var I,
                  T,
                  y,
                  _,
                  f,
                  l,
                  h = !1,
                  p =
                    typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
                function N0(u, a, Y0) {
                  var Q0 = (a >>>= 0) + Y0;
                  for (Y0 = a; u[Y0] && !(Y0 >= Q0); ) ++Y0;
                  if (16 < Y0 - a && u.buffer && p)
                    return p.decode(u.subarray(a, Y0));
                  for (Q0 = ""; a < Y0; ) {
                    var W0 = u[a++];
                    if (128 & W0) {
                      var V0 = 63 & u[a++];
                      if ((224 & W0) == 192)
                        Q0 += String.fromCharCode(((31 & W0) << 6) | V0);
                      else {
                        var P0 = 63 & u[a++];
                        65536 >
                        (W0 =
                          (240 & W0) == 224
                            ? ((15 & W0) << 12) | (V0 << 6) | P0
                            : ((7 & W0) << 18) |
                              (V0 << 12) |
                              (P0 << 6) |
                              (63 & u[a++]))
                          ? (Q0 += String.fromCharCode(W0))
                          : ((W0 -= 65536),
                            (Q0 += String.fromCharCode(
                              55296 | (W0 >> 10),
                              56320 | (1023 & W0)
                            )));
                      }
                    } else Q0 += String.fromCharCode(W0);
                  }
                  return Q0;
                }
                function e(u, a) {
                  return (u >>>= 0) ? N0(_, u, a) : "";
                }
                function P(u, a, Y0, Q0) {
                  if (!(0 < Q0)) return 0;
                  var W0 = (Y0 >>>= 0);
                  Q0 = Y0 + Q0 - 1;
                  for (var V0 = 0; V0 < u.length; ++V0) {
                    var P0 = u.charCodeAt(V0);
                    if (
                      (55296 <= P0 &&
                        57343 >= P0 &&
                        (P0 =
                          (65536 + ((1023 & P0) << 10)) |
                          (1023 & u.charCodeAt(++V0))),
                      127 >= P0)
                    ) {
                      if (Y0 >= Q0) break;
                      a[Y0++ >>> 0] = P0;
                    } else {
                      if (2047 >= P0) {
                        if (Y0 + 1 >= Q0) break;
                        a[Y0++ >>> 0] = 192 | (P0 >> 6);
                      } else {
                        if (65535 >= P0) {
                          if (Y0 + 2 >= Q0) break;
                          a[Y0++ >>> 0] = 224 | (P0 >> 12);
                        } else {
                          if (Y0 + 3 >= Q0) break;
                          ((a[Y0++ >>> 0] = 240 | (P0 >> 18)),
                            (a[Y0++ >>> 0] = 128 | ((P0 >> 12) & 63)));
                        }
                        a[Y0++ >>> 0] = 128 | ((P0 >> 6) & 63);
                      }
                      a[Y0++ >>> 0] = 128 | (63 & P0);
                    }
                  }
                  return ((a[Y0 >>> 0] = 0), Y0 - W0);
                }
                function x(u) {
                  for (var a = 0, Y0 = 0; Y0 < u.length; ++Y0) {
                    var Q0 = u.charCodeAt(Y0);
                    127 >= Q0
                      ? a++
                      : 2047 >= Q0
                        ? (a += 2)
                        : 55296 <= Q0 && 57343 >= Q0
                          ? ((a += 4), ++Y0)
                          : (a += 3);
                  }
                  return a;
                }
                function r() {
                  var u = I.buffer;
                  ((T = u),
                    ($.HEAP8 = y = new Int8Array(u)),
                    ($.HEAP16 = new Int16Array(u)),
                    ($.HEAP32 = f = new Int32Array(u)),
                    ($.HEAPU8 = _ = new Uint8Array(u)),
                    ($.HEAPU16 = new Uint16Array(u)),
                    ($.HEAPU32 = l = new Uint32Array(u)),
                    ($.HEAPF32 = new Float32Array(u)),
                    ($.HEAPF64 = new Float64Array(u)));
                }
                var C,
                  v = [],
                  k = [],
                  o = [],
                  J0 = [],
                  z0 = 0;
                function A0() {
                  var u = $.preRun.shift();
                  v.unshift(u);
                }
                var w0,
                  Y1 = 0,
                  b = null,
                  m = null;
                function n(u) {
                  throw (
                    $.onAbort && $.onAbort(u),
                    j((u = "Aborted(" + u + ")")),
                    (h = !0),
                    (u = new WebAssembly.RuntimeError(
                      u + ". Build with -sASSERTIONS for more info."
                    )),
                    K(u),
                    u
                  );
                }
                function M0() {
                  return w0.startsWith("data:application/octet-stream;base64,");
                }
                if (((w0 = "ort-wasm.wasm"), !M0())) {
                  var D0 = w0;
                  w0 = $.locateFile ? $.locateFile(D0, E) : E + D0;
                }
                function Z0() {
                  var u = w0;
                  try {
                    if (u == w0 && O) return new Uint8Array(O);
                    if (L) return L(u);
                    throw "both async and sync fetching of the wasm failed";
                  } catch (a) {
                    n(a);
                  }
                }
                function B1(u) {
                  ((this.name = "ExitStatus"),
                    (this.message = "Program terminated with exit(" + u + ")"),
                    (this.status = u));
                }
                function j1(u) {
                  for (; 0 < u.length; ) u.shift()($);
                }
                var v1 = [],
                  M1 = 0,
                  x0 = 0;
                function h1(u) {
                  ((this.Db = u),
                    (this.zb = u - 24),
                    (this.Ub = function (a) {
                      l[((this.zb + 4) >> 2) >>> 0] = a;
                    }),
                    (this.Eb = function () {
                      return l[((this.zb + 4) >> 2) >>> 0];
                    }),
                    (this.Sb = function (a) {
                      l[((this.zb + 8) >> 2) >>> 0] = a;
                    }),
                    (this.Wb = function () {
                      return l[((this.zb + 8) >> 2) >>> 0];
                    }),
                    (this.Tb = function () {
                      f[(this.zb >> 2) >>> 0] = 0;
                    }),
                    (this.Ib = function (a) {
                      y[((this.zb + 12) >> 0) >>> 0] = a ? 1 : 0;
                    }),
                    (this.Pb = function () {
                      return y[((this.zb + 12) >> 0) >>> 0] != 0;
                    }),
                    (this.Jb = function (a) {
                      y[((this.zb + 13) >> 0) >>> 0] = a ? 1 : 0;
                    }),
                    (this.Lb = function () {
                      return y[((this.zb + 13) >> 0) >>> 0] != 0;
                    }),
                    (this.Rb = function (a, Y0) {
                      (this.Fb(0),
                        this.Ub(a),
                        this.Sb(Y0),
                        this.Tb(),
                        this.Ib(!1),
                        this.Jb(!1));
                    }),
                    (this.Nb = function () {
                      f[(this.zb >> 2) >>> 0] += 1;
                    }),
                    (this.Xb = function () {
                      var a = f[(this.zb >> 2) >>> 0];
                      return ((f[(this.zb >> 2) >>> 0] = a - 1), a === 1);
                    }),
                    (this.Fb = function (a) {
                      l[((this.zb + 16) >> 2) >>> 0] = a;
                    }),
                    (this.Ob = function () {
                      return l[((this.zb + 16) >> 2) >>> 0];
                    }),
                    (this.Qb = function () {
                      if (JY(this.Eb())) return l[(this.Db >> 2) >>> 0];
                      var a = this.Ob();
                      return a !== 0 ? a : this.Db;
                    }));
                }
                function g1(u) {
                  return D9(new h1(u).zb);
                }
                var b5 = [];
                function r0(u) {
                  var a = b5[u];
                  return (
                    a ||
                      (u >= b5.length && (b5.length = u + 1),
                      (b5[u] = a = C.get(u))),
                    a
                  );
                }
                function q8(u) {
                  var a = x(u) + 1,
                    Y0 = u1(a);
                  return (Y0 && P(u, y, Y0, a), Y0);
                }
                var w8 = {};
                function Y6() {
                  if (!R8) {
                    var u,
                      a = {
                        USER: "web_user",
                        LOGNAME: "web_user",
                        PATH: "/",
                        PWD: "/",
                        HOME: "/home/web_user",
                        LANG:
                          (
                            (typeof navigator == "object" &&
                              navigator.languages &&
                              navigator.languages[0]) ||
                            "C"
                          ).replace("-", "_") + ".UTF-8",
                        _: M || "./this.program",
                      };
                    for (u in w8)
                      w8[u] === void 0 ? delete a[u] : (a[u] = w8[u]);
                    var Y0 = [];
                    for (u in a) Y0.push(u + "=" + a[u]);
                    R8 = Y0;
                  }
                  return R8;
                }
                var R8,
                  PX = [null, [], []];
                function SX(u, a) {
                  var Y0 = PX[u];
                  a === 0 || a === 10
                    ? ((u === 1 ? Z : j)(N0(Y0, 0)), (Y0.length = 0))
                    : Y0.push(a);
                }
                var m5 = 0;
                function R9(u) {
                  return u % 4 == 0 && (u % 100 != 0 || u % 400 == 0);
                }
                var Q1 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
                  I4 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                function KG(u, a, Y0, Q0) {
                  function W0(B0, S1, t1) {
                    for (
                      B0 = typeof B0 == "number" ? B0.toString() : B0 || "";
                      B0.length < S1;
                    )
                      B0 = t1[0] + B0;
                    return B0;
                  }
                  function V0(B0, S1) {
                    return W0(B0, S1, "0");
                  }
                  function P0(B0, S1) {
                    function t1(s6) {
                      return 0 > s6 ? -1 : 0 < s6 ? 1 : 0;
                    }
                    var C8;
                    return (
                      (C8 = t1(B0.getFullYear() - S1.getFullYear())) === 0 &&
                        (C8 = t1(B0.getMonth() - S1.getMonth())) === 0 &&
                        (C8 = t1(B0.getDate() - S1.getDate())),
                      C8
                    );
                  }
                  function m0(B0) {
                    switch (B0.getDay()) {
                      case 0:
                        return new Date(B0.getFullYear() - 1, 11, 29);
                      case 1:
                        return B0;
                      case 2:
                        return new Date(B0.getFullYear(), 0, 3);
                      case 3:
                        return new Date(B0.getFullYear(), 0, 2);
                      case 4:
                        return new Date(B0.getFullYear(), 0, 1);
                      case 5:
                        return new Date(B0.getFullYear() - 1, 11, 31);
                      case 6:
                        return new Date(B0.getFullYear() - 1, 11, 30);
                    }
                  }
                  function k0(B0) {
                    var S1 = B0.Bb;
                    for (
                      B0 = new Date(new Date(B0.Cb + 1900, 0, 1).getTime());
                      0 < S1;
                    ) {
                      var t1 = B0.getMonth(),
                        C8 = (R9(B0.getFullYear()) ? Q1 : I4)[t1];
                      if (!(S1 > C8 - B0.getDate())) {
                        B0.setDate(B0.getDate() + S1);
                        break;
                      }
                      ((S1 -= C8 - B0.getDate() + 1),
                        B0.setDate(1),
                        11 > t1
                          ? B0.setMonth(t1 + 1)
                          : (B0.setMonth(0),
                            B0.setFullYear(B0.getFullYear() + 1)));
                    }
                    return (
                      (t1 = new Date(B0.getFullYear() + 1, 0, 4)),
                      (S1 = m0(new Date(B0.getFullYear(), 0, 4))),
                      (t1 = m0(t1)),
                      0 >= P0(S1, B0)
                        ? 0 >= P0(t1, B0)
                          ? B0.getFullYear() + 1
                          : B0.getFullYear()
                        : B0.getFullYear() - 1
                    );
                  }
                  var V1 = f[((Q0 + 40) >> 2) >>> 0];
                  for (var d1 in ((Q0 = {
                    $b: f[(Q0 >> 2) >>> 0],
                    Zb: f[((Q0 + 4) >> 2) >>> 0],
                    Gb: f[((Q0 + 8) >> 2) >>> 0],
                    Kb: f[((Q0 + 12) >> 2) >>> 0],
                    Hb: f[((Q0 + 16) >> 2) >>> 0],
                    Cb: f[((Q0 + 20) >> 2) >>> 0],
                    Ab: f[((Q0 + 24) >> 2) >>> 0],
                    Bb: f[((Q0 + 28) >> 2) >>> 0],
                    bc: f[((Q0 + 32) >> 2) >>> 0],
                    Yb: f[((Q0 + 36) >> 2) >>> 0],
                    ac: V1 ? e(V1) : "",
                  }),
                  (Y0 = e(Y0)),
                  (V1 = {
                    "%c": "%a %b %d %H:%M:%S %Y",
                    "%D": "%m/%d/%y",
                    "%F": "%Y-%m-%d",
                    "%h": "%b",
                    "%r": "%I:%M:%S %p",
                    "%R": "%H:%M",
                    "%T": "%H:%M:%S",
                    "%x": "%m/%d/%y",
                    "%X": "%H:%M:%S",
                    "%Ec": "%c",
                    "%EC": "%C",
                    "%Ex": "%m/%d/%y",
                    "%EX": "%H:%M:%S",
                    "%Ey": "%y",
                    "%EY": "%Y",
                    "%Od": "%d",
                    "%Oe": "%e",
                    "%OH": "%H",
                    "%OI": "%I",
                    "%Om": "%m",
                    "%OM": "%M",
                    "%OS": "%S",
                    "%Ou": "%u",
                    "%OU": "%U",
                    "%OV": "%V",
                    "%Ow": "%w",
                    "%OW": "%W",
                    "%Oy": "%y",
                  })))
                    Y0 = Y0.replace(new RegExp(d1, "g"), V1[d1]);
                  var v5 =
                      "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
                        " "
                      ),
                    w5 =
                      "January February March April May June July August September October November December".split(
                        " "
                      );
                  for (d1 in ((V1 = {
                    "%a": function (B0) {
                      return v5[B0.Ab].substring(0, 3);
                    },
                    "%A": function (B0) {
                      return v5[B0.Ab];
                    },
                    "%b": function (B0) {
                      return w5[B0.Hb].substring(0, 3);
                    },
                    "%B": function (B0) {
                      return w5[B0.Hb];
                    },
                    "%C": function (B0) {
                      return V0(((B0.Cb + 1900) / 100) | 0, 2);
                    },
                    "%d": function (B0) {
                      return V0(B0.Kb, 2);
                    },
                    "%e": function (B0) {
                      return W0(B0.Kb, 2, " ");
                    },
                    "%g": function (B0) {
                      return k0(B0).toString().substring(2);
                    },
                    "%G": function (B0) {
                      return k0(B0);
                    },
                    "%H": function (B0) {
                      return V0(B0.Gb, 2);
                    },
                    "%I": function (B0) {
                      return (
                        (B0 = B0.Gb) == 0 ? (B0 = 12) : 12 < B0 && (B0 -= 12),
                        V0(B0, 2)
                      );
                    },
                    "%j": function (B0) {
                      for (
                        var S1 = 0, t1 = 0;
                        t1 <= B0.Hb - 1;
                        S1 += (R9(B0.Cb + 1900) ? Q1 : I4)[t1++]
                      );
                      return V0(B0.Kb + S1, 3);
                    },
                    "%m": function (B0) {
                      return V0(B0.Hb + 1, 2);
                    },
                    "%M": function (B0) {
                      return V0(B0.Zb, 2);
                    },
                    "%n": function () {
                      return `
`;
                    },
                    "%p": function (B0) {
                      return 0 <= B0.Gb && 12 > B0.Gb ? "AM" : "PM";
                    },
                    "%S": function (B0) {
                      return V0(B0.$b, 2);
                    },
                    "%t": function () {
                      return "\t";
                    },
                    "%u": function (B0) {
                      return B0.Ab || 7;
                    },
                    "%U": function (B0) {
                      return V0(Math.floor((B0.Bb + 7 - B0.Ab) / 7), 2);
                    },
                    "%V": function (B0) {
                      var S1 = Math.floor((B0.Bb + 7 - ((B0.Ab + 6) % 7)) / 7);
                      if ((2 >= (B0.Ab + 371 - B0.Bb - 2) % 7 && S1++, S1))
                        S1 == 53 &&
                          ((t1 = (B0.Ab + 371 - B0.Bb) % 7) == 4 ||
                            (t1 == 3 && R9(B0.Cb)) ||
                            (S1 = 1));
                      else {
                        S1 = 52;
                        var t1 = (B0.Ab + 7 - B0.Bb - 1) % 7;
                        (t1 == 4 || (t1 == 5 && R9((B0.Cb % 400) - 1))) && S1++;
                      }
                      return V0(S1, 2);
                    },
                    "%w": function (B0) {
                      return B0.Ab;
                    },
                    "%W": function (B0) {
                      return V0(
                        Math.floor((B0.Bb + 7 - ((B0.Ab + 6) % 7)) / 7),
                        2
                      );
                    },
                    "%y": function (B0) {
                      return (B0.Cb + 1900).toString().substring(2);
                    },
                    "%Y": function (B0) {
                      return B0.Cb + 1900;
                    },
                    "%z": function (B0) {
                      var S1 = 0 <= (B0 = B0.Yb);
                      return (
                        (B0 = Math.abs(B0) / 60),
                        (S1 ? "+" : "-") +
                          String("0000" + ((B0 / 60) * 100 + (B0 % 60))).slice(
                            -4
                          )
                      );
                    },
                    "%Z": function (B0) {
                      return B0.ac;
                    },
                    "%%": function () {
                      return "%";
                    },
                  }),
                  (Y0 = Y0.replace(/%%/g, "\x00\x00")),
                  V1))
                    Y0.includes(d1) &&
                      (Y0 = Y0.replace(new RegExp(d1, "g"), V1[d1](Q0)));
                  return (
                    (d1 = (function (B0) {
                      var S1 = Array(x(B0) + 1);
                      return (P(B0, S1, 0, S1.length), S1);
                    })((Y0 = Y0.replace(/\0\0/g, "%")))),
                    d1.length > a ? 0 : (y.set(d1, u >>> 0), d1.length - 1)
                  );
                }
                var VG = {
                  a: function (u) {
                    return u1(u + 24) + 24;
                  },
                  m: function (u) {
                    return (
                      (u = new h1(u)).Pb() || (u.Ib(!0), M1--),
                      u.Jb(!1),
                      v1.push(u),
                      u.Nb(),
                      u.Qb()
                    );
                  },
                  ia: function (u) {
                    throw (
                      j(
                        "Unexpected exception thrown, this is not properly supported - aborting"
                      ),
                      (h = !0),
                      u
                    );
                  },
                  w: function () {
                    H1(0);
                    var u = v1.pop();
                    if (u.Xb() && !u.Lb()) {
                      var a = u.Wb();
                      (a && r0(a)(u.Db), g1(u.Db));
                    }
                    x0 = 0;
                  },
                  d: function () {
                    var u = x0;
                    if (!u) return (m5 = 0);
                    var a = new h1(u);
                    a.Fb(u);
                    var Y0 = a.Eb();
                    if (!Y0) return ((m5 = 0), u);
                    for (
                      var Q0 = Array.prototype.slice.call(arguments), W0 = 0;
                      W0 < Q0.length;
                      W0++
                    ) {
                      var V0 = Q0[W0];
                      if (V0 === 0 || V0 === Y0) break;
                      if (E9(V0, Y0, a.zb + 16)) return ((m5 = V0), u);
                    }
                    return ((m5 = Y0), u);
                  },
                  k: function () {
                    var u = x0;
                    if (!u) return (m5 = 0);
                    var a = new h1(u);
                    a.Fb(u);
                    var Y0 = a.Eb();
                    if (!Y0) return ((m5 = 0), u);
                    for (
                      var Q0 = Array.prototype.slice.call(arguments), W0 = 0;
                      W0 < Q0.length;
                      W0++
                    ) {
                      var V0 = Q0[W0];
                      if (V0 === 0 || V0 === Y0) break;
                      if (E9(V0, Y0, a.zb + 16)) return ((m5 = V0), u);
                    }
                    return ((m5 = Y0), u);
                  },
                  g: function () {
                    var u = x0;
                    if (!u) return (m5 = 0);
                    var a = new h1(u);
                    a.Fb(u);
                    var Y0 = a.Eb();
                    if (!Y0) return ((m5 = 0), u);
                    for (
                      var Q0 = Array.prototype.slice.call(arguments), W0 = 0;
                      W0 < Q0.length;
                      W0++
                    ) {
                      var V0 = Q0[W0];
                      if (V0 === 0 || V0 === Y0) break;
                      if (E9(V0, Y0, a.zb + 16)) return ((m5 = V0), u);
                    }
                    return ((m5 = Y0), u);
                  },
                  s: g1,
                  L: function () {
                    var u = v1.pop();
                    u || n("no exception to throw");
                    var a = u.Db;
                    throw (
                      u.Lb() || (v1.push(u), u.Jb(!0), u.Ib(!1), M1++),
                      (x0 = a),
                      a
                    );
                  },
                  b: function (u, a, Y0) {
                    throw (new h1(u).Rb(a, Y0), (x0 = u), M1++, u);
                  },
                  la: function () {
                    return M1;
                  },
                  i: function (u) {
                    throw (x0 || (x0 = u), u);
                  },
                  H: function () {
                    return 0;
                  },
                  Ba: function () {},
                  pa: function () {},
                  ra: function () {},
                  ka: function () {
                    return 0;
                  },
                  za: function () {},
                  ua: function () {},
                  ya: function () {},
                  R: function () {},
                  qa: function () {},
                  na: function () {},
                  Aa: function () {},
                  oa: function () {},
                  Ha: function () {},
                  Ja: function () {
                    n(
                      "To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking"
                    );
                  },
                  Ia: function () {
                    n(
                      "To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking"
                    );
                  },
                  S: function () {
                    return Date.now();
                  },
                  Ca: function () {
                    return !0;
                  },
                  Da: function (u, a) {
                    ((u = new Date(
                      1000 * (l[u >>> 2] + 4294967296 * f[(u + 4) >>> 2])
                    )),
                      (f[(a >> 2) >>> 0] = u.getUTCSeconds()),
                      (f[((a + 4) >> 2) >>> 0] = u.getUTCMinutes()),
                      (f[((a + 8) >> 2) >>> 0] = u.getUTCHours()),
                      (f[((a + 12) >> 2) >>> 0] = u.getUTCDate()),
                      (f[((a + 16) >> 2) >>> 0] = u.getUTCMonth()),
                      (f[((a + 20) >> 2) >>> 0] = u.getUTCFullYear() - 1900),
                      (f[((a + 24) >> 2) >>> 0] = u.getUTCDay()),
                      (f[((a + 28) >> 2) >>> 0] =
                        ((u.getTime() -
                          Date.UTC(u.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) /
                          86400000) |
                        0));
                  },
                  Ea: function (u, a) {
                    ((u = new Date(
                      1000 * (l[u >>> 2] + 4294967296 * f[(u + 4) >>> 2])
                    )),
                      (f[(a >> 2) >>> 0] = u.getSeconds()),
                      (f[((a + 4) >> 2) >>> 0] = u.getMinutes()),
                      (f[((a + 8) >> 2) >>> 0] = u.getHours()),
                      (f[((a + 12) >> 2) >>> 0] = u.getDate()),
                      (f[((a + 16) >> 2) >>> 0] = u.getMonth()),
                      (f[((a + 20) >> 2) >>> 0] = u.getFullYear() - 1900),
                      (f[((a + 24) >> 2) >>> 0] = u.getDay()));
                    var Y0 = new Date(u.getFullYear(), 0, 1);
                    ((f[((a + 28) >> 2) >>> 0] =
                      ((u.getTime() - Y0.getTime()) / 86400000) | 0),
                      (f[((a + 36) >> 2) >>> 0] = -60 * u.getTimezoneOffset()));
                    var Q0 = new Date(
                      u.getFullYear(),
                      6,
                      1
                    ).getTimezoneOffset();
                    ((Y0 = Y0.getTimezoneOffset()),
                      (f[((a + 32) >> 2) >>> 0] =
                        0 |
                        (Q0 != Y0 &&
                          u.getTimezoneOffset() == Math.min(Y0, Q0))));
                  },
                  Fa: function (u) {
                    var a = new Date(
                        f[((u + 20) >> 2) >>> 0] + 1900,
                        f[((u + 16) >> 2) >>> 0],
                        f[((u + 12) >> 2) >>> 0],
                        f[((u + 8) >> 2) >>> 0],
                        f[((u + 4) >> 2) >>> 0],
                        f[(u >> 2) >>> 0],
                        0
                      ),
                      Y0 = f[((u + 32) >> 2) >>> 0],
                      Q0 = a.getTimezoneOffset(),
                      W0 = new Date(a.getFullYear(), 0, 1),
                      V0 = new Date(a.getFullYear(), 6, 1).getTimezoneOffset(),
                      P0 = W0.getTimezoneOffset(),
                      m0 = Math.min(P0, V0);
                    return (
                      0 > Y0
                        ? (f[((u + 32) >> 2) >>> 0] = Number(
                            V0 != P0 && m0 == Q0
                          ))
                        : 0 < Y0 != (m0 == Q0) &&
                          ((V0 = Math.max(P0, V0)),
                          a.setTime(
                            a.getTime() + 60000 * ((0 < Y0 ? m0 : V0) - Q0)
                          )),
                      (f[((u + 24) >> 2) >>> 0] = a.getDay()),
                      (f[((u + 28) >> 2) >>> 0] =
                        ((a.getTime() - W0.getTime()) / 86400000) | 0),
                      (f[(u >> 2) >>> 0] = a.getSeconds()),
                      (f[((u + 4) >> 2) >>> 0] = a.getMinutes()),
                      (f[((u + 8) >> 2) >>> 0] = a.getHours()),
                      (f[((u + 12) >> 2) >>> 0] = a.getDate()),
                      (f[((u + 16) >> 2) >>> 0] = a.getMonth()),
                      (a.getTime() / 1000) | 0
                    );
                  },
                  sa: function () {
                    return -52;
                  },
                  ta: function () {},
                  Ga: function u(a, Y0, Q0) {
                    u.Vb ||
                      ((u.Vb = !0),
                      (function (W0, V0, P0) {
                        function m0(w5) {
                          return (w5 = w5
                            .toTimeString()
                            .match(/\(([A-Za-z ]+)\)$/))
                            ? w5[1]
                            : "GMT";
                        }
                        var k0 = new Date().getFullYear(),
                          V1 = new Date(k0, 0, 1),
                          d1 = new Date(k0, 6, 1);
                        k0 = V1.getTimezoneOffset();
                        var v5 = d1.getTimezoneOffset();
                        ((f[(W0 >> 2) >>> 0] = 60 * Math.max(k0, v5)),
                          (f[(V0 >> 2) >>> 0] = Number(k0 != v5)),
                          (W0 = m0(V1)),
                          (V0 = m0(d1)),
                          (W0 = q8(W0)),
                          (V0 = q8(V0)),
                          v5 < k0
                            ? ((l[(P0 >> 2) >>> 0] = W0),
                              (l[((P0 + 4) >> 2) >>> 0] = V0))
                            : ((l[(P0 >> 2) >>> 0] = V0),
                              (l[((P0 + 4) >> 2) >>> 0] = W0)));
                      })(a, Y0, Q0));
                  },
                  B: function () {
                    n("");
                  },
                  ma: function () {
                    return 4294901760;
                  },
                  I: z
                    ? () => {
                        var u = process.hrtime();
                        return 1000 * u[0] + u[1] / 1e6;
                      }
                    : () => performance.now(),
                  xa: function (u, a, Y0) {
                    _.copyWithin(u >>> 0, a >>> 0, (a + Y0) >>> 0);
                  },
                  G: function (u) {
                    var a = _.length;
                    if (4294901760 < (u >>>= 0)) return !1;
                    for (var Y0 = 1; 4 >= Y0; Y0 *= 2) {
                      var Q0 = a * (1 + 0.2 / Y0);
                      Q0 = Math.min(Q0, u + 100663296);
                      var W0 = Math;
                      ((Q0 = Math.max(u, Q0)),
                        (W0 = W0.min.call(
                          W0,
                          4294901760,
                          Q0 + ((65536 - (Q0 % 65536)) % 65536)
                        )));
                      X: {
                        try {
                          (I.grow((W0 - T.byteLength + 65535) >>> 16), r());
                          var V0 = 1;
                          break X;
                        } catch (P0) {}
                        V0 = void 0;
                      }
                      if (V0) return !0;
                    }
                    return !1;
                  },
                  va: function (u, a) {
                    var Y0 = 0;
                    return (
                      Y6().forEach(function (Q0, W0) {
                        var V0 = a + Y0;
                        for (
                          W0 = l[((u + 4 * W0) >> 2) >>> 0] = V0, V0 = 0;
                          V0 < Q0.length;
                          ++V0
                        )
                          y[(W0++ >> 0) >>> 0] = Q0.charCodeAt(V0);
                        ((y[(W0 >> 0) >>> 0] = 0), (Y0 += Q0.length + 1));
                      }),
                      0
                    );
                  },
                  wa: function (u, a) {
                    var Y0 = Y6();
                    l[(u >> 2) >>> 0] = Y0.length;
                    var Q0 = 0;
                    return (
                      Y0.forEach(function (W0) {
                        Q0 += W0.length + 1;
                      }),
                      (l[(a >> 2) >>> 0] = Q0),
                      0
                    );
                  },
                  ba: function (u) {
                    (w ||
                      0 < z0 ||
                      (z9(),
                      j1(o),
                      QY(0),
                      PX[1].length && SX(1, 10),
                      PX[2].length && SX(2, 10)),
                      w || 0 < z0 || ($.onExit && $.onExit(u), (h = !0)),
                      A(u, new B1(u)));
                  },
                  E: function () {
                    return 52;
                  },
                  Q: function () {
                    return 52;
                  },
                  ca: function () {
                    return 70;
                  },
                  P: function (u, a, Y0, Q0) {
                    for (var W0 = 0, V0 = 0; V0 < Y0; V0++) {
                      var P0 = l[(a >> 2) >>> 0],
                        m0 = l[((a + 4) >> 2) >>> 0];
                      a += 8;
                      for (var k0 = 0; k0 < m0; k0++) SX(u, _[(P0 + k0) >>> 0]);
                      W0 += m0;
                    }
                    return ((l[(Q0 >> 2) >>> 0] = W0), 0);
                  },
                  c: function () {
                    return m5;
                  },
                  ja: function u(a, Y0) {
                    u.Mb ||
                      (u.Mb = (function () {
                        if (
                          typeof crypto == "object" &&
                          typeof crypto.getRandomValues == "function"
                        ) {
                          var W0 = new Uint8Array(1);
                          return () => (crypto.getRandomValues(W0), W0[0]);
                        }
                        if (z)
                          try {
                            var V0 = Q(6113);
                            return () => V0.randomBytes(1)[0];
                          } catch (P0) {}
                        return () => n("randomDevice");
                      })());
                    for (var Q0 = 0; Q0 < Y0; Q0++)
                      y[((a + Q0) >> 0) >>> 0] = u.Mb();
                    return 0;
                  },
                  ea: function (u, a, Y0) {
                    var Q0 = G1();
                    try {
                      return r0(u)(a, Y0);
                    } catch (W0) {
                      if ((J1(Q0), W0 !== W0 + 0)) throw W0;
                      H1(1, 0);
                    }
                  },
                  fa: function (u, a, Y0) {
                    var Q0 = G1();
                    try {
                      return r0(u)(a, Y0);
                    } catch (W0) {
                      if ((J1(Q0), W0 !== W0 + 0)) throw W0;
                      H1(1, 0);
                    }
                  },
                  J: function (u) {
                    var a = G1();
                    try {
                      return r0(u)();
                    } catch (Y0) {
                      if ((J1(a), Y0 !== Y0 + 0)) throw Y0;
                      H1(1, 0);
                    }
                  },
                  e: function (u, a) {
                    var Y0 = G1();
                    try {
                      return r0(u)(a);
                    } catch (Q0) {
                      if ((J1(Y0), Q0 !== Q0 + 0)) throw Q0;
                      H1(1, 0);
                    }
                  },
                  N: function (u, a, Y0) {
                    var Q0 = G1();
                    try {
                      return r0(u)(a, Y0);
                    } catch (W0) {
                      if ((J1(Q0), W0 !== W0 + 0)) throw W0;
                      H1(1, 0);
                    }
                  },
                  O: function (u, a, Y0) {
                    var Q0 = G1();
                    try {
                      return r0(u)(a, Y0);
                    } catch (W0) {
                      if ((J1(Q0), W0 !== W0 + 0)) throw W0;
                      H1(1, 0);
                    }
                  },
                  j: function (u, a, Y0) {
                    var Q0 = G1();
                    try {
                      return r0(u)(a, Y0);
                    } catch (W0) {
                      if ((J1(Q0), W0 !== W0 + 0)) throw W0;
                      H1(1, 0);
                    }
                  },
                  o: function (u, a, Y0, Q0) {
                    var W0 = G1();
                    try {
                      return r0(u)(a, Y0, Q0);
                    } catch (V0) {
                      if ((J1(W0), V0 !== V0 + 0)) throw V0;
                      H1(1, 0);
                    }
                  },
                  p: function (u, a, Y0, Q0, W0) {
                    var V0 = G1();
                    try {
                      return r0(u)(a, Y0, Q0, W0);
                    } catch (P0) {
                      if ((J1(V0), P0 !== P0 + 0)) throw P0;
                      H1(1, 0);
                    }
                  },
                  M: function (u, a, Y0, Q0, W0, V0) {
                    var P0 = G1();
                    try {
                      return r0(u)(a, Y0, Q0, W0, V0);
                    } catch (m0) {
                      if ((J1(P0), m0 !== m0 + 0)) throw m0;
                      H1(1, 0);
                    }
                  },
                  r: function (u, a, Y0, Q0, W0, V0) {
                    var P0 = G1();
                    try {
                      return r0(u)(a, Y0, Q0, W0, V0);
                    } catch (m0) {
                      if ((J1(P0), m0 !== m0 + 0)) throw m0;
                      H1(1, 0);
                    }
                  },
                  v: function (u, a, Y0, Q0, W0, V0, P0) {
                    var m0 = G1();
                    try {
                      return r0(u)(a, Y0, Q0, W0, V0, P0);
                    } catch (k0) {
                      if ((J1(m0), k0 !== k0 + 0)) throw k0;
                      H1(1, 0);
                    }
                  },
                  K: function (u, a, Y0, Q0, W0, V0, P0, m0) {
                    var k0 = G1();
                    try {
                      return r0(u)(a, Y0, Q0, W0, V0, P0, m0);
                    } catch (V1) {
                      if ((J1(k0), V1 !== V1 + 0)) throw V1;
                      H1(1, 0);
                    }
                  },
                  D: function (u, a, Y0, Q0, W0, V0, P0, m0, k0, V1, d1, v5) {
                    var w5 = G1();
                    try {
                      return r0(u)(a, Y0, Q0, W0, V0, P0, m0, k0, V1, d1, v5);
                    } catch (B0) {
                      if ((J1(w5), B0 !== B0 + 0)) throw B0;
                      H1(1, 0);
                    }
                  },
                  X: function (u, a, Y0, Q0, W0, V0, P0, m0) {
                    var k0 = G1();
                    try {
                      return FY(u, a, Y0, Q0, W0, V0, P0, m0);
                    } catch (V1) {
                      if ((J1(k0), V1 !== V1 + 0)) throw V1;
                      H1(1, 0);
                    }
                  },
                  V: function (u, a, Y0, Q0, W0, V0, P0) {
                    var m0 = G1();
                    try {
                      return HY(u, a, Y0, Q0, W0, V0, P0);
                    } catch (k0) {
                      if ((J1(m0), k0 !== k0 + 0)) throw k0;
                      H1(1, 0);
                    }
                  },
                  U: function (u, a, Y0, Q0, W0) {
                    var V0 = G1();
                    try {
                      return NY(u, a, Y0, Q0, W0);
                    } catch (P0) {
                      if ((J1(V0), P0 !== P0 + 0)) throw P0;
                      H1(1, 0);
                    }
                  },
                  Z: function (u, a, Y0, Q0) {
                    var W0 = G1();
                    try {
                      return KY(u, a, Y0, Q0);
                    } catch (V0) {
                      if ((J1(W0), V0 !== V0 + 0)) throw V0;
                      H1(1, 0);
                    }
                  },
                  W: function (u) {
                    var a = G1();
                    try {
                      return WY(u);
                    } catch (Y0) {
                      if ((J1(a), Y0 !== Y0 + 0)) throw Y0;
                      H1(1, 0);
                    }
                  },
                  Y: function (u, a) {
                    var Y0 = G1();
                    try {
                      return VY(u, a);
                    } catch (Q0) {
                      if ((J1(Y0), Q0 !== Q0 + 0)) throw Q0;
                      H1(1, 0);
                    }
                  },
                  T: function (u, a, Y0) {
                    var Q0 = G1();
                    try {
                      return $Y(u, a, Y0);
                    } catch (W0) {
                      if ((J1(Q0), W0 !== W0 + 0)) throw W0;
                      H1(1, 0);
                    }
                  },
                  f: function (u) {
                    var a = G1();
                    try {
                      r0(u)();
                    } catch (Y0) {
                      if ((J1(a), Y0 !== Y0 + 0)) throw Y0;
                      H1(1, 0);
                    }
                  },
                  q: function (u, a) {
                    var Y0 = G1();
                    try {
                      r0(u)(a);
                    } catch (Q0) {
                      if ((J1(Y0), Q0 !== Q0 + 0)) throw Q0;
                      H1(1, 0);
                    }
                  },
                  h: function (u, a, Y0) {
                    var Q0 = G1();
                    try {
                      r0(u)(a, Y0);
                    } catch (W0) {
                      if ((J1(Q0), W0 !== W0 + 0)) throw W0;
                      H1(1, 0);
                    }
                  },
                  da: function (u, a, Y0, Q0) {
                    var W0 = G1();
                    try {
                      r0(u)(a, Y0, Q0);
                    } catch (V0) {
                      if ((J1(W0), V0 !== V0 + 0)) throw V0;
                      H1(1, 0);
                    }
                  },
                  l: function (u, a, Y0, Q0) {
                    var W0 = G1();
                    try {
                      r0(u)(a, Y0, Q0);
                    } catch (V0) {
                      if ((J1(W0), V0 !== V0 + 0)) throw V0;
                      H1(1, 0);
                    }
                  },
                  t: function (u, a, Y0, Q0, W0) {
                    var V0 = G1();
                    try {
                      r0(u)(a, Y0, Q0, W0);
                    } catch (P0) {
                      if ((J1(V0), P0 !== P0 + 0)) throw P0;
                      H1(1, 0);
                    }
                  },
                  u: function (u, a, Y0, Q0, W0, V0) {
                    var P0 = G1();
                    try {
                      r0(u)(a, Y0, Q0, W0, V0);
                    } catch (m0) {
                      if ((J1(P0), m0 !== m0 + 0)) throw m0;
                      H1(1, 0);
                    }
                  },
                  x: function (u, a, Y0, Q0, W0, V0, P0) {
                    var m0 = G1();
                    try {
                      r0(u)(a, Y0, Q0, W0, V0, P0);
                    } catch (k0) {
                      if ((J1(m0), k0 !== k0 + 0)) throw k0;
                      H1(1, 0);
                    }
                  },
                  z: function (u, a, Y0, Q0, W0, V0, P0, m0) {
                    var k0 = G1();
                    try {
                      r0(u)(a, Y0, Q0, W0, V0, P0, m0);
                    } catch (V1) {
                      if ((J1(k0), V1 !== V1 + 0)) throw V1;
                      H1(1, 0);
                    }
                  },
                  ga: function (u, a, Y0, Q0, W0, V0, P0, m0, k0) {
                    var V1 = G1();
                    try {
                      r0(u)(a, Y0, Q0, W0, V0, P0, m0, k0);
                    } catch (d1) {
                      if ((J1(V1), d1 !== d1 + 0)) throw d1;
                      H1(1, 0);
                    }
                  },
                  A: function (u, a, Y0, Q0, W0, V0, P0, m0, k0, V1, d1) {
                    var v5 = G1();
                    try {
                      r0(u)(a, Y0, Q0, W0, V0, P0, m0, k0, V1, d1);
                    } catch (w5) {
                      if ((J1(v5), w5 !== w5 + 0)) throw w5;
                      H1(1, 0);
                    }
                  },
                  C: function (
                    u,
                    a,
                    Y0,
                    Q0,
                    W0,
                    V0,
                    P0,
                    m0,
                    k0,
                    V1,
                    d1,
                    v5,
                    w5,
                    B0,
                    S1,
                    t1
                  ) {
                    var C8 = G1();
                    try {
                      r0(u)(
                        a,
                        Y0,
                        Q0,
                        W0,
                        V0,
                        P0,
                        m0,
                        k0,
                        V1,
                        d1,
                        v5,
                        w5,
                        B0,
                        S1,
                        t1
                      );
                    } catch (s6) {
                      if ((J1(C8), s6 !== s6 + 0)) throw s6;
                      H1(1, 0);
                    }
                  },
                  aa: function (u, a, Y0, Q0, W0, V0, P0, m0) {
                    var k0 = G1();
                    try {
                      UY(u, a, Y0, Q0, W0, V0, P0, m0);
                    } catch (V1) {
                      if ((J1(k0), V1 !== V1 + 0)) throw V1;
                      H1(1, 0);
                    }
                  },
                  _: function (u, a, Y0, Q0, W0, V0, P0, m0, k0, V1, d1, v5) {
                    var w5 = G1();
                    try {
                      BY(u, a, Y0, Q0, W0, V0, P0, m0, k0, V1, d1, v5);
                    } catch (B0) {
                      if ((J1(w5), B0 !== B0 + 0)) throw B0;
                      H1(1, 0);
                    }
                  },
                  $: function (u, a, Y0, Q0, W0, V0) {
                    var P0 = G1();
                    try {
                      LY(u, a, Y0, Q0, W0, V0);
                    } catch (m0) {
                      if ((J1(P0), m0 !== m0 + 0)) throw m0;
                      H1(1, 0);
                    }
                  },
                  n: function (u) {
                    return u;
                  },
                  F: function (u) {
                    m5 = u;
                  },
                  ha: KG,
                  y: function (u, a, Y0, Q0) {
                    return KG(u, a, Y0, Q0);
                  },
                };
                ((function () {
                  function u(W0) {
                    (($.asm = W0.exports),
                      (I = $.asm.Ka),
                      r(),
                      (C = $.asm.ib),
                      k.unshift($.asm.La),
                      Y1--,
                      $.monitorRunDependencies && $.monitorRunDependencies(Y1),
                      Y1 == 0 &&
                        (b !== null && (clearInterval(b), (b = null)),
                        m && ((W0 = m), (m = null), W0())));
                  }
                  function a(W0) {
                    u(W0.instance);
                  }
                  function Y0(W0) {
                    return (function () {
                      if (!O && (D || R)) {
                        if (
                          typeof fetch == "function" &&
                          !w0.startsWith("file://")
                        )
                          return fetch(w0, { credentials: "same-origin" })
                            .then(function (V0) {
                              if (!V0.ok)
                                throw (
                                  "failed to load wasm binary file at '" +
                                  w0 +
                                  "'"
                                );
                              return V0.arrayBuffer();
                            })
                            .catch(function () {
                              return Z0();
                            });
                        if (W)
                          return new Promise(function (V0, P0) {
                            W(
                              w0,
                              function (m0) {
                                V0(new Uint8Array(m0));
                              },
                              P0
                            );
                          });
                      }
                      return Promise.resolve().then(function () {
                        return Z0();
                      });
                    })()
                      .then(function (V0) {
                        return WebAssembly.instantiate(V0, Q0);
                      })
                      .then(function (V0) {
                        return V0;
                      })
                      .then(W0, function (V0) {
                        (j("failed to asynchronously prepare wasm: " + V0),
                          n(V0));
                      });
                  }
                  var Q0 = { a: VG };
                  if (
                    (Y1++,
                    $.monitorRunDependencies && $.monitorRunDependencies(Y1),
                    $.instantiateWasm)
                  )
                    try {
                      return $.instantiateWasm(Q0, u);
                    } catch (W0) {
                      return (
                        j(
                          "Module.instantiateWasm callback failed with error: " +
                            W0
                        ),
                        !1
                      );
                    }
                  (O ||
                  typeof WebAssembly.instantiateStreaming != "function" ||
                  M0() ||
                  w0.startsWith("file://") ||
                  z ||
                  typeof fetch != "function"
                    ? Y0(a)
                    : fetch(w0, { credentials: "same-origin" }).then(
                        function (W0) {
                          return WebAssembly.instantiateStreaming(W0, Q0).then(
                            a,
                            function (V0) {
                              return (
                                j("wasm streaming compile failed: " + V0),
                                j("falling back to ArrayBuffer instantiation"),
                                Y0(a)
                              );
                            }
                          );
                        }
                      )
                  ).catch(K);
                })(),
                  ($.___wasm_call_ctors = function () {
                    return ($.___wasm_call_ctors = $.asm.La).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtInit = function () {
                    return ($._OrtInit = $.asm.Ma).apply(null, arguments);
                  }),
                  ($._OrtCreateSessionOptions = function () {
                    return ($._OrtCreateSessionOptions = $.asm.Na).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtAppendExecutionProvider = function () {
                    return ($._OrtAppendExecutionProvider = $.asm.Oa).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtAddSessionConfigEntry = function () {
                    return ($._OrtAddSessionConfigEntry = $.asm.Pa).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtReleaseSessionOptions = function () {
                    return ($._OrtReleaseSessionOptions = $.asm.Qa).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtCreateSession = function () {
                    return ($._OrtCreateSession = $.asm.Ra).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtReleaseSession = function () {
                    return ($._OrtReleaseSession = $.asm.Sa).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtGetInputCount = function () {
                    return ($._OrtGetInputCount = $.asm.Ta).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtGetOutputCount = function () {
                    return ($._OrtGetOutputCount = $.asm.Ua).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtGetInputName = function () {
                    return ($._OrtGetInputName = $.asm.Va).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtGetOutputName = function () {
                    return ($._OrtGetOutputName = $.asm.Wa).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtFree = function () {
                    return ($._OrtFree = $.asm.Xa).apply(null, arguments);
                  }),
                  ($._OrtCreateTensor = function () {
                    return ($._OrtCreateTensor = $.asm.Ya).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtGetTensorData = function () {
                    return ($._OrtGetTensorData = $.asm.Za).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtReleaseTensor = function () {
                    return ($._OrtReleaseTensor = $.asm._a).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtCreateRunOptions = function () {
                    return ($._OrtCreateRunOptions = $.asm.$a).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtAddRunConfigEntry = function () {
                    return ($._OrtAddRunConfigEntry = $.asm.ab).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtReleaseRunOptions = function () {
                    return ($._OrtReleaseRunOptions = $.asm.bb).apply(
                      null,
                      arguments
                    );
                  }),
                  ($._OrtRun = function () {
                    return ($._OrtRun = $.asm.cb).apply(null, arguments);
                  }),
                  ($._OrtEndProfiling = function () {
                    return ($._OrtEndProfiling = $.asm.db).apply(
                      null,
                      arguments
                    );
                  }));
                var o6,
                  u1 = ($._malloc = function () {
                    return (u1 = $._malloc = $.asm.eb).apply(null, arguments);
                  }),
                  D9 = ($._free = function () {
                    return (D9 = $._free = $.asm.fb).apply(null, arguments);
                  }),
                  QY = ($._fflush = function () {
                    return (QY = $._fflush = $.asm.gb).apply(null, arguments);
                  }),
                  z9 = ($.___funcs_on_exit = function () {
                    return (z9 = $.___funcs_on_exit = $.asm.hb).apply(
                      null,
                      arguments
                    );
                  }),
                  H1 = ($._setThrew = function () {
                    return (H1 = $._setThrew = $.asm.jb).apply(null, arguments);
                  }),
                  G1 = ($.stackSave = function () {
                    return (G1 = $.stackSave = $.asm.kb).apply(null, arguments);
                  }),
                  J1 = ($.stackRestore = function () {
                    return (J1 = $.stackRestore = $.asm.lb).apply(
                      null,
                      arguments
                    );
                  }),
                  GY = ($.stackAlloc = function () {
                    return (GY = $.stackAlloc = $.asm.mb).apply(
                      null,
                      arguments
                    );
                  }),
                  E9 = ($.___cxa_can_catch = function () {
                    return (E9 = $.___cxa_can_catch = $.asm.nb).apply(
                      null,
                      arguments
                    );
                  }),
                  JY = ($.___cxa_is_pointer_type = function () {
                    return (JY = $.___cxa_is_pointer_type = $.asm.ob).apply(
                      null,
                      arguments
                    );
                  }),
                  WY = ($.dynCall_j = function () {
                    return (WY = $.dynCall_j = $.asm.pb).apply(null, arguments);
                  }),
                  HY = ($.dynCall_iiiiij = function () {
                    return (HY = $.dynCall_iiiiij = $.asm.qb).apply(
                      null,
                      arguments
                    );
                  }),
                  $Y = ($.dynCall_jii = function () {
                    return ($Y = $.dynCall_jii = $.asm.rb).apply(
                      null,
                      arguments
                    );
                  }),
                  UY = ($.dynCall_viiiiij = function () {
                    return (UY = $.dynCall_viiiiij = $.asm.sb).apply(
                      null,
                      arguments
                    );
                  }),
                  LY = ($.dynCall_vjji = function () {
                    return (LY = $.dynCall_vjji = $.asm.tb).apply(
                      null,
                      arguments
                    );
                  }),
                  BY = ($.dynCall_viiijjjii = function () {
                    return (BY = $.dynCall_viiijjjii = $.asm.ub).apply(
                      null,
                      arguments
                    );
                  }),
                  KY = ($.dynCall_iij = function () {
                    return (KY = $.dynCall_iij = $.asm.vb).apply(
                      null,
                      arguments
                    );
                  }),
                  VY = ($.dynCall_ji = function () {
                    return (VY = $.dynCall_ji = $.asm.wb).apply(
                      null,
                      arguments
                    );
                  }),
                  FY = ($.dynCall_iiiiiij = function () {
                    return (FY = $.dynCall_iiiiiij = $.asm.xb).apply(
                      null,
                      arguments
                    );
                  }),
                  NY = ($.dynCall_iiij = function () {
                    return (NY = $.dynCall_iiij = $.asm.yb).apply(
                      null,
                      arguments
                    );
                  });
                function MY() {
                  function u() {
                    if (!o6 && ((o6 = !0), ($.calledRun = !0), !h)) {
                      if (
                        (j1(k),
                        B($),
                        $.onRuntimeInitialized && $.onRuntimeInitialized(),
                        $.postRun)
                      )
                        for (
                          typeof $.postRun == "function" &&
                          ($.postRun = [$.postRun]);
                          $.postRun.length;
                        ) {
                          var a = $.postRun.shift();
                          J0.unshift(a);
                        }
                      j1(J0);
                    }
                  }
                  if (!(0 < Y1)) {
                    if ($.preRun)
                      for (
                        typeof $.preRun == "function" &&
                        ($.preRun = [$.preRun]);
                        $.preRun.length;
                      )
                        A0();
                    (j1(v),
                      0 < Y1 ||
                        ($.setStatus
                          ? ($.setStatus("Running..."),
                            setTimeout(function () {
                              (setTimeout(function () {
                                $.setStatus("");
                              }, 1),
                                u());
                            }, 1))
                          : u()));
                  }
                }
                if (
                  (($.UTF8ToString = e),
                  ($.stringToUTF8 = function (u, a, Y0) {
                    return P(u, _, a, Y0);
                  }),
                  ($.lengthBytesUTF8 = x),
                  ($.stackSave = G1),
                  ($.stackRestore = J1),
                  ($.stackAlloc = GY),
                  (m = function u() {
                    (o6 || MY(), o6 || (m = u));
                  }),
                  $.preInit)
                )
                  for (
                    typeof $.preInit == "function" && ($.preInit = [$.preInit]);
                    0 < $.preInit.length;
                  )
                    $.preInit.pop()();
                return (MY(), U.ready);
              });
          X.exports = J;
        },
        4537: (X) => {
          X.exports = function (Y, Q) {
            for (
              var G = Array(arguments.length - 1), J = 0, U = 2, $ = !0;
              U < arguments.length;
            )
              G[J++] = arguments[U++];
            return new Promise(function (B, K) {
              G[J] = function (V) {
                if ($)
                  if ((($ = !1), V)) K(V);
                  else {
                    for (
                      var W = Array(arguments.length - 1), L = 0;
                      L < W.length;
                    )
                      W[L++] = arguments[L];
                    B.apply(null, W);
                  }
              };
              try {
                Y.apply(Q || null, G);
              } catch (V) {
                $ && (($ = !1), K(V));
              }
            });
          };
        },
        7419: (X, Y) => {
          var Q = Y;
          Q.length = function (B) {
            var K = B.length;
            if (!K) return 0;
            for (var V = 0; --K % 4 > 1 && B.charAt(K) === "="; ) ++V;
            return Math.ceil(3 * B.length) / 4 - V;
          };
          for (var G = Array(64), J = Array(123), U = 0; U < 64; )
            J[
              (G[U] =
                U < 26
                  ? U + 65
                  : U < 52
                    ? U + 71
                    : U < 62
                      ? U - 4
                      : (U - 59) | 43)
            ] = U++;
          Q.encode = function (B, K, V) {
            for (var W, L = null, H = [], F = 0, N = 0; K < V; ) {
              var q = B[K++];
              switch (N) {
                case 0:
                  ((H[F++] = G[q >> 2]), (W = (3 & q) << 4), (N = 1));
                  break;
                case 1:
                  ((H[F++] = G[W | (q >> 4)]), (W = (15 & q) << 2), (N = 2));
                  break;
                case 2:
                  ((H[F++] = G[W | (q >> 6)]), (H[F++] = G[63 & q]), (N = 0));
              }
              F > 8191 &&
                ((L || (L = [])).push(String.fromCharCode.apply(String, H)),
                (F = 0));
            }
            return (
              N && ((H[F++] = G[W]), (H[F++] = 61), N === 1 && (H[F++] = 61)),
              L
                ? (F &&
                    L.push(String.fromCharCode.apply(String, H.slice(0, F))),
                  L.join(""))
                : String.fromCharCode.apply(String, H.slice(0, F))
            );
          };
          var $ = "invalid encoding";
          ((Q.decode = function (B, K, V) {
            for (var W, L = V, H = 0, F = 0; F < B.length; ) {
              var N = B.charCodeAt(F++);
              if (N === 61 && H > 1) break;
              if ((N = J[N]) === void 0) throw Error($);
              switch (H) {
                case 0:
                  ((W = N), (H = 1));
                  break;
                case 1:
                  ((K[V++] = (W << 2) | ((48 & N) >> 4)), (W = N), (H = 2));
                  break;
                case 2:
                  ((K[V++] = ((15 & W) << 4) | ((60 & N) >> 2)),
                    (W = N),
                    (H = 3));
                  break;
                case 3:
                  ((K[V++] = ((3 & W) << 6) | N), (H = 0));
              }
            }
            if (H === 1) throw Error($);
            return V - L;
          }),
            (Q.test = function (B) {
              return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(
                B
              );
            }));
        },
        9211: (X) => {
          function Y() {
            this._listeners = {};
          }
          ((X.exports = Y),
            (Y.prototype.on = function (Q, G, J) {
              return (
                (this._listeners[Q] || (this._listeners[Q] = [])).push({
                  fn: G,
                  ctx: J || this,
                }),
                this
              );
            }),
            (Y.prototype.off = function (Q, G) {
              if (Q === void 0) this._listeners = {};
              else if (G === void 0) this._listeners[Q] = [];
              else
                for (var J = this._listeners[Q], U = 0; U < J.length; )
                  J[U].fn === G ? J.splice(U, 1) : ++U;
              return this;
            }),
            (Y.prototype.emit = function (Q) {
              var G = this._listeners[Q];
              if (G) {
                for (var J = [], U = 1; U < arguments.length; )
                  J.push(arguments[U++]);
                for (U = 0; U < G.length; ) G[U].fn.apply(G[U++].ctx, J);
              }
              return this;
            }));
        },
        945: (X) => {
          function Y($) {
            return (
              typeof Float32Array < "u"
                ? (function () {
                    var B = new Float32Array([-0]),
                      K = new Uint8Array(B.buffer),
                      V = K[3] === 128;
                    function W(N, q, M) {
                      ((B[0] = N),
                        (q[M] = K[0]),
                        (q[M + 1] = K[1]),
                        (q[M + 2] = K[2]),
                        (q[M + 3] = K[3]));
                    }
                    function L(N, q, M) {
                      ((B[0] = N),
                        (q[M] = K[3]),
                        (q[M + 1] = K[2]),
                        (q[M + 2] = K[1]),
                        (q[M + 3] = K[0]));
                    }
                    function H(N, q) {
                      return (
                        (K[0] = N[q]),
                        (K[1] = N[q + 1]),
                        (K[2] = N[q + 2]),
                        (K[3] = N[q + 3]),
                        B[0]
                      );
                    }
                    function F(N, q) {
                      return (
                        (K[3] = N[q]),
                        (K[2] = N[q + 1]),
                        (K[1] = N[q + 2]),
                        (K[0] = N[q + 3]),
                        B[0]
                      );
                    }
                    (($.writeFloatLE = V ? W : L),
                      ($.writeFloatBE = V ? L : W),
                      ($.readFloatLE = V ? H : F),
                      ($.readFloatBE = V ? F : H));
                  })()
                : (function () {
                    function B(V, W, L, H) {
                      var F = W < 0 ? 1 : 0;
                      if ((F && (W = -W), W === 0))
                        V(1 / W > 0 ? 0 : 2147483648, L, H);
                      else if (isNaN(W)) V(2143289344, L, H);
                      else if (W > 340282346638528860000000000000000000000)
                        V(((F << 31) | 2139095040) >>> 0, L, H);
                      else if (
                        W <
                        0.000000000000000000000000000000000000011754943508222875
                      )
                        V(
                          ((F << 31) |
                            Math.round(
                              W /
                                0.000000000000000000000000000000000000000000001401298464324817
                            )) >>>
                            0,
                          L,
                          H
                        );
                      else {
                        var N = Math.floor(Math.log(W) / Math.LN2);
                        V(
                          ((F << 31) |
                            ((N + 127) << 23) |
                            (8388607 &
                              Math.round(W * Math.pow(2, -N) * 8388608))) >>>
                            0,
                          L,
                          H
                        );
                      }
                    }
                    function K(V, W, L) {
                      var H = V(W, L),
                        F = 2 * (H >> 31) + 1,
                        N = (H >>> 23) & 255,
                        q = 8388607 & H;
                      return N === 255
                        ? q
                          ? NaN
                          : F * (1 / 0)
                        : N === 0
                          ? 0.000000000000000000000000000000000000000000001401298464324817 *
                            F *
                            q
                          : F * Math.pow(2, N - 150) * (q + 8388608);
                    }
                    (($.writeFloatLE = B.bind(null, Q)),
                      ($.writeFloatBE = B.bind(null, G)),
                      ($.readFloatLE = K.bind(null, J)),
                      ($.readFloatBE = K.bind(null, U)));
                  })(),
              typeof Float64Array < "u"
                ? (function () {
                    var B = new Float64Array([-0]),
                      K = new Uint8Array(B.buffer),
                      V = K[7] === 128;
                    function W(N, q, M) {
                      ((B[0] = N),
                        (q[M] = K[0]),
                        (q[M + 1] = K[1]),
                        (q[M + 2] = K[2]),
                        (q[M + 3] = K[3]),
                        (q[M + 4] = K[4]),
                        (q[M + 5] = K[5]),
                        (q[M + 6] = K[6]),
                        (q[M + 7] = K[7]));
                    }
                    function L(N, q, M) {
                      ((B[0] = N),
                        (q[M] = K[7]),
                        (q[M + 1] = K[6]),
                        (q[M + 2] = K[5]),
                        (q[M + 3] = K[4]),
                        (q[M + 4] = K[3]),
                        (q[M + 5] = K[2]),
                        (q[M + 6] = K[1]),
                        (q[M + 7] = K[0]));
                    }
                    function H(N, q) {
                      return (
                        (K[0] = N[q]),
                        (K[1] = N[q + 1]),
                        (K[2] = N[q + 2]),
                        (K[3] = N[q + 3]),
                        (K[4] = N[q + 4]),
                        (K[5] = N[q + 5]),
                        (K[6] = N[q + 6]),
                        (K[7] = N[q + 7]),
                        B[0]
                      );
                    }
                    function F(N, q) {
                      return (
                        (K[7] = N[q]),
                        (K[6] = N[q + 1]),
                        (K[5] = N[q + 2]),
                        (K[4] = N[q + 3]),
                        (K[3] = N[q + 4]),
                        (K[2] = N[q + 5]),
                        (K[1] = N[q + 6]),
                        (K[0] = N[q + 7]),
                        B[0]
                      );
                    }
                    (($.writeDoubleLE = V ? W : L),
                      ($.writeDoubleBE = V ? L : W),
                      ($.readDoubleLE = V ? H : F),
                      ($.readDoubleBE = V ? F : H));
                  })()
                : (function () {
                    function B(V, W, L, H, F, N) {
                      var q = H < 0 ? 1 : 0;
                      if ((q && (H = -H), H === 0))
                        (V(0, F, N + W),
                          V(1 / H > 0 ? 0 : 2147483648, F, N + L));
                      else if (isNaN(H))
                        (V(0, F, N + W), V(2146959360, F, N + L));
                      else if (
                        H >
                        179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
                      )
                        (V(0, F, N + W),
                          V(((q << 31) | 2146435072) >>> 0, F, N + L));
                      else {
                        var M;
                        if (
                          H <
                          0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022250738585072014
                        )
                          (V(
                            (M =
                              H /
                              0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005) >>>
                              0,
                            F,
                            N + W
                          ),
                            V(((q << 31) | (M / 4294967296)) >>> 0, F, N + L));
                        else {
                          var A = Math.floor(Math.log(H) / Math.LN2);
                          (A === 1024 && (A = 1023),
                            V(
                              (4503599627370496 * (M = H * Math.pow(2, -A))) >>>
                                0,
                              F,
                              N + W
                            ),
                            V(
                              ((q << 31) |
                                ((A + 1023) << 20) |
                                ((1048576 * M) & 1048575)) >>>
                                0,
                              F,
                              N + L
                            ));
                        }
                      }
                    }
                    function K(V, W, L, H, F) {
                      var N = V(H, F + W),
                        q = V(H, F + L),
                        M = 2 * (q >> 31) + 1,
                        A = (q >>> 20) & 2047,
                        D = 4294967296 * (1048575 & q) + N;
                      return A === 2047
                        ? D
                          ? NaN
                          : M * (1 / 0)
                        : A === 0
                          ? 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005 *
                            M *
                            D
                          : M * Math.pow(2, A - 1075) * (D + 4503599627370496);
                    }
                    (($.writeDoubleLE = B.bind(null, Q, 0, 4)),
                      ($.writeDoubleBE = B.bind(null, G, 4, 0)),
                      ($.readDoubleLE = K.bind(null, J, 0, 4)),
                      ($.readDoubleBE = K.bind(null, U, 4, 0)));
                  })(),
              $
            );
          }
          function Q($, B, K) {
            ((B[K] = 255 & $),
              (B[K + 1] = ($ >>> 8) & 255),
              (B[K + 2] = ($ >>> 16) & 255),
              (B[K + 3] = $ >>> 24));
          }
          function G($, B, K) {
            ((B[K] = $ >>> 24),
              (B[K + 1] = ($ >>> 16) & 255),
              (B[K + 2] = ($ >>> 8) & 255),
              (B[K + 3] = 255 & $));
          }
          function J($, B) {
            return (
              ($[B] | ($[B + 1] << 8) | ($[B + 2] << 16) | ($[B + 3] << 24)) >>>
              0
            );
          }
          function U($, B) {
            return (
              (($[B] << 24) | ($[B + 1] << 16) | ($[B + 2] << 8) | $[B + 3]) >>>
              0
            );
          }
          X.exports = Y(Y);
        },
        7199: (module) => {
          function inquire(moduleName) {
            try {
              var mod = eval("quire".replace(/^/, "re"))(moduleName);
              if (mod && (mod.length || Object.keys(mod).length)) return mod;
            } catch (X) {}
            return null;
          }
          module.exports = inquire;
        },
        6662: (X) => {
          X.exports = function (Y, Q, G) {
            var J = G || 8192,
              U = J >>> 1,
              $ = null,
              B = J;
            return function (K) {
              if (K < 1 || K > U) return Y(K);
              B + K > J && (($ = Y(J)), (B = 0));
              var V = Q.call($, B, (B += K));
              return (7 & B && (B = 1 + (7 | B)), V);
            };
          };
        },
        4997: (X, Y) => {
          var Q = Y;
          ((Q.length = function (G) {
            for (var J = 0, U = 0, $ = 0; $ < G.length; ++$)
              (U = G.charCodeAt($)) < 128
                ? (J += 1)
                : U < 2048
                  ? (J += 2)
                  : (64512 & U) == 55296 &&
                      (64512 & G.charCodeAt($ + 1)) == 56320
                    ? (++$, (J += 4))
                    : (J += 3);
            return J;
          }),
            (Q.read = function (G, J, U) {
              if (U - J < 1) return "";
              for (var $, B = null, K = [], V = 0; J < U; )
                (($ = G[J++]) < 128
                  ? (K[V++] = $)
                  : $ > 191 && $ < 224
                    ? (K[V++] = ((31 & $) << 6) | (63 & G[J++]))
                    : $ > 239 && $ < 365
                      ? (($ =
                          (((7 & $) << 18) |
                            ((63 & G[J++]) << 12) |
                            ((63 & G[J++]) << 6) |
                            (63 & G[J++])) -
                          65536),
                        (K[V++] = 55296 + ($ >> 10)),
                        (K[V++] = 56320 + (1023 & $)))
                      : (K[V++] =
                          ((15 & $) << 12) |
                          ((63 & G[J++]) << 6) |
                          (63 & G[J++])),
                  V > 8191 &&
                    ((B || (B = [])).push(String.fromCharCode.apply(String, K)),
                    (V = 0)));
              return B
                ? (V &&
                    B.push(String.fromCharCode.apply(String, K.slice(0, V))),
                  B.join(""))
                : String.fromCharCode.apply(String, K.slice(0, V));
            }),
            (Q.write = function (G, J, U) {
              for (var $, B, K = U, V = 0; V < G.length; ++V)
                ($ = G.charCodeAt(V)) < 128
                  ? (J[U++] = $)
                  : $ < 2048
                    ? ((J[U++] = ($ >> 6) | 192), (J[U++] = (63 & $) | 128))
                    : (64512 & $) == 55296 &&
                        (64512 & (B = G.charCodeAt(V + 1))) == 56320
                      ? (($ = 65536 + ((1023 & $) << 10) + (1023 & B)),
                        ++V,
                        (J[U++] = ($ >> 18) | 240),
                        (J[U++] = (($ >> 12) & 63) | 128),
                        (J[U++] = (($ >> 6) & 63) | 128),
                        (J[U++] = (63 & $) | 128))
                      : ((J[U++] = ($ >> 12) | 224),
                        (J[U++] = (($ >> 6) & 63) | 128),
                        (J[U++] = (63 & $) | 128));
              return U - K;
            }));
        },
        3442: (X, Y) => {
          Y.__esModule = !0;
          var Q = (function () {
            function G(J) {
              if (!J)
                throw TypeError("Invalid argument; `value` has no value.");
              ((this.value = G.EMPTY), J && G.isGuid(J) && (this.value = J));
            }
            return (
              (G.isGuid = function (J) {
                var U = J.toString();
                return J && (J instanceof G || G.validator.test(U));
              }),
              (G.create = function () {
                return new G(
                  [G.gen(2), G.gen(1), G.gen(1), G.gen(1), G.gen(3)].join("-")
                );
              }),
              (G.createEmpty = function () {
                return new G("emptyguid");
              }),
              (G.parse = function (J) {
                return new G(J);
              }),
              (G.raw = function () {
                return [G.gen(2), G.gen(1), G.gen(1), G.gen(1), G.gen(3)].join(
                  "-"
                );
              }),
              (G.gen = function (J) {
                for (var U = "", $ = 0; $ < J; $++)
                  U += ((65536 * (1 + Math.random())) | 0)
                    .toString(16)
                    .substring(1);
                return U;
              }),
              (G.prototype.equals = function (J) {
                return G.isGuid(J) && this.value === J.toString();
              }),
              (G.prototype.isEmpty = function () {
                return this.value === G.EMPTY;
              }),
              (G.prototype.toString = function () {
                return this.value;
              }),
              (G.prototype.toJSON = function () {
                return { value: this.value };
              }),
              (G.validator = new RegExp(
                "^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$",
                "i"
              )),
              (G.EMPTY = "00000000-0000-0000-0000-000000000000"),
              G
            );
          })();
          Y.Guid = Q;
        },
        3720: (X) => {
          X.exports = Q;
          var Y = null;
          try {
            Y = new WebAssembly.Instance(
              new WebAssembly.Module(
                new Uint8Array([
                  0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4,
                  127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6,
                  1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5,
                  100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3,
                  5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0,
                  5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1,
                  6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66,
                  32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126,
                  34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126,
                  32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3,
                  173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0,
                  32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32,
                  134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34,
                  4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32,
                  0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173,
                  66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4,
                  167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134,
                  132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66,
                  32, 135, 167, 36, 0, 32, 4, 167, 11,
                ])
              ),
              {}
            ).exports;
          } catch (w) {}
          function Q(w, I, T) {
            ((this.low = 0 | w), (this.high = 0 | I), (this.unsigned = !!T));
          }
          function G(w) {
            return (w && w.__isLong__) === !0;
          }
          (Q.prototype.__isLong__,
            Object.defineProperty(Q.prototype, "__isLong__", { value: !0 }),
            (Q.isLong = G));
          var J = {},
            U = {};
          function $(w, I) {
            var T, y, _;
            return I
              ? (_ = 0 <= (w >>>= 0) && w < 256) && (y = U[w])
                ? y
                : ((T = K(w, (0 | w) < 0 ? -1 : 0, !0)), _ && (U[w] = T), T)
              : (_ = -128 <= (w |= 0) && w < 128) && (y = J[w])
                ? y
                : ((T = K(w, w < 0 ? -1 : 0, !1)), _ && (J[w] = T), T);
          }
          function B(w, I) {
            if (isNaN(w)) return I ? A : M;
            if (I) {
              if (w < 0) return A;
              if (w >= F) return O;
            } else {
              if (w <= -N) return Z;
              if (w + 1 >= N) return E;
            }
            return w < 0 ? B(-w, I).neg() : K((w % H) | 0, (w / H) | 0, I);
          }
          function K(w, I, T) {
            return new Q(w, I, T);
          }
          ((Q.fromInt = $), (Q.fromNumber = B), (Q.fromBits = K));
          var V = Math.pow;
          function W(w, I, T) {
            if (w.length === 0) throw Error("empty string");
            if (
              w === "NaN" ||
              w === "Infinity" ||
              w === "+Infinity" ||
              w === "-Infinity"
            )
              return M;
            if (
              (typeof I == "number" ? ((T = I), (I = !1)) : (I = !!I),
              (T = T || 10) < 2 || 36 < T)
            )
              throw RangeError("radix");
            var y;
            if ((y = w.indexOf("-")) > 0) throw Error("interior hyphen");
            if (y === 0) return W(w.substring(1), I, T).neg();
            for (var _ = B(V(T, 8)), f = M, l = 0; l < w.length; l += 8) {
              var h = Math.min(8, w.length - l),
                p = parseInt(w.substring(l, l + h), T);
              if (h < 8) {
                var N0 = B(V(T, h));
                f = f.mul(N0).add(B(p));
              } else f = (f = f.mul(_)).add(B(p));
            }
            return ((f.unsigned = I), f);
          }
          function L(w, I) {
            return typeof w == "number"
              ? B(w, I)
              : typeof w == "string"
                ? W(w, I)
                : K(w.low, w.high, typeof I == "boolean" ? I : w.unsigned);
          }
          ((Q.fromString = W), (Q.fromValue = L));
          var H = 4294967296,
            F = H * H,
            N = F / 2,
            q = $(16777216),
            M = $(0);
          Q.ZERO = M;
          var A = $(0, !0);
          Q.UZERO = A;
          var D = $(1);
          Q.ONE = D;
          var R = $(1, !0);
          Q.UONE = R;
          var z = $(-1);
          Q.NEG_ONE = z;
          var E = K(-1, 2147483647, !1);
          Q.MAX_VALUE = E;
          var O = K(-1, -1, !0);
          Q.MAX_UNSIGNED_VALUE = O;
          var Z = K(0, -2147483648, !1);
          Q.MIN_VALUE = Z;
          var j = Q.prototype;
          ((j.toInt = function () {
            return this.unsigned ? this.low >>> 0 : this.low;
          }),
            (j.toNumber = function () {
              return this.unsigned
                ? (this.high >>> 0) * H + (this.low >>> 0)
                : this.high * H + (this.low >>> 0);
            }),
            (j.toString = function (w) {
              if ((w = w || 10) < 2 || 36 < w) throw RangeError("radix");
              if (this.isZero()) return "0";
              if (this.isNegative()) {
                if (this.eq(Z)) {
                  var I = B(w),
                    T = this.div(I),
                    y = T.mul(I).sub(this);
                  return T.toString(w) + y.toInt().toString(w);
                }
                return "-" + this.neg().toString(w);
              }
              for (var _ = B(V(w, 6), this.unsigned), f = this, l = ""; ; ) {
                var h = f.div(_),
                  p = (f.sub(h.mul(_)).toInt() >>> 0).toString(w);
                if ((f = h).isZero()) return p + l;
                for (; p.length < 6; ) p = "0" + p;
                l = "" + p + l;
              }
            }),
            (j.getHighBits = function () {
              return this.high;
            }),
            (j.getHighBitsUnsigned = function () {
              return this.high >>> 0;
            }),
            (j.getLowBits = function () {
              return this.low;
            }),
            (j.getLowBitsUnsigned = function () {
              return this.low >>> 0;
            }),
            (j.getNumBitsAbs = function () {
              if (this.isNegative())
                return this.eq(Z) ? 64 : this.neg().getNumBitsAbs();
              for (
                var w = this.high != 0 ? this.high : this.low, I = 31;
                I > 0 && (w & (1 << I)) == 0;
                I--
              );
              return this.high != 0 ? I + 33 : I + 1;
            }),
            (j.isZero = function () {
              return this.high === 0 && this.low === 0;
            }),
            (j.eqz = j.isZero),
            (j.isNegative = function () {
              return !this.unsigned && this.high < 0;
            }),
            (j.isPositive = function () {
              return this.unsigned || this.high >= 0;
            }),
            (j.isOdd = function () {
              return (1 & this.low) == 1;
            }),
            (j.isEven = function () {
              return (1 & this.low) == 0;
            }),
            (j.equals = function (w) {
              return (
                G(w) || (w = L(w)),
                (this.unsigned === w.unsigned ||
                  this.high >>> 31 != 1 ||
                  w.high >>> 31 != 1) &&
                  this.high === w.high &&
                  this.low === w.low
              );
            }),
            (j.eq = j.equals),
            (j.notEquals = function (w) {
              return !this.eq(w);
            }),
            (j.neq = j.notEquals),
            (j.ne = j.notEquals),
            (j.lessThan = function (w) {
              return this.comp(w) < 0;
            }),
            (j.lt = j.lessThan),
            (j.lessThanOrEqual = function (w) {
              return this.comp(w) <= 0;
            }),
            (j.lte = j.lessThanOrEqual),
            (j.le = j.lessThanOrEqual),
            (j.greaterThan = function (w) {
              return this.comp(w) > 0;
            }),
            (j.gt = j.greaterThan),
            (j.greaterThanOrEqual = function (w) {
              return this.comp(w) >= 0;
            }),
            (j.gte = j.greaterThanOrEqual),
            (j.ge = j.greaterThanOrEqual),
            (j.compare = function (w) {
              if ((G(w) || (w = L(w)), this.eq(w))) return 0;
              var I = this.isNegative(),
                T = w.isNegative();
              return I && !T
                ? -1
                : !I && T
                  ? 1
                  : this.unsigned
                    ? w.high >>> 0 > this.high >>> 0 ||
                      (w.high === this.high && w.low >>> 0 > this.low >>> 0)
                      ? -1
                      : 1
                    : this.sub(w).isNegative()
                      ? -1
                      : 1;
            }),
            (j.comp = j.compare),
            (j.negate = function () {
              return !this.unsigned && this.eq(Z) ? Z : this.not().add(D);
            }),
            (j.neg = j.negate),
            (j.add = function (w) {
              G(w) || (w = L(w));
              var I = this.high >>> 16,
                T = 65535 & this.high,
                y = this.low >>> 16,
                _ = 65535 & this.low,
                f = w.high >>> 16,
                l = 65535 & w.high,
                h = w.low >>> 16,
                p = 0,
                N0 = 0,
                e = 0,
                P = 0;
              return (
                (e += (P += _ + (65535 & w.low)) >>> 16),
                (N0 += (e += y + h) >>> 16),
                (p += (N0 += T + l) >>> 16),
                (p += I + f),
                K(
                  ((e &= 65535) << 16) | (P &= 65535),
                  ((p &= 65535) << 16) | (N0 &= 65535),
                  this.unsigned
                )
              );
            }),
            (j.subtract = function (w) {
              return (G(w) || (w = L(w)), this.add(w.neg()));
            }),
            (j.sub = j.subtract),
            (j.multiply = function (w) {
              if (this.isZero()) return M;
              if ((G(w) || (w = L(w)), Y))
                return K(
                  Y.mul(this.low, this.high, w.low, w.high),
                  Y.get_high(),
                  this.unsigned
                );
              if (w.isZero()) return M;
              if (this.eq(Z)) return w.isOdd() ? Z : M;
              if (w.eq(Z)) return this.isOdd() ? Z : M;
              if (this.isNegative())
                return w.isNegative()
                  ? this.neg().mul(w.neg())
                  : this.neg().mul(w).neg();
              if (w.isNegative()) return this.mul(w.neg()).neg();
              if (this.lt(q) && w.lt(q))
                return B(this.toNumber() * w.toNumber(), this.unsigned);
              var I = this.high >>> 16,
                T = 65535 & this.high,
                y = this.low >>> 16,
                _ = 65535 & this.low,
                f = w.high >>> 16,
                l = 65535 & w.high,
                h = w.low >>> 16,
                p = 65535 & w.low,
                N0 = 0,
                e = 0,
                P = 0,
                x = 0;
              return (
                (P += (x += _ * p) >>> 16),
                (e += (P += y * p) >>> 16),
                (P &= 65535),
                (e += (P += _ * h) >>> 16),
                (N0 += (e += T * p) >>> 16),
                (e &= 65535),
                (N0 += (e += y * h) >>> 16),
                (e &= 65535),
                (N0 += (e += _ * l) >>> 16),
                (N0 += I * p + T * h + y * l + _ * f),
                K(
                  ((P &= 65535) << 16) | (x &= 65535),
                  ((N0 &= 65535) << 16) | (e &= 65535),
                  this.unsigned
                )
              );
            }),
            (j.mul = j.multiply),
            (j.divide = function (w) {
              if ((G(w) || (w = L(w)), w.isZero()))
                throw Error("division by zero");
              var I, T, y;
              if (Y)
                return this.unsigned ||
                  this.high !== -2147483648 ||
                  w.low !== -1 ||
                  w.high !== -1
                  ? K(
                      (this.unsigned ? Y.div_u : Y.div_s)(
                        this.low,
                        this.high,
                        w.low,
                        w.high
                      ),
                      Y.get_high(),
                      this.unsigned
                    )
                  : this;
              if (this.isZero()) return this.unsigned ? A : M;
              if (this.unsigned) {
                if ((w.unsigned || (w = w.toUnsigned()), w.gt(this))) return A;
                if (w.gt(this.shru(1))) return R;
                y = A;
              } else {
                if (this.eq(Z))
                  return w.eq(D) || w.eq(z)
                    ? Z
                    : w.eq(Z)
                      ? D
                      : (I = this.shr(1).div(w).shl(1)).eq(M)
                        ? w.isNegative()
                          ? D
                          : z
                        : ((T = this.sub(w.mul(I))), (y = I.add(T.div(w))));
                if (w.eq(Z)) return this.unsigned ? A : M;
                if (this.isNegative())
                  return w.isNegative()
                    ? this.neg().div(w.neg())
                    : this.neg().div(w).neg();
                if (w.isNegative()) return this.div(w.neg()).neg();
                y = M;
              }
              for (T = this; T.gte(w); ) {
                I = Math.max(1, Math.floor(T.toNumber() / w.toNumber()));
                for (
                  var _ = Math.ceil(Math.log(I) / Math.LN2),
                    f = _ <= 48 ? 1 : V(2, _ - 48),
                    l = B(I),
                    h = l.mul(w);
                  h.isNegative() || h.gt(T);
                )
                  h = (l = B((I -= f), this.unsigned)).mul(w);
                (l.isZero() && (l = D), (y = y.add(l)), (T = T.sub(h)));
              }
              return y;
            }),
            (j.div = j.divide),
            (j.modulo = function (w) {
              return (
                G(w) || (w = L(w)),
                Y
                  ? K(
                      (this.unsigned ? Y.rem_u : Y.rem_s)(
                        this.low,
                        this.high,
                        w.low,
                        w.high
                      ),
                      Y.get_high(),
                      this.unsigned
                    )
                  : this.sub(this.div(w).mul(w))
              );
            }),
            (j.mod = j.modulo),
            (j.rem = j.modulo),
            (j.not = function () {
              return K(~this.low, ~this.high, this.unsigned);
            }),
            (j.and = function (w) {
              return (
                G(w) || (w = L(w)),
                K(this.low & w.low, this.high & w.high, this.unsigned)
              );
            }),
            (j.or = function (w) {
              return (
                G(w) || (w = L(w)),
                K(this.low | w.low, this.high | w.high, this.unsigned)
              );
            }),
            (j.xor = function (w) {
              return (
                G(w) || (w = L(w)),
                K(this.low ^ w.low, this.high ^ w.high, this.unsigned)
              );
            }),
            (j.shiftLeft = function (w) {
              return (
                G(w) && (w = w.toInt()),
                (w &= 63) == 0
                  ? this
                  : w < 32
                    ? K(
                        this.low << w,
                        (this.high << w) | (this.low >>> (32 - w)),
                        this.unsigned
                      )
                    : K(0, this.low << (w - 32), this.unsigned)
              );
            }),
            (j.shl = j.shiftLeft),
            (j.shiftRight = function (w) {
              return (
                G(w) && (w = w.toInt()),
                (w &= 63) == 0
                  ? this
                  : w < 32
                    ? K(
                        (this.low >>> w) | (this.high << (32 - w)),
                        this.high >> w,
                        this.unsigned
                      )
                    : K(
                        this.high >> (w - 32),
                        this.high >= 0 ? 0 : -1,
                        this.unsigned
                      )
              );
            }),
            (j.shr = j.shiftRight),
            (j.shiftRightUnsigned = function (w) {
              if ((G(w) && (w = w.toInt()), (w &= 63) == 0)) return this;
              var I = this.high;
              return w < 32
                ? K((this.low >>> w) | (I << (32 - w)), I >>> w, this.unsigned)
                : K(w === 32 ? I : I >>> (w - 32), 0, this.unsigned);
            }),
            (j.shru = j.shiftRightUnsigned),
            (j.shr_u = j.shiftRightUnsigned),
            (j.toSigned = function () {
              return this.unsigned ? K(this.low, this.high, !1) : this;
            }),
            (j.toUnsigned = function () {
              return this.unsigned ? this : K(this.low, this.high, !0);
            }),
            (j.toBytes = function (w) {
              return w ? this.toBytesLE() : this.toBytesBE();
            }),
            (j.toBytesLE = function () {
              var w = this.high,
                I = this.low;
              return [
                255 & I,
                (I >>> 8) & 255,
                (I >>> 16) & 255,
                I >>> 24,
                255 & w,
                (w >>> 8) & 255,
                (w >>> 16) & 255,
                w >>> 24,
              ];
            }),
            (j.toBytesBE = function () {
              var w = this.high,
                I = this.low;
              return [
                w >>> 24,
                (w >>> 16) & 255,
                (w >>> 8) & 255,
                255 & w,
                I >>> 24,
                (I >>> 16) & 255,
                (I >>> 8) & 255,
                255 & I,
              ];
            }),
            (Q.fromBytes = function (w, I, T) {
              return T ? Q.fromBytesLE(w, I) : Q.fromBytesBE(w, I);
            }),
            (Q.fromBytesLE = function (w, I) {
              return new Q(
                w[0] | (w[1] << 8) | (w[2] << 16) | (w[3] << 24),
                w[4] | (w[5] << 8) | (w[6] << 16) | (w[7] << 24),
                I
              );
            }),
            (Q.fromBytesBE = function (w, I) {
              return new Q(
                (w[4] << 24) | (w[5] << 16) | (w[6] << 8) | w[7],
                (w[0] << 24) | (w[1] << 16) | (w[2] << 8) | w[3],
                I
              );
            }));
        },
        1446: (X, Y, Q) => {
          var G,
            J,
            U,
            $ = Q(2100),
            B = $.Reader,
            K = $.Writer,
            V = $.util,
            W = $.roots.default || ($.roots.default = {});
          ((W.onnx =
            (((U = {}).Version =
              ((G = {}),
              ((J = Object.create(G))[(G[0] = "_START_VERSION")] = 0),
              (J[(G[1] = "IR_VERSION_2017_10_10")] = 1),
              (J[(G[2] = "IR_VERSION_2017_10_30")] = 2),
              (J[(G[3] = "IR_VERSION_2017_11_3")] = 3),
              (J[(G[4] = "IR_VERSION_2019_1_22")] = 4),
              (J[(G[5] = "IR_VERSION")] = 5),
              J)),
            (U.AttributeProto = (function () {
              function L(H) {
                if (
                  ((this.floats = []),
                  (this.ints = []),
                  (this.strings = []),
                  (this.tensors = []),
                  (this.graphs = []),
                  H)
                )
                  for (var F = Object.keys(H), N = 0; N < F.length; ++N)
                    H[F[N]] != null && (this[F[N]] = H[F[N]]);
              }
              return (
                (L.prototype.name = ""),
                (L.prototype.refAttrName = ""),
                (L.prototype.docString = ""),
                (L.prototype.type = 0),
                (L.prototype.f = 0),
                (L.prototype.i = V.Long ? V.Long.fromBits(0, 0, !1) : 0),
                (L.prototype.s = V.newBuffer([])),
                (L.prototype.t = null),
                (L.prototype.g = null),
                (L.prototype.floats = V.emptyArray),
                (L.prototype.ints = V.emptyArray),
                (L.prototype.strings = V.emptyArray),
                (L.prototype.tensors = V.emptyArray),
                (L.prototype.graphs = V.emptyArray),
                (L.create = function (H) {
                  return new L(H);
                }),
                (L.encode = function (H, F) {
                  if (
                    (F || (F = K.create()),
                    H.name != null &&
                      H.hasOwnProperty("name") &&
                      F.uint32(10).string(H.name),
                    H.f != null &&
                      H.hasOwnProperty("f") &&
                      F.uint32(21).float(H.f),
                    H.i != null &&
                      H.hasOwnProperty("i") &&
                      F.uint32(24).int64(H.i),
                    H.s != null &&
                      H.hasOwnProperty("s") &&
                      F.uint32(34).bytes(H.s),
                    H.t != null &&
                      H.hasOwnProperty("t") &&
                      W.onnx.TensorProto.encode(
                        H.t,
                        F.uint32(42).fork()
                      ).ldelim(),
                    H.g != null &&
                      H.hasOwnProperty("g") &&
                      W.onnx.GraphProto.encode(
                        H.g,
                        F.uint32(50).fork()
                      ).ldelim(),
                    H.floats != null && H.floats.length)
                  ) {
                    F.uint32(58).fork();
                    for (var N = 0; N < H.floats.length; ++N)
                      F.float(H.floats[N]);
                    F.ldelim();
                  }
                  if (H.ints != null && H.ints.length) {
                    for (F.uint32(66).fork(), N = 0; N < H.ints.length; ++N)
                      F.int64(H.ints[N]);
                    F.ldelim();
                  }
                  if (H.strings != null && H.strings.length)
                    for (N = 0; N < H.strings.length; ++N)
                      F.uint32(74).bytes(H.strings[N]);
                  if (H.tensors != null && H.tensors.length)
                    for (N = 0; N < H.tensors.length; ++N)
                      W.onnx.TensorProto.encode(
                        H.tensors[N],
                        F.uint32(82).fork()
                      ).ldelim();
                  if (H.graphs != null && H.graphs.length)
                    for (N = 0; N < H.graphs.length; ++N)
                      W.onnx.GraphProto.encode(
                        H.graphs[N],
                        F.uint32(90).fork()
                      ).ldelim();
                  return (
                    H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      F.uint32(106).string(H.docString),
                    H.type != null &&
                      H.hasOwnProperty("type") &&
                      F.uint32(160).int32(H.type),
                    H.refAttrName != null &&
                      H.hasOwnProperty("refAttrName") &&
                      F.uint32(170).string(H.refAttrName),
                    F
                  );
                }),
                (L.encodeDelimited = function (H, F) {
                  return this.encode(H, F).ldelim();
                }),
                (L.decode = function (H, F) {
                  H instanceof B || (H = B.create(H));
                  for (
                    var N = F === void 0 ? H.len : H.pos + F,
                      q = new W.onnx.AttributeProto();
                    H.pos < N;
                  ) {
                    var M = H.uint32();
                    switch (M >>> 3) {
                      case 1:
                        q.name = H.string();
                        break;
                      case 21:
                        q.refAttrName = H.string();
                        break;
                      case 13:
                        q.docString = H.string();
                        break;
                      case 20:
                        q.type = H.int32();
                        break;
                      case 2:
                        q.f = H.float();
                        break;
                      case 3:
                        q.i = H.int64();
                        break;
                      case 4:
                        q.s = H.bytes();
                        break;
                      case 5:
                        q.t = W.onnx.TensorProto.decode(H, H.uint32());
                        break;
                      case 6:
                        q.g = W.onnx.GraphProto.decode(H, H.uint32());
                        break;
                      case 7:
                        if (
                          ((q.floats && q.floats.length) || (q.floats = []),
                          (7 & M) == 2)
                        )
                          for (var A = H.uint32() + H.pos; H.pos < A; )
                            q.floats.push(H.float());
                        else q.floats.push(H.float());
                        break;
                      case 8:
                        if (
                          ((q.ints && q.ints.length) || (q.ints = []),
                          (7 & M) == 2)
                        )
                          for (A = H.uint32() + H.pos; H.pos < A; )
                            q.ints.push(H.int64());
                        else q.ints.push(H.int64());
                        break;
                      case 9:
                        ((q.strings && q.strings.length) || (q.strings = []),
                          q.strings.push(H.bytes()));
                        break;
                      case 10:
                        ((q.tensors && q.tensors.length) || (q.tensors = []),
                          q.tensors.push(
                            W.onnx.TensorProto.decode(H, H.uint32())
                          ));
                        break;
                      case 11:
                        ((q.graphs && q.graphs.length) || (q.graphs = []),
                          q.graphs.push(
                            W.onnx.GraphProto.decode(H, H.uint32())
                          ));
                        break;
                      default:
                        H.skipType(7 & M);
                    }
                  }
                  return q;
                }),
                (L.decodeDelimited = function (H) {
                  return (
                    H instanceof B || (H = new B(H)),
                    this.decode(H, H.uint32())
                  );
                }),
                (L.verify = function (H) {
                  if (typeof H != "object" || H === null)
                    return "object expected";
                  if (
                    H.name != null &&
                    H.hasOwnProperty("name") &&
                    !V.isString(H.name)
                  )
                    return "name: string expected";
                  if (
                    H.refAttrName != null &&
                    H.hasOwnProperty("refAttrName") &&
                    !V.isString(H.refAttrName)
                  )
                    return "refAttrName: string expected";
                  if (
                    H.docString != null &&
                    H.hasOwnProperty("docString") &&
                    !V.isString(H.docString)
                  )
                    return "docString: string expected";
                  if (H.type != null && H.hasOwnProperty("type"))
                    switch (H.type) {
                      default:
                        return "type: enum value expected";
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                      case 8:
                      case 9:
                      case 10:
                    }
                  if (
                    H.f != null &&
                    H.hasOwnProperty("f") &&
                    typeof H.f != "number"
                  )
                    return "f: number expected";
                  if (
                    H.i != null &&
                    H.hasOwnProperty("i") &&
                    !(
                      V.isInteger(H.i) ||
                      (H.i && V.isInteger(H.i.low) && V.isInteger(H.i.high))
                    )
                  )
                    return "i: integer|Long expected";
                  if (
                    H.s != null &&
                    H.hasOwnProperty("s") &&
                    !((H.s && typeof H.s.length == "number") || V.isString(H.s))
                  )
                    return "s: buffer expected";
                  if (
                    H.t != null &&
                    H.hasOwnProperty("t") &&
                    (N = W.onnx.TensorProto.verify(H.t))
                  )
                    return "t." + N;
                  if (
                    H.g != null &&
                    H.hasOwnProperty("g") &&
                    (N = W.onnx.GraphProto.verify(H.g))
                  )
                    return "g." + N;
                  if (H.floats != null && H.hasOwnProperty("floats")) {
                    if (!Array.isArray(H.floats))
                      return "floats: array expected";
                    for (var F = 0; F < H.floats.length; ++F)
                      if (typeof H.floats[F] != "number")
                        return "floats: number[] expected";
                  }
                  if (H.ints != null && H.hasOwnProperty("ints")) {
                    if (!Array.isArray(H.ints)) return "ints: array expected";
                    for (F = 0; F < H.ints.length; ++F)
                      if (
                        !(
                          V.isInteger(H.ints[F]) ||
                          (H.ints[F] &&
                            V.isInteger(H.ints[F].low) &&
                            V.isInteger(H.ints[F].high))
                        )
                      )
                        return "ints: integer|Long[] expected";
                  }
                  if (H.strings != null && H.hasOwnProperty("strings")) {
                    if (!Array.isArray(H.strings))
                      return "strings: array expected";
                    for (F = 0; F < H.strings.length; ++F)
                      if (
                        !(
                          (H.strings[F] &&
                            typeof H.strings[F].length == "number") ||
                          V.isString(H.strings[F])
                        )
                      )
                        return "strings: buffer[] expected";
                  }
                  if (H.tensors != null && H.hasOwnProperty("tensors")) {
                    if (!Array.isArray(H.tensors))
                      return "tensors: array expected";
                    for (F = 0; F < H.tensors.length; ++F)
                      if ((N = W.onnx.TensorProto.verify(H.tensors[F])))
                        return "tensors." + N;
                  }
                  if (H.graphs != null && H.hasOwnProperty("graphs")) {
                    if (!Array.isArray(H.graphs))
                      return "graphs: array expected";
                    for (F = 0; F < H.graphs.length; ++F) {
                      var N;
                      if ((N = W.onnx.GraphProto.verify(H.graphs[F])))
                        return "graphs." + N;
                    }
                  }
                  return null;
                }),
                (L.fromObject = function (H) {
                  if (H instanceof W.onnx.AttributeProto) return H;
                  var F = new W.onnx.AttributeProto();
                  switch (
                    (H.name != null && (F.name = String(H.name)),
                    H.refAttrName != null &&
                      (F.refAttrName = String(H.refAttrName)),
                    H.docString != null && (F.docString = String(H.docString)),
                    H.type)
                  ) {
                    case "UNDEFINED":
                    case 0:
                      F.type = 0;
                      break;
                    case "FLOAT":
                    case 1:
                      F.type = 1;
                      break;
                    case "INT":
                    case 2:
                      F.type = 2;
                      break;
                    case "STRING":
                    case 3:
                      F.type = 3;
                      break;
                    case "TENSOR":
                    case 4:
                      F.type = 4;
                      break;
                    case "GRAPH":
                    case 5:
                      F.type = 5;
                      break;
                    case "FLOATS":
                    case 6:
                      F.type = 6;
                      break;
                    case "INTS":
                    case 7:
                      F.type = 7;
                      break;
                    case "STRINGS":
                    case 8:
                      F.type = 8;
                      break;
                    case "TENSORS":
                    case 9:
                      F.type = 9;
                      break;
                    case "GRAPHS":
                    case 10:
                      F.type = 10;
                  }
                  if (
                    (H.f != null && (F.f = Number(H.f)),
                    H.i != null &&
                      (V.Long
                        ? ((F.i = V.Long.fromValue(H.i)).unsigned = !1)
                        : typeof H.i == "string"
                          ? (F.i = parseInt(H.i, 10))
                          : typeof H.i == "number"
                            ? (F.i = H.i)
                            : typeof H.i == "object" &&
                              (F.i = new V.LongBits(
                                H.i.low >>> 0,
                                H.i.high >>> 0
                              ).toNumber())),
                    H.s != null &&
                      (typeof H.s == "string"
                        ? V.base64.decode(
                            H.s,
                            (F.s = V.newBuffer(V.base64.length(H.s))),
                            0
                          )
                        : H.s.length && (F.s = H.s)),
                    H.t != null)
                  ) {
                    if (typeof H.t != "object")
                      throw TypeError(
                        ".onnx.AttributeProto.t: object expected"
                      );
                    F.t = W.onnx.TensorProto.fromObject(H.t);
                  }
                  if (H.g != null) {
                    if (typeof H.g != "object")
                      throw TypeError(
                        ".onnx.AttributeProto.g: object expected"
                      );
                    F.g = W.onnx.GraphProto.fromObject(H.g);
                  }
                  if (H.floats) {
                    if (!Array.isArray(H.floats))
                      throw TypeError(
                        ".onnx.AttributeProto.floats: array expected"
                      );
                    F.floats = [];
                    for (var N = 0; N < H.floats.length; ++N)
                      F.floats[N] = Number(H.floats[N]);
                  }
                  if (H.ints) {
                    if (!Array.isArray(H.ints))
                      throw TypeError(
                        ".onnx.AttributeProto.ints: array expected"
                      );
                    for (F.ints = [], N = 0; N < H.ints.length; ++N)
                      V.Long
                        ? ((F.ints[N] = V.Long.fromValue(H.ints[N])).unsigned =
                            !1)
                        : typeof H.ints[N] == "string"
                          ? (F.ints[N] = parseInt(H.ints[N], 10))
                          : typeof H.ints[N] == "number"
                            ? (F.ints[N] = H.ints[N])
                            : typeof H.ints[N] == "object" &&
                              (F.ints[N] = new V.LongBits(
                                H.ints[N].low >>> 0,
                                H.ints[N].high >>> 0
                              ).toNumber());
                  }
                  if (H.strings) {
                    if (!Array.isArray(H.strings))
                      throw TypeError(
                        ".onnx.AttributeProto.strings: array expected"
                      );
                    for (F.strings = [], N = 0; N < H.strings.length; ++N)
                      typeof H.strings[N] == "string"
                        ? V.base64.decode(
                            H.strings[N],
                            (F.strings[N] = V.newBuffer(
                              V.base64.length(H.strings[N])
                            )),
                            0
                          )
                        : H.strings[N].length && (F.strings[N] = H.strings[N]);
                  }
                  if (H.tensors) {
                    if (!Array.isArray(H.tensors))
                      throw TypeError(
                        ".onnx.AttributeProto.tensors: array expected"
                      );
                    for (F.tensors = [], N = 0; N < H.tensors.length; ++N) {
                      if (typeof H.tensors[N] != "object")
                        throw TypeError(
                          ".onnx.AttributeProto.tensors: object expected"
                        );
                      F.tensors[N] = W.onnx.TensorProto.fromObject(
                        H.tensors[N]
                      );
                    }
                  }
                  if (H.graphs) {
                    if (!Array.isArray(H.graphs))
                      throw TypeError(
                        ".onnx.AttributeProto.graphs: array expected"
                      );
                    for (F.graphs = [], N = 0; N < H.graphs.length; ++N) {
                      if (typeof H.graphs[N] != "object")
                        throw TypeError(
                          ".onnx.AttributeProto.graphs: object expected"
                        );
                      F.graphs[N] = W.onnx.GraphProto.fromObject(H.graphs[N]);
                    }
                  }
                  return F;
                }),
                (L.toObject = function (H, F) {
                  F || (F = {});
                  var N = {};
                  if (
                    ((F.arrays || F.defaults) &&
                      ((N.floats = []),
                      (N.ints = []),
                      (N.strings = []),
                      (N.tensors = []),
                      (N.graphs = [])),
                    F.defaults)
                  ) {
                    if (((N.name = ""), (N.f = 0), V.Long)) {
                      var q = new V.Long(0, 0, !1);
                      N.i =
                        F.longs === String
                          ? q.toString()
                          : F.longs === Number
                            ? q.toNumber()
                            : q;
                    } else N.i = F.longs === String ? "0" : 0;
                    (F.bytes === String
                      ? (N.s = "")
                      : ((N.s = []),
                        F.bytes !== Array && (N.s = V.newBuffer(N.s))),
                      (N.t = null),
                      (N.g = null),
                      (N.docString = ""),
                      (N.type = F.enums === String ? "UNDEFINED" : 0),
                      (N.refAttrName = ""));
                  }
                  if (
                    (H.name != null &&
                      H.hasOwnProperty("name") &&
                      (N.name = H.name),
                    H.f != null &&
                      H.hasOwnProperty("f") &&
                      (N.f = F.json && !isFinite(H.f) ? String(H.f) : H.f),
                    H.i != null &&
                      H.hasOwnProperty("i") &&
                      (typeof H.i == "number"
                        ? (N.i = F.longs === String ? String(H.i) : H.i)
                        : (N.i =
                            F.longs === String
                              ? V.Long.prototype.toString.call(H.i)
                              : F.longs === Number
                                ? new V.LongBits(
                                    H.i.low >>> 0,
                                    H.i.high >>> 0
                                  ).toNumber()
                                : H.i)),
                    H.s != null &&
                      H.hasOwnProperty("s") &&
                      (N.s =
                        F.bytes === String
                          ? V.base64.encode(H.s, 0, H.s.length)
                          : F.bytes === Array
                            ? Array.prototype.slice.call(H.s)
                            : H.s),
                    H.t != null &&
                      H.hasOwnProperty("t") &&
                      (N.t = W.onnx.TensorProto.toObject(H.t, F)),
                    H.g != null &&
                      H.hasOwnProperty("g") &&
                      (N.g = W.onnx.GraphProto.toObject(H.g, F)),
                    H.floats && H.floats.length)
                  ) {
                    N.floats = [];
                    for (var M = 0; M < H.floats.length; ++M)
                      N.floats[M] =
                        F.json && !isFinite(H.floats[M])
                          ? String(H.floats[M])
                          : H.floats[M];
                  }
                  if (H.ints && H.ints.length)
                    for (N.ints = [], M = 0; M < H.ints.length; ++M)
                      typeof H.ints[M] == "number"
                        ? (N.ints[M] =
                            F.longs === String ? String(H.ints[M]) : H.ints[M])
                        : (N.ints[M] =
                            F.longs === String
                              ? V.Long.prototype.toString.call(H.ints[M])
                              : F.longs === Number
                                ? new V.LongBits(
                                    H.ints[M].low >>> 0,
                                    H.ints[M].high >>> 0
                                  ).toNumber()
                                : H.ints[M]);
                  if (H.strings && H.strings.length)
                    for (N.strings = [], M = 0; M < H.strings.length; ++M)
                      N.strings[M] =
                        F.bytes === String
                          ? V.base64.encode(
                              H.strings[M],
                              0,
                              H.strings[M].length
                            )
                          : F.bytes === Array
                            ? Array.prototype.slice.call(H.strings[M])
                            : H.strings[M];
                  if (H.tensors && H.tensors.length)
                    for (N.tensors = [], M = 0; M < H.tensors.length; ++M)
                      N.tensors[M] = W.onnx.TensorProto.toObject(
                        H.tensors[M],
                        F
                      );
                  if (H.graphs && H.graphs.length)
                    for (N.graphs = [], M = 0; M < H.graphs.length; ++M)
                      N.graphs[M] = W.onnx.GraphProto.toObject(H.graphs[M], F);
                  return (
                    H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      (N.docString = H.docString),
                    H.type != null &&
                      H.hasOwnProperty("type") &&
                      (N.type =
                        F.enums === String
                          ? W.onnx.AttributeProto.AttributeType[H.type]
                          : H.type),
                    H.refAttrName != null &&
                      H.hasOwnProperty("refAttrName") &&
                      (N.refAttrName = H.refAttrName),
                    N
                  );
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                (L.AttributeType = (function () {
                  var H = {},
                    F = Object.create(H);
                  return (
                    (F[(H[0] = "UNDEFINED")] = 0),
                    (F[(H[1] = "FLOAT")] = 1),
                    (F[(H[2] = "INT")] = 2),
                    (F[(H[3] = "STRING")] = 3),
                    (F[(H[4] = "TENSOR")] = 4),
                    (F[(H[5] = "GRAPH")] = 5),
                    (F[(H[6] = "FLOATS")] = 6),
                    (F[(H[7] = "INTS")] = 7),
                    (F[(H[8] = "STRINGS")] = 8),
                    (F[(H[9] = "TENSORS")] = 9),
                    (F[(H[10] = "GRAPHS")] = 10),
                    F
                  );
                })()),
                L
              );
            })()),
            (U.ValueInfoProto = (function () {
              function L(H) {
                if (H)
                  for (var F = Object.keys(H), N = 0; N < F.length; ++N)
                    H[F[N]] != null && (this[F[N]] = H[F[N]]);
              }
              return (
                (L.prototype.name = ""),
                (L.prototype.type = null),
                (L.prototype.docString = ""),
                (L.create = function (H) {
                  return new L(H);
                }),
                (L.encode = function (H, F) {
                  return (
                    F || (F = K.create()),
                    H.name != null &&
                      H.hasOwnProperty("name") &&
                      F.uint32(10).string(H.name),
                    H.type != null &&
                      H.hasOwnProperty("type") &&
                      W.onnx.TypeProto.encode(
                        H.type,
                        F.uint32(18).fork()
                      ).ldelim(),
                    H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      F.uint32(26).string(H.docString),
                    F
                  );
                }),
                (L.encodeDelimited = function (H, F) {
                  return this.encode(H, F).ldelim();
                }),
                (L.decode = function (H, F) {
                  H instanceof B || (H = B.create(H));
                  for (
                    var N = F === void 0 ? H.len : H.pos + F,
                      q = new W.onnx.ValueInfoProto();
                    H.pos < N;
                  ) {
                    var M = H.uint32();
                    switch (M >>> 3) {
                      case 1:
                        q.name = H.string();
                        break;
                      case 2:
                        q.type = W.onnx.TypeProto.decode(H, H.uint32());
                        break;
                      case 3:
                        q.docString = H.string();
                        break;
                      default:
                        H.skipType(7 & M);
                    }
                  }
                  return q;
                }),
                (L.decodeDelimited = function (H) {
                  return (
                    H instanceof B || (H = new B(H)),
                    this.decode(H, H.uint32())
                  );
                }),
                (L.verify = function (H) {
                  if (typeof H != "object" || H === null)
                    return "object expected";
                  if (
                    H.name != null &&
                    H.hasOwnProperty("name") &&
                    !V.isString(H.name)
                  )
                    return "name: string expected";
                  if (H.type != null && H.hasOwnProperty("type")) {
                    var F = W.onnx.TypeProto.verify(H.type);
                    if (F) return "type." + F;
                  }
                  return H.docString != null &&
                    H.hasOwnProperty("docString") &&
                    !V.isString(H.docString)
                    ? "docString: string expected"
                    : null;
                }),
                (L.fromObject = function (H) {
                  if (H instanceof W.onnx.ValueInfoProto) return H;
                  var F = new W.onnx.ValueInfoProto();
                  if (
                    (H.name != null && (F.name = String(H.name)),
                    H.type != null)
                  ) {
                    if (typeof H.type != "object")
                      throw TypeError(
                        ".onnx.ValueInfoProto.type: object expected"
                      );
                    F.type = W.onnx.TypeProto.fromObject(H.type);
                  }
                  return (
                    H.docString != null && (F.docString = String(H.docString)),
                    F
                  );
                }),
                (L.toObject = function (H, F) {
                  F || (F = {});
                  var N = {};
                  return (
                    F.defaults &&
                      ((N.name = ""), (N.type = null), (N.docString = "")),
                    H.name != null &&
                      H.hasOwnProperty("name") &&
                      (N.name = H.name),
                    H.type != null &&
                      H.hasOwnProperty("type") &&
                      (N.type = W.onnx.TypeProto.toObject(H.type, F)),
                    H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      (N.docString = H.docString),
                    N
                  );
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                L
              );
            })()),
            (U.NodeProto = (function () {
              function L(H) {
                if (
                  ((this.input = []),
                  (this.output = []),
                  (this.attribute = []),
                  H)
                )
                  for (var F = Object.keys(H), N = 0; N < F.length; ++N)
                    H[F[N]] != null && (this[F[N]] = H[F[N]]);
              }
              return (
                (L.prototype.input = V.emptyArray),
                (L.prototype.output = V.emptyArray),
                (L.prototype.name = ""),
                (L.prototype.opType = ""),
                (L.prototype.domain = ""),
                (L.prototype.attribute = V.emptyArray),
                (L.prototype.docString = ""),
                (L.create = function (H) {
                  return new L(H);
                }),
                (L.encode = function (H, F) {
                  if (
                    (F || (F = K.create()), H.input != null && H.input.length)
                  )
                    for (var N = 0; N < H.input.length; ++N)
                      F.uint32(10).string(H.input[N]);
                  if (H.output != null && H.output.length)
                    for (N = 0; N < H.output.length; ++N)
                      F.uint32(18).string(H.output[N]);
                  if (
                    (H.name != null &&
                      H.hasOwnProperty("name") &&
                      F.uint32(26).string(H.name),
                    H.opType != null &&
                      H.hasOwnProperty("opType") &&
                      F.uint32(34).string(H.opType),
                    H.attribute != null && H.attribute.length)
                  )
                    for (N = 0; N < H.attribute.length; ++N)
                      W.onnx.AttributeProto.encode(
                        H.attribute[N],
                        F.uint32(42).fork()
                      ).ldelim();
                  return (
                    H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      F.uint32(50).string(H.docString),
                    H.domain != null &&
                      H.hasOwnProperty("domain") &&
                      F.uint32(58).string(H.domain),
                    F
                  );
                }),
                (L.encodeDelimited = function (H, F) {
                  return this.encode(H, F).ldelim();
                }),
                (L.decode = function (H, F) {
                  H instanceof B || (H = B.create(H));
                  for (
                    var N = F === void 0 ? H.len : H.pos + F,
                      q = new W.onnx.NodeProto();
                    H.pos < N;
                  ) {
                    var M = H.uint32();
                    switch (M >>> 3) {
                      case 1:
                        ((q.input && q.input.length) || (q.input = []),
                          q.input.push(H.string()));
                        break;
                      case 2:
                        ((q.output && q.output.length) || (q.output = []),
                          q.output.push(H.string()));
                        break;
                      case 3:
                        q.name = H.string();
                        break;
                      case 4:
                        q.opType = H.string();
                        break;
                      case 7:
                        q.domain = H.string();
                        break;
                      case 5:
                        ((q.attribute && q.attribute.length) ||
                          (q.attribute = []),
                          q.attribute.push(
                            W.onnx.AttributeProto.decode(H, H.uint32())
                          ));
                        break;
                      case 6:
                        q.docString = H.string();
                        break;
                      default:
                        H.skipType(7 & M);
                    }
                  }
                  return q;
                }),
                (L.decodeDelimited = function (H) {
                  return (
                    H instanceof B || (H = new B(H)),
                    this.decode(H, H.uint32())
                  );
                }),
                (L.verify = function (H) {
                  if (typeof H != "object" || H === null)
                    return "object expected";
                  if (H.input != null && H.hasOwnProperty("input")) {
                    if (!Array.isArray(H.input)) return "input: array expected";
                    for (var F = 0; F < H.input.length; ++F)
                      if (!V.isString(H.input[F]))
                        return "input: string[] expected";
                  }
                  if (H.output != null && H.hasOwnProperty("output")) {
                    if (!Array.isArray(H.output))
                      return "output: array expected";
                    for (F = 0; F < H.output.length; ++F)
                      if (!V.isString(H.output[F]))
                        return "output: string[] expected";
                  }
                  if (
                    H.name != null &&
                    H.hasOwnProperty("name") &&
                    !V.isString(H.name)
                  )
                    return "name: string expected";
                  if (
                    H.opType != null &&
                    H.hasOwnProperty("opType") &&
                    !V.isString(H.opType)
                  )
                    return "opType: string expected";
                  if (
                    H.domain != null &&
                    H.hasOwnProperty("domain") &&
                    !V.isString(H.domain)
                  )
                    return "domain: string expected";
                  if (H.attribute != null && H.hasOwnProperty("attribute")) {
                    if (!Array.isArray(H.attribute))
                      return "attribute: array expected";
                    for (F = 0; F < H.attribute.length; ++F) {
                      var N = W.onnx.AttributeProto.verify(H.attribute[F]);
                      if (N) return "attribute." + N;
                    }
                  }
                  return H.docString != null &&
                    H.hasOwnProperty("docString") &&
                    !V.isString(H.docString)
                    ? "docString: string expected"
                    : null;
                }),
                (L.fromObject = function (H) {
                  if (H instanceof W.onnx.NodeProto) return H;
                  var F = new W.onnx.NodeProto();
                  if (H.input) {
                    if (!Array.isArray(H.input))
                      throw TypeError(".onnx.NodeProto.input: array expected");
                    F.input = [];
                    for (var N = 0; N < H.input.length; ++N)
                      F.input[N] = String(H.input[N]);
                  }
                  if (H.output) {
                    if (!Array.isArray(H.output))
                      throw TypeError(".onnx.NodeProto.output: array expected");
                    for (F.output = [], N = 0; N < H.output.length; ++N)
                      F.output[N] = String(H.output[N]);
                  }
                  if (
                    (H.name != null && (F.name = String(H.name)),
                    H.opType != null && (F.opType = String(H.opType)),
                    H.domain != null && (F.domain = String(H.domain)),
                    H.attribute)
                  ) {
                    if (!Array.isArray(H.attribute))
                      throw TypeError(
                        ".onnx.NodeProto.attribute: array expected"
                      );
                    for (F.attribute = [], N = 0; N < H.attribute.length; ++N) {
                      if (typeof H.attribute[N] != "object")
                        throw TypeError(
                          ".onnx.NodeProto.attribute: object expected"
                        );
                      F.attribute[N] = W.onnx.AttributeProto.fromObject(
                        H.attribute[N]
                      );
                    }
                  }
                  return (
                    H.docString != null && (F.docString = String(H.docString)),
                    F
                  );
                }),
                (L.toObject = function (H, F) {
                  F || (F = {});
                  var N = {};
                  if (
                    ((F.arrays || F.defaults) &&
                      ((N.input = []), (N.output = []), (N.attribute = [])),
                    F.defaults &&
                      ((N.name = ""),
                      (N.opType = ""),
                      (N.docString = ""),
                      (N.domain = "")),
                    H.input && H.input.length)
                  ) {
                    N.input = [];
                    for (var q = 0; q < H.input.length; ++q)
                      N.input[q] = H.input[q];
                  }
                  if (H.output && H.output.length)
                    for (N.output = [], q = 0; q < H.output.length; ++q)
                      N.output[q] = H.output[q];
                  if (
                    (H.name != null &&
                      H.hasOwnProperty("name") &&
                      (N.name = H.name),
                    H.opType != null &&
                      H.hasOwnProperty("opType") &&
                      (N.opType = H.opType),
                    H.attribute && H.attribute.length)
                  )
                    for (N.attribute = [], q = 0; q < H.attribute.length; ++q)
                      N.attribute[q] = W.onnx.AttributeProto.toObject(
                        H.attribute[q],
                        F
                      );
                  return (
                    H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      (N.docString = H.docString),
                    H.domain != null &&
                      H.hasOwnProperty("domain") &&
                      (N.domain = H.domain),
                    N
                  );
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                L
              );
            })()),
            (U.ModelProto = (function () {
              function L(H) {
                if (((this.opsetImport = []), (this.metadataProps = []), H))
                  for (var F = Object.keys(H), N = 0; N < F.length; ++N)
                    H[F[N]] != null && (this[F[N]] = H[F[N]]);
              }
              return (
                (L.prototype.irVersion = V.Long
                  ? V.Long.fromBits(0, 0, !1)
                  : 0),
                (L.prototype.opsetImport = V.emptyArray),
                (L.prototype.producerName = ""),
                (L.prototype.producerVersion = ""),
                (L.prototype.domain = ""),
                (L.prototype.modelVersion = V.Long
                  ? V.Long.fromBits(0, 0, !1)
                  : 0),
                (L.prototype.docString = ""),
                (L.prototype.graph = null),
                (L.prototype.metadataProps = V.emptyArray),
                (L.create = function (H) {
                  return new L(H);
                }),
                (L.encode = function (H, F) {
                  if (
                    (F || (F = K.create()),
                    H.irVersion != null &&
                      H.hasOwnProperty("irVersion") &&
                      F.uint32(8).int64(H.irVersion),
                    H.producerName != null &&
                      H.hasOwnProperty("producerName") &&
                      F.uint32(18).string(H.producerName),
                    H.producerVersion != null &&
                      H.hasOwnProperty("producerVersion") &&
                      F.uint32(26).string(H.producerVersion),
                    H.domain != null &&
                      H.hasOwnProperty("domain") &&
                      F.uint32(34).string(H.domain),
                    H.modelVersion != null &&
                      H.hasOwnProperty("modelVersion") &&
                      F.uint32(40).int64(H.modelVersion),
                    H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      F.uint32(50).string(H.docString),
                    H.graph != null &&
                      H.hasOwnProperty("graph") &&
                      W.onnx.GraphProto.encode(
                        H.graph,
                        F.uint32(58).fork()
                      ).ldelim(),
                    H.opsetImport != null && H.opsetImport.length)
                  )
                    for (var N = 0; N < H.opsetImport.length; ++N)
                      W.onnx.OperatorSetIdProto.encode(
                        H.opsetImport[N],
                        F.uint32(66).fork()
                      ).ldelim();
                  if (H.metadataProps != null && H.metadataProps.length)
                    for (N = 0; N < H.metadataProps.length; ++N)
                      W.onnx.StringStringEntryProto.encode(
                        H.metadataProps[N],
                        F.uint32(114).fork()
                      ).ldelim();
                  return F;
                }),
                (L.encodeDelimited = function (H, F) {
                  return this.encode(H, F).ldelim();
                }),
                (L.decode = function (H, F) {
                  H instanceof B || (H = B.create(H));
                  for (
                    var N = F === void 0 ? H.len : H.pos + F,
                      q = new W.onnx.ModelProto();
                    H.pos < N;
                  ) {
                    var M = H.uint32();
                    switch (M >>> 3) {
                      case 1:
                        q.irVersion = H.int64();
                        break;
                      case 8:
                        ((q.opsetImport && q.opsetImport.length) ||
                          (q.opsetImport = []),
                          q.opsetImport.push(
                            W.onnx.OperatorSetIdProto.decode(H, H.uint32())
                          ));
                        break;
                      case 2:
                        q.producerName = H.string();
                        break;
                      case 3:
                        q.producerVersion = H.string();
                        break;
                      case 4:
                        q.domain = H.string();
                        break;
                      case 5:
                        q.modelVersion = H.int64();
                        break;
                      case 6:
                        q.docString = H.string();
                        break;
                      case 7:
                        q.graph = W.onnx.GraphProto.decode(H, H.uint32());
                        break;
                      case 14:
                        ((q.metadataProps && q.metadataProps.length) ||
                          (q.metadataProps = []),
                          q.metadataProps.push(
                            W.onnx.StringStringEntryProto.decode(H, H.uint32())
                          ));
                        break;
                      default:
                        H.skipType(7 & M);
                    }
                  }
                  return q;
                }),
                (L.decodeDelimited = function (H) {
                  return (
                    H instanceof B || (H = new B(H)),
                    this.decode(H, H.uint32())
                  );
                }),
                (L.verify = function (H) {
                  if (typeof H != "object" || H === null)
                    return "object expected";
                  if (
                    H.irVersion != null &&
                    H.hasOwnProperty("irVersion") &&
                    !(
                      V.isInteger(H.irVersion) ||
                      (H.irVersion &&
                        V.isInteger(H.irVersion.low) &&
                        V.isInteger(H.irVersion.high))
                    )
                  )
                    return "irVersion: integer|Long expected";
                  if (
                    H.opsetImport != null &&
                    H.hasOwnProperty("opsetImport")
                  ) {
                    if (!Array.isArray(H.opsetImport))
                      return "opsetImport: array expected";
                    for (var F = 0; F < H.opsetImport.length; ++F)
                      if (
                        (N = W.onnx.OperatorSetIdProto.verify(H.opsetImport[F]))
                      )
                        return "opsetImport." + N;
                  }
                  if (
                    H.producerName != null &&
                    H.hasOwnProperty("producerName") &&
                    !V.isString(H.producerName)
                  )
                    return "producerName: string expected";
                  if (
                    H.producerVersion != null &&
                    H.hasOwnProperty("producerVersion") &&
                    !V.isString(H.producerVersion)
                  )
                    return "producerVersion: string expected";
                  if (
                    H.domain != null &&
                    H.hasOwnProperty("domain") &&
                    !V.isString(H.domain)
                  )
                    return "domain: string expected";
                  if (
                    H.modelVersion != null &&
                    H.hasOwnProperty("modelVersion") &&
                    !(
                      V.isInteger(H.modelVersion) ||
                      (H.modelVersion &&
                        V.isInteger(H.modelVersion.low) &&
                        V.isInteger(H.modelVersion.high))
                    )
                  )
                    return "modelVersion: integer|Long expected";
                  if (
                    H.docString != null &&
                    H.hasOwnProperty("docString") &&
                    !V.isString(H.docString)
                  )
                    return "docString: string expected";
                  if (
                    H.graph != null &&
                    H.hasOwnProperty("graph") &&
                    (N = W.onnx.GraphProto.verify(H.graph))
                  )
                    return "graph." + N;
                  if (
                    H.metadataProps != null &&
                    H.hasOwnProperty("metadataProps")
                  ) {
                    if (!Array.isArray(H.metadataProps))
                      return "metadataProps: array expected";
                    for (F = 0; F < H.metadataProps.length; ++F) {
                      var N;
                      if (
                        (N = W.onnx.StringStringEntryProto.verify(
                          H.metadataProps[F]
                        ))
                      )
                        return "metadataProps." + N;
                    }
                  }
                  return null;
                }),
                (L.fromObject = function (H) {
                  if (H instanceof W.onnx.ModelProto) return H;
                  var F = new W.onnx.ModelProto();
                  if (
                    (H.irVersion != null &&
                      (V.Long
                        ? ((F.irVersion = V.Long.fromValue(
                            H.irVersion
                          )).unsigned = !1)
                        : typeof H.irVersion == "string"
                          ? (F.irVersion = parseInt(H.irVersion, 10))
                          : typeof H.irVersion == "number"
                            ? (F.irVersion = H.irVersion)
                            : typeof H.irVersion == "object" &&
                              (F.irVersion = new V.LongBits(
                                H.irVersion.low >>> 0,
                                H.irVersion.high >>> 0
                              ).toNumber())),
                    H.opsetImport)
                  ) {
                    if (!Array.isArray(H.opsetImport))
                      throw TypeError(
                        ".onnx.ModelProto.opsetImport: array expected"
                      );
                    F.opsetImport = [];
                    for (var N = 0; N < H.opsetImport.length; ++N) {
                      if (typeof H.opsetImport[N] != "object")
                        throw TypeError(
                          ".onnx.ModelProto.opsetImport: object expected"
                        );
                      F.opsetImport[N] = W.onnx.OperatorSetIdProto.fromObject(
                        H.opsetImport[N]
                      );
                    }
                  }
                  if (
                    (H.producerName != null &&
                      (F.producerName = String(H.producerName)),
                    H.producerVersion != null &&
                      (F.producerVersion = String(H.producerVersion)),
                    H.domain != null && (F.domain = String(H.domain)),
                    H.modelVersion != null &&
                      (V.Long
                        ? ((F.modelVersion = V.Long.fromValue(
                            H.modelVersion
                          )).unsigned = !1)
                        : typeof H.modelVersion == "string"
                          ? (F.modelVersion = parseInt(H.modelVersion, 10))
                          : typeof H.modelVersion == "number"
                            ? (F.modelVersion = H.modelVersion)
                            : typeof H.modelVersion == "object" &&
                              (F.modelVersion = new V.LongBits(
                                H.modelVersion.low >>> 0,
                                H.modelVersion.high >>> 0
                              ).toNumber())),
                    H.docString != null && (F.docString = String(H.docString)),
                    H.graph != null)
                  ) {
                    if (typeof H.graph != "object")
                      throw TypeError(
                        ".onnx.ModelProto.graph: object expected"
                      );
                    F.graph = W.onnx.GraphProto.fromObject(H.graph);
                  }
                  if (H.metadataProps) {
                    if (!Array.isArray(H.metadataProps))
                      throw TypeError(
                        ".onnx.ModelProto.metadataProps: array expected"
                      );
                    for (
                      F.metadataProps = [], N = 0;
                      N < H.metadataProps.length;
                      ++N
                    ) {
                      if (typeof H.metadataProps[N] != "object")
                        throw TypeError(
                          ".onnx.ModelProto.metadataProps: object expected"
                        );
                      F.metadataProps[N] =
                        W.onnx.StringStringEntryProto.fromObject(
                          H.metadataProps[N]
                        );
                    }
                  }
                  return F;
                }),
                (L.toObject = function (H, F) {
                  F || (F = {});
                  var N = {};
                  if (
                    ((F.arrays || F.defaults) &&
                      ((N.opsetImport = []), (N.metadataProps = [])),
                    F.defaults)
                  ) {
                    if (V.Long) {
                      var q = new V.Long(0, 0, !1);
                      N.irVersion =
                        F.longs === String
                          ? q.toString()
                          : F.longs === Number
                            ? q.toNumber()
                            : q;
                    } else N.irVersion = F.longs === String ? "0" : 0;
                    ((N.producerName = ""),
                      (N.producerVersion = ""),
                      (N.domain = ""),
                      V.Long
                        ? ((q = new V.Long(0, 0, !1)),
                          (N.modelVersion =
                            F.longs === String
                              ? q.toString()
                              : F.longs === Number
                                ? q.toNumber()
                                : q))
                        : (N.modelVersion = F.longs === String ? "0" : 0),
                      (N.docString = ""),
                      (N.graph = null));
                  }
                  if (
                    (H.irVersion != null &&
                      H.hasOwnProperty("irVersion") &&
                      (typeof H.irVersion == "number"
                        ? (N.irVersion =
                            F.longs === String
                              ? String(H.irVersion)
                              : H.irVersion)
                        : (N.irVersion =
                            F.longs === String
                              ? V.Long.prototype.toString.call(H.irVersion)
                              : F.longs === Number
                                ? new V.LongBits(
                                    H.irVersion.low >>> 0,
                                    H.irVersion.high >>> 0
                                  ).toNumber()
                                : H.irVersion)),
                    H.producerName != null &&
                      H.hasOwnProperty("producerName") &&
                      (N.producerName = H.producerName),
                    H.producerVersion != null &&
                      H.hasOwnProperty("producerVersion") &&
                      (N.producerVersion = H.producerVersion),
                    H.domain != null &&
                      H.hasOwnProperty("domain") &&
                      (N.domain = H.domain),
                    H.modelVersion != null &&
                      H.hasOwnProperty("modelVersion") &&
                      (typeof H.modelVersion == "number"
                        ? (N.modelVersion =
                            F.longs === String
                              ? String(H.modelVersion)
                              : H.modelVersion)
                        : (N.modelVersion =
                            F.longs === String
                              ? V.Long.prototype.toString.call(H.modelVersion)
                              : F.longs === Number
                                ? new V.LongBits(
                                    H.modelVersion.low >>> 0,
                                    H.modelVersion.high >>> 0
                                  ).toNumber()
                                : H.modelVersion)),
                    H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      (N.docString = H.docString),
                    H.graph != null &&
                      H.hasOwnProperty("graph") &&
                      (N.graph = W.onnx.GraphProto.toObject(H.graph, F)),
                    H.opsetImport && H.opsetImport.length)
                  ) {
                    N.opsetImport = [];
                    for (var M = 0; M < H.opsetImport.length; ++M)
                      N.opsetImport[M] = W.onnx.OperatorSetIdProto.toObject(
                        H.opsetImport[M],
                        F
                      );
                  }
                  if (H.metadataProps && H.metadataProps.length)
                    for (
                      N.metadataProps = [], M = 0;
                      M < H.metadataProps.length;
                      ++M
                    )
                      N.metadataProps[M] =
                        W.onnx.StringStringEntryProto.toObject(
                          H.metadataProps[M],
                          F
                        );
                  return N;
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                L
              );
            })()),
            (U.StringStringEntryProto = (function () {
              function L(H) {
                if (H)
                  for (var F = Object.keys(H), N = 0; N < F.length; ++N)
                    H[F[N]] != null && (this[F[N]] = H[F[N]]);
              }
              return (
                (L.prototype.key = ""),
                (L.prototype.value = ""),
                (L.create = function (H) {
                  return new L(H);
                }),
                (L.encode = function (H, F) {
                  return (
                    F || (F = K.create()),
                    H.key != null &&
                      H.hasOwnProperty("key") &&
                      F.uint32(10).string(H.key),
                    H.value != null &&
                      H.hasOwnProperty("value") &&
                      F.uint32(18).string(H.value),
                    F
                  );
                }),
                (L.encodeDelimited = function (H, F) {
                  return this.encode(H, F).ldelim();
                }),
                (L.decode = function (H, F) {
                  H instanceof B || (H = B.create(H));
                  for (
                    var N = F === void 0 ? H.len : H.pos + F,
                      q = new W.onnx.StringStringEntryProto();
                    H.pos < N;
                  ) {
                    var M = H.uint32();
                    switch (M >>> 3) {
                      case 1:
                        q.key = H.string();
                        break;
                      case 2:
                        q.value = H.string();
                        break;
                      default:
                        H.skipType(7 & M);
                    }
                  }
                  return q;
                }),
                (L.decodeDelimited = function (H) {
                  return (
                    H instanceof B || (H = new B(H)),
                    this.decode(H, H.uint32())
                  );
                }),
                (L.verify = function (H) {
                  return typeof H != "object" || H === null
                    ? "object expected"
                    : H.key != null &&
                        H.hasOwnProperty("key") &&
                        !V.isString(H.key)
                      ? "key: string expected"
                      : H.value != null &&
                          H.hasOwnProperty("value") &&
                          !V.isString(H.value)
                        ? "value: string expected"
                        : null;
                }),
                (L.fromObject = function (H) {
                  if (H instanceof W.onnx.StringStringEntryProto) return H;
                  var F = new W.onnx.StringStringEntryProto();
                  return (
                    H.key != null && (F.key = String(H.key)),
                    H.value != null && (F.value = String(H.value)),
                    F
                  );
                }),
                (L.toObject = function (H, F) {
                  F || (F = {});
                  var N = {};
                  return (
                    F.defaults && ((N.key = ""), (N.value = "")),
                    H.key != null && H.hasOwnProperty("key") && (N.key = H.key),
                    H.value != null &&
                      H.hasOwnProperty("value") &&
                      (N.value = H.value),
                    N
                  );
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                L
              );
            })()),
            (U.TensorAnnotation = (function () {
              function L(H) {
                if (((this.quantParameterTensorNames = []), H))
                  for (var F = Object.keys(H), N = 0; N < F.length; ++N)
                    H[F[N]] != null && (this[F[N]] = H[F[N]]);
              }
              return (
                (L.prototype.tensorName = ""),
                (L.prototype.quantParameterTensorNames = V.emptyArray),
                (L.create = function (H) {
                  return new L(H);
                }),
                (L.encode = function (H, F) {
                  if (
                    (F || (F = K.create()),
                    H.tensorName != null &&
                      H.hasOwnProperty("tensorName") &&
                      F.uint32(10).string(H.tensorName),
                    H.quantParameterTensorNames != null &&
                      H.quantParameterTensorNames.length)
                  )
                    for (var N = 0; N < H.quantParameterTensorNames.length; ++N)
                      W.onnx.StringStringEntryProto.encode(
                        H.quantParameterTensorNames[N],
                        F.uint32(18).fork()
                      ).ldelim();
                  return F;
                }),
                (L.encodeDelimited = function (H, F) {
                  return this.encode(H, F).ldelim();
                }),
                (L.decode = function (H, F) {
                  H instanceof B || (H = B.create(H));
                  for (
                    var N = F === void 0 ? H.len : H.pos + F,
                      q = new W.onnx.TensorAnnotation();
                    H.pos < N;
                  ) {
                    var M = H.uint32();
                    switch (M >>> 3) {
                      case 1:
                        q.tensorName = H.string();
                        break;
                      case 2:
                        ((q.quantParameterTensorNames &&
                          q.quantParameterTensorNames.length) ||
                          (q.quantParameterTensorNames = []),
                          q.quantParameterTensorNames.push(
                            W.onnx.StringStringEntryProto.decode(H, H.uint32())
                          ));
                        break;
                      default:
                        H.skipType(7 & M);
                    }
                  }
                  return q;
                }),
                (L.decodeDelimited = function (H) {
                  return (
                    H instanceof B || (H = new B(H)),
                    this.decode(H, H.uint32())
                  );
                }),
                (L.verify = function (H) {
                  if (typeof H != "object" || H === null)
                    return "object expected";
                  if (
                    H.tensorName != null &&
                    H.hasOwnProperty("tensorName") &&
                    !V.isString(H.tensorName)
                  )
                    return "tensorName: string expected";
                  if (
                    H.quantParameterTensorNames != null &&
                    H.hasOwnProperty("quantParameterTensorNames")
                  ) {
                    if (!Array.isArray(H.quantParameterTensorNames))
                      return "quantParameterTensorNames: array expected";
                    for (
                      var F = 0;
                      F < H.quantParameterTensorNames.length;
                      ++F
                    ) {
                      var N = W.onnx.StringStringEntryProto.verify(
                        H.quantParameterTensorNames[F]
                      );
                      if (N) return "quantParameterTensorNames." + N;
                    }
                  }
                  return null;
                }),
                (L.fromObject = function (H) {
                  if (H instanceof W.onnx.TensorAnnotation) return H;
                  var F = new W.onnx.TensorAnnotation();
                  if (
                    (H.tensorName != null &&
                      (F.tensorName = String(H.tensorName)),
                    H.quantParameterTensorNames)
                  ) {
                    if (!Array.isArray(H.quantParameterTensorNames))
                      throw TypeError(
                        ".onnx.TensorAnnotation.quantParameterTensorNames: array expected"
                      );
                    F.quantParameterTensorNames = [];
                    for (
                      var N = 0;
                      N < H.quantParameterTensorNames.length;
                      ++N
                    ) {
                      if (typeof H.quantParameterTensorNames[N] != "object")
                        throw TypeError(
                          ".onnx.TensorAnnotation.quantParameterTensorNames: object expected"
                        );
                      F.quantParameterTensorNames[N] =
                        W.onnx.StringStringEntryProto.fromObject(
                          H.quantParameterTensorNames[N]
                        );
                    }
                  }
                  return F;
                }),
                (L.toObject = function (H, F) {
                  F || (F = {});
                  var N = {};
                  if (
                    ((F.arrays || F.defaults) &&
                      (N.quantParameterTensorNames = []),
                    F.defaults && (N.tensorName = ""),
                    H.tensorName != null &&
                      H.hasOwnProperty("tensorName") &&
                      (N.tensorName = H.tensorName),
                    H.quantParameterTensorNames &&
                      H.quantParameterTensorNames.length)
                  ) {
                    N.quantParameterTensorNames = [];
                    for (var q = 0; q < H.quantParameterTensorNames.length; ++q)
                      N.quantParameterTensorNames[q] =
                        W.onnx.StringStringEntryProto.toObject(
                          H.quantParameterTensorNames[q],
                          F
                        );
                  }
                  return N;
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                L
              );
            })()),
            (U.GraphProto = (function () {
              function L(H) {
                if (
                  ((this.node = []),
                  (this.initializer = []),
                  (this.input = []),
                  (this.output = []),
                  (this.valueInfo = []),
                  (this.quantizationAnnotation = []),
                  H)
                )
                  for (var F = Object.keys(H), N = 0; N < F.length; ++N)
                    H[F[N]] != null && (this[F[N]] = H[F[N]]);
              }
              return (
                (L.prototype.node = V.emptyArray),
                (L.prototype.name = ""),
                (L.prototype.initializer = V.emptyArray),
                (L.prototype.docString = ""),
                (L.prototype.input = V.emptyArray),
                (L.prototype.output = V.emptyArray),
                (L.prototype.valueInfo = V.emptyArray),
                (L.prototype.quantizationAnnotation = V.emptyArray),
                (L.create = function (H) {
                  return new L(H);
                }),
                (L.encode = function (H, F) {
                  if ((F || (F = K.create()), H.node != null && H.node.length))
                    for (var N = 0; N < H.node.length; ++N)
                      W.onnx.NodeProto.encode(
                        H.node[N],
                        F.uint32(10).fork()
                      ).ldelim();
                  if (
                    (H.name != null &&
                      H.hasOwnProperty("name") &&
                      F.uint32(18).string(H.name),
                    H.initializer != null && H.initializer.length)
                  )
                    for (N = 0; N < H.initializer.length; ++N)
                      W.onnx.TensorProto.encode(
                        H.initializer[N],
                        F.uint32(42).fork()
                      ).ldelim();
                  if (
                    (H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      F.uint32(82).string(H.docString),
                    H.input != null && H.input.length)
                  )
                    for (N = 0; N < H.input.length; ++N)
                      W.onnx.ValueInfoProto.encode(
                        H.input[N],
                        F.uint32(90).fork()
                      ).ldelim();
                  if (H.output != null && H.output.length)
                    for (N = 0; N < H.output.length; ++N)
                      W.onnx.ValueInfoProto.encode(
                        H.output[N],
                        F.uint32(98).fork()
                      ).ldelim();
                  if (H.valueInfo != null && H.valueInfo.length)
                    for (N = 0; N < H.valueInfo.length; ++N)
                      W.onnx.ValueInfoProto.encode(
                        H.valueInfo[N],
                        F.uint32(106).fork()
                      ).ldelim();
                  if (
                    H.quantizationAnnotation != null &&
                    H.quantizationAnnotation.length
                  )
                    for (N = 0; N < H.quantizationAnnotation.length; ++N)
                      W.onnx.TensorAnnotation.encode(
                        H.quantizationAnnotation[N],
                        F.uint32(114).fork()
                      ).ldelim();
                  return F;
                }),
                (L.encodeDelimited = function (H, F) {
                  return this.encode(H, F).ldelim();
                }),
                (L.decode = function (H, F) {
                  H instanceof B || (H = B.create(H));
                  for (
                    var N = F === void 0 ? H.len : H.pos + F,
                      q = new W.onnx.GraphProto();
                    H.pos < N;
                  ) {
                    var M = H.uint32();
                    switch (M >>> 3) {
                      case 1:
                        ((q.node && q.node.length) || (q.node = []),
                          q.node.push(W.onnx.NodeProto.decode(H, H.uint32())));
                        break;
                      case 2:
                        q.name = H.string();
                        break;
                      case 5:
                        ((q.initializer && q.initializer.length) ||
                          (q.initializer = []),
                          q.initializer.push(
                            W.onnx.TensorProto.decode(H, H.uint32())
                          ));
                        break;
                      case 10:
                        q.docString = H.string();
                        break;
                      case 11:
                        ((q.input && q.input.length) || (q.input = []),
                          q.input.push(
                            W.onnx.ValueInfoProto.decode(H, H.uint32())
                          ));
                        break;
                      case 12:
                        ((q.output && q.output.length) || (q.output = []),
                          q.output.push(
                            W.onnx.ValueInfoProto.decode(H, H.uint32())
                          ));
                        break;
                      case 13:
                        ((q.valueInfo && q.valueInfo.length) ||
                          (q.valueInfo = []),
                          q.valueInfo.push(
                            W.onnx.ValueInfoProto.decode(H, H.uint32())
                          ));
                        break;
                      case 14:
                        ((q.quantizationAnnotation &&
                          q.quantizationAnnotation.length) ||
                          (q.quantizationAnnotation = []),
                          q.quantizationAnnotation.push(
                            W.onnx.TensorAnnotation.decode(H, H.uint32())
                          ));
                        break;
                      default:
                        H.skipType(7 & M);
                    }
                  }
                  return q;
                }),
                (L.decodeDelimited = function (H) {
                  return (
                    H instanceof B || (H = new B(H)),
                    this.decode(H, H.uint32())
                  );
                }),
                (L.verify = function (H) {
                  if (typeof H != "object" || H === null)
                    return "object expected";
                  if (H.node != null && H.hasOwnProperty("node")) {
                    if (!Array.isArray(H.node)) return "node: array expected";
                    for (var F = 0; F < H.node.length; ++F)
                      if ((N = W.onnx.NodeProto.verify(H.node[F])))
                        return "node." + N;
                  }
                  if (
                    H.name != null &&
                    H.hasOwnProperty("name") &&
                    !V.isString(H.name)
                  )
                    return "name: string expected";
                  if (
                    H.initializer != null &&
                    H.hasOwnProperty("initializer")
                  ) {
                    if (!Array.isArray(H.initializer))
                      return "initializer: array expected";
                    for (F = 0; F < H.initializer.length; ++F)
                      if ((N = W.onnx.TensorProto.verify(H.initializer[F])))
                        return "initializer." + N;
                  }
                  if (
                    H.docString != null &&
                    H.hasOwnProperty("docString") &&
                    !V.isString(H.docString)
                  )
                    return "docString: string expected";
                  if (H.input != null && H.hasOwnProperty("input")) {
                    if (!Array.isArray(H.input)) return "input: array expected";
                    for (F = 0; F < H.input.length; ++F)
                      if ((N = W.onnx.ValueInfoProto.verify(H.input[F])))
                        return "input." + N;
                  }
                  if (H.output != null && H.hasOwnProperty("output")) {
                    if (!Array.isArray(H.output))
                      return "output: array expected";
                    for (F = 0; F < H.output.length; ++F)
                      if ((N = W.onnx.ValueInfoProto.verify(H.output[F])))
                        return "output." + N;
                  }
                  if (H.valueInfo != null && H.hasOwnProperty("valueInfo")) {
                    if (!Array.isArray(H.valueInfo))
                      return "valueInfo: array expected";
                    for (F = 0; F < H.valueInfo.length; ++F)
                      if ((N = W.onnx.ValueInfoProto.verify(H.valueInfo[F])))
                        return "valueInfo." + N;
                  }
                  if (
                    H.quantizationAnnotation != null &&
                    H.hasOwnProperty("quantizationAnnotation")
                  ) {
                    if (!Array.isArray(H.quantizationAnnotation))
                      return "quantizationAnnotation: array expected";
                    for (F = 0; F < H.quantizationAnnotation.length; ++F) {
                      var N;
                      if (
                        (N = W.onnx.TensorAnnotation.verify(
                          H.quantizationAnnotation[F]
                        ))
                      )
                        return "quantizationAnnotation." + N;
                    }
                  }
                  return null;
                }),
                (L.fromObject = function (H) {
                  if (H instanceof W.onnx.GraphProto) return H;
                  var F = new W.onnx.GraphProto();
                  if (H.node) {
                    if (!Array.isArray(H.node))
                      throw TypeError(".onnx.GraphProto.node: array expected");
                    F.node = [];
                    for (var N = 0; N < H.node.length; ++N) {
                      if (typeof H.node[N] != "object")
                        throw TypeError(
                          ".onnx.GraphProto.node: object expected"
                        );
                      F.node[N] = W.onnx.NodeProto.fromObject(H.node[N]);
                    }
                  }
                  if (
                    (H.name != null && (F.name = String(H.name)), H.initializer)
                  ) {
                    if (!Array.isArray(H.initializer))
                      throw TypeError(
                        ".onnx.GraphProto.initializer: array expected"
                      );
                    for (
                      F.initializer = [], N = 0;
                      N < H.initializer.length;
                      ++N
                    ) {
                      if (typeof H.initializer[N] != "object")
                        throw TypeError(
                          ".onnx.GraphProto.initializer: object expected"
                        );
                      F.initializer[N] = W.onnx.TensorProto.fromObject(
                        H.initializer[N]
                      );
                    }
                  }
                  if (
                    (H.docString != null && (F.docString = String(H.docString)),
                    H.input)
                  ) {
                    if (!Array.isArray(H.input))
                      throw TypeError(".onnx.GraphProto.input: array expected");
                    for (F.input = [], N = 0; N < H.input.length; ++N) {
                      if (typeof H.input[N] != "object")
                        throw TypeError(
                          ".onnx.GraphProto.input: object expected"
                        );
                      F.input[N] = W.onnx.ValueInfoProto.fromObject(H.input[N]);
                    }
                  }
                  if (H.output) {
                    if (!Array.isArray(H.output))
                      throw TypeError(
                        ".onnx.GraphProto.output: array expected"
                      );
                    for (F.output = [], N = 0; N < H.output.length; ++N) {
                      if (typeof H.output[N] != "object")
                        throw TypeError(
                          ".onnx.GraphProto.output: object expected"
                        );
                      F.output[N] = W.onnx.ValueInfoProto.fromObject(
                        H.output[N]
                      );
                    }
                  }
                  if (H.valueInfo) {
                    if (!Array.isArray(H.valueInfo))
                      throw TypeError(
                        ".onnx.GraphProto.valueInfo: array expected"
                      );
                    for (F.valueInfo = [], N = 0; N < H.valueInfo.length; ++N) {
                      if (typeof H.valueInfo[N] != "object")
                        throw TypeError(
                          ".onnx.GraphProto.valueInfo: object expected"
                        );
                      F.valueInfo[N] = W.onnx.ValueInfoProto.fromObject(
                        H.valueInfo[N]
                      );
                    }
                  }
                  if (H.quantizationAnnotation) {
                    if (!Array.isArray(H.quantizationAnnotation))
                      throw TypeError(
                        ".onnx.GraphProto.quantizationAnnotation: array expected"
                      );
                    for (
                      F.quantizationAnnotation = [], N = 0;
                      N < H.quantizationAnnotation.length;
                      ++N
                    ) {
                      if (typeof H.quantizationAnnotation[N] != "object")
                        throw TypeError(
                          ".onnx.GraphProto.quantizationAnnotation: object expected"
                        );
                      F.quantizationAnnotation[N] =
                        W.onnx.TensorAnnotation.fromObject(
                          H.quantizationAnnotation[N]
                        );
                    }
                  }
                  return F;
                }),
                (L.toObject = function (H, F) {
                  F || (F = {});
                  var N = {};
                  if (
                    ((F.arrays || F.defaults) &&
                      ((N.node = []),
                      (N.initializer = []),
                      (N.input = []),
                      (N.output = []),
                      (N.valueInfo = []),
                      (N.quantizationAnnotation = [])),
                    F.defaults && ((N.name = ""), (N.docString = "")),
                    H.node && H.node.length)
                  ) {
                    N.node = [];
                    for (var q = 0; q < H.node.length; ++q)
                      N.node[q] = W.onnx.NodeProto.toObject(H.node[q], F);
                  }
                  if (
                    (H.name != null &&
                      H.hasOwnProperty("name") &&
                      (N.name = H.name),
                    H.initializer && H.initializer.length)
                  )
                    for (
                      N.initializer = [], q = 0;
                      q < H.initializer.length;
                      ++q
                    )
                      N.initializer[q] = W.onnx.TensorProto.toObject(
                        H.initializer[q],
                        F
                      );
                  if (
                    (H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      (N.docString = H.docString),
                    H.input && H.input.length)
                  )
                    for (N.input = [], q = 0; q < H.input.length; ++q)
                      N.input[q] = W.onnx.ValueInfoProto.toObject(
                        H.input[q],
                        F
                      );
                  if (H.output && H.output.length)
                    for (N.output = [], q = 0; q < H.output.length; ++q)
                      N.output[q] = W.onnx.ValueInfoProto.toObject(
                        H.output[q],
                        F
                      );
                  if (H.valueInfo && H.valueInfo.length)
                    for (N.valueInfo = [], q = 0; q < H.valueInfo.length; ++q)
                      N.valueInfo[q] = W.onnx.ValueInfoProto.toObject(
                        H.valueInfo[q],
                        F
                      );
                  if (
                    H.quantizationAnnotation &&
                    H.quantizationAnnotation.length
                  )
                    for (
                      N.quantizationAnnotation = [], q = 0;
                      q < H.quantizationAnnotation.length;
                      ++q
                    )
                      N.quantizationAnnotation[q] =
                        W.onnx.TensorAnnotation.toObject(
                          H.quantizationAnnotation[q],
                          F
                        );
                  return N;
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                L
              );
            })()),
            (U.TensorProto = (function () {
              function L(H) {
                if (
                  ((this.dims = []),
                  (this.floatData = []),
                  (this.int32Data = []),
                  (this.stringData = []),
                  (this.int64Data = []),
                  (this.externalData = []),
                  (this.doubleData = []),
                  (this.uint64Data = []),
                  H)
                )
                  for (var F = Object.keys(H), N = 0; N < F.length; ++N)
                    H[F[N]] != null && (this[F[N]] = H[F[N]]);
              }
              return (
                (L.prototype.dims = V.emptyArray),
                (L.prototype.dataType = 0),
                (L.prototype.segment = null),
                (L.prototype.floatData = V.emptyArray),
                (L.prototype.int32Data = V.emptyArray),
                (L.prototype.stringData = V.emptyArray),
                (L.prototype.int64Data = V.emptyArray),
                (L.prototype.name = ""),
                (L.prototype.docString = ""),
                (L.prototype.rawData = V.newBuffer([])),
                (L.prototype.externalData = V.emptyArray),
                (L.prototype.dataLocation = 0),
                (L.prototype.doubleData = V.emptyArray),
                (L.prototype.uint64Data = V.emptyArray),
                (L.create = function (H) {
                  return new L(H);
                }),
                (L.encode = function (H, F) {
                  if (
                    (F || (F = K.create()), H.dims != null && H.dims.length)
                  ) {
                    F.uint32(10).fork();
                    for (var N = 0; N < H.dims.length; ++N) F.int64(H.dims[N]);
                    F.ldelim();
                  }
                  if (
                    (H.dataType != null &&
                      H.hasOwnProperty("dataType") &&
                      F.uint32(16).int32(H.dataType),
                    H.segment != null &&
                      H.hasOwnProperty("segment") &&
                      W.onnx.TensorProto.Segment.encode(
                        H.segment,
                        F.uint32(26).fork()
                      ).ldelim(),
                    H.floatData != null && H.floatData.length)
                  ) {
                    for (
                      F.uint32(34).fork(), N = 0;
                      N < H.floatData.length;
                      ++N
                    )
                      F.float(H.floatData[N]);
                    F.ldelim();
                  }
                  if (H.int32Data != null && H.int32Data.length) {
                    for (
                      F.uint32(42).fork(), N = 0;
                      N < H.int32Data.length;
                      ++N
                    )
                      F.int32(H.int32Data[N]);
                    F.ldelim();
                  }
                  if (H.stringData != null && H.stringData.length)
                    for (N = 0; N < H.stringData.length; ++N)
                      F.uint32(50).bytes(H.stringData[N]);
                  if (H.int64Data != null && H.int64Data.length) {
                    for (
                      F.uint32(58).fork(), N = 0;
                      N < H.int64Data.length;
                      ++N
                    )
                      F.int64(H.int64Data[N]);
                    F.ldelim();
                  }
                  if (
                    (H.name != null &&
                      H.hasOwnProperty("name") &&
                      F.uint32(66).string(H.name),
                    H.rawData != null &&
                      H.hasOwnProperty("rawData") &&
                      F.uint32(74).bytes(H.rawData),
                    H.doubleData != null && H.doubleData.length)
                  ) {
                    for (
                      F.uint32(82).fork(), N = 0;
                      N < H.doubleData.length;
                      ++N
                    )
                      F.double(H.doubleData[N]);
                    F.ldelim();
                  }
                  if (H.uint64Data != null && H.uint64Data.length) {
                    for (
                      F.uint32(90).fork(), N = 0;
                      N < H.uint64Data.length;
                      ++N
                    )
                      F.uint64(H.uint64Data[N]);
                    F.ldelim();
                  }
                  if (
                    (H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      F.uint32(98).string(H.docString),
                    H.externalData != null && H.externalData.length)
                  )
                    for (N = 0; N < H.externalData.length; ++N)
                      W.onnx.StringStringEntryProto.encode(
                        H.externalData[N],
                        F.uint32(106).fork()
                      ).ldelim();
                  return (
                    H.dataLocation != null &&
                      H.hasOwnProperty("dataLocation") &&
                      F.uint32(112).int32(H.dataLocation),
                    F
                  );
                }),
                (L.encodeDelimited = function (H, F) {
                  return this.encode(H, F).ldelim();
                }),
                (L.decode = function (H, F) {
                  H instanceof B || (H = B.create(H));
                  for (
                    var N = F === void 0 ? H.len : H.pos + F,
                      q = new W.onnx.TensorProto();
                    H.pos < N;
                  ) {
                    var M = H.uint32();
                    switch (M >>> 3) {
                      case 1:
                        if (
                          ((q.dims && q.dims.length) || (q.dims = []),
                          (7 & M) == 2)
                        )
                          for (var A = H.uint32() + H.pos; H.pos < A; )
                            q.dims.push(H.int64());
                        else q.dims.push(H.int64());
                        break;
                      case 2:
                        q.dataType = H.int32();
                        break;
                      case 3:
                        q.segment = W.onnx.TensorProto.Segment.decode(
                          H,
                          H.uint32()
                        );
                        break;
                      case 4:
                        if (
                          ((q.floatData && q.floatData.length) ||
                            (q.floatData = []),
                          (7 & M) == 2)
                        )
                          for (A = H.uint32() + H.pos; H.pos < A; )
                            q.floatData.push(H.float());
                        else q.floatData.push(H.float());
                        break;
                      case 5:
                        if (
                          ((q.int32Data && q.int32Data.length) ||
                            (q.int32Data = []),
                          (7 & M) == 2)
                        )
                          for (A = H.uint32() + H.pos; H.pos < A; )
                            q.int32Data.push(H.int32());
                        else q.int32Data.push(H.int32());
                        break;
                      case 6:
                        ((q.stringData && q.stringData.length) ||
                          (q.stringData = []),
                          q.stringData.push(H.bytes()));
                        break;
                      case 7:
                        if (
                          ((q.int64Data && q.int64Data.length) ||
                            (q.int64Data = []),
                          (7 & M) == 2)
                        )
                          for (A = H.uint32() + H.pos; H.pos < A; )
                            q.int64Data.push(H.int64());
                        else q.int64Data.push(H.int64());
                        break;
                      case 8:
                        q.name = H.string();
                        break;
                      case 12:
                        q.docString = H.string();
                        break;
                      case 9:
                        q.rawData = H.bytes();
                        break;
                      case 13:
                        ((q.externalData && q.externalData.length) ||
                          (q.externalData = []),
                          q.externalData.push(
                            W.onnx.StringStringEntryProto.decode(H, H.uint32())
                          ));
                        break;
                      case 14:
                        q.dataLocation = H.int32();
                        break;
                      case 10:
                        if (
                          ((q.doubleData && q.doubleData.length) ||
                            (q.doubleData = []),
                          (7 & M) == 2)
                        )
                          for (A = H.uint32() + H.pos; H.pos < A; )
                            q.doubleData.push(H.double());
                        else q.doubleData.push(H.double());
                        break;
                      case 11:
                        if (
                          ((q.uint64Data && q.uint64Data.length) ||
                            (q.uint64Data = []),
                          (7 & M) == 2)
                        )
                          for (A = H.uint32() + H.pos; H.pos < A; )
                            q.uint64Data.push(H.uint64());
                        else q.uint64Data.push(H.uint64());
                        break;
                      default:
                        H.skipType(7 & M);
                    }
                  }
                  return q;
                }),
                (L.decodeDelimited = function (H) {
                  return (
                    H instanceof B || (H = new B(H)),
                    this.decode(H, H.uint32())
                  );
                }),
                (L.verify = function (H) {
                  if (typeof H != "object" || H === null)
                    return "object expected";
                  if (H.dims != null && H.hasOwnProperty("dims")) {
                    if (!Array.isArray(H.dims)) return "dims: array expected";
                    for (var F = 0; F < H.dims.length; ++F)
                      if (
                        !(
                          V.isInteger(H.dims[F]) ||
                          (H.dims[F] &&
                            V.isInteger(H.dims[F].low) &&
                            V.isInteger(H.dims[F].high))
                        )
                      )
                        return "dims: integer|Long[] expected";
                  }
                  if (
                    H.dataType != null &&
                    H.hasOwnProperty("dataType") &&
                    !V.isInteger(H.dataType)
                  )
                    return "dataType: integer expected";
                  if (
                    H.segment != null &&
                    H.hasOwnProperty("segment") &&
                    (N = W.onnx.TensorProto.Segment.verify(H.segment))
                  )
                    return "segment." + N;
                  if (H.floatData != null && H.hasOwnProperty("floatData")) {
                    if (!Array.isArray(H.floatData))
                      return "floatData: array expected";
                    for (F = 0; F < H.floatData.length; ++F)
                      if (typeof H.floatData[F] != "number")
                        return "floatData: number[] expected";
                  }
                  if (H.int32Data != null && H.hasOwnProperty("int32Data")) {
                    if (!Array.isArray(H.int32Data))
                      return "int32Data: array expected";
                    for (F = 0; F < H.int32Data.length; ++F)
                      if (!V.isInteger(H.int32Data[F]))
                        return "int32Data: integer[] expected";
                  }
                  if (H.stringData != null && H.hasOwnProperty("stringData")) {
                    if (!Array.isArray(H.stringData))
                      return "stringData: array expected";
                    for (F = 0; F < H.stringData.length; ++F)
                      if (
                        !(
                          (H.stringData[F] &&
                            typeof H.stringData[F].length == "number") ||
                          V.isString(H.stringData[F])
                        )
                      )
                        return "stringData: buffer[] expected";
                  }
                  if (H.int64Data != null && H.hasOwnProperty("int64Data")) {
                    if (!Array.isArray(H.int64Data))
                      return "int64Data: array expected";
                    for (F = 0; F < H.int64Data.length; ++F)
                      if (
                        !(
                          V.isInteger(H.int64Data[F]) ||
                          (H.int64Data[F] &&
                            V.isInteger(H.int64Data[F].low) &&
                            V.isInteger(H.int64Data[F].high))
                        )
                      )
                        return "int64Data: integer|Long[] expected";
                  }
                  if (
                    H.name != null &&
                    H.hasOwnProperty("name") &&
                    !V.isString(H.name)
                  )
                    return "name: string expected";
                  if (
                    H.docString != null &&
                    H.hasOwnProperty("docString") &&
                    !V.isString(H.docString)
                  )
                    return "docString: string expected";
                  if (
                    H.rawData != null &&
                    H.hasOwnProperty("rawData") &&
                    !(
                      (H.rawData && typeof H.rawData.length == "number") ||
                      V.isString(H.rawData)
                    )
                  )
                    return "rawData: buffer expected";
                  if (
                    H.externalData != null &&
                    H.hasOwnProperty("externalData")
                  ) {
                    if (!Array.isArray(H.externalData))
                      return "externalData: array expected";
                    for (F = 0; F < H.externalData.length; ++F) {
                      var N;
                      if (
                        (N = W.onnx.StringStringEntryProto.verify(
                          H.externalData[F]
                        ))
                      )
                        return "externalData." + N;
                    }
                  }
                  if (
                    H.dataLocation != null &&
                    H.hasOwnProperty("dataLocation")
                  )
                    switch (H.dataLocation) {
                      default:
                        return "dataLocation: enum value expected";
                      case 0:
                      case 1:
                    }
                  if (H.doubleData != null && H.hasOwnProperty("doubleData")) {
                    if (!Array.isArray(H.doubleData))
                      return "doubleData: array expected";
                    for (F = 0; F < H.doubleData.length; ++F)
                      if (typeof H.doubleData[F] != "number")
                        return "doubleData: number[] expected";
                  }
                  if (H.uint64Data != null && H.hasOwnProperty("uint64Data")) {
                    if (!Array.isArray(H.uint64Data))
                      return "uint64Data: array expected";
                    for (F = 0; F < H.uint64Data.length; ++F)
                      if (
                        !(
                          V.isInteger(H.uint64Data[F]) ||
                          (H.uint64Data[F] &&
                            V.isInteger(H.uint64Data[F].low) &&
                            V.isInteger(H.uint64Data[F].high))
                        )
                      )
                        return "uint64Data: integer|Long[] expected";
                  }
                  return null;
                }),
                (L.fromObject = function (H) {
                  if (H instanceof W.onnx.TensorProto) return H;
                  var F = new W.onnx.TensorProto();
                  if (H.dims) {
                    if (!Array.isArray(H.dims))
                      throw TypeError(".onnx.TensorProto.dims: array expected");
                    F.dims = [];
                    for (var N = 0; N < H.dims.length; ++N)
                      V.Long
                        ? ((F.dims[N] = V.Long.fromValue(H.dims[N])).unsigned =
                            !1)
                        : typeof H.dims[N] == "string"
                          ? (F.dims[N] = parseInt(H.dims[N], 10))
                          : typeof H.dims[N] == "number"
                            ? (F.dims[N] = H.dims[N])
                            : typeof H.dims[N] == "object" &&
                              (F.dims[N] = new V.LongBits(
                                H.dims[N].low >>> 0,
                                H.dims[N].high >>> 0
                              ).toNumber());
                  }
                  if (
                    (H.dataType != null && (F.dataType = 0 | H.dataType),
                    H.segment != null)
                  ) {
                    if (typeof H.segment != "object")
                      throw TypeError(
                        ".onnx.TensorProto.segment: object expected"
                      );
                    F.segment = W.onnx.TensorProto.Segment.fromObject(
                      H.segment
                    );
                  }
                  if (H.floatData) {
                    if (!Array.isArray(H.floatData))
                      throw TypeError(
                        ".onnx.TensorProto.floatData: array expected"
                      );
                    for (F.floatData = [], N = 0; N < H.floatData.length; ++N)
                      F.floatData[N] = Number(H.floatData[N]);
                  }
                  if (H.int32Data) {
                    if (!Array.isArray(H.int32Data))
                      throw TypeError(
                        ".onnx.TensorProto.int32Data: array expected"
                      );
                    for (F.int32Data = [], N = 0; N < H.int32Data.length; ++N)
                      F.int32Data[N] = 0 | H.int32Data[N];
                  }
                  if (H.stringData) {
                    if (!Array.isArray(H.stringData))
                      throw TypeError(
                        ".onnx.TensorProto.stringData: array expected"
                      );
                    for (F.stringData = [], N = 0; N < H.stringData.length; ++N)
                      typeof H.stringData[N] == "string"
                        ? V.base64.decode(
                            H.stringData[N],
                            (F.stringData[N] = V.newBuffer(
                              V.base64.length(H.stringData[N])
                            )),
                            0
                          )
                        : H.stringData[N].length &&
                          (F.stringData[N] = H.stringData[N]);
                  }
                  if (H.int64Data) {
                    if (!Array.isArray(H.int64Data))
                      throw TypeError(
                        ".onnx.TensorProto.int64Data: array expected"
                      );
                    for (F.int64Data = [], N = 0; N < H.int64Data.length; ++N)
                      V.Long
                        ? ((F.int64Data[N] = V.Long.fromValue(
                            H.int64Data[N]
                          )).unsigned = !1)
                        : typeof H.int64Data[N] == "string"
                          ? (F.int64Data[N] = parseInt(H.int64Data[N], 10))
                          : typeof H.int64Data[N] == "number"
                            ? (F.int64Data[N] = H.int64Data[N])
                            : typeof H.int64Data[N] == "object" &&
                              (F.int64Data[N] = new V.LongBits(
                                H.int64Data[N].low >>> 0,
                                H.int64Data[N].high >>> 0
                              ).toNumber());
                  }
                  if (
                    (H.name != null && (F.name = String(H.name)),
                    H.docString != null && (F.docString = String(H.docString)),
                    H.rawData != null &&
                      (typeof H.rawData == "string"
                        ? V.base64.decode(
                            H.rawData,
                            (F.rawData = V.newBuffer(
                              V.base64.length(H.rawData)
                            )),
                            0
                          )
                        : H.rawData.length && (F.rawData = H.rawData)),
                    H.externalData)
                  ) {
                    if (!Array.isArray(H.externalData))
                      throw TypeError(
                        ".onnx.TensorProto.externalData: array expected"
                      );
                    for (
                      F.externalData = [], N = 0;
                      N < H.externalData.length;
                      ++N
                    ) {
                      if (typeof H.externalData[N] != "object")
                        throw TypeError(
                          ".onnx.TensorProto.externalData: object expected"
                        );
                      F.externalData[N] =
                        W.onnx.StringStringEntryProto.fromObject(
                          H.externalData[N]
                        );
                    }
                  }
                  switch (H.dataLocation) {
                    case "DEFAULT":
                    case 0:
                      F.dataLocation = 0;
                      break;
                    case "EXTERNAL":
                    case 1:
                      F.dataLocation = 1;
                  }
                  if (H.doubleData) {
                    if (!Array.isArray(H.doubleData))
                      throw TypeError(
                        ".onnx.TensorProto.doubleData: array expected"
                      );
                    for (F.doubleData = [], N = 0; N < H.doubleData.length; ++N)
                      F.doubleData[N] = Number(H.doubleData[N]);
                  }
                  if (H.uint64Data) {
                    if (!Array.isArray(H.uint64Data))
                      throw TypeError(
                        ".onnx.TensorProto.uint64Data: array expected"
                      );
                    for (F.uint64Data = [], N = 0; N < H.uint64Data.length; ++N)
                      V.Long
                        ? ((F.uint64Data[N] = V.Long.fromValue(
                            H.uint64Data[N]
                          )).unsigned = !0)
                        : typeof H.uint64Data[N] == "string"
                          ? (F.uint64Data[N] = parseInt(H.uint64Data[N], 10))
                          : typeof H.uint64Data[N] == "number"
                            ? (F.uint64Data[N] = H.uint64Data[N])
                            : typeof H.uint64Data[N] == "object" &&
                              (F.uint64Data[N] = new V.LongBits(
                                H.uint64Data[N].low >>> 0,
                                H.uint64Data[N].high >>> 0
                              ).toNumber(!0));
                  }
                  return F;
                }),
                (L.toObject = function (H, F) {
                  F || (F = {});
                  var N = {};
                  if (
                    ((F.arrays || F.defaults) &&
                      ((N.dims = []),
                      (N.floatData = []),
                      (N.int32Data = []),
                      (N.stringData = []),
                      (N.int64Data = []),
                      (N.doubleData = []),
                      (N.uint64Data = []),
                      (N.externalData = [])),
                    F.defaults &&
                      ((N.dataType = 0),
                      (N.segment = null),
                      (N.name = ""),
                      F.bytes === String
                        ? (N.rawData = "")
                        : ((N.rawData = []),
                          F.bytes !== Array &&
                            (N.rawData = V.newBuffer(N.rawData))),
                      (N.docString = ""),
                      (N.dataLocation = F.enums === String ? "DEFAULT" : 0)),
                    H.dims && H.dims.length)
                  ) {
                    N.dims = [];
                    for (var q = 0; q < H.dims.length; ++q)
                      typeof H.dims[q] == "number"
                        ? (N.dims[q] =
                            F.longs === String ? String(H.dims[q]) : H.dims[q])
                        : (N.dims[q] =
                            F.longs === String
                              ? V.Long.prototype.toString.call(H.dims[q])
                              : F.longs === Number
                                ? new V.LongBits(
                                    H.dims[q].low >>> 0,
                                    H.dims[q].high >>> 0
                                  ).toNumber()
                                : H.dims[q]);
                  }
                  if (
                    (H.dataType != null &&
                      H.hasOwnProperty("dataType") &&
                      (N.dataType = H.dataType),
                    H.segment != null &&
                      H.hasOwnProperty("segment") &&
                      (N.segment = W.onnx.TensorProto.Segment.toObject(
                        H.segment,
                        F
                      )),
                    H.floatData && H.floatData.length)
                  )
                    for (N.floatData = [], q = 0; q < H.floatData.length; ++q)
                      N.floatData[q] =
                        F.json && !isFinite(H.floatData[q])
                          ? String(H.floatData[q])
                          : H.floatData[q];
                  if (H.int32Data && H.int32Data.length)
                    for (N.int32Data = [], q = 0; q < H.int32Data.length; ++q)
                      N.int32Data[q] = H.int32Data[q];
                  if (H.stringData && H.stringData.length)
                    for (N.stringData = [], q = 0; q < H.stringData.length; ++q)
                      N.stringData[q] =
                        F.bytes === String
                          ? V.base64.encode(
                              H.stringData[q],
                              0,
                              H.stringData[q].length
                            )
                          : F.bytes === Array
                            ? Array.prototype.slice.call(H.stringData[q])
                            : H.stringData[q];
                  if (H.int64Data && H.int64Data.length)
                    for (N.int64Data = [], q = 0; q < H.int64Data.length; ++q)
                      typeof H.int64Data[q] == "number"
                        ? (N.int64Data[q] =
                            F.longs === String
                              ? String(H.int64Data[q])
                              : H.int64Data[q])
                        : (N.int64Data[q] =
                            F.longs === String
                              ? V.Long.prototype.toString.call(H.int64Data[q])
                              : F.longs === Number
                                ? new V.LongBits(
                                    H.int64Data[q].low >>> 0,
                                    H.int64Data[q].high >>> 0
                                  ).toNumber()
                                : H.int64Data[q]);
                  if (
                    (H.name != null &&
                      H.hasOwnProperty("name") &&
                      (N.name = H.name),
                    H.rawData != null &&
                      H.hasOwnProperty("rawData") &&
                      (N.rawData =
                        F.bytes === String
                          ? V.base64.encode(H.rawData, 0, H.rawData.length)
                          : F.bytes === Array
                            ? Array.prototype.slice.call(H.rawData)
                            : H.rawData),
                    H.doubleData && H.doubleData.length)
                  )
                    for (N.doubleData = [], q = 0; q < H.doubleData.length; ++q)
                      N.doubleData[q] =
                        F.json && !isFinite(H.doubleData[q])
                          ? String(H.doubleData[q])
                          : H.doubleData[q];
                  if (H.uint64Data && H.uint64Data.length)
                    for (N.uint64Data = [], q = 0; q < H.uint64Data.length; ++q)
                      typeof H.uint64Data[q] == "number"
                        ? (N.uint64Data[q] =
                            F.longs === String
                              ? String(H.uint64Data[q])
                              : H.uint64Data[q])
                        : (N.uint64Data[q] =
                            F.longs === String
                              ? V.Long.prototype.toString.call(H.uint64Data[q])
                              : F.longs === Number
                                ? new V.LongBits(
                                    H.uint64Data[q].low >>> 0,
                                    H.uint64Data[q].high >>> 0
                                  ).toNumber(!0)
                                : H.uint64Data[q]);
                  if (
                    (H.docString != null &&
                      H.hasOwnProperty("docString") &&
                      (N.docString = H.docString),
                    H.externalData && H.externalData.length)
                  )
                    for (
                      N.externalData = [], q = 0;
                      q < H.externalData.length;
                      ++q
                    )
                      N.externalData[q] =
                        W.onnx.StringStringEntryProto.toObject(
                          H.externalData[q],
                          F
                        );
                  return (
                    H.dataLocation != null &&
                      H.hasOwnProperty("dataLocation") &&
                      (N.dataLocation =
                        F.enums === String
                          ? W.onnx.TensorProto.DataLocation[H.dataLocation]
                          : H.dataLocation),
                    N
                  );
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                (L.DataType = (function () {
                  var H = {},
                    F = Object.create(H);
                  return (
                    (F[(H[0] = "UNDEFINED")] = 0),
                    (F[(H[1] = "FLOAT")] = 1),
                    (F[(H[2] = "UINT8")] = 2),
                    (F[(H[3] = "INT8")] = 3),
                    (F[(H[4] = "UINT16")] = 4),
                    (F[(H[5] = "INT16")] = 5),
                    (F[(H[6] = "INT32")] = 6),
                    (F[(H[7] = "INT64")] = 7),
                    (F[(H[8] = "STRING")] = 8),
                    (F[(H[9] = "BOOL")] = 9),
                    (F[(H[10] = "FLOAT16")] = 10),
                    (F[(H[11] = "DOUBLE")] = 11),
                    (F[(H[12] = "UINT32")] = 12),
                    (F[(H[13] = "UINT64")] = 13),
                    (F[(H[14] = "COMPLEX64")] = 14),
                    (F[(H[15] = "COMPLEX128")] = 15),
                    (F[(H[16] = "BFLOAT16")] = 16),
                    F
                  );
                })()),
                (L.Segment = (function () {
                  function H(F) {
                    if (F)
                      for (var N = Object.keys(F), q = 0; q < N.length; ++q)
                        F[N[q]] != null && (this[N[q]] = F[N[q]]);
                  }
                  return (
                    (H.prototype.begin = V.Long
                      ? V.Long.fromBits(0, 0, !1)
                      : 0),
                    (H.prototype.end = V.Long ? V.Long.fromBits(0, 0, !1) : 0),
                    (H.create = function (F) {
                      return new H(F);
                    }),
                    (H.encode = function (F, N) {
                      return (
                        N || (N = K.create()),
                        F.begin != null &&
                          F.hasOwnProperty("begin") &&
                          N.uint32(8).int64(F.begin),
                        F.end != null &&
                          F.hasOwnProperty("end") &&
                          N.uint32(16).int64(F.end),
                        N
                      );
                    }),
                    (H.encodeDelimited = function (F, N) {
                      return this.encode(F, N).ldelim();
                    }),
                    (H.decode = function (F, N) {
                      F instanceof B || (F = B.create(F));
                      for (
                        var q = N === void 0 ? F.len : F.pos + N,
                          M = new W.onnx.TensorProto.Segment();
                        F.pos < q;
                      ) {
                        var A = F.uint32();
                        switch (A >>> 3) {
                          case 1:
                            M.begin = F.int64();
                            break;
                          case 2:
                            M.end = F.int64();
                            break;
                          default:
                            F.skipType(7 & A);
                        }
                      }
                      return M;
                    }),
                    (H.decodeDelimited = function (F) {
                      return (
                        F instanceof B || (F = new B(F)),
                        this.decode(F, F.uint32())
                      );
                    }),
                    (H.verify = function (F) {
                      return typeof F != "object" || F === null
                        ? "object expected"
                        : F.begin != null &&
                            F.hasOwnProperty("begin") &&
                            !(
                              V.isInteger(F.begin) ||
                              (F.begin &&
                                V.isInteger(F.begin.low) &&
                                V.isInteger(F.begin.high))
                            )
                          ? "begin: integer|Long expected"
                          : F.end != null &&
                              F.hasOwnProperty("end") &&
                              !(
                                V.isInteger(F.end) ||
                                (F.end &&
                                  V.isInteger(F.end.low) &&
                                  V.isInteger(F.end.high))
                              )
                            ? "end: integer|Long expected"
                            : null;
                    }),
                    (H.fromObject = function (F) {
                      if (F instanceof W.onnx.TensorProto.Segment) return F;
                      var N = new W.onnx.TensorProto.Segment();
                      return (
                        F.begin != null &&
                          (V.Long
                            ? ((N.begin = V.Long.fromValue(F.begin)).unsigned =
                                !1)
                            : typeof F.begin == "string"
                              ? (N.begin = parseInt(F.begin, 10))
                              : typeof F.begin == "number"
                                ? (N.begin = F.begin)
                                : typeof F.begin == "object" &&
                                  (N.begin = new V.LongBits(
                                    F.begin.low >>> 0,
                                    F.begin.high >>> 0
                                  ).toNumber())),
                        F.end != null &&
                          (V.Long
                            ? ((N.end = V.Long.fromValue(F.end)).unsigned = !1)
                            : typeof F.end == "string"
                              ? (N.end = parseInt(F.end, 10))
                              : typeof F.end == "number"
                                ? (N.end = F.end)
                                : typeof F.end == "object" &&
                                  (N.end = new V.LongBits(
                                    F.end.low >>> 0,
                                    F.end.high >>> 0
                                  ).toNumber())),
                        N
                      );
                    }),
                    (H.toObject = function (F, N) {
                      N || (N = {});
                      var q = {};
                      if (N.defaults) {
                        if (V.Long) {
                          var M = new V.Long(0, 0, !1);
                          q.begin =
                            N.longs === String
                              ? M.toString()
                              : N.longs === Number
                                ? M.toNumber()
                                : M;
                        } else q.begin = N.longs === String ? "0" : 0;
                        V.Long
                          ? ((M = new V.Long(0, 0, !1)),
                            (q.end =
                              N.longs === String
                                ? M.toString()
                                : N.longs === Number
                                  ? M.toNumber()
                                  : M))
                          : (q.end = N.longs === String ? "0" : 0);
                      }
                      return (
                        F.begin != null &&
                          F.hasOwnProperty("begin") &&
                          (typeof F.begin == "number"
                            ? (q.begin =
                                N.longs === String ? String(F.begin) : F.begin)
                            : (q.begin =
                                N.longs === String
                                  ? V.Long.prototype.toString.call(F.begin)
                                  : N.longs === Number
                                    ? new V.LongBits(
                                        F.begin.low >>> 0,
                                        F.begin.high >>> 0
                                      ).toNumber()
                                    : F.begin)),
                        F.end != null &&
                          F.hasOwnProperty("end") &&
                          (typeof F.end == "number"
                            ? (q.end =
                                N.longs === String ? String(F.end) : F.end)
                            : (q.end =
                                N.longs === String
                                  ? V.Long.prototype.toString.call(F.end)
                                  : N.longs === Number
                                    ? new V.LongBits(
                                        F.end.low >>> 0,
                                        F.end.high >>> 0
                                      ).toNumber()
                                    : F.end)),
                        q
                      );
                    }),
                    (H.prototype.toJSON = function () {
                      return this.constructor.toObject(
                        this,
                        $.util.toJSONOptions
                      );
                    }),
                    H
                  );
                })()),
                (L.DataLocation = (function () {
                  var H = {},
                    F = Object.create(H);
                  return (
                    (F[(H[0] = "DEFAULT")] = 0),
                    (F[(H[1] = "EXTERNAL")] = 1),
                    F
                  );
                })()),
                L
              );
            })()),
            (U.TensorShapeProto = (function () {
              function L(H) {
                if (((this.dim = []), H))
                  for (var F = Object.keys(H), N = 0; N < F.length; ++N)
                    H[F[N]] != null && (this[F[N]] = H[F[N]]);
              }
              return (
                (L.prototype.dim = V.emptyArray),
                (L.create = function (H) {
                  return new L(H);
                }),
                (L.encode = function (H, F) {
                  if ((F || (F = K.create()), H.dim != null && H.dim.length))
                    for (var N = 0; N < H.dim.length; ++N)
                      W.onnx.TensorShapeProto.Dimension.encode(
                        H.dim[N],
                        F.uint32(10).fork()
                      ).ldelim();
                  return F;
                }),
                (L.encodeDelimited = function (H, F) {
                  return this.encode(H, F).ldelim();
                }),
                (L.decode = function (H, F) {
                  H instanceof B || (H = B.create(H));
                  for (
                    var N = F === void 0 ? H.len : H.pos + F,
                      q = new W.onnx.TensorShapeProto();
                    H.pos < N;
                  ) {
                    var M = H.uint32();
                    M >>> 3 == 1
                      ? ((q.dim && q.dim.length) || (q.dim = []),
                        q.dim.push(
                          W.onnx.TensorShapeProto.Dimension.decode(
                            H,
                            H.uint32()
                          )
                        ))
                      : H.skipType(7 & M);
                  }
                  return q;
                }),
                (L.decodeDelimited = function (H) {
                  return (
                    H instanceof B || (H = new B(H)),
                    this.decode(H, H.uint32())
                  );
                }),
                (L.verify = function (H) {
                  if (typeof H != "object" || H === null)
                    return "object expected";
                  if (H.dim != null && H.hasOwnProperty("dim")) {
                    if (!Array.isArray(H.dim)) return "dim: array expected";
                    for (var F = 0; F < H.dim.length; ++F) {
                      var N = W.onnx.TensorShapeProto.Dimension.verify(
                        H.dim[F]
                      );
                      if (N) return "dim." + N;
                    }
                  }
                  return null;
                }),
                (L.fromObject = function (H) {
                  if (H instanceof W.onnx.TensorShapeProto) return H;
                  var F = new W.onnx.TensorShapeProto();
                  if (H.dim) {
                    if (!Array.isArray(H.dim))
                      throw TypeError(
                        ".onnx.TensorShapeProto.dim: array expected"
                      );
                    F.dim = [];
                    for (var N = 0; N < H.dim.length; ++N) {
                      if (typeof H.dim[N] != "object")
                        throw TypeError(
                          ".onnx.TensorShapeProto.dim: object expected"
                        );
                      F.dim[N] = W.onnx.TensorShapeProto.Dimension.fromObject(
                        H.dim[N]
                      );
                    }
                  }
                  return F;
                }),
                (L.toObject = function (H, F) {
                  F || (F = {});
                  var N = {};
                  if (
                    ((F.arrays || F.defaults) && (N.dim = []),
                    H.dim && H.dim.length)
                  ) {
                    N.dim = [];
                    for (var q = 0; q < H.dim.length; ++q)
                      N.dim[q] = W.onnx.TensorShapeProto.Dimension.toObject(
                        H.dim[q],
                        F
                      );
                  }
                  return N;
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                (L.Dimension = (function () {
                  function H(N) {
                    if (N)
                      for (var q = Object.keys(N), M = 0; M < q.length; ++M)
                        N[q[M]] != null && (this[q[M]] = N[q[M]]);
                  }
                  var F;
                  return (
                    (H.prototype.dimValue = V.Long
                      ? V.Long.fromBits(0, 0, !1)
                      : 0),
                    (H.prototype.dimParam = ""),
                    (H.prototype.denotation = ""),
                    Object.defineProperty(H.prototype, "value", {
                      get: V.oneOfGetter((F = ["dimValue", "dimParam"])),
                      set: V.oneOfSetter(F),
                    }),
                    (H.create = function (N) {
                      return new H(N);
                    }),
                    (H.encode = function (N, q) {
                      return (
                        q || (q = K.create()),
                        N.dimValue != null &&
                          N.hasOwnProperty("dimValue") &&
                          q.uint32(8).int64(N.dimValue),
                        N.dimParam != null &&
                          N.hasOwnProperty("dimParam") &&
                          q.uint32(18).string(N.dimParam),
                        N.denotation != null &&
                          N.hasOwnProperty("denotation") &&
                          q.uint32(26).string(N.denotation),
                        q
                      );
                    }),
                    (H.encodeDelimited = function (N, q) {
                      return this.encode(N, q).ldelim();
                    }),
                    (H.decode = function (N, q) {
                      N instanceof B || (N = B.create(N));
                      for (
                        var M = q === void 0 ? N.len : N.pos + q,
                          A = new W.onnx.TensorShapeProto.Dimension();
                        N.pos < M;
                      ) {
                        var D = N.uint32();
                        switch (D >>> 3) {
                          case 1:
                            A.dimValue = N.int64();
                            break;
                          case 2:
                            A.dimParam = N.string();
                            break;
                          case 3:
                            A.denotation = N.string();
                            break;
                          default:
                            N.skipType(7 & D);
                        }
                      }
                      return A;
                    }),
                    (H.decodeDelimited = function (N) {
                      return (
                        N instanceof B || (N = new B(N)),
                        this.decode(N, N.uint32())
                      );
                    }),
                    (H.verify = function (N) {
                      if (typeof N != "object" || N === null)
                        return "object expected";
                      var q = {};
                      if (
                        N.dimValue != null &&
                        N.hasOwnProperty("dimValue") &&
                        ((q.value = 1),
                        !(
                          V.isInteger(N.dimValue) ||
                          (N.dimValue &&
                            V.isInteger(N.dimValue.low) &&
                            V.isInteger(N.dimValue.high))
                        ))
                      )
                        return "dimValue: integer|Long expected";
                      if (N.dimParam != null && N.hasOwnProperty("dimParam")) {
                        if (q.value === 1) return "value: multiple values";
                        if (((q.value = 1), !V.isString(N.dimParam)))
                          return "dimParam: string expected";
                      }
                      return N.denotation != null &&
                        N.hasOwnProperty("denotation") &&
                        !V.isString(N.denotation)
                        ? "denotation: string expected"
                        : null;
                    }),
                    (H.fromObject = function (N) {
                      if (N instanceof W.onnx.TensorShapeProto.Dimension)
                        return N;
                      var q = new W.onnx.TensorShapeProto.Dimension();
                      return (
                        N.dimValue != null &&
                          (V.Long
                            ? ((q.dimValue = V.Long.fromValue(
                                N.dimValue
                              )).unsigned = !1)
                            : typeof N.dimValue == "string"
                              ? (q.dimValue = parseInt(N.dimValue, 10))
                              : typeof N.dimValue == "number"
                                ? (q.dimValue = N.dimValue)
                                : typeof N.dimValue == "object" &&
                                  (q.dimValue = new V.LongBits(
                                    N.dimValue.low >>> 0,
                                    N.dimValue.high >>> 0
                                  ).toNumber())),
                        N.dimParam != null && (q.dimParam = String(N.dimParam)),
                        N.denotation != null &&
                          (q.denotation = String(N.denotation)),
                        q
                      );
                    }),
                    (H.toObject = function (N, q) {
                      q || (q = {});
                      var M = {};
                      return (
                        q.defaults && (M.denotation = ""),
                        N.dimValue != null &&
                          N.hasOwnProperty("dimValue") &&
                          (typeof N.dimValue == "number"
                            ? (M.dimValue =
                                q.longs === String
                                  ? String(N.dimValue)
                                  : N.dimValue)
                            : (M.dimValue =
                                q.longs === String
                                  ? V.Long.prototype.toString.call(N.dimValue)
                                  : q.longs === Number
                                    ? new V.LongBits(
                                        N.dimValue.low >>> 0,
                                        N.dimValue.high >>> 0
                                      ).toNumber()
                                    : N.dimValue),
                          q.oneofs && (M.value = "dimValue")),
                        N.dimParam != null &&
                          N.hasOwnProperty("dimParam") &&
                          ((M.dimParam = N.dimParam),
                          q.oneofs && (M.value = "dimParam")),
                        N.denotation != null &&
                          N.hasOwnProperty("denotation") &&
                          (M.denotation = N.denotation),
                        M
                      );
                    }),
                    (H.prototype.toJSON = function () {
                      return this.constructor.toObject(
                        this,
                        $.util.toJSONOptions
                      );
                    }),
                    H
                  );
                })()),
                L
              );
            })()),
            (U.TypeProto = (function () {
              function L(F) {
                if (F)
                  for (var N = Object.keys(F), q = 0; q < N.length; ++q)
                    F[N[q]] != null && (this[N[q]] = F[N[q]]);
              }
              var H;
              return (
                (L.prototype.tensorType = null),
                (L.prototype.denotation = ""),
                Object.defineProperty(L.prototype, "value", {
                  get: V.oneOfGetter((H = ["tensorType"])),
                  set: V.oneOfSetter(H),
                }),
                (L.create = function (F) {
                  return new L(F);
                }),
                (L.encode = function (F, N) {
                  return (
                    N || (N = K.create()),
                    F.tensorType != null &&
                      F.hasOwnProperty("tensorType") &&
                      W.onnx.TypeProto.Tensor.encode(
                        F.tensorType,
                        N.uint32(10).fork()
                      ).ldelim(),
                    F.denotation != null &&
                      F.hasOwnProperty("denotation") &&
                      N.uint32(50).string(F.denotation),
                    N
                  );
                }),
                (L.encodeDelimited = function (F, N) {
                  return this.encode(F, N).ldelim();
                }),
                (L.decode = function (F, N) {
                  F instanceof B || (F = B.create(F));
                  for (
                    var q = N === void 0 ? F.len : F.pos + N,
                      M = new W.onnx.TypeProto();
                    F.pos < q;
                  ) {
                    var A = F.uint32();
                    switch (A >>> 3) {
                      case 1:
                        M.tensorType = W.onnx.TypeProto.Tensor.decode(
                          F,
                          F.uint32()
                        );
                        break;
                      case 6:
                        M.denotation = F.string();
                        break;
                      default:
                        F.skipType(7 & A);
                    }
                  }
                  return M;
                }),
                (L.decodeDelimited = function (F) {
                  return (
                    F instanceof B || (F = new B(F)),
                    this.decode(F, F.uint32())
                  );
                }),
                (L.verify = function (F) {
                  if (typeof F != "object" || F === null)
                    return "object expected";
                  if (F.tensorType != null && F.hasOwnProperty("tensorType")) {
                    var N = W.onnx.TypeProto.Tensor.verify(F.tensorType);
                    if (N) return "tensorType." + N;
                  }
                  return F.denotation != null &&
                    F.hasOwnProperty("denotation") &&
                    !V.isString(F.denotation)
                    ? "denotation: string expected"
                    : null;
                }),
                (L.fromObject = function (F) {
                  if (F instanceof W.onnx.TypeProto) return F;
                  var N = new W.onnx.TypeProto();
                  if (F.tensorType != null) {
                    if (typeof F.tensorType != "object")
                      throw TypeError(
                        ".onnx.TypeProto.tensorType: object expected"
                      );
                    N.tensorType = W.onnx.TypeProto.Tensor.fromObject(
                      F.tensorType
                    );
                  }
                  return (
                    F.denotation != null &&
                      (N.denotation = String(F.denotation)),
                    N
                  );
                }),
                (L.toObject = function (F, N) {
                  N || (N = {});
                  var q = {};
                  return (
                    N.defaults && (q.denotation = ""),
                    F.tensorType != null &&
                      F.hasOwnProperty("tensorType") &&
                      ((q.tensorType = W.onnx.TypeProto.Tensor.toObject(
                        F.tensorType,
                        N
                      )),
                      N.oneofs && (q.value = "tensorType")),
                    F.denotation != null &&
                      F.hasOwnProperty("denotation") &&
                      (q.denotation = F.denotation),
                    q
                  );
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                (L.Tensor = (function () {
                  function F(N) {
                    if (N)
                      for (var q = Object.keys(N), M = 0; M < q.length; ++M)
                        N[q[M]] != null && (this[q[M]] = N[q[M]]);
                  }
                  return (
                    (F.prototype.elemType = 0),
                    (F.prototype.shape = null),
                    (F.create = function (N) {
                      return new F(N);
                    }),
                    (F.encode = function (N, q) {
                      return (
                        q || (q = K.create()),
                        N.elemType != null &&
                          N.hasOwnProperty("elemType") &&
                          q.uint32(8).int32(N.elemType),
                        N.shape != null &&
                          N.hasOwnProperty("shape") &&
                          W.onnx.TensorShapeProto.encode(
                            N.shape,
                            q.uint32(18).fork()
                          ).ldelim(),
                        q
                      );
                    }),
                    (F.encodeDelimited = function (N, q) {
                      return this.encode(N, q).ldelim();
                    }),
                    (F.decode = function (N, q) {
                      N instanceof B || (N = B.create(N));
                      for (
                        var M = q === void 0 ? N.len : N.pos + q,
                          A = new W.onnx.TypeProto.Tensor();
                        N.pos < M;
                      ) {
                        var D = N.uint32();
                        switch (D >>> 3) {
                          case 1:
                            A.elemType = N.int32();
                            break;
                          case 2:
                            A.shape = W.onnx.TensorShapeProto.decode(
                              N,
                              N.uint32()
                            );
                            break;
                          default:
                            N.skipType(7 & D);
                        }
                      }
                      return A;
                    }),
                    (F.decodeDelimited = function (N) {
                      return (
                        N instanceof B || (N = new B(N)),
                        this.decode(N, N.uint32())
                      );
                    }),
                    (F.verify = function (N) {
                      if (typeof N != "object" || N === null)
                        return "object expected";
                      if (
                        N.elemType != null &&
                        N.hasOwnProperty("elemType") &&
                        !V.isInteger(N.elemType)
                      )
                        return "elemType: integer expected";
                      if (N.shape != null && N.hasOwnProperty("shape")) {
                        var q = W.onnx.TensorShapeProto.verify(N.shape);
                        if (q) return "shape." + q;
                      }
                      return null;
                    }),
                    (F.fromObject = function (N) {
                      if (N instanceof W.onnx.TypeProto.Tensor) return N;
                      var q = new W.onnx.TypeProto.Tensor();
                      if (
                        (N.elemType != null && (q.elemType = 0 | N.elemType),
                        N.shape != null)
                      ) {
                        if (typeof N.shape != "object")
                          throw TypeError(
                            ".onnx.TypeProto.Tensor.shape: object expected"
                          );
                        q.shape = W.onnx.TensorShapeProto.fromObject(N.shape);
                      }
                      return q;
                    }),
                    (F.toObject = function (N, q) {
                      q || (q = {});
                      var M = {};
                      return (
                        q.defaults && ((M.elemType = 0), (M.shape = null)),
                        N.elemType != null &&
                          N.hasOwnProperty("elemType") &&
                          (M.elemType = N.elemType),
                        N.shape != null &&
                          N.hasOwnProperty("shape") &&
                          (M.shape = W.onnx.TensorShapeProto.toObject(
                            N.shape,
                            q
                          )),
                        M
                      );
                    }),
                    (F.prototype.toJSON = function () {
                      return this.constructor.toObject(
                        this,
                        $.util.toJSONOptions
                      );
                    }),
                    F
                  );
                })()),
                L
              );
            })()),
            (U.OperatorSetIdProto = (function () {
              function L(H) {
                if (H)
                  for (var F = Object.keys(H), N = 0; N < F.length; ++N)
                    H[F[N]] != null && (this[F[N]] = H[F[N]]);
              }
              return (
                (L.prototype.domain = ""),
                (L.prototype.version = V.Long ? V.Long.fromBits(0, 0, !1) : 0),
                (L.create = function (H) {
                  return new L(H);
                }),
                (L.encode = function (H, F) {
                  return (
                    F || (F = K.create()),
                    H.domain != null &&
                      H.hasOwnProperty("domain") &&
                      F.uint32(10).string(H.domain),
                    H.version != null &&
                      H.hasOwnProperty("version") &&
                      F.uint32(16).int64(H.version),
                    F
                  );
                }),
                (L.encodeDelimited = function (H, F) {
                  return this.encode(H, F).ldelim();
                }),
                (L.decode = function (H, F) {
                  H instanceof B || (H = B.create(H));
                  for (
                    var N = F === void 0 ? H.len : H.pos + F,
                      q = new W.onnx.OperatorSetIdProto();
                    H.pos < N;
                  ) {
                    var M = H.uint32();
                    switch (M >>> 3) {
                      case 1:
                        q.domain = H.string();
                        break;
                      case 2:
                        q.version = H.int64();
                        break;
                      default:
                        H.skipType(7 & M);
                    }
                  }
                  return q;
                }),
                (L.decodeDelimited = function (H) {
                  return (
                    H instanceof B || (H = new B(H)),
                    this.decode(H, H.uint32())
                  );
                }),
                (L.verify = function (H) {
                  return typeof H != "object" || H === null
                    ? "object expected"
                    : H.domain != null &&
                        H.hasOwnProperty("domain") &&
                        !V.isString(H.domain)
                      ? "domain: string expected"
                      : H.version != null &&
                          H.hasOwnProperty("version") &&
                          !(
                            V.isInteger(H.version) ||
                            (H.version &&
                              V.isInteger(H.version.low) &&
                              V.isInteger(H.version.high))
                          )
                        ? "version: integer|Long expected"
                        : null;
                }),
                (L.fromObject = function (H) {
                  if (H instanceof W.onnx.OperatorSetIdProto) return H;
                  var F = new W.onnx.OperatorSetIdProto();
                  return (
                    H.domain != null && (F.domain = String(H.domain)),
                    H.version != null &&
                      (V.Long
                        ? ((F.version = V.Long.fromValue(H.version)).unsigned =
                            !1)
                        : typeof H.version == "string"
                          ? (F.version = parseInt(H.version, 10))
                          : typeof H.version == "number"
                            ? (F.version = H.version)
                            : typeof H.version == "object" &&
                              (F.version = new V.LongBits(
                                H.version.low >>> 0,
                                H.version.high >>> 0
                              ).toNumber())),
                    F
                  );
                }),
                (L.toObject = function (H, F) {
                  F || (F = {});
                  var N = {};
                  if (F.defaults)
                    if (((N.domain = ""), V.Long)) {
                      var q = new V.Long(0, 0, !1);
                      N.version =
                        F.longs === String
                          ? q.toString()
                          : F.longs === Number
                            ? q.toNumber()
                            : q;
                    } else N.version = F.longs === String ? "0" : 0;
                  return (
                    H.domain != null &&
                      H.hasOwnProperty("domain") &&
                      (N.domain = H.domain),
                    H.version != null &&
                      H.hasOwnProperty("version") &&
                      (typeof H.version == "number"
                        ? (N.version =
                            F.longs === String ? String(H.version) : H.version)
                        : (N.version =
                            F.longs === String
                              ? V.Long.prototype.toString.call(H.version)
                              : F.longs === Number
                                ? new V.LongBits(
                                    H.version.low >>> 0,
                                    H.version.high >>> 0
                                  ).toNumber()
                                : H.version)),
                    N
                  );
                }),
                (L.prototype.toJSON = function () {
                  return this.constructor.toObject(this, $.util.toJSONOptions);
                }),
                L
              );
            })()),
            U)),
            (X.exports = W));
        },
        2100: (X, Y, Q) => {
          X.exports = Q(9482);
        },
        9482: (X, Y, Q) => {
          var G = Y;
          function J() {
            (G.util._configure(),
              G.Writer._configure(G.BufferWriter),
              G.Reader._configure(G.BufferReader));
          }
          ((G.build = "minimal"),
            (G.Writer = Q(1173)),
            (G.BufferWriter = Q(3155)),
            (G.Reader = Q(1408)),
            (G.BufferReader = Q(593)),
            (G.util = Q(9693)),
            (G.rpc = Q(5994)),
            (G.roots = Q(5054)),
            (G.configure = J),
            J());
        },
        1408: (X, Y, Q) => {
          X.exports = K;
          var G,
            J = Q(9693),
            U = J.LongBits,
            $ = J.utf8;
          function B(q, M) {
            return RangeError(
              "index out of range: " + q.pos + " + " + (M || 1) + " > " + q.len
            );
          }
          function K(q) {
            ((this.buf = q), (this.pos = 0), (this.len = q.length));
          }
          var V,
            W =
              typeof Uint8Array < "u"
                ? function (q) {
                    if (q instanceof Uint8Array || Array.isArray(q))
                      return new K(q);
                    throw Error("illegal buffer");
                  }
                : function (q) {
                    if (Array.isArray(q)) return new K(q);
                    throw Error("illegal buffer");
                  },
            L = function () {
              return J.Buffer
                ? function (q) {
                    return (K.create = function (M) {
                      return J.Buffer.isBuffer(M) ? new G(M) : W(M);
                    })(q);
                  }
                : W;
            };
          function H() {
            var q = new U(0, 0),
              M = 0;
            if (!(this.len - this.pos > 4)) {
              for (; M < 3; ++M) {
                if (this.pos >= this.len) throw B(this);
                if (
                  ((q.lo =
                    (q.lo | ((127 & this.buf[this.pos]) << (7 * M))) >>> 0),
                  this.buf[this.pos++] < 128)
                )
                  return q;
              }
              return (
                (q.lo =
                  (q.lo | ((127 & this.buf[this.pos++]) << (7 * M))) >>> 0),
                q
              );
            }
            for (; M < 4; ++M)
              if (
                ((q.lo =
                  (q.lo | ((127 & this.buf[this.pos]) << (7 * M))) >>> 0),
                this.buf[this.pos++] < 128)
              )
                return q;
            if (
              ((q.lo = (q.lo | ((127 & this.buf[this.pos]) << 28)) >>> 0),
              (q.hi = (q.hi | ((127 & this.buf[this.pos]) >> 4)) >>> 0),
              this.buf[this.pos++] < 128)
            )
              return q;
            if (((M = 0), this.len - this.pos > 4)) {
              for (; M < 5; ++M)
                if (
                  ((q.hi =
                    (q.hi | ((127 & this.buf[this.pos]) << (7 * M + 3))) >>> 0),
                  this.buf[this.pos++] < 128)
                )
                  return q;
            } else
              for (; M < 5; ++M) {
                if (this.pos >= this.len) throw B(this);
                if (
                  ((q.hi =
                    (q.hi | ((127 & this.buf[this.pos]) << (7 * M + 3))) >>> 0),
                  this.buf[this.pos++] < 128)
                )
                  return q;
              }
            throw Error("invalid varint encoding");
          }
          function F(q, M) {
            return (
              (q[M - 4] |
                (q[M - 3] << 8) |
                (q[M - 2] << 16) |
                (q[M - 1] << 24)) >>>
              0
            );
          }
          function N() {
            if (this.pos + 8 > this.len) throw B(this, 8);
            return new U(
              F(this.buf, (this.pos += 4)),
              F(this.buf, (this.pos += 4))
            );
          }
          ((K.create = L()),
            (K.prototype._slice =
              J.Array.prototype.subarray || J.Array.prototype.slice),
            (K.prototype.uint32 =
              ((V = 4294967295),
              function () {
                if (
                  ((V = (127 & this.buf[this.pos]) >>> 0),
                  this.buf[this.pos++] < 128)
                )
                  return V;
                if (
                  ((V = (V | ((127 & this.buf[this.pos]) << 7)) >>> 0),
                  this.buf[this.pos++] < 128)
                )
                  return V;
                if (
                  ((V = (V | ((127 & this.buf[this.pos]) << 14)) >>> 0),
                  this.buf[this.pos++] < 128)
                )
                  return V;
                if (
                  ((V = (V | ((127 & this.buf[this.pos]) << 21)) >>> 0),
                  this.buf[this.pos++] < 128)
                )
                  return V;
                if (
                  ((V = (V | ((15 & this.buf[this.pos]) << 28)) >>> 0),
                  this.buf[this.pos++] < 128)
                )
                  return V;
                if ((this.pos += 5) > this.len)
                  throw ((this.pos = this.len), B(this, 10));
                return V;
              })),
            (K.prototype.int32 = function () {
              return 0 | this.uint32();
            }),
            (K.prototype.sint32 = function () {
              var q = this.uint32();
              return ((q >>> 1) ^ -(1 & q)) | 0;
            }),
            (K.prototype.bool = function () {
              return this.uint32() !== 0;
            }),
            (K.prototype.fixed32 = function () {
              if (this.pos + 4 > this.len) throw B(this, 4);
              return F(this.buf, (this.pos += 4));
            }),
            (K.prototype.sfixed32 = function () {
              if (this.pos + 4 > this.len) throw B(this, 4);
              return 0 | F(this.buf, (this.pos += 4));
            }),
            (K.prototype.float = function () {
              if (this.pos + 4 > this.len) throw B(this, 4);
              var q = J.float.readFloatLE(this.buf, this.pos);
              return ((this.pos += 4), q);
            }),
            (K.prototype.double = function () {
              if (this.pos + 8 > this.len) throw B(this, 4);
              var q = J.float.readDoubleLE(this.buf, this.pos);
              return ((this.pos += 8), q);
            }),
            (K.prototype.bytes = function () {
              var q = this.uint32(),
                M = this.pos,
                A = this.pos + q;
              if (A > this.len) throw B(this, q);
              return (
                (this.pos += q),
                Array.isArray(this.buf)
                  ? this.buf.slice(M, A)
                  : M === A
                    ? new this.buf.constructor(0)
                    : this._slice.call(this.buf, M, A)
              );
            }),
            (K.prototype.string = function () {
              var q = this.bytes();
              return $.read(q, 0, q.length);
            }),
            (K.prototype.skip = function (q) {
              if (typeof q == "number") {
                if (this.pos + q > this.len) throw B(this, q);
                this.pos += q;
              } else
                do if (this.pos >= this.len) throw B(this);
                while (128 & this.buf[this.pos++]);
              return this;
            }),
            (K.prototype.skipType = function (q) {
              switch (q) {
                case 0:
                  this.skip();
                  break;
                case 1:
                  this.skip(8);
                  break;
                case 2:
                  this.skip(this.uint32());
                  break;
                case 3:
                  for (; (q = 7 & this.uint32()) != 4; ) this.skipType(q);
                  break;
                case 5:
                  this.skip(4);
                  break;
                default:
                  throw Error(
                    "invalid wire type " + q + " at offset " + this.pos
                  );
              }
              return this;
            }),
            (K._configure = function (q) {
              ((G = q), (K.create = L()), G._configure());
              var M = J.Long ? "toLong" : "toNumber";
              J.merge(K.prototype, {
                int64: function () {
                  return H.call(this)[M](!1);
                },
                uint64: function () {
                  return H.call(this)[M](!0);
                },
                sint64: function () {
                  return H.call(this).zzDecode()[M](!1);
                },
                fixed64: function () {
                  return N.call(this)[M](!0);
                },
                sfixed64: function () {
                  return N.call(this)[M](!1);
                },
              });
            }));
        },
        593: (X, Y, Q) => {
          X.exports = U;
          var G = Q(1408);
          (U.prototype = Object.create(G.prototype)).constructor = U;
          var J = Q(9693);
          function U($) {
            G.call(this, $);
          }
          ((U._configure = function () {
            J.Buffer && (U.prototype._slice = J.Buffer.prototype.slice);
          }),
            (U.prototype.string = function () {
              var $ = this.uint32();
              return this.buf.utf8Slice
                ? this.buf.utf8Slice(
                    this.pos,
                    (this.pos = Math.min(this.pos + $, this.len))
                  )
                : this.buf.toString(
                    "utf-8",
                    this.pos,
                    (this.pos = Math.min(this.pos + $, this.len))
                  );
            }),
            U._configure());
        },
        5054: (X) => {
          X.exports = {};
        },
        5994: (X, Y, Q) => {
          Y.Service = Q(7948);
        },
        7948: (X, Y, Q) => {
          X.exports = J;
          var G = Q(9693);
          function J(U, $, B) {
            if (typeof U != "function")
              throw TypeError("rpcImpl must be a function");
            (G.EventEmitter.call(this),
              (this.rpcImpl = U),
              (this.requestDelimited = Boolean($)),
              (this.responseDelimited = Boolean(B)));
          }
          (((J.prototype = Object.create(
            G.EventEmitter.prototype
          )).constructor = J),
            (J.prototype.rpcCall = function U($, B, K, V, W) {
              if (!V) throw TypeError("request must be specified");
              var L = this;
              if (!W) return G.asPromise(U, L, $, B, K, V);
              if (L.rpcImpl)
                try {
                  return L.rpcImpl(
                    $,
                    B[L.requestDelimited ? "encodeDelimited" : "encode"](
                      V
                    ).finish(),
                    function (H, F) {
                      if (H) return (L.emit("error", H, $), W(H));
                      if (F !== null) {
                        if (!(F instanceof K))
                          try {
                            F =
                              K[
                                L.responseDelimited
                                  ? "decodeDelimited"
                                  : "decode"
                              ](F);
                          } catch (N) {
                            return (L.emit("error", N, $), W(N));
                          }
                        return (L.emit("data", F, $), W(null, F));
                      }
                      L.end(!0);
                    }
                  );
                } catch (H) {
                  return (
                    L.emit("error", H, $),
                    void setTimeout(function () {
                      W(H);
                    }, 0)
                  );
                }
              else
                setTimeout(function () {
                  W(Error("already ended"));
                }, 0);
            }),
            (J.prototype.end = function (U) {
              return (
                this.rpcImpl &&
                  (U || this.rpcImpl(null, null, null),
                  (this.rpcImpl = null),
                  this.emit("end").off()),
                this
              );
            }));
        },
        1945: (X, Y, Q) => {
          X.exports = J;
          var G = Q(9693);
          function J(K, V) {
            ((this.lo = K >>> 0), (this.hi = V >>> 0));
          }
          var U = (J.zero = new J(0, 0));
          ((U.toNumber = function () {
            return 0;
          }),
            (U.zzEncode = U.zzDecode =
              function () {
                return this;
              }),
            (U.length = function () {
              return 1;
            }));
          var $ = (J.zeroHash = "\x00\x00\x00\x00\x00\x00\x00\x00");
          ((J.fromNumber = function (K) {
            if (K === 0) return U;
            var V = K < 0;
            V && (K = -K);
            var W = K >>> 0,
              L = ((K - W) / 4294967296) >>> 0;
            return (
              V &&
                ((L = ~L >>> 0),
                (W = ~W >>> 0),
                ++W > 4294967295 && ((W = 0), ++L > 4294967295 && (L = 0))),
              new J(W, L)
            );
          }),
            (J.from = function (K) {
              if (typeof K == "number") return J.fromNumber(K);
              if (G.isString(K)) {
                if (!G.Long) return J.fromNumber(parseInt(K, 10));
                K = G.Long.fromString(K);
              }
              return K.low || K.high ? new J(K.low >>> 0, K.high >>> 0) : U;
            }),
            (J.prototype.toNumber = function (K) {
              if (!K && this.hi >>> 31) {
                var V = (1 + ~this.lo) >>> 0,
                  W = ~this.hi >>> 0;
                return (V || (W = (W + 1) >>> 0), -(V + 4294967296 * W));
              }
              return this.lo + 4294967296 * this.hi;
            }),
            (J.prototype.toLong = function (K) {
              return G.Long
                ? new G.Long(0 | this.lo, 0 | this.hi, Boolean(K))
                : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(K) };
            }));
          var B = String.prototype.charCodeAt;
          ((J.fromHash = function (K) {
            return K === $
              ? U
              : new J(
                  (B.call(K, 0) |
                    (B.call(K, 1) << 8) |
                    (B.call(K, 2) << 16) |
                    (B.call(K, 3) << 24)) >>>
                    0,
                  (B.call(K, 4) |
                    (B.call(K, 5) << 8) |
                    (B.call(K, 6) << 16) |
                    (B.call(K, 7) << 24)) >>>
                    0
                );
          }),
            (J.prototype.toHash = function () {
              return String.fromCharCode(
                255 & this.lo,
                (this.lo >>> 8) & 255,
                (this.lo >>> 16) & 255,
                this.lo >>> 24,
                255 & this.hi,
                (this.hi >>> 8) & 255,
                (this.hi >>> 16) & 255,
                this.hi >>> 24
              );
            }),
            (J.prototype.zzEncode = function () {
              var K = this.hi >> 31;
              return (
                (this.hi = (((this.hi << 1) | (this.lo >>> 31)) ^ K) >>> 0),
                (this.lo = ((this.lo << 1) ^ K) >>> 0),
                this
              );
            }),
            (J.prototype.zzDecode = function () {
              var K = -(1 & this.lo);
              return (
                (this.lo = (((this.lo >>> 1) | (this.hi << 31)) ^ K) >>> 0),
                (this.hi = ((this.hi >>> 1) ^ K) >>> 0),
                this
              );
            }),
            (J.prototype.length = function () {
              var K = this.lo,
                V = ((this.lo >>> 28) | (this.hi << 4)) >>> 0,
                W = this.hi >>> 24;
              return W === 0
                ? V === 0
                  ? K < 16384
                    ? K < 128
                      ? 1
                      : 2
                    : K < 2097152
                      ? 3
                      : 4
                  : V < 16384
                    ? V < 128
                      ? 5
                      : 6
                    : V < 2097152
                      ? 7
                      : 8
                : W < 128
                  ? 9
                  : 10;
            }));
        },
        9693: function (X, Y, Q) {
          var G = Y;
          function J($, B, K) {
            for (var V = Object.keys(B), W = 0; W < V.length; ++W)
              ($[V[W]] !== void 0 && K) || ($[V[W]] = B[V[W]]);
            return $;
          }
          function U($) {
            function B(K, V) {
              if (!(this instanceof B)) return new B(K, V);
              (Object.defineProperty(this, "message", {
                get: function () {
                  return K;
                },
              }),
                Error.captureStackTrace
                  ? Error.captureStackTrace(this, B)
                  : Object.defineProperty(this, "stack", {
                      value: Error().stack || "",
                    }),
                V && J(this, V));
            }
            return (
              ((B.prototype = Object.create(Error.prototype)).constructor = B),
              Object.defineProperty(B.prototype, "name", {
                get: function () {
                  return $;
                },
              }),
              (B.prototype.toString = function () {
                return this.name + ": " + this.message;
              }),
              B
            );
          }
          ((G.asPromise = Q(4537)),
            (G.base64 = Q(7419)),
            (G.EventEmitter = Q(9211)),
            (G.float = Q(945)),
            (G.inquire = Q(7199)),
            (G.utf8 = Q(4997)),
            (G.pool = Q(6662)),
            (G.LongBits = Q(1945)),
            (G.isNode = Boolean(
              typeof global < "u" &&
              global &&
              global.process &&
              global.process.versions &&
              global.process.versions.node
            )),
            (G.global =
              (G.isNode && global) ||
              (typeof window < "u" && window) ||
              (typeof self < "u" && self) ||
              this),
            (G.emptyArray = Object.freeze ? Object.freeze([]) : []),
            (G.emptyObject = Object.freeze ? Object.freeze({}) : {}),
            (G.isInteger =
              Number.isInteger ||
              function ($) {
                return (
                  typeof $ == "number" && isFinite($) && Math.floor($) === $
                );
              }),
            (G.isString = function ($) {
              return typeof $ == "string" || $ instanceof String;
            }),
            (G.isObject = function ($) {
              return $ && typeof $ == "object";
            }),
            (G.isset = G.isSet =
              function ($, B) {
                var K = $[B];
                return (
                  !(K == null || !$.hasOwnProperty(B)) &&
                  (typeof K != "object" ||
                    (Array.isArray(K) ? K.length : Object.keys(K).length) > 0)
                );
              }),
            (G.Buffer = (function () {
              try {
                var $ = G.inquire("buffer").Buffer;
                return $.prototype.utf8Write ? $ : null;
              } catch (B) {
                return null;
              }
            })()),
            (G._Buffer_from = null),
            (G._Buffer_allocUnsafe = null),
            (G.newBuffer = function ($) {
              return typeof $ == "number"
                ? G.Buffer
                  ? G._Buffer_allocUnsafe($)
                  : new G.Array($)
                : G.Buffer
                  ? G._Buffer_from($)
                  : typeof Uint8Array > "u"
                    ? $
                    : new Uint8Array($);
            }),
            (G.Array = typeof Uint8Array < "u" ? Uint8Array : Array),
            (G.Long =
              (G.global.dcodeIO && G.global.dcodeIO.Long) ||
              G.global.Long ||
              G.inquire("long")),
            (G.key2Re = /^true|false|0|1$/),
            (G.key32Re = /^-?(?:0|[1-9][0-9]*)$/),
            (G.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/),
            (G.longToHash = function ($) {
              return $ ? G.LongBits.from($).toHash() : G.LongBits.zeroHash;
            }),
            (G.longFromHash = function ($, B) {
              var K = G.LongBits.fromHash($);
              return G.Long
                ? G.Long.fromBits(K.lo, K.hi, B)
                : K.toNumber(Boolean(B));
            }),
            (G.merge = J),
            (G.lcFirst = function ($) {
              return $.charAt(0).toLowerCase() + $.substring(1);
            }),
            (G.newError = U),
            (G.ProtocolError = U("ProtocolError")),
            (G.oneOfGetter = function ($) {
              for (var B = {}, K = 0; K < $.length; ++K) B[$[K]] = 1;
              return function () {
                for (var V = Object.keys(this), W = V.length - 1; W > -1; --W)
                  if (
                    B[V[W]] === 1 &&
                    this[V[W]] !== void 0 &&
                    this[V[W]] !== null
                  )
                    return V[W];
              };
            }),
            (G.oneOfSetter = function ($) {
              return function (B) {
                for (var K = 0; K < $.length; ++K)
                  $[K] !== B && delete this[$[K]];
              };
            }),
            (G.toJSONOptions = {
              longs: String,
              enums: String,
              bytes: String,
              json: !0,
            }),
            (G._configure = function () {
              var $ = G.Buffer;
              $
                ? ((G._Buffer_from =
                    ($.from !== Uint8Array.from && $.from) ||
                    function (B, K) {
                      return new $(B, K);
                    }),
                  (G._Buffer_allocUnsafe =
                    $.allocUnsafe ||
                    function (B) {
                      return new $(B);
                    }))
                : (G._Buffer_from = G._Buffer_allocUnsafe = null);
            }));
        },
        1173: (X, Y, Q) => {
          X.exports = L;
          var G,
            J = Q(9693),
            U = J.LongBits,
            $ = J.base64,
            B = J.utf8;
          function K(D, R, z) {
            ((this.fn = D),
              (this.len = R),
              (this.next = void 0),
              (this.val = z));
          }
          function V() {}
          function W(D) {
            ((this.head = D.head),
              (this.tail = D.tail),
              (this.len = D.len),
              (this.next = D.states));
          }
          function L() {
            ((this.len = 0),
              (this.head = new K(V, 0, 0)),
              (this.tail = this.head),
              (this.states = null));
          }
          var H = function () {
            return J.Buffer
              ? function () {
                  return (L.create = function () {
                    return new G();
                  })();
                }
              : function () {
                  return new L();
                };
          };
          function F(D, R, z) {
            R[z] = 255 & D;
          }
          function N(D, R) {
            ((this.len = D), (this.next = void 0), (this.val = R));
          }
          function q(D, R, z) {
            for (; D.hi; )
              ((R[z++] = (127 & D.lo) | 128),
                (D.lo = ((D.lo >>> 7) | (D.hi << 25)) >>> 0),
                (D.hi >>>= 7));
            for (; D.lo > 127; )
              ((R[z++] = (127 & D.lo) | 128), (D.lo = D.lo >>> 7));
            R[z++] = D.lo;
          }
          function M(D, R, z) {
            ((R[z] = 255 & D),
              (R[z + 1] = (D >>> 8) & 255),
              (R[z + 2] = (D >>> 16) & 255),
              (R[z + 3] = D >>> 24));
          }
          ((L.create = H()),
            (L.alloc = function (D) {
              return new J.Array(D);
            }),
            J.Array !== Array &&
              (L.alloc = J.pool(L.alloc, J.Array.prototype.subarray)),
            (L.prototype._push = function (D, R, z) {
              return (
                (this.tail = this.tail.next = new K(D, R, z)),
                (this.len += R),
                this
              );
            }),
            (N.prototype = Object.create(K.prototype)),
            (N.prototype.fn = function (D, R, z) {
              for (; D > 127; ) ((R[z++] = (127 & D) | 128), (D >>>= 7));
              R[z] = D;
            }),
            (L.prototype.uint32 = function (D) {
              return (
                (this.len += (this.tail = this.tail.next =
                  new N(
                    (D >>>= 0) < 128
                      ? 1
                      : D < 16384
                        ? 2
                        : D < 2097152
                          ? 3
                          : D < 268435456
                            ? 4
                            : 5,
                    D
                  )).len),
                this
              );
            }),
            (L.prototype.int32 = function (D) {
              return D < 0
                ? this._push(q, 10, U.fromNumber(D))
                : this.uint32(D);
            }),
            (L.prototype.sint32 = function (D) {
              return this.uint32(((D << 1) ^ (D >> 31)) >>> 0);
            }),
            (L.prototype.uint64 = function (D) {
              var R = U.from(D);
              return this._push(q, R.length(), R);
            }),
            (L.prototype.int64 = L.prototype.uint64),
            (L.prototype.sint64 = function (D) {
              var R = U.from(D).zzEncode();
              return this._push(q, R.length(), R);
            }),
            (L.prototype.bool = function (D) {
              return this._push(F, 1, D ? 1 : 0);
            }),
            (L.prototype.fixed32 = function (D) {
              return this._push(M, 4, D >>> 0);
            }),
            (L.prototype.sfixed32 = L.prototype.fixed32),
            (L.prototype.fixed64 = function (D) {
              var R = U.from(D);
              return this._push(M, 4, R.lo)._push(M, 4, R.hi);
            }),
            (L.prototype.sfixed64 = L.prototype.fixed64),
            (L.prototype.float = function (D) {
              return this._push(J.float.writeFloatLE, 4, D);
            }),
            (L.prototype.double = function (D) {
              return this._push(J.float.writeDoubleLE, 8, D);
            }));
          var A = J.Array.prototype.set
            ? function (D, R, z) {
                R.set(D, z);
              }
            : function (D, R, z) {
                for (var E = 0; E < D.length; ++E) R[z + E] = D[E];
              };
          ((L.prototype.bytes = function (D) {
            var R = D.length >>> 0;
            if (!R) return this._push(F, 1, 0);
            if (J.isString(D)) {
              var z = L.alloc((R = $.length(D)));
              ($.decode(D, z, 0), (D = z));
            }
            return this.uint32(R)._push(A, R, D);
          }),
            (L.prototype.string = function (D) {
              var R = B.length(D);
              return R
                ? this.uint32(R)._push(B.write, R, D)
                : this._push(F, 1, 0);
            }),
            (L.prototype.fork = function () {
              return (
                (this.states = new W(this)),
                (this.head = this.tail = new K(V, 0, 0)),
                (this.len = 0),
                this
              );
            }),
            (L.prototype.reset = function () {
              return (
                this.states
                  ? ((this.head = this.states.head),
                    (this.tail = this.states.tail),
                    (this.len = this.states.len),
                    (this.states = this.states.next))
                  : ((this.head = this.tail = new K(V, 0, 0)), (this.len = 0)),
                this
              );
            }),
            (L.prototype.ldelim = function () {
              var D = this.head,
                R = this.tail,
                z = this.len;
              return (
                this.reset().uint32(z),
                z &&
                  ((this.tail.next = D.next), (this.tail = R), (this.len += z)),
                this
              );
            }),
            (L.prototype.finish = function () {
              for (
                var D = this.head.next,
                  R = this.constructor.alloc(this.len),
                  z = 0;
                D;
              )
                (D.fn(D.val, R, z), (z += D.len), (D = D.next));
              return R;
            }),
            (L._configure = function (D) {
              ((G = D), (L.create = H()), G._configure());
            }));
        },
        3155: (X, Y, Q) => {
          X.exports = U;
          var G = Q(1173);
          (U.prototype = Object.create(G.prototype)).constructor = U;
          var J = Q(9693);
          function U() {
            G.call(this);
          }
          function $(B, K, V) {
            B.length < 40
              ? J.utf8.write(B, K, V)
              : K.utf8Write
                ? K.utf8Write(B, V)
                : K.write(B, V);
          }
          ((U._configure = function () {
            ((U.alloc = J._Buffer_allocUnsafe),
              (U.writeBytesBuffer =
                J.Buffer &&
                J.Buffer.prototype instanceof Uint8Array &&
                J.Buffer.prototype.set.name === "set"
                  ? function (B, K, V) {
                      K.set(B, V);
                    }
                  : function (B, K, V) {
                      if (B.copy) B.copy(K, V, 0, B.length);
                      else for (var W = 0; W < B.length; ) K[V++] = B[W++];
                    }));
          }),
            (U.prototype.bytes = function (B) {
              J.isString(B) && (B = J._Buffer_from(B, "base64"));
              var K = B.length >>> 0;
              return (
                this.uint32(K),
                K && this._push(U.writeBytesBuffer, K, B),
                this
              );
            }),
            (U.prototype.string = function (B) {
              var K = J.Buffer.byteLength(B);
              return (this.uint32(K), K && this._push($, K, B), this);
            }),
            U._configure());
        },
        7714: (X, Y, Q) => {
          Y.R = void 0;
          let G = Q(6919),
            J = Q(7448);
          Y.R = new (class {
            async init() {}
            async createSessionHandler(U, $) {
              let B = new G.Session($);
              return (await B.loadModel(U), new J.OnnxjsSessionHandler(B));
            }
          })();
        },
        4200: (X, Y, Q) => {
          Y.c8 = Y.rX = void 0;
          let G = Q(6207),
            J = Q(9719),
            U = Q(2157),
            $ = Q(2306);
          ((Y.rX = () => {
            if (
              ((typeof G.env.wasm.initTimeout != "number" ||
                G.env.wasm.initTimeout < 0) &&
                (G.env.wasm.initTimeout = 0),
              typeof G.env.wasm.simd != "boolean" && (G.env.wasm.simd = !0),
              typeof G.env.wasm.proxy != "boolean" && (G.env.wasm.proxy = !1),
              typeof G.env.wasm.numThreads != "number" ||
                !Number.isInteger(G.env.wasm.numThreads) ||
                G.env.wasm.numThreads <= 0)
            ) {
              let B =
                typeof navigator > "u"
                  ? (0, J.cpus)().length
                  : navigator.hardwareConcurrency;
              G.env.wasm.numThreads = Math.min(4, Math.ceil((B || 1) / 2));
            }
          }),
            (Y.c8 = new (class {
              async init() {
                ((0, Y.rX)(), await (0, U.initWasm)());
              }
              async createSessionHandler(B, K) {
                let V = new $.OnnxruntimeWebAssemblySessionHandler();
                return (await V.loadModel(B, K), Promise.resolve(V));
              }
            })()));
        },
        6018: function (X, Y, Q) {
          var G =
              (this && this.__createBinding) ||
              (Object.create
                ? function ($, B, K, V) {
                    V === void 0 && (V = K);
                    var W = Object.getOwnPropertyDescriptor(B, K);
                    ((W &&
                      !("get" in W
                        ? !B.__esModule
                        : W.writable || W.configurable)) ||
                      (W = {
                        enumerable: !0,
                        get: function () {
                          return B[K];
                        },
                      }),
                      Object.defineProperty($, V, W));
                  }
                : function ($, B, K, V) {
                    (V === void 0 && (V = K), ($[V] = B[K]));
                  }),
            J =
              (this && this.__exportStar) ||
              function ($, B) {
                for (var K in $)
                  K === "default" ||
                    Object.prototype.hasOwnProperty.call(B, K) ||
                    G(B, $, K);
              };
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            J(Q(6207), Y));
          let U = Q(6207);
          {
            let $ = Q(7714).R;
            (0, U.registerBackend)("webgl", $, -10);
          }
          {
            let $ = Q(4200).c8;
            ((0, U.registerBackend)("cpu", $, 10),
              (0, U.registerBackend)("wasm", $, 10),
              (0, U.registerBackend)("xnnpack", $, 9));
          }
        },
        246: (X, Y) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.createAttributeWithCacheKey = void 0));
          class Q {
            constructor(G) {
              Object.assign(this, G);
            }
            get cacheKey() {
              return (
                this._cacheKey ||
                  (this._cacheKey = Object.getOwnPropertyNames(this)
                    .sort()
                    .map((G) => `${this[G]}`)
                    .join(";")),
                this._cacheKey
              );
            }
          }
          Y.createAttributeWithCacheKey = (G) => new Q(G);
        },
        7778: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.Attribute = void 0));
          let G = Q(1446),
            J = Q(9395),
            U = Q(9162),
            $ = Q(2517);
          var B = J.onnxruntime.experimental.fbs;
          class K {
            constructor(V) {
              if (((this._attributes = new Map()), V != null)) {
                for (let W of V)
                  W instanceof G.onnx.AttributeProto
                    ? this._attributes.set(W.name, [
                        K.getValue(W),
                        K.getType(W),
                      ])
                    : W instanceof B.Attribute &&
                      this._attributes.set(W.name(), [
                        K.getValue(W),
                        K.getType(W),
                      ]);
                if (this._attributes.size < V.length)
                  throw Error("duplicated attribute names");
              }
            }
            set(V, W, L) {
              this._attributes.set(V, [L, W]);
            }
            delete(V) {
              this._attributes.delete(V);
            }
            getFloat(V, W) {
              return this.get(V, "float", W);
            }
            getInt(V, W) {
              return this.get(V, "int", W);
            }
            getString(V, W) {
              return this.get(V, "string", W);
            }
            getTensor(V, W) {
              return this.get(V, "tensor", W);
            }
            getFloats(V, W) {
              return this.get(V, "floats", W);
            }
            getInts(V, W) {
              return this.get(V, "ints", W);
            }
            getStrings(V, W) {
              return this.get(V, "strings", W);
            }
            getTensors(V, W) {
              return this.get(V, "tensors", W);
            }
            get(V, W, L) {
              let H = this._attributes.get(V);
              if (H === void 0) {
                if (L !== void 0) return L;
                throw Error(`required attribute not found: ${V}`);
              }
              if (H[1] !== W)
                throw Error(`type mismatch: expected ${W} but got ${H[1]}`);
              return H[0];
            }
            static getType(V) {
              let W = V instanceof G.onnx.AttributeProto ? V.type : V.type();
              switch (W) {
                case G.onnx.AttributeProto.AttributeType.FLOAT:
                  return "float";
                case G.onnx.AttributeProto.AttributeType.INT:
                  return "int";
                case G.onnx.AttributeProto.AttributeType.STRING:
                  return "string";
                case G.onnx.AttributeProto.AttributeType.TENSOR:
                  return "tensor";
                case G.onnx.AttributeProto.AttributeType.FLOATS:
                  return "floats";
                case G.onnx.AttributeProto.AttributeType.INTS:
                  return "ints";
                case G.onnx.AttributeProto.AttributeType.STRINGS:
                  return "strings";
                case G.onnx.AttributeProto.AttributeType.TENSORS:
                  return "tensors";
                default:
                  throw Error(
                    `attribute type is not supported yet: ${G.onnx.AttributeProto.AttributeType[W]}`
                  );
              }
            }
            static getValue(V) {
              let W = V instanceof G.onnx.AttributeProto ? V.type : V.type();
              if (
                W === G.onnx.AttributeProto.AttributeType.GRAPH ||
                W === G.onnx.AttributeProto.AttributeType.GRAPHS
              )
                throw Error("graph attribute is not supported yet");
              let L = this.getValueNoCheck(V);
              if (
                W === G.onnx.AttributeProto.AttributeType.INT &&
                $.LongUtil.isLong(L)
              )
                return $.LongUtil.longToNumber(L);
              if (W === G.onnx.AttributeProto.AttributeType.INTS) {
                let H = L,
                  F = Array(H.length);
                for (let N = 0; N < H.length; N++) {
                  let q = H[N];
                  F[N] = $.LongUtil.longToNumber(q);
                }
                return F;
              }
              if (W === G.onnx.AttributeProto.AttributeType.TENSOR)
                return V instanceof G.onnx.AttributeProto
                  ? U.Tensor.fromProto(L)
                  : U.Tensor.fromOrtTensor(L);
              if (W === G.onnx.AttributeProto.AttributeType.TENSORS) {
                if (V instanceof G.onnx.AttributeProto)
                  return L.map((H) => U.Tensor.fromProto(H));
                if (V instanceof B.Attribute)
                  return L.map((H) => U.Tensor.fromOrtTensor(H));
              }
              if (
                W === G.onnx.AttributeProto.AttributeType.STRING &&
                V instanceof G.onnx.AttributeProto
              ) {
                let H = L;
                return (0, $.decodeUtf8String)(H);
              }
              return W === G.onnx.AttributeProto.AttributeType.STRINGS &&
                V instanceof G.onnx.AttributeProto
                ? L.map($.decodeUtf8String)
                : L;
            }
            static getValueNoCheck(V) {
              return V instanceof G.onnx.AttributeProto
                ? this.getValueNoCheckFromOnnxFormat(V)
                : this.getValueNoCheckFromOrtFormat(V);
            }
            static getValueNoCheckFromOnnxFormat(V) {
              switch (V.type) {
                case G.onnx.AttributeProto.AttributeType.FLOAT:
                  return V.f;
                case G.onnx.AttributeProto.AttributeType.INT:
                  return V.i;
                case G.onnx.AttributeProto.AttributeType.STRING:
                  return V.s;
                case G.onnx.AttributeProto.AttributeType.TENSOR:
                  return V.t;
                case G.onnx.AttributeProto.AttributeType.GRAPH:
                  return V.g;
                case G.onnx.AttributeProto.AttributeType.FLOATS:
                  return V.floats;
                case G.onnx.AttributeProto.AttributeType.INTS:
                  return V.ints;
                case G.onnx.AttributeProto.AttributeType.STRINGS:
                  return V.strings;
                case G.onnx.AttributeProto.AttributeType.TENSORS:
                  return V.tensors;
                case G.onnx.AttributeProto.AttributeType.GRAPHS:
                  return V.graphs;
                default:
                  throw Error(
                    `unsupported attribute type: ${G.onnx.AttributeProto.AttributeType[V.type]}`
                  );
              }
            }
            static getValueNoCheckFromOrtFormat(V) {
              switch (V.type()) {
                case B.AttributeType.FLOAT:
                  return V.f();
                case B.AttributeType.INT:
                  return V.i();
                case B.AttributeType.STRING:
                  return V.s();
                case B.AttributeType.TENSOR:
                  return V.t();
                case B.AttributeType.GRAPH:
                  return V.g();
                case B.AttributeType.FLOATS:
                  return V.floatsArray();
                case B.AttributeType.INTS: {
                  let W = [];
                  for (let L = 0; L < V.intsLength(); L++) W.push(V.ints(L));
                  return W;
                }
                case B.AttributeType.STRINGS: {
                  let W = [];
                  for (let L = 0; L < V.stringsLength(); L++)
                    W.push(V.strings(L));
                  return W;
                }
                case B.AttributeType.TENSORS: {
                  let W = [];
                  for (let L = 0; L < V.tensorsLength(); L++)
                    W.push(V.tensors(L));
                  return W;
                }
                default:
                  throw Error(
                    `unsupported attribute type: ${B.AttributeType[V.type()]}`
                  );
              }
            }
          }
          Y.Attribute = K;
        },
        7091: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.resolveBackend = Y.backend = void 0));
          let G = Q(5038),
            J = new Map();
          async function U($) {
            let B = Y.backend;
            if (
              B[$] !== void 0 &&
              (function (K) {
                let V = K;
                return (
                  "initialize" in V &&
                  typeof V.initialize == "function" &&
                  "createSessionHandler" in V &&
                  typeof V.createSessionHandler == "function" &&
                  "dispose" in V &&
                  typeof V.dispose == "function"
                );
              })(B[$])
            ) {
              let K = B[$],
                V = K.initialize();
              if ((typeof V == "object" && "then" in V && (V = await V), V))
                return (J.set($, K), K);
            }
          }
          ((Y.backend = { webgl: new G.WebGLBackend() }),
            (Y.resolveBackend = async function $(B) {
              if (!B) return $(["webgl"]);
              {
                let K = typeof B == "string" ? [B] : B;
                for (let V of K) {
                  let W = J.get(V);
                  if (W) return W;
                  let L = await U(V);
                  if (L) return L;
                }
              }
              throw Error("no available backend to use");
            }));
        },
        5038: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.WebGLBackend = void 0));
          let G = Q(6207),
            J = Q(3694),
            U = Q(6416),
            $ = Q(7305);
          Y.WebGLBackend = class {
            get contextId() {
              return G.env.webgl.contextId;
            }
            set contextId(B) {
              G.env.webgl.contextId = B;
            }
            get matmulMaxBatchSize() {
              return G.env.webgl.matmulMaxBatchSize;
            }
            set matmulMaxBatchSize(B) {
              G.env.webgl.matmulMaxBatchSize = B;
            }
            get textureCacheMode() {
              return G.env.webgl.textureCacheMode;
            }
            set textureCacheMode(B) {
              G.env.webgl.textureCacheMode = B;
            }
            get pack() {
              return G.env.webgl.pack;
            }
            set pack(B) {
              G.env.webgl.pack = B;
            }
            get async() {
              return G.env.webgl.async;
            }
            set async(B) {
              G.env.webgl.async = B;
            }
            initialize() {
              try {
                return (
                  (this.glContext = (0, $.createWebGLContext)(this.contextId)),
                  typeof this.matmulMaxBatchSize != "number" &&
                    (this.matmulMaxBatchSize = 16),
                  typeof this.textureCacheMode != "string" &&
                    (this.textureCacheMode = "full"),
                  typeof this.pack != "boolean" && (this.pack = !1),
                  typeof this.async != "boolean" && (this.async = !1),
                  J.Logger.setWithEnv(G.env),
                  J.Logger.verbose(
                    "WebGLBackend",
                    `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`
                  ),
                  !0
                );
              } catch (B) {
                return (
                  J.Logger.warning(
                    "WebGLBackend",
                    `Unable to initialize WebGLBackend. ${B}`
                  ),
                  !1
                );
              }
            }
            createSessionHandler(B) {
              return new U.WebGLSessionHandler(this, B);
            }
            dispose() {
              this.glContext.dispose();
            }
          };
        },
        5107: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.CoordsGlslLib = void 0));
          let G = Q(2517),
            J = Q(8520),
            U = Q(5060),
            $ = Q(7859),
            B = Q(9390);
          class K extends J.GlslLib {
            constructor(V) {
              super(V);
            }
            getFunctions() {
              return Object.assign(
                Object.assign(
                  Object.assign(
                    Object.assign(
                      Object.assign(
                        Object.assign(
                          Object.assign({}, this.offsetToCoords()),
                          this.coordsToOffset()
                        ),
                        this.toVec()
                      ),
                      this.valueFrom()
                    ),
                    this.getCommonUtilFuncs()
                  ),
                  this.getInputsSamplingSnippets()
                ),
                this.getOutputSamplingSnippet()
              );
            }
            getCustomTypes() {
              return {};
            }
            offsetToCoords() {
              return {
                offsetToCoords: new J.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `),
              };
            }
            coordsToOffset() {
              return {
                coordsToOffset: new J.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `),
              };
            }
            getOutputSamplingSnippet() {
              let V = this.context.outputTextureLayout;
              return V.isPacked
                ? this.getPackedOutputSamplingSnippet(V)
                : this.getUnpackedOutputSamplingSnippet(V);
            }
            getPackedOutputSamplingSnippet(V) {
              let W = V.unpackedShape,
                L = [V.width, V.height],
                H = {};
              switch (W.length) {
                case 0:
                  H.getOutputCoords = this.getOutputScalarCoords();
                  break;
                case 1:
                  H.getOutputCoords = this.getOutputPacked1DCoords(W, L);
                  break;
                case 2:
                  H.getOutputCoords = this.getOutputPacked2DCoords(W, L);
                  break;
                case 3:
                  H.getOutputCoords = this.getOutputPacked3DCoords(W, L);
                  break;
                default:
                  H.getOutputCoords = this.getOutputPackedNDCoords(W, L);
              }
              let N = `
      void setOutput(vec4 val) {
        ${(0, U.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
              return ((H.floatTextureSetRGBA = new J.GlslLibRoutine(N)), H);
            }
            getUnpackedOutputSamplingSnippet(V) {
              let W = V.unpackedShape,
                L = [V.width, V.height],
                H = {};
              switch (W.length) {
                case 0:
                  H.getOutputCoords = this.getOutputScalarCoords();
                  break;
                case 1:
                  H.getOutputCoords = this.getOutputUnpacked1DCoords(W, L);
                  break;
                case 2:
                  H.getOutputCoords = this.getOutputUnpacked2DCoords(W, L);
                  break;
                case 3:
                  H.getOutputCoords = this.getOutputUnpacked3DCoords(W, L);
                  break;
                case 4:
                  H.getOutputCoords = this.getOutputUnpacked4DCoords(W, L);
                  break;
                case 5:
                  H.getOutputCoords = this.getOutputUnpacked5DCoords(W, L);
                  break;
                case 6:
                  H.getOutputCoords = this.getOutputUnpacked6DCoords(W, L);
                  break;
                default:
                  throw Error(`Unsupported output dimensionality: ${W.length}`);
              }
              let N = `
        void setOutput(float val) {
          ${(0, U.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
              return ((H.floatTextureSetR = new J.GlslLibRoutine(N)), H);
            }
            getOutputScalarCoords() {
              return new J.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `);
            }
            getOutputPacked1DCoords(V, W) {
              let L = W,
                H = "";
              return L[0] === 1
                ? ((H = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${L[1]}.0);
          }
        `),
                  new J.GlslLibRoutine(H))
                : L[1] === 1
                  ? ((H = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${L[0]}.0);
          }
        `),
                    new J.GlslLibRoutine(H))
                  : ((H = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${L[0]}, ${L[1]}));
          return 2 * (resTexRC.y * ${L[0]} + resTexRC.x);
        }
      `),
                    new J.GlslLibRoutine(H));
            }
            getOutputPacked2DCoords(V, W) {
              let L = "";
              if (G.ArrayUtil.arraysEqual(V, W))
                return (
                  (L = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${W[0]}, ${W[1]}));
        }
      `),
                  new J.GlslLibRoutine(L)
                );
              let H = W,
                F = Math.ceil(V[1] / 2);
              return (
                (L = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${H[0]}, ${H[1]}));

          int index = resTexRC.y * ${H[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${F}) * 2;
          int c = 2 * (index / ${F});

          return ivec2(r, c);
        }
      `),
                new J.GlslLibRoutine(L)
              );
            }
            getOutputPacked3DCoords(V, W) {
              let L = [W[0], W[1]],
                H = Math.ceil(V[2] / 2),
                F = H * Math.ceil(V[1] / 2),
                N = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${L[0]}, ${L[1]}));
          int index = resTexRC.y * ${L[0]} + resTexRC.x;

          int b = index / ${F};
          index -= b * ${F};

          // reverse r and c order for packed texture
          int r = imod(index, ${H}) * 2;
          int c = 2 * (index / ${H});

          return ivec3(b, r, c);
        }
      `;
              return new J.GlslLibRoutine(N);
            }
            getOutputPackedNDCoords(V, W) {
              let L = [W[0], W[1]],
                H = Math.ceil(V[V.length - 1] / 2),
                F = H * Math.ceil(V[V.length - 2] / 2),
                N = F,
                q = "",
                M = "b, r, c";
              for (let D = 2; D < V.length - 1; D++)
                ((N *= V[V.length - D - 1]),
                  (q =
                    `
      int b${D} = index / ${N};
      index -= b${D} * ${N};
    ` + q),
                  (M = `b${D}, ` + M));
              let A = `
      ivec${V.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${L[0]}, ${L[1]}));
        int index = resTexRC.y * ${L[0]} + resTexRC.x;

        ${q}

        int b = index / ${F};
        index -= b * ${F};

        // reverse r and c order for packed texture
        int r = imod(index, ${H}) * 2;
        int c = 2 * (index / ${H});

        return ivec${V.length}(${M});
      }
    `;
              return new J.GlslLibRoutine(A);
            }
            getOutputUnpacked1DCoords(V, W) {
              let L = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${W[0]}, ${W[1]}));
          return resTexRC.y * ${W[0]} + resTexRC.x;
        }
      `;
              return new J.GlslLibRoutine(L);
            }
            getOutputUnpacked2DCoords(V, W) {
              let L = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${W[0]}, ${W[1]}));
          int index = resTexRC.y * ${W[0]} + resTexRC.x;
          int r = index / ${V[1]};
          int c = index - r * ${V[1]};
          return ivec2(r, c);
        }
      `;
              return new J.GlslLibRoutine(L);
            }
            getOutputUnpacked3DCoords(V, W) {
              let L = "",
                H = V.length,
                F = null;
              (H < 2 && (F = []), (F = Array(H - 1)), (F[H - 2] = V[H - 1]));
              for (let M = H - 3; M >= 0; --M) F[M] = F[M + 1] * V[M + 1];
              let N = ["r", "c", "d"],
                q = F.map(
                  (M, A) =>
                    `int ${N[A]} = index / ${M}; ${A === F.length - 1 ? `int ${N[A + 1]} = index - ${N[A]} * ${M}` : `index -= ${N[A]} * ${M}`};`
                ).join("");
              return (
                (L = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${W[0]}, ${W[1]}));
          int index = resTexRC.y * ${W[0]} + resTexRC.x;
          ${q}
          return ivec3(r, c, d);
        }
      `),
                new J.GlslLibRoutine(L)
              );
            }
            getOutputUnpacked4DCoords(V, W) {
              let L = "",
                H = V.length,
                F = null;
              (H < 2 && (F = []), (F = Array(H - 1)), (F[H - 2] = V[H - 1]));
              for (let M = H - 3; M >= 0; --M) F[M] = F[M + 1] * V[M + 1];
              let N = ["r", "c", "d", "d2"],
                q = F.map(
                  (M, A) =>
                    `int ${N[A]} = index / ${M}; ${A === F.length - 1 ? `int ${N[A + 1]} = index - ${N[A]} * ${M}` : `index -= ${N[A]} * ${M}`};`
                ).join("");
              return (
                (L = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${W[0]}, ${W[1]}));
          int index = resTexRC.y * ${W[0]} + resTexRC.x;
          ${q}
          return ivec4(r, c, d, d2);
        }
      `),
                new J.GlslLibRoutine(L)
              );
            }
            getOutputUnpacked5DCoords(V, W) {
              let L = "",
                H = V.length,
                F = null;
              (H < 2 && (F = []), (F = Array(H - 1)), (F[H - 2] = V[H - 1]));
              for (let M = H - 3; M >= 0; --M) F[M] = F[M + 1] * V[M + 1];
              let N = ["r", "c", "d", "d2", "d3"],
                q = F.map(
                  (M, A) =>
                    `int ${N[A]} = index / ${M}; ${A === F.length - 1 ? `int ${N[A + 1]} = index - ${N[A]} * ${M}` : `index -= ${N[A]} * ${M}`};`
                ).join("");
              return (
                (L = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${W[0]}, ${W[1]}));
          int index = resTexRC.y * ${W[0]} + resTexRC.x;
          ${q}
          return ivec5(r, c, d, d2, d3);
        }
      `),
                new J.GlslLibRoutine(L)
              );
            }
            getOutputUnpacked6DCoords(V, W) {
              let L = "",
                H = V.length,
                F = null;
              (H < 2 && (F = []), (F = Array(H - 1)), (F[H - 2] = V[H - 1]));
              for (let M = H - 3; M >= 0; --M) F[M] = F[M + 1] * V[M + 1];
              let N = ["r", "c", "d", "d2", "d3", "d4"],
                q = F.map(
                  (M, A) =>
                    `int ${N[A]} = index / ${M}; ${A === F.length - 1 ? `int ${N[A + 1]} = index - ${N[A]} * ${M}` : `index -= ${N[A]} * ${M}`};`
                ).join("");
              return (
                (L = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${W[0]}, ${W[1]}));
         int index = resTexRC.y * ${W[0]} + resTexRC.x;
         ${q}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `),
                new J.GlslLibRoutine(L)
              );
            }
            getCommonUtilFuncs() {
              let V = {},
                W = "uvFromFlat";
              ((V[W] = new J.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `)),
                (W = "packedUVfrom1D"),
                (V[W] = new J.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `)),
                (W = "packedUVfrom2D"),
                (V[W] = new J.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `)),
                (W = "packedUVfrom3D"),
                (V[W] = new J.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `)),
                (W = "sampleTexture"));
              let L = (0, U.getGlsl)(this.context.glContext.version);
              return (
                (V[W] = new J.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${L.texture2D}(textureSampler, uv).r;
        }`)),
                V
              );
            }
            getInputsSamplingSnippets() {
              let V = {},
                W = this.context.outputTextureLayout;
              return (
                this.context.programInfo.inputNames.forEach((L, H) => {
                  let F = this.context.inputTextureLayouts[H],
                    N = (0, B.generateShaderFuncNameFromInputSamplerName)(L);
                  F.isPacked
                    ? (V[N] = this.getPackedSamplerFromInput(N, L, F))
                    : (V[N] = this.getUnpackedSamplerFromInput(N, L, F));
                  let q = (0,
                  B.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(L);
                  F.unpackedShape.length <= W.unpackedShape.length &&
                    (F.isPacked
                      ? (V[q] = this.getPackedSamplerAtOutputCoords(q, F, W, L))
                      : (V[q] = this.getUnpackedSamplerAtOutputCoords(
                          q,
                          F,
                          W,
                          L
                        )));
                }),
                V
              );
            }
            getPackedSamplerAtOutputCoords(V, W, L, H) {
              let F = W.unpackedShape,
                N = L.unpackedShape,
                q = H,
                M = (0, B.generateShaderFuncNameFromInputSamplerName)(q),
                A = F.length,
                D = N.length,
                R = G.BroadcastUtil.getBroadcastDims(F, N),
                z = (0, B.getCoordsDataType)(D),
                E = D - A,
                O,
                Z = (0, B.getGlChannels)();
              O =
                A === 0
                  ? ""
                  : D < 2 && R.length >= 1
                    ? "coords = 0;"
                    : R.map((_) => `coords.${Z[_ + E]} = 0;`).join(`
`);
              let j = "";
              j =
                D < 2 && A > 0
                  ? "coords"
                  : F.map((_, f) => `coords.${Z[f + E]}`).join(", ");
              let w = "return outputValue;",
                I = G.ShapeUtil.size(F) === 1,
                T = G.ShapeUtil.size(N) === 1;
              if (A !== 1 || I || T) {
                if (I && !T)
                  w =
                    D === 1
                      ? `
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `
                      : `
          return vec4(outputValue.x);
        `;
                else if (R.length) {
                  let _ = A - 2,
                    f = A - 1;
                  R.indexOf(_) > -1 && R.indexOf(f) > -1
                    ? (w = "return vec4(outputValue.x);")
                    : R.indexOf(_) > -1
                      ? (w =
                          "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);")
                      : R.indexOf(f) > -1 &&
                        (w = "return vec4(outputValue.xx, outputValue.zz);");
                }
              } else
                w = `
        return vec4(outputValue.xy, outputValue.xy);
      `;
              let y = `
      vec4 ${V}() {
        ${z} coords = getOutputCoords();
        
        int lastDim = coords.${Z[D - 1]};
        coords.${Z[D - 1]} = coords.${Z[D - 2]};
        coords.${Z[D - 2]} = lastDim;
      
        ${O}
        vec4 outputValue = ${M}(${j});
        ${w}
      }
    `;
              return new J.GlslLibRoutine(y, ["coordinates.getOutputCoords"]);
            }
            getUnpackedSamplerAtOutputCoords(V, W, L, H) {
              let F = [L.width, L.height],
                N = [W.width, W.height],
                q = W.unpackedShape.length,
                M = L.unpackedShape.length,
                A = W.unpackedShape,
                D = L.unpackedShape,
                R = (0, B.generateShaderFuncNameFromInputSamplerName)(H);
              if (q === M && G.ArrayUtil.arraysEqual(N, F)) {
                let T = `
          float ${V}() {
            return sampleTexture(${H}, TexCoords);
          }
        `;
                return new J.GlslLibRoutine(T, ["coordinates.sampleTexture"]);
              }
              let z = (0, B.getCoordsDataType)(M),
                E = G.BroadcastUtil.getBroadcastDims(A, D),
                O = M - q,
                Z,
                j = (0, B.getGlChannels)();
              Z =
                q === 0
                  ? ""
                  : M < 2 && E.length >= 1
                    ? "coords = 0;"
                    : E.map((T) => `coords.${j[T + O]} = 0;`).join(`
`);
              let w = "";
              w =
                M < 2 && q > 0
                  ? "coords"
                  : W.unpackedShape
                      .map((T, y) => `coords.${j[y + O]}`)
                      .join(", ");
              let I = `
        float ${V}() {
          ${z} coords = getOutputCoords();
          ${Z}
          return ${R}(${w});
        }
      `;
              return new J.GlslLibRoutine(I, ["coordinates.getOutputCoords"]);
            }
            getPackedSamplerFromInput(V, W, L) {
              switch (L.unpackedShape.length) {
                case 0:
                  return this.getPackedSamplerScalar(V, W);
                case 1:
                  return this.getPackedSampler1D(V, W, L);
                case 2:
                  return this.getPackedSampler2D(V, W, L);
                case 3:
                  return this.getPackedSampler3D(V, W, L);
                default:
                  return this.getPackedSamplerND(V, W, L);
              }
            }
            getUnpackedSamplerFromInput(V, W, L) {
              let H = L.unpackedShape;
              switch (H.length) {
                case 0:
                  return this.getUnpackedSamplerScalar(V, W, L);
                case 1:
                  return this.getUnpackedSampler1D(V, W, L);
                case 2:
                  return this.getUnpackedSampler2D(V, W, L);
                case 3:
                  return this.getUnpackedSampler3D(V, W, L);
                case 4:
                  return this.getUnpackedSampler4D(V, W, L);
                case 5:
                  return this.getUnpackedSampler5D(V, W, L);
                case 6:
                  return this.getUnpackedSampler6D(V, W, L);
                default:
                  throw Error(`Unsupported dimension ${H.length}-D`);
              }
            }
            getPackedSamplerScalar(V, W) {
              let L = `
          vec4 ${V}() {
            return ${(0, U.getGlsl)(this.context.glContext.version).texture2D}(${W}, halfCR);
          }
        `;
              return new J.GlslLibRoutine(L);
            }
            getPackedSampler1D(V, W, L) {
              let H = [L.width, L.height],
                F = [H[1], H[0]],
                N = (0, U.getGlsl)(this.context.glContext.version),
                q = `vec4 ${V}(int index) {
      vec2 uv = packedUVfrom1D(
      ${F[0]}, ${F[1]}, index);
      return ${N.texture2D}(${W}, uv);
    }`;
              return new J.GlslLibRoutine(q, ["coordinates.packedUVfrom1D"]);
            }
            getPackedSampler2D(V, W, L) {
              let H = L.unpackedShape,
                F = [L.width, L.height],
                N = (0, U.getGlsl)(this.context.glContext.version),
                q = F[0],
                M = F[1];
              if (F != null && G.ArrayUtil.arraysEqual(H, F)) {
                let z = `vec4 ${V}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${M}.0, ${q}.0);
        return ${N.texture2D}(${W}, uv);
      }`;
                return new J.GlslLibRoutine(z);
              }
              let A = F,
                D = Math.ceil(H[1] / 2),
                R = `vec4 ${V}(int row, int col) {
      vec2 uv = packedUVfrom2D(${A[1]}, ${A[0]}, ${D}, row, col);
      return ${N.texture2D}(${W}, uv);
    }`;
              return new J.GlslLibRoutine(R, ["coordinates.packedUVfrom2D"]);
            }
            getPackedSampler3D(V, W, L) {
              let H = L.unpackedShape,
                F = [L.width, L.height],
                N = [F[0], F[1]],
                q = (0, U.getGlsl)(this.context.glContext.version);
              if (H[0] === 1) {
                let z = H.slice(1),
                  E = [1, 2],
                  O = (0, B.squeezeInputShape)(H, z),
                  Z = ["b", "row", "col"],
                  j = JSON.parse(JSON.stringify(L));
                j.unpackedShape = O;
                let w = this.getPackedSamplerFromInput(V, W, j),
                  I = `${w.routineBody}
      vec4 ${V}(int b, int row, int col) {
        return ${V}(${(0, B.getSqueezedParams)(Z, E)});
      } `;
                return new J.GlslLibRoutine(I, w.dependencies);
              }
              let M = N[0],
                A = N[1],
                D = Math.ceil(H[2] / 2),
                R = `vec4 ${V}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${A}, ${M}, ${D * Math.ceil(H[1] / 2)}, ${D}, b, row, col);
      return ${q.texture2D}(${W}, uv);}`;
              return new J.GlslLibRoutine(R, ["coordinates.packedUVfrom3D"]);
            }
            getPackedSamplerND(V, W, L) {
              let H = L.unpackedShape,
                F = H.length,
                N = [L.width, L.height],
                q = (0, U.getGlsl)(this.context.glContext.version),
                M = [N[0], N[1]],
                A = M[1],
                D = M[0],
                R = Math.ceil(H[F - 1] / 2),
                z = R * Math.ceil(H[F - 2] / 2),
                E = "int b, int row, int col",
                O = `b * ${z} + (row / 2) * ${R} + (col / 2)`;
              for (let j = 2; j < F - 1; j++)
                ((E = `int b${j}, ` + E),
                  (z *= H[F - j - 1]),
                  (O = `b${j} * ${z} + ` + O));
              let Z = `vec4 ${V}(${E}) {
      int index = ${O};
      int texR = index / ${D};
      int texC = index - texR * ${D};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${D}, ${A});
      return ${q.texture2D}(${W}, uv);
    }`;
              return new J.GlslLibRoutine(Z);
            }
            getUnpackedSamplerScalar(V, W, L) {
              let [H, F] = [L.width, L.height];
              if (H === 1 && F === 1) {
                let q = `
          float ${V}() {
            return sampleTexture(${W}, halfCR);
          }
        `;
                return new J.GlslLibRoutine(q, ["coordinates.sampleTexture"]);
              }
              let N = `
        float ${V}() {
          int offset_${W} = coordsToOffset(TexCoords, ${H}, ${F});
          vec2 uv = uvFromFlat(${H}, ${F}, offset_${W});
          return sampleTexture(${W}, uv);
        }
      `;
              return new J.GlslLibRoutine(N, [
                "coordinates.uvFromFlat",
                "coordinates.sampleTexture",
                "coordinates.coordsToOffset",
              ]);
            }
            getUnpackedSampler1D(V, W, L) {
              let { width: H, height: F } = L;
              if (F === 1 && H === 1) {
                let q = `
        float ${V}(int index) {
          return sampleTexture(${W}, halfCR);
        }
      `;
                return new J.GlslLibRoutine(q, ["coordinates.sampleTexture"]);
              }
              if (F === 1) {
                let q = `
          float ${V}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${H}.0, 0.5);
            return sampleTexture(${W}, uv);
          }
        `;
                return new J.GlslLibRoutine(q, ["coordinates.sampleTexture"]);
              }
              if (H === 1) {
                let q = `
          float ${V}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${F}.0);
            return sampleTexture(${W}, uv);
          }
        `;
                return new J.GlslLibRoutine(q, ["coordinates.sampleTexture"]);
              }
              let N = `
        float ${V}(int index) {
          vec2 uv = uvFromFlat(${H}, ${F}, index);
          return sampleTexture(${W}, uv);
        }
      `;
              return new J.GlslLibRoutine(N, [
                "coordinates.uvFromFlat",
                "coordinates.sampleTexture",
              ]);
            }
            getUnpackedSampler2D(V, W, L) {
              let H = L.unpackedShape,
                F = [L.height, L.width];
              if (F != null && G.ArrayUtil.arraysEqual(H, F)) {
                let z = `
          float ${V}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${F[1]}.0, ${F[0]}.0);
            return sampleTexture(${W}, uv);
          }
        `;
                return new J.GlslLibRoutine(z, ["coordinates.sampleTexture"]);
              }
              let { newShape: N, keptDims: q } = (0, $.squeezeShape)(H),
                M = N;
              if (M.length < H.length) {
                let z = (0, B.squeezeInputShape)(H, M),
                  E = JSON.parse(JSON.stringify(L));
                E.unpackedShape = z;
                let O = ["col", "row"],
                  Z = `
          ${this.getUnpackedSamplerFromInput(V, W, E).routineBody}
          float ${V}(int row, int col) {
            return ${V}(${(0, B.getSqueezedParams)(O, q)});
          }
        `;
                return new J.GlslLibRoutine(Z, ["coordinates.sampleTexture"]);
              }
              let A = F[1],
                D = F[0];
              if (D === 1) {
                let z = `
          float ${V}(int row, int col) {
            int offset_${W} = coordsToOffset(TexCoords, ${A}, ${D});
            float index = dot(vec3(row, col, offset_${W}), vec3(${H[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${A}.0);
            return sampleTexture(${W}, uv);
          }
        `;
                return new J.GlslLibRoutine(z, [
                  "coordinates.sampleTexture",
                  "coordinates.coordsToOffset",
                ]);
              }
              if (A === 1) {
                let z = `
          float ${V}(int row, int col) {
            int offset_${W} = coordsToOffset(TexCoords, ${A}, ${D});
            float index = dot(vec3(row, col, offset_${W}), vec3(${H[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${D}.0, 0.5);
            return sampleTexture(${W}, uv);
          }
        `;
                return new J.GlslLibRoutine(z, [
                  "coordinates.sampleTexture",
                  "coordinates.coordsToOffset",
                ]);
              }
              let R = `
        float ${V}(int row, int col) {
          int index = col * ${H[1]} + row;
          vec2 uv = uvFromFlat(${A}, ${D}, index);
          return sampleTexture(${W}, uv);
        }
      `;
              return new J.GlslLibRoutine(R, [
                "coordinates.uvFromFlat",
                "coordinates.sampleTexture",
                "coordinates.coordsToOffset",
              ]);
            }
            getUnpackedSampler3D(V, W, L) {
              let H = L.unpackedShape,
                F = H[1] * H[2],
                N = H[2],
                { newShape: q, keptDims: M } = (0, $.squeezeShape)(H),
                A = q;
              if (A.length < H.length) {
                let R = (0, B.squeezeInputShape)(H, A),
                  z = ["batch", "col", "row"],
                  E = JSON.parse(JSON.stringify(L));
                E.unpackedShape = R;
                let O = this.getUnpackedSamplerFromInput(V, W, E),
                  Z = M.reverse(),
                  j = `
          ${O.routineBody}
          float ${V}(int batch, int row, int col) {
            return ${V}(${(0, B.getSqueezedParams)(z, Z)});
          }
        `;
                return new J.GlslLibRoutine(j, O.dependencies);
              }
              let D = `
          float ${V}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${F} + col * ${N} + row;
            vec2 uv = uvFromFlat(${L.width}, ${L.height}, index);
            return sampleTexture(${W}, uv);
          }
      `;
              return new J.GlslLibRoutine(D, [
                "coordinates.uvFromFlat",
                "coordinates.sampleTexture",
                "coordinates.coordsToOffset",
              ]);
            }
            getUnpackedSampler4D(V, W, L) {
              let H = L.unpackedShape,
                F = H[3],
                N = H[2] * F,
                q = `
        float ${V}(int row, int col, int depth, int depth2) {
          int index = row * ${H[1] * N} + col * ${N} +
              depth2 * ${F} + depth;
          vec2 uv = uvFromFlat(${L.width}, ${L.height}, index);
          return sampleTexture(${W}, uv);
        }
      `;
              return new J.GlslLibRoutine(q, [
                "coordinates.uvFromFlat",
                "coordinates.sampleTexture",
              ]);
            }
            getUnpackedSampler5D(V, W, L) {
              let H = L.unpackedShape,
                F = H[4],
                N = H[3] * F,
                q = H[2] * N,
                M = H[1] * q,
                { newShape: A, keptDims: D } = (0, $.squeezeShape)(H);
              if (A.length < H.length) {
                let z = (0, B.squeezeInputShape)(H, A),
                  E = ["row", "col", "depth", "depth2", "depth3"],
                  O = JSON.parse(JSON.stringify(L));
                O.unpackedShape = z;
                let Z = `
          ${this.getUnpackedSamplerFromInput(V, W, O).routineBody}
          float ${V}(int row, int col, int depth, int depth2, int depth3) {
            return ${V}(${(0, B.getSqueezedParams)(E, D)});
          }
        `;
                return new J.GlslLibRoutine(Z, [
                  "coordinates.sampleTexture",
                  "coordinates.uvFromFlat",
                ]);
              }
              let R = `
        float ${V}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${M} + col * ${q} + depth * ${N} +
          depth3 * ${F} + depth2;
          vec2 uv = uvFromFlat(${L.width}, ${L.height}, index);
          return sampleTexture(${W}, uv);
        }
      `;
              return new J.GlslLibRoutine(R, [
                "coordinates.sampleTexture",
                "coordinates.uvFromFlat",
              ]);
            }
            getUnpackedSampler6D(V, W, L) {
              let H = L.unpackedShape,
                F = H[5],
                N = H[4] * F,
                q = H[3] * N,
                M = H[2] * q,
                A = H[1] * M,
                { newShape: D, keptDims: R } = (0, $.squeezeShape)(H);
              if (D.length < H.length) {
                let E = (0, B.squeezeInputShape)(H, D),
                  O = ["row", "col", "depth", "depth2", "depth3", "depth4"],
                  Z = JSON.parse(JSON.stringify(L));
                Z.unpackedShape = E;
                let j = `
            ${this.getUnpackedSamplerFromInput(V, W, Z).routineBody}
            float ${V}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${V}(${(0, B.getSqueezedParams)(O, R)});
            }
          `;
                return new J.GlslLibRoutine(j, [
                  "coordinates.sampleTexture",
                  "coordinates.uvFromFlat",
                ]);
              }
              let z = `
          float ${V}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${A} + col * ${M} + depth * ${q} +
            depth2 * ${N} + depth3 * ${F} + depth4;
            vec2 uv = uvFromFlat(${L.width}, ${L.height}, index);
            return sampleTexture(${W}, uv);
          }
        `;
              return new J.GlslLibRoutine(z, [
                "coordinates.uvFromFlat",
                "coordinates.sampleTexture",
                "coordinates.coordsToOffset",
              ]);
            }
            toVec() {
              let V = this.context.outputTextureLayout,
                W = V.shape.length,
                L = V.strides,
                H = V.width,
                F = V.height,
                N = [];
              for (let M = 0; M < W - 1; ++M)
                (N.push(`
        c[${M}] = offset / ${L[M]};`),
                  N.push(`
        offset -= c[${M}] * ${L[M]};`));
              N.push(`
        c[${W - 1}] = offset;`);
              let q = `
      void toVec(vec2 texCoords, out int c[${W}]) {
        int offset = coordsToOffset(texCoords, ${H}, ${F});
        ${N.join("")}
      }
      void toVec(int offset, out int c[${W}]) {
        ${N.join("")}
      }
    `;
              return {
                toVec: new J.GlslLibRoutine(q, ["coordinates.coordsToOffset"]),
              };
            }
            valueFrom() {
              let V = {};
              return (
                this.context.programInfo.inputNames.forEach((W, L) => {
                  let H = this.context.inputTextureLayouts[L],
                    F = (H.unpackedShape.length > 0 ? H.unpackedShape : H.shape)
                      .length,
                    N = `_${W}`;
                  ((V[N] = new J.GlslLibRoutine(
                    this.getValueFromSingle(W, F, H.width, H.height, !1),
                    [
                      `shapeUtils.indicesToOffset${N}`,
                      "coordinates.offsetToCoords",
                      "fragcolor.getColorAsFloat",
                    ]
                  )),
                    (N += "_T"),
                    (V[N] = new J.GlslLibRoutine(
                      this.getValueFromSingle(W, F, H.width, H.height, !0),
                      [
                        `shapeUtils.indicesToOffset${N}`,
                        "coordinates.offsetToCoords",
                        "fragcolor.getColorAsFloat",
                      ]
                    )));
                }),
                V
              );
            }
            getValueFromSingle(V, W, L, H, F) {
              let N = `_${V}`;
              return (
                F && (N += "_T"),
                `
        float ${N}(int m[${W}]) {
          int offset = indicesToOffset${N}(m);
          vec2 coords = offsetToCoords(offset, ${L}, ${H});
          float value = getColorAsFloat(${(0, U.getGlsl)(this.context.glContext.version).texture2D}(${V}, coords));
          return value;
        }
        `
              );
            }
            getPackedValueFrom(V, W, L, H, F) {
              let N = `_${V}_Pack`;
              return (
                F && (N += "_T"),
                `
        vec4 ${N}(int m[${W}]) {
          int offset = indicesToOffset_${V}(m);
          vec2 coords = offsetToCoords(offset, ${L}, ${H});
          return ${(0, U.getGlsl)(this.context.glContext.version).texture2D}(${V}, coords);
        }
        `
              );
            }
          }
          Y.CoordsGlslLib = K;
        },
        8520: (X, Y) => {
          var Q;
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.TopologicalSortGlslRoutines =
              Y.GlslLibRoutineNode =
              Y.GlslLibRoutine =
              Y.GlslLib =
              Y.GlslContext =
              Y.FunctionType =
                void 0),
            ((Q = Y.FunctionType || (Y.FunctionType = {}))[(Q.ValueBased = 0)] =
              "ValueBased"),
            (Q[(Q.Positional = 1)] = "Positional"),
            (Y.GlslContext = class {
              constructor(G, J, U, $) {
                ((this.glContext = G),
                  (this.programInfo = J),
                  (this.inputTextureLayouts = U),
                  (this.outputTextureLayout = $));
              }
            }),
            (Y.GlslLib = class {
              constructor(G) {
                this.context = G;
              }
            }),
            (Y.GlslLibRoutine = class {
              constructor(G, J) {
                ((this.routineBody = G), (this.dependencies = J));
              }
            }),
            (Y.GlslLibRoutineNode = class {
              constructor(G, J, U) {
                ((this.name = G),
                  (this.dependencies = U || []),
                  J && (this.routineBody = J));
              }
              addDependency(G) {
                G && this.dependencies.push(G);
              }
            }),
            (Y.TopologicalSortGlslRoutines = class {
              static returnOrderedNodes(G) {
                if (!G || G.length === 0) return [];
                if (G.length === 1) return G;
                let J = new Set(),
                  U = new Set(),
                  $ = [];
                return (this.createOrderedNodes(G, J, U, $), $);
              }
              static createOrderedNodes(G, J, U, $) {
                for (let B = 0; B < G.length; ++B)
                  this.dfsTraverse(G[B], J, U, $);
              }
              static dfsTraverse(G, J, U, $) {
                if (!G || U.has(G.name)) return;
                if (J.has(G.name))
                  throw Error(
                    "Cyclic dependency detected. Can't topologically sort routines needed for shader."
                  );
                J.add(G.name);
                let B = G.dependencies;
                if (B && B.length > 0)
                  for (let K = 0; K < B.length; ++K)
                    this.dfsTraverse(B[K], J, U, $);
                ($.push(G), U.add(G.name), J.delete(G.name));
              }
            }));
        },
        7341: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.EncodingGlslLib = void 0));
          let G = Q(8520);
          class J extends G.GlslLib {
            constructor(U) {
              super(U);
            }
            getFunctions() {
              return Object.assign(
                Object.assign({}, this.encodeFloat32()),
                this.decodeFloat32()
              );
            }
            getCustomTypes() {
              return {};
            }
            encodeFloat32() {
              return {
                encode: new G.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `),
              };
            }
            decodeFloat32() {
              return {
                decode:
                  new G.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `),
              };
            }
            encodeUint8() {
              let U = J.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
              return {
                encode: new G.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${U}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `),
              };
            }
            decodeUint8() {
              let U = J.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
              return {
                decode: new G.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${U}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `),
              };
            }
            static isLittleEndian() {
              let U = new ArrayBuffer(4),
                $ = new Uint32Array(U),
                B = new Uint8Array(U);
              if ((($[0] = 3735928559), B[0] === 239)) return !0;
              if (B[0] === 222) return !1;
              throw Error("unknown endianness");
            }
          }
          Y.EncodingGlslLib = J;
        },
        9894: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.FragColorGlslLib = void 0));
          let G = Q(8520),
            J = Q(5060);
          class U extends G.GlslLib {
            constructor($) {
              super($);
            }
            getFunctions() {
              return Object.assign(
                Object.assign({}, this.setFragColor()),
                this.getColorAsFloat()
              );
            }
            getCustomTypes() {
              return {};
            }
            setFragColor() {
              let $ = (0, J.getGlsl)(this.context.glContext.version);
              return {
                setFragColor: new G.GlslLibRoutine(
                  `
        void setFragColor(float value) {
            ${$.output} = encode(value);
        }
        `,
                  ["encoding.encode"]
                ),
              };
            }
            getColorAsFloat() {
              return {
                getColorAsFloat: new G.GlslLibRoutine(
                  `
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,
                  ["encoding.decode"]
                ),
              };
            }
          }
          Y.FragColorGlslLib = U;
        },
        2848: (X, Y) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.replaceInlines = void 0));
          let Q =
            /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
          Y.replaceInlines = function (G) {
            let J = {},
              U;
            for (; (U = Q.exec(G)) !== null; ) {
              let $ = U[3]
                .split(",")
                .map((B) => {
                  let K = B.trim().split(" ");
                  return K && K.length === 2
                    ? { type: K[0], name: K[1] }
                    : null;
                })
                .filter((B) => B !== null);
              J[U[2]] = { params: $, body: U[4] };
            }
            for (let $ in J) {
              let B =
                  "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace(
                    "__FUNC__",
                    $
                  ),
                K = new RegExp(B, "gm");
              for (; (U = K.exec(G)) !== null; ) {
                let V = U[1],
                  W = U[2],
                  L = U[3].split(","),
                  H = V ? `${V} ${W};` : "",
                  F = J[$].body,
                  N = "";
                (J[$].params.forEach((M, A) => {
                  M &&
                    (N += `${M.type} ${M.name} = ${L[A]};
`);
                }),
                  (F = `${N}
 ${F}`),
                  (F = F.replace("return", `${W} = `)));
                let q = `
      ${H}
      {
        ${F}
      }
      `;
                G = G.replace(U[0], q);
              }
            }
            return G.replace(Q, "");
          };
        },
        8879: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.GlslPreprocessor = void 0));
          let G = Q(8520),
            J = Q(2848),
            U = Q(5483),
            $ = Q(5060);
          Y.GlslPreprocessor = class {
            constructor(B, K, V, W) {
              ((this.libs = {}),
                (this.glslLibRoutineDependencyGraph = {}),
                (this.context = new G.GlslContext(B, K, V, W)),
                Object.keys(U.glslRegistry).forEach((H) => {
                  let F = new U.glslRegistry[H](this.context);
                  this.libs[H] = F;
                }));
              let L = this.glslLibRoutineDependencyGraph;
              for (let H in this.libs) {
                let F = this.libs[H].getFunctions();
                for (let N in F) {
                  let q = H + "." + N,
                    M;
                  L[q]
                    ? ((M = L[q]), (M.routineBody = F[N].routineBody))
                    : ((M = new G.GlslLibRoutineNode(q, F[N].routineBody)),
                      (L[q] = M));
                  let A = F[N].dependencies;
                  if (A)
                    for (let D = 0; D < A.length; ++D)
                      if (L[A[D]]) M.addDependency(L[A[D]]);
                      else {
                        let R = new G.GlslLibRoutineNode(A[D]);
                        ((L[A[D]] = R), M.addDependency(R));
                      }
                }
              }
            }
            preprocess() {
              let B = this.context.programInfo,
                K = B.shaderSource;
              return (
                this.context.programInfo.hasMain ||
                  (K = `${K}
      ${(0, $.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`),
                (K = (0, J.replaceInlines)(K)),
                `${(0, $.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(B.inputNames, B.variables)}
    ${this.getImports(K)}
    ${K}`
              );
            }
            getImports(B) {
              let K = this.selectGlslLibRoutinesToBeIncluded(B);
              if (K.length === 0) return "";
              let V = "";
              for (let W = 0; W < K.length; ++W) {
                if (!K[W].routineBody)
                  throw Error(
                    `Missing body for the Glsl Library routine: ${K[W].name}`
                  );
                V +=
                  K[W].routineBody +
                  `
`;
              }
              return V;
            }
            selectGlslLibRoutinesToBeIncluded(B) {
              let K = [];
              return (
                Object.keys(this.glslLibRoutineDependencyGraph).forEach((V) => {
                  let W = V.split(".")[1];
                  B.indexOf(W) !== -1 &&
                    K.push(this.glslLibRoutineDependencyGraph[V]);
                }),
                G.TopologicalSortGlslRoutines.returnOrderedNodes(K)
              );
            }
            getUniforms(B, K) {
              let V = [];
              if (B) for (let W of B) V.push(`uniform sampler2D ${W};`);
              if (K)
                for (let W of K)
                  V.push(
                    `uniform ${W.type} ${W.name}${W.arrayLength ? `[${W.arrayLength}]` : ""};`
                  );
              return V.join(`
`);
            }
          };
        },
        5483: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.glslRegistry = void 0));
          let G = Q(5107),
            J = Q(7341),
            U = Q(9894),
            $ = Q(2655),
            B = Q(3891);
          Y.glslRegistry = {
            encoding: J.EncodingGlslLib,
            fragcolor: U.FragColorGlslLib,
            vec: B.VecGlslLib,
            shapeUtils: $.ShapeUtilsGlslLib,
            coordinates: G.CoordsGlslLib,
          };
        },
        2655: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.ShapeUtilsGlslLib = void 0));
          let G = Q(8520);
          class J extends G.GlslLib {
            constructor(U) {
              super(U);
            }
            getFunctions() {
              return Object.assign(
                Object.assign(
                  Object.assign(
                    Object.assign(
                      Object.assign({}, this.bcastIndex()),
                      this.bcastMatmulIndex()
                    ),
                    this.offsetToIndices()
                  ),
                  this.indicesToOffset()
                ),
                this.incrementIndices()
              );
            }
            getCustomTypes() {
              return {};
            }
            bcastIndex() {
              let U = this.context.outputTextureLayout.shape.length,
                $ = {};
              return (
                this.context.programInfo.inputNames.forEach((B, K) => {
                  let V = this.context.inputTextureLayouts[K].unpackedShape;
                  if (V.length <= U) {
                    let W = V.length,
                      L = U - W,
                      H = `bcastIndices_${B}`,
                      F = "";
                    for (let q = 0; q < W; ++q)
                      F += `
          realIndices[${q}] = int( mod(float(bcastedIndices[${L + q}]), ${V[q]}.0) );
          `;
                    let N = `
        void ${H} (int bcastedIndices[${U}], out int realIndices[${W}]) {
          ${F}
        }
        `;
                    $[H] = new G.GlslLibRoutine(N);
                  }
                }),
                $
              );
            }
            bcastMatmulIndex() {
              let U = this.context.outputTextureLayout.shape.length,
                $ = {};
              return (
                this.context.programInfo.inputNames.forEach((B, K) => {
                  let V = this.context.inputTextureLayouts[K].shape;
                  if (!(V.length < 2 || V.length > U)) {
                    let W = V.length,
                      L = U - W,
                      H = `bcastMatmulIndices_${B}`,
                      F = "";
                    for (let q = 0; q < W - 2; ++q)
                      F += `
          realIndices[${q}] = int( mod(float(bcastedIndices[${L + q}]), ${V[q]}.0) );
          `;
                    let N = `
        void ${H}(int bcastedIndices[${U}], out int realIndices[${W}]) {
          ${F}
          realIndices[${W - 1}] = bcastedIndices[${U - 1}];
          realIndices[${W - 2}] = bcastedIndices[${U - 2}];
        }
        `;
                    $[H] = new G.GlslLibRoutine(N);
                  }
                }),
                $
              );
            }
            indicesToOffset() {
              let U = {};
              return (
                this.context.programInfo.inputNames.forEach(($, B) => {
                  let K = this.context.inputTextureLayouts[B].shape,
                    V = this.context.inputTextureLayouts[B].strides,
                    W = K.length,
                    L = `indicesToOffset_${$}`;
                  ((U[L] = new G.GlslLibRoutine(
                    J.indexToOffsetSingle(L, W, V)
                  )),
                    (L = `indicesToOffset_${$}_T`),
                    (U[L] = new G.GlslLibRoutine(
                      J.indexToOffsetSingle(L, W, V.slice().reverse())
                    )));
                }),
                U
              );
            }
            static indexToOffsetSingle(U, $, B) {
              let K = "";
              for (let V = $ - 1; V >= 0; --V)
                K += `
        offset += indices[${V}] * ${B[V]};
        `;
              return `
      int ${U}(int indices[${$}]) {
        int offset = 0;
        ${K}
        return offset;
      }
      `;
            }
            offsetToIndices() {
              let U = {};
              return (
                this.context.programInfo.inputNames.forEach(($, B) => {
                  let K = this.context.inputTextureLayouts[B].shape,
                    V = this.context.inputTextureLayouts[B].strides,
                    W = K.length,
                    L = `offsetToIndices_${$}`;
                  ((U[L] = new G.GlslLibRoutine(
                    J.offsetToIndicesSingle(L, W, V)
                  )),
                    (L = `offsetToIndices_${$}_T`),
                    (U[L] = new G.GlslLibRoutine(
                      J.offsetToIndicesSingle(L, W, V.slice().reverse())
                    )));
                }),
                U
              );
            }
            static offsetToIndicesSingle(U, $, B) {
              let K = [];
              for (let V = 0; V < $ - 1; ++V)
                (K.push(`
      indices[${V}] = offset / ${B[V]};`),
                  K.push(`
        offset -= indices[${V}] * ${B[V]};`));
              return (
                K.push(`
      indices[${$ - 1}] = offset;`),
                `
      void ${U}(int offset, out int indices[${$}]) {
        ${K.join("")}
      }
      `
              );
            }
            incrementIndices() {
              let U = {};
              return (
                this.context.programInfo.inputNames.forEach(($, B) => {
                  let K = this.context.inputTextureLayouts[B].shape,
                    V = K.length,
                    W = `incrementIndices_${$}`,
                    L = "";
                  for (let F = 0; F < V; ++F)
                    L += `
        shape[${F}] = ${K[F]};`;
                  let H = `
        void ${W}(int axis, out int indices[${V}]) {
          int shape[${V}];
          ${L};
          for(int i = ${V} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
                  U[W] = new G.GlslLibRoutine(H);
                }),
                U
              );
            }
          }
          Y.ShapeUtilsGlslLib = J;
        },
        5060: (X, Y) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.getDefaultFragShaderMain =
              Y.getFragShaderPreamble =
              Y.getVertexShaderSource =
              Y.getGlsl =
                void 0));
          let Q = {
              version: "",
              attribute: "attribute",
              varyingVertex: "varying",
              varyingFrag: "varying",
              texture2D: "texture2D",
              output: "gl_FragColor",
              outputDeclaration: "",
            },
            G = {
              version: "#version 300 es",
              attribute: "in",
              varyingVertex: "out",
              varyingFrag: "in",
              texture2D: "texture",
              output: "outputColor",
              outputDeclaration: "out vec4 outputColor;",
            };
          function J(U) {
            return U === 1 ? Q : G;
          }
          ((Y.getGlsl = J),
            (Y.getVertexShaderSource = function (U) {
              let $ = J(U);
              return `${$.version}
      precision highp float;
      ${$.attribute} vec3 position;
      ${$.attribute} vec2 textureCoord;

      ${$.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
            }),
            (Y.getFragShaderPreamble = function (U) {
              let $ = J(U);
              return `${$.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${$.varyingFrag} vec2 TexCoords;
    ${$.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
            }),
            (Y.getDefaultFragShaderMain = function (U, $) {
              return `
  void main() {
    int indices[${$}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${J(U).output} = result;
  }
  `;
            }));
        },
        3891: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.VecGlslLib = void 0));
          let G = Q(8520);
          class J extends G.GlslLib {
            constructor(U) {
              super(U);
            }
            getCustomTypes() {
              return {};
            }
            getFunctions() {
              return Object.assign(
                Object.assign(
                  Object.assign(
                    Object.assign({}, this.binaryVecFunctions()),
                    this.copyVec()
                  ),
                  this.setVecItem()
                ),
                this.getVecItem()
              );
            }
            binaryVecFunctions() {
              let U = this.context.outputTextureLayout.shape.length,
                $ = { add: "+=", sub: "-=", mul: "*=", div: "/=" },
                B = {};
              for (let K in $) {
                let V = `${K}Vec`,
                  W = "";
                for (let H = 0; H < U; ++H)
                  W += `
          dest[${H}] ${$[K]} src[${H}];
          `;
                let L = `
        void ${V}(int src[${U}], out int dest[${U}]) {
          ${W}
        }
        `;
                B[V] = new G.GlslLibRoutine(L);
              }
              return B;
            }
            copyVec() {
              let U = this.context.outputTextureLayout.shape.length,
                $ = "";
              for (let K = 0; K < U; ++K)
                $ += `
        dest[${K}] = src[${K}];
        `;
              let B = `
      void copyVec(int src[${U}], out int dest[${U}]) {
        ${$}
      }
      `;
              return { copyVec: new G.GlslLibRoutine(B) };
            }
            setVecItem() {
              let U = this.context.outputTextureLayout.shape.length,
                $ = `
        if(index < 0)
            index =${U} + index;
        if (index == 0)
            m[0] = value;
        `;
              for (let K = 1; K < U - 1; ++K)
                $ += `
        else if (index == ${K})
            m[${K}] = value;
            `;
              $ += `
        else
            m[${U - 1}] = value;
        `;
              let B = `
      void setVecItem(out int m[${U}], int index, int value) {
        ${$}
      }
        `;
              return { setVecItem: new G.GlslLibRoutine(B) };
            }
            getVecItem() {
              let U = this.context.outputTextureLayout.shape.length,
                $ = `
        if(index < 0)
            index = ${U} + index;
        if (index == 0)
            return m[0];
      `;
              for (let K = 1; K < U - 1; ++K)
                $ += `
        else if (index == ${K})
            return m[${K}];
      `;
              $ += `
        else
            return m[${U - 1}];
        `;
              let B = `
      int getVecItem(int m[${U}], int index) {
        ${$}
      }
    `;
              return { getVecItem: new G.GlslLibRoutine(B) };
            }
          }
          Y.VecGlslLib = J;
        },
        8316: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.WebGLInferenceHandler = void 0));
          let G = Q(3694),
            J = Q(9162),
            U = Q(2517),
            $ = Q(2403),
            B = Q(7019),
            K = Q(8710),
            V = Q(5611),
            W = Q(4057),
            L = Q(2039);
          Y.WebGLInferenceHandler = class {
            constructor(H) {
              ((this.session = H),
                (this.packedTextureDataCache = new Map()),
                (this.unpackedTextureDataCache = new Map()));
            }
            calculateTextureWidthAndHeight(H, F) {
              return (0, W.calculateTextureWidthAndHeight)(
                this.session.layoutStrategy,
                H,
                F
              );
            }
            executeProgram(H, F) {
              if (F.length < H.inputNames.length)
                throw Error(
                  `Input size mustn't be less than ${H.inputNames.length}.`
                );
              if (H.inputNames.length !== H.inputTypes.length)
                throw Error("input names size does not match input types");
              let N = [];
              for (let z = 0; z < H.inputNames.length; ++z)
                N[z] = this.getOrCreateTextureData(F[z], H.inputTypes[z]);
              let q = ((z, E) => {
                  let O = E.map(
                      (j) =>
                        `${j.unpackedShape.join(",")};${j.width}x${j.height}`
                    ).join("_"),
                    Z = z.name;
                  return (
                    z.cacheHint && (Z += "[" + z.cacheHint + "]"),
                    (Z += ":" + O),
                    Z
                  );
                })(H, N),
                M = this.session.programManager.getArtifact(q),
                A = M
                  ? M.programInfo
                  : typeof H.get == "function"
                    ? H.get()
                    : H,
                D = (0, W.createTextureLayoutFromTextureType)(
                  this.session.layoutStrategy,
                  A.output.dims,
                  A.output.textureType
                ),
                R = this.createTextureData(D, A.output.type);
              return (
                M ||
                  ((M = this.session.programManager.build(A, N, R)),
                  this.session.programManager.setArtifact(q, M)),
                this.runProgram(M, N, R),
                R
              );
            }
            run(H, F) {
              return this.executeProgram(H, F).tensor;
            }
            runProgram(H, F, N) {
              for (let q = 0; q < F.length; ++q)
                if (
                  !!F[q].isPacked !=
                  (H.programInfo.inputTypes[q] === L.TextureType.packed)
                )
                  throw Error(`input[${q}] property packed inconsistent`);
              if (
                !!N.isPacked !=
                (H.programInfo.output.textureType === L.TextureType.packed)
              )
                throw Error("output property packed inconsistent");
              this.session.programManager.run(H, F, N);
            }
            getOrCreateTextureData(H, F) {
              let N = this.getTextureData(H.dataId, F === L.TextureType.packed);
              if (
                !N &&
                ((N = this.getTextureData(
                  H.dataId,
                  F !== L.TextureType.packed
                )),
                N)
              )
                return F === L.TextureType.packed
                  ? this.pack(N)
                  : this.unpack(N);
              if (!N) {
                let q = (0, W.createTextureLayoutFromTextureType)(
                  this.session.layoutStrategy,
                  H.dims,
                  F
                );
                if (F === L.TextureType.packedLastDimension) {
                  let D = H.dims;
                  if (D.length === 4) {
                    let R = [D[0], Math.ceil((D[1] * D[2] * D[3]) / 4)],
                      z = (0, W.createTextureLayoutFromTextureType)(
                        this.session.layoutStrategy,
                        R,
                        F
                      ),
                      E = H.numberData;
                    if ((D[1] * D[2] * D[3]) % 4 != 0) {
                      let O = D[0],
                        Z = D[1] * D[2] * D[3],
                        j = Math.ceil((Z * 1) / 4) * 4;
                      E = new Float32Array(O * j);
                      for (let w = 0; w < O; ++w) {
                        let I = w * Z,
                          T = w * j + (w % 1) * Z;
                        E.set(H.numberData.subarray(I, I + Z), T);
                      }
                    }
                    return this.createTextureData(z, H.type, E, H, 1);
                  }
                }
                if (F === L.TextureType.packed) {
                  let M = (0, W.createTextureLayoutFromShape)(
                      this.session.layoutStrategy,
                      H.dims,
                      1,
                      [],
                      { reverseWH: !0 }
                    ),
                    A = this.createTextureData(M, H.type, H.numberData, H, 1);
                  N = this.pack(A);
                } else
                  N = this.createTextureData(q, H.type, H.numberData, H, 1);
              }
              return N;
            }
            createTextureDataFromLayoutBindTensor(H, F, N, q) {
              return this.createTextureData(H, F, N, q, 1);
            }
            createTextureData(H, F, N, q, M) {
              G.Logger.verbose(
                "InferenceHandler",
                `Creating TextureData: layout:[${JSON.stringify(H)}]`
              );
              let A = this.session.textureManager.createTextureFromLayout(
                F,
                H,
                N,
                M
              );
              return this.createTextureDataFromTexture(H, F, A, q);
            }
            reshapeUnpacked(H, F) {
              let N = this.getOrCreateTextureData(H, L.TextureType.unpacked),
                q = {
                  channels: N.channels,
                  height: N.height,
                  width: N.width,
                  shape: F.length !== 0 ? F : [1],
                  strides: U.ShapeUtil.computeStrides(F),
                  unpackedShape: F,
                };
              return this.createTextureDataFromTexture(q, H.type, N.texture)
                .tensor;
            }
            reshapePacked(H, F) {
              let N = this.getOrCreateTextureData(H, L.TextureType.packed);
              if ((0, B.isReshapeCheap)(H.dims, F)) {
                let R = {
                  channels: N.channels,
                  height: N.height,
                  width: N.width,
                  shape: F.length !== 0 ? F : [1],
                  strides: U.ShapeUtil.computeStrides(F),
                  unpackedShape: F,
                  isPacked: !0,
                };
                return this.createTextureDataFromTexture(R, H.type, N.texture)
                  .tensor;
              }
              let q = (0, B.processDims3D)(H.dims),
                M = (0, B.processDims3D)(F),
                A = this.reshapePacked(H, q),
                D = this.run(
                  (0, B.createPackedReshape3DProgramInfoLoader)(this, A, M),
                  [A]
                );
              return this.reshapePacked(D, F);
            }
            cast(H, F) {
              let N = this.getOrCreateTextureData(H, L.TextureType.unpacked);
              return this.createTextureDataFromTexture(N, F, N.texture).tensor;
            }
            createTextureDataFromTexture(H, F, N, q, M) {
              let A = Object.assign(Object.assign({}, H), {
                tensor:
                  q ||
                  new J.Tensor(
                    H.unpackedShape,
                    F,
                    (D) => this.readTexture(A),
                    async (D) => this.readTextureAsync(A),
                    void 0,
                    M
                  ),
                texture: N,
              });
              return (this.setTextureData(A.tensor.dataId, A, H.isPacked), A);
            }
            getTextureData(H, F = !1) {
              return this.session.isInitializer(H)
                ? this.session.getTextureData(H, F)
                : F
                  ? this.packedTextureDataCache.get(H)
                  : this.unpackedTextureDataCache.get(H);
            }
            setTextureData(H, F, N = !1) {
              this.session.isInitializer(H)
                ? this.session.setTextureData(H, F, N)
                : (N
                    ? this.packedTextureDataCache
                    : this.unpackedTextureDataCache
                  ).set(H, F);
            }
            isTextureLayoutCached(H, F = !1) {
              return !!this.getTextureData(H.dataId, F);
            }
            dispose() {
              (this.session.textureManager.clearActiveTextures(),
                this.packedTextureDataCache.forEach((H) =>
                  this.session.textureManager.releaseTexture(H)
                ),
                (this.packedTextureDataCache = new Map()),
                this.unpackedTextureDataCache.forEach((H) =>
                  this.session.textureManager.releaseTexture(H)
                ),
                (this.unpackedTextureDataCache = new Map()));
            }
            readTexture(H) {
              return H.isPacked
                ? this.readTexture(this.unpack(H))
                : this.session.backend.glContext.isFloat32DownloadSupported
                  ? this.session.textureManager.readTexture(
                      H,
                      H.tensor.type,
                      H.channels
                    )
                  : this.session.textureManager.readUint8TextureAsFloat(
                      (0, K.encodeAsUint8)(this, H)
                    );
            }
            async readTextureAsync(H) {
              return H.isPacked
                ? this.readTextureAsync(this.unpack(H))
                : this.session.backend.glContext.isFloat32DownloadSupported
                  ? this.session.textureManager.readTextureAsync(
                      H,
                      H.tensor.type,
                      H.channels
                    )
                  : this.session.textureManager.readUint8TextureAsFloat(
                      (0, K.encodeAsUint8)(this, H)
                    );
            }
            pack(H) {
              return this.executeProgram(
                (0, $.createPackProgramInfoLoader)(this, H.tensor),
                [H.tensor]
              );
            }
            unpack(H) {
              return this.executeProgram(
                (0, V.createUnpackProgramInfoLoader)(this, H.tensor),
                [H.tensor]
              );
            }
          };
        },
        1640: function (X, Y, Q) {
          var G =
              (this && this.__createBinding) ||
              (Object.create
                ? function (e, P, x, r) {
                    r === void 0 && (r = x);
                    var C = Object.getOwnPropertyDescriptor(P, x);
                    ((C &&
                      !("get" in C
                        ? !P.__esModule
                        : C.writable || C.configurable)) ||
                      (C = {
                        enumerable: !0,
                        get: function () {
                          return P[x];
                        },
                      }),
                      Object.defineProperty(e, r, C));
                  }
                : function (e, P, x, r) {
                    (r === void 0 && (r = x), (e[r] = P[x]));
                  }),
            J =
              (this && this.__setModuleDefault) ||
              (Object.create
                ? function (e, P) {
                    Object.defineProperty(e, "default", {
                      enumerable: !0,
                      value: P,
                    });
                  }
                : function (e, P) {
                    e.default = P;
                  }),
            U =
              (this && this.__importStar) ||
              function (e) {
                if (e && e.__esModule) return e;
                var P = {};
                if (e != null)
                  for (var x in e)
                    x !== "default" &&
                      Object.prototype.hasOwnProperty.call(e, x) &&
                      G(P, e, x);
                return (J(P, e), P);
              };
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.WEBGL_OP_RESOLVE_RULES = void 0));
          let $ = Q(2898),
            B = U(Q(7839)),
            K = Q(4196),
            V = Q(2069),
            W = Q(8138),
            L = Q(9663),
            H = Q(5193),
            F = Q(7992),
            N = Q(1253),
            q = Q(4776),
            M = Q(6572),
            A = Q(3346),
            D = Q(5623),
            R = Q(2870),
            z = Q(2143),
            E = Q(4939),
            O = Q(718),
            Z = Q(2268),
            j = Q(8117),
            w = Q(2278),
            I = Q(5524),
            T = Q(5975),
            y = Q(3933),
            _ = Q(6558),
            f = Q(5723),
            l = Q(3738),
            h = U(Q(4909)),
            p = Q(8428),
            N0 = Q(9793);
          Y.WEBGL_OP_RESOLVE_RULES = [
            ["Abs", "", "6+", h.abs],
            ["Acos", "", "7+", h.acos],
            ["Add", "", "7+", B.add],
            ["And", "", "7+", B.and],
            ["Asin", "", "7+", h.asin],
            ["Atan", "", "7+", h.atan],
            [
              "AveragePool",
              "",
              "7+",
              z.averagePool,
              z.parseAveragePoolAttributes,
            ],
            [
              "BatchNormalization",
              "",
              "7+",
              $.batchNormalization,
              $.parseBatchNormalizationAttributes,
            ],
            ["Cast", "", "6+", K.cast, K.parseCastAttributes],
            ["Ceil", "", "6+", h.ceil],
            ["Clip", "", "6-10", h.clip, h.parseClipAttributes],
            ["Clip", "", "11+", h.clipV11],
            ["Concat", "", "4+", V.concat, V.parseConcatAttributes],
            ["Conv", "", "1+", W.conv, W.parseConvAttributes],
            [
              "ConvTranspose",
              "",
              "1+",
              L.convTranspose,
              L.parseConvTransposeAttributes,
            ],
            ["Cos", "", "7+", h.cos],
            ["Div", "", "7+", B.div],
            ["Dropout", "", "7+", h.identity],
            [
              "DepthToSpace",
              "",
              "1+",
              H.depthToSpace,
              H.parseDepthToSpaceAttributes,
            ],
            ["Equal", "", "7+", B.equal],
            ["Elu", "", "6+", h.elu, h.parseEluAttributes],
            ["Exp", "", "6+", h.exp],
            ["Flatten", "", "1+", F.flatten, F.parseFlattenAttributes],
            ["Floor", "", "6+", h.floor],
            ["FusedConv", "com.microsoft", "1+", W.conv, W.parseConvAttributes],
            ["Gather", "", "1+", N.gather, N.parseGatherAttributes],
            ["Gemm", "", "7-10", q.gemm, q.parseGemmAttributesV7],
            ["Gemm", "", "11+", q.gemm, q.parseGemmAttributesV11],
            [
              "GlobalAveragePool",
              "",
              "1+",
              z.globalAveragePool,
              z.parseGlobalAveragePoolAttributes,
            ],
            ["GlobalMaxPool", "", "1+", z.globalMaxPool],
            ["Greater", "", "7+", B.greater],
            ["Identity", "", "1+", h.identity],
            [
              "ImageScaler",
              "",
              "1+",
              M.imageScaler,
              M.parseImageScalerAttributes,
            ],
            [
              "InstanceNormalization",
              "",
              "6+",
              A.instanceNormalization,
              A.parseInstanceNormalizationAttributes,
            ],
            ["LeakyRelu", "", "6+", h.leakyRelu, h.parseLeakyReluAttributes],
            ["Less", "", "7+", B.less],
            ["Log", "", "6+", h.log],
            ["MatMul", "", "1+", D.matMul, D.parseMatMulAttributes],
            ["MaxPool", "", "1+", z.maxPool, z.parseMaxPoolAttributes],
            ["Mul", "", "7+", B.mul],
            ["Neg", "", "6+", h.neg],
            ["Not", "", "1+", h.not],
            ["Or", "", "7+", B.or],
            ["Pad", "", "2-10", R.padV2, R.parsePadAttributesV2],
            ["Pad", "", "11+", R.padV11, R.parsePadAttributesV11],
            ["Pow", "", "7+", B.pow],
            ["PRelu", "", "7+", B.pRelu],
            ["ReduceLogSum", "", "1+", E.reduceLogSum, E.parseReduceAttributes],
            ["ReduceMax", "", "1+", E.reduceMax, E.parseReduceAttributes],
            ["ReduceMean", "", "1+", E.reduceMean, E.parseReduceAttributes],
            ["ReduceMin", "", "1+", E.reduceMin, E.parseReduceAttributes],
            ["ReduceProd", "", "1+", E.reduceProd, E.parseReduceAttributes],
            ["ReduceSum", "", "1-12", E.reduceSum, E.parseReduceAttributes],
            [
              "ReduceSumSquare",
              "",
              "1+",
              E.reduceLogSumSquare,
              E.parseReduceAttributes,
            ],
            ["Relu", "", "6+", h.relu],
            ["Reshape", "", "5+", O.reshape],
            ["Resize", "", "10", Z.resize, Z.parseResizeAttributesV10],
            ["Resize", "", "11+", Z.resize, Z.parseResizeAttributesV11],
            ["Shape", "", "1+", j.shape],
            ["Sigmoid", "", "6+", h.sigmoid],
            ["Sin", "", "7+", h.sin],
            ["Slice", "", "10+", w.sliceV10],
            ["Slice", "", "1-9", w.slice, w.parseSliceAttributes],
            ["Softmax", "", "1-12", I.softmax, I.parseSoftmaxAttributes],
            ["Softmax", "", "13+", I.softmaxV13, I.parseSoftmaxAttributesV13],
            ["Split", "", "2-12", T.split, T.parseSplitAttributes],
            ["Sqrt", "", "6+", h.sqrt],
            ["Squeeze", "", "1-12", y.squeeze, y.parseSqueezeAttributes],
            ["Squeeze", "", "13+", y.squeezeV13],
            ["Sub", "", "7+", B.sub],
            ["Sum", "", "6+", _.sum],
            ["Tan", "", "7+", h.tan],
            ["Tanh", "", "6+", h.tanh],
            ["Tile", "", "6+", f.tile],
            ["Transpose", "", "1+", l.transpose, l.parseTransposeAttributes],
            ["Upsample", "", "7-8", N0.upsample, N0.parseUpsampleAttributesV7],
            ["Upsample", "", "9", N0.upsample, N0.parseUpsampleAttributesV9],
            ["Unsqueeze", "", "1-12", p.unsqueeze, p.parseUnsqueezeAttributes],
            ["Unsqueeze", "", "13+", p.unsqueezeV13],
            ["Xor", "", "7+", B.xor],
          ];
        },
        2898: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseBatchNormalizationAttributes = Y.batchNormalization =
              void 0));
          let G = Q(246),
            J = Q(5060),
            U = Q(2039),
            $ = {
              name: "BatchNormalization",
              inputNames: ["A", "Scale", "B", "Mean", "Variance"],
              inputTypes: [
                U.TextureType.unpacked,
                U.TextureType.unpacked,
                U.TextureType.unpacked,
                U.TextureType.unpacked,
                U.TextureType.unpacked,
              ],
            };
          ((Y.batchNormalization = (V, W, L) => (
            K(W),
            [
              V.run(
                Object.assign(Object.assign({}, $), {
                  cacheHint: L.cacheKey,
                  get: () => B(V, W, L),
                }),
                W
              ),
            ]
          )),
            (Y.parseBatchNormalizationAttributes = (V) => {
              let W = V.attributes.getFloat("epsilon", 0.00001),
                L = V.attributes.getFloat("momentum", 0.9),
                H = V.attributes.getInt("spatial", 1);
              return (0, G.createAttributeWithCacheKey)({
                epsilon: W,
                momentum: L,
                spatial: H,
              });
            }));
          let B = (V, W, L) => {
              let H = (0, J.getGlsl)(V.session.backend.glContext.version),
                F = W[0].dims.length,
                [N, q] = V.calculateTextureWidthAndHeight(
                  W[1].dims,
                  U.TextureType.unpacked
                ),
                M = `
  float process(int[${F}] indices) {
    vec2 position = offsetToCoords(indices[1], ${N}, ${q});
    float scale = getColorAsFloat(${H.texture2D}(Scale, position));
    float mean = getColorAsFloat(${H.texture2D}(Mean, position));
    float variance = getColorAsFloat(${H.texture2D}(Variance, position));
    float b = getColorAsFloat(${H.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${L.epsilon})) ) + b;
  }`;
              return Object.assign(Object.assign({}, $), {
                output: {
                  dims: W[0].dims,
                  type: W[0].type,
                  textureType: U.TextureType.unpacked,
                },
                shaderSource: M,
              });
            },
            K = (V) => {
              if (!V || V.length !== 5)
                throw Error("BatchNormalization requires 5 inputs.");
              let W = V[0],
                L = V[1],
                H = V[2],
                F = V[3],
                N = V[4];
              if (
                W.dims.length < 3 ||
                L.dims.length !== 1 ||
                H.dims.length !== 1 ||
                F.dims.length !== 1 ||
                N.dims.length !== 1
              )
                throw Error("invalid input shape.");
              if (
                L.dims[0] !== W.dims[1] ||
                H.dims[0] !== W.dims[1] ||
                F.dims[0] !== W.dims[1] ||
                N.dims[0] !== W.dims[1]
              )
                throw Error("invalid input shape.");
              if (
                (W.type !== "float32" && W.type !== "float64") ||
                (L.type !== "float32" && L.type !== "float64") ||
                (H.type !== "float32" && H.type !== "float64") ||
                (F.type !== "float32" && F.type !== "float64") ||
                (N.type !== "float32" && N.type !== "float64")
              )
                throw Error("invalid input tensor types.");
            };
        },
        7839: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.xor =
              Y.sub =
              Y.pRelu =
              Y.pow =
              Y.or =
              Y.mul =
              Y.less =
              Y.greater =
              Y.equal =
              Y.div =
              Y.and =
              Y.add =
              Y.glslPRelu =
              Y.glslPow =
              Y.glslXor =
              Y.glslOr =
              Y.glslAnd =
              Y.glslLess =
              Y.glslGreater =
              Y.glslEqual =
              Y.glslSub =
              Y.glslMul =
              Y.glslDiv =
              Y.glslAdd =
                void 0));
          let G = Q(2517),
            J = Q(8520),
            U = Q(5060),
            $ = Q(2039);
          function B() {
            return {
              body: `
  float add_(float a, float b) {
    return a + b;
  }
  vec4 add_(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,
              name: "add_",
              type: J.FunctionType.ValueBased,
            };
          }
          function K() {
            return {
              body: `
  float div_(float a, float b) {
    return a / b;
  }
  vec4 div_(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,
              name: "div_",
              type: J.FunctionType.ValueBased,
            };
          }
          function V() {
            return {
              body: `
  float mul_(float a, float b) {
    return a * b;
  }
  vec4 mul_(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,
              name: "mul_",
              type: J.FunctionType.ValueBased,
            };
          }
          function W() {
            return {
              body: `
  float sub_(float a, float b) {
    return a - b;
  }
  vec4 sub_(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,
              name: "sub_",
              type: J.FunctionType.ValueBased,
            };
          }
          function L() {
            return {
              body: `
  float equal_(float a, float b) {
    return float(a == b);
  }
  vec4 equal_(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,
              name: "equal_",
              type: J.FunctionType.ValueBased,
            };
          }
          function H() {
            return {
              body: `
  float greater_(float a, float b) {
    return float(a > b);
  }
  vec4 greater_(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,
              name: "greater_",
              type: J.FunctionType.ValueBased,
            };
          }
          function F() {
            return {
              body: `
  float less_(float a, float b) {
    return float(a < b);
  }
  vec4 less_(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,
              name: "less_",
              type: J.FunctionType.ValueBased,
            };
          }
          function N() {
            return {
              body: `
  float and_(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 and_(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,
              name: "and_",
              type: J.FunctionType.ValueBased,
            };
          }
          function q() {
            return {
              body: `
  float or_(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 or_(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,
              name: "or_",
              type: J.FunctionType.ValueBased,
            };
          }
          function M() {
            return {
              body: `
  float xor_(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 xor_(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,
              name: "xor_",
              type: J.FunctionType.ValueBased,
            };
          }
          function A() {
            return (function (E) {
              let O = `${E}_`;
              return {
                body: `
  float ${O}(float a, float b) {
    return ${E}(a, b);
  }
  vec4 ${O}(vec4 v1, vec4 v2) {
    return ${E}(v1, v2);
  }
  `,
                name: O,
                type: J.FunctionType.ValueBased,
              };
            })("pow");
          }
          function D() {
            return {
              body: `
  float prelu_(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 prelu_(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,
              name: "prelu_",
              type: J.FunctionType.ValueBased,
            };
          }
          ((Y.glslAdd = B),
            (Y.glslDiv = K),
            (Y.glslMul = V),
            (Y.glslSub = W),
            (Y.glslEqual = L),
            (Y.glslGreater = H),
            (Y.glslLess = F),
            (Y.glslAnd = N),
            (Y.glslOr = q),
            (Y.glslXor = M),
            (Y.glslPow = A),
            (Y.glslPRelu = D));
          let R = (E, O, Z, j = O[0].type, w) => {
              let I = E.session.pack
                ? $.TextureType.packed
                : $.TextureType.unpacked;
              return {
                name: Z.name,
                inputNames: ["A", "B"],
                inputTypes: [I, I],
                cacheHint: w,
                get: () => z(E, O, Z, j),
              };
            },
            z = (E, O, Z, j = O[0].type) => {
              let w = E.session.pack
                  ? $.TextureType.packed
                  : $.TextureType.unpacked,
                I = !G.ShapeUtil.areEqual(O[0].dims, O[1].dims),
                T = O[0].dims,
                y = E.session.pack;
              if (I) {
                let l = G.BroadcastUtil.calcShape(O[0].dims, O[1].dims, !1);
                if (!l)
                  throw Error("Can't perform binary op on the given tensors");
                T = l;
                let h = T.length,
                  p = O[0].dims.length !== 0 ? O[0].dims.length : 1,
                  N0 = O[1].dims.length !== 0 ? O[1].dims.length : 1,
                  e =
                    O[0].dims.length !== 0
                      ? "bcastIndices_A(indices, aindices);"
                      : "aindices[0] = 0;",
                  P =
                    O[1].dims.length !== 0
                      ? "bcastIndices_B(indices, bindices);"
                      : "bindices[0] = 0;",
                  x = (0, U.getGlsl)(E.session.backend.glContext.version),
                  r = y
                    ? `
      ${Z.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${Z.name}(a, b);
        ${x.output} = result;
      }`
                    : `
      ${Z.body}
      float process(int indices[${h}]) {
        int aindices[${p}];
        int bindices[${N0}];
        ${e}
        ${P}
        return ${Z.name}(_A(aindices), _B(bindices));
      }`;
                return {
                  name: Z.name,
                  inputNames: ["A", "B"],
                  inputTypes: [w, w],
                  output: { dims: T, type: j, textureType: w },
                  shaderSource: r,
                  hasMain: y,
                };
              }
              let _ = (0, U.getGlsl)(E.session.backend.glContext.version),
                f = `
    ${Z.body}
    void main() {
      vec4 v1 = ${_.texture2D}(A, TexCoords);
      vec4 v2 = ${_.texture2D}(B, TexCoords);
      vec4 result = ${Z.name}(v1, v2);
      ${_.output} = result;
    }
    `;
              return {
                name: Z.name,
                inputNames: ["A", "B"],
                inputTypes: [w, w],
                output: { dims: O[0].dims, type: j, textureType: w },
                shaderSource: f,
                hasMain: !0,
              };
            };
          ((Y.add = (E, O) => [E.run(R(E, O, B()), O)]),
            (Y.and = (E, O) => [E.run(R(E, O, N(), "bool"), O)]),
            (Y.div = (E, O) => [E.run(R(E, O, K()), O)]),
            (Y.equal = (E, O) => [E.run(R(E, O, L(), "bool"), O)]),
            (Y.greater = (E, O) => [E.run(R(E, O, H(), "bool"), O)]),
            (Y.less = (E, O) => [E.run(R(E, O, F(), "bool"), O)]),
            (Y.mul = (E, O) => [E.run(R(E, O, V()), O)]),
            (Y.or = (E, O) => [E.run(R(E, O, q(), "bool"), O)]),
            (Y.pow = (E, O) => [E.run(R(E, O, A()), O)]),
            (Y.pRelu = (E, O) => [E.run(R(E, O, D()), O)]),
            (Y.sub = (E, O) => [E.run(R(E, O, W()), O)]),
            (Y.xor = (E, O) => [E.run(R(E, O, M(), "bool"), O)]));
        },
        4196: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseCastAttributes = Y.cast = void 0));
          let G = Q(2517);
          ((Y.cast = (U, $, B) => (J($), [U.cast($[0], B)])),
            (Y.parseCastAttributes = (U) =>
              G.ProtoUtil.tensorDataTypeFromProto(U.attributes.getInt("to"))));
          let J = (U) => {
            if (!U || U.length !== 1) throw Error("Cast requires 1 input.");
            if (U[0].type === "string") throw Error("Invalid input type.");
          };
        },
        1163: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.createPackedConcatProgramInfoLoader = void 0));
          let G = Q(5060),
            J = Q(2039),
            U = Q(9390),
            $ = Q(2827);
          Y.createPackedConcatProgramInfoLoader = (K, V, W) => {
            let L =
              ((H = V.length),
              (F = W.cacheKey),
              {
                name: "Concat (packed)",
                inputNames: Array.from({ length: H }, (N, q) => `X${q}`),
                inputTypes: Array(H).fill(J.TextureType.packed),
                cacheHint: F,
              });
            var H, F;
            return Object.assign(Object.assign({}, L), {
              get: () =>
                ((N, q, M, A) => {
                  let D = M[0].dims.slice();
                  if (A >= D.length || A < -1 * D.length)
                    throw Error(
                      "axis specified for concat doesn't match input dimensionality"
                    );
                  A < 0 && (A = D.length + A);
                  let R = D.slice(0);
                  for (let e = 1; e < M.length; e++) {
                    let P = M[e].dims.slice();
                    for (let x = 0; x < D.length; x++)
                      if (x === A) R[A] += P[x];
                      else if (D[x] !== P[x])
                        throw Error("non concat dimensions must match");
                  }
                  let z = R.length,
                    E = (0, $.getChannels)("coords", z),
                    O = (0, U.getCoordsDataType)(z),
                    Z = (0, $.unpackFromChannel)(),
                    j = M.map((e) => e.dims),
                    w = (0, U.getGlChannels)(z),
                    I = Array(j.length - 1);
                  I[0] = j[0][A];
                  for (let e = 1; e < I.length; e++) I[e] = I[e - 1] + j[e][A];
                  let T = w[A],
                    y = w.slice(-2),
                    _ = w.join(),
                    f = `if (${T} < ${I[0]}) {
        return getChannel(
            getX0(${_}), vec2(${y.join()}));
        }`;
                  for (let e = 1; e < I.length; e++) {
                    let P = I[e - 1];
                    f += `
            if (${T} < ${I[e]}  && ${T} >= ${I[e - 1]}) {
              return getChannel(
                getX${e}(${B(w, T, P)}),
                vec2(${B(y, T, P)}));
            }`;
                  }
                  let l = I.length,
                    h = I[I.length - 1];
                  f += `
            return getChannel(
              getX${l}(${B(w, T, h)}),
              vec2(${B(y, T, h)}));`;
                  let p = (0, G.getGlsl)(N.session.backend.glContext.version),
                    N0 = `
          ${Z}
          float getValue(${w.map((e) => "int " + e)}) {
            ${f}
          }

          void main() {
            ${O} coords = getOutputCoords();
            int lastDim = coords.${w[z - 1]};
            coords.${w[z - 1]} = coords.${w[z - 2]};
            coords.${w[z - 2]} = lastDim;

            vec4 result = vec4(getValue(${E}), 0., 0., 0.);

            ${E[z - 1]} = ${E[z - 1]} + 1;
            if (${E[z - 1]} < ${R[z - 1]}) {
              result.g = getValue(${E});
            }

            ${E[z - 2]} = ${E[z - 2]} + 1;
            if (${E[z - 2]} < ${R[z - 2]}) {
              result.a = getValue(${E});
            }

            ${E[z - 1]} = ${E[z - 1]} - 1;
            if (${E[z - 2]} < ${R[z - 2]} &&
                ${E[z - 1]} < ${R[z - 1]}) {
              result.b = getValue(${E});
            }
            ${p.output} = result;
          }
        `;
                  return Object.assign(Object.assign({}, q), {
                    output: {
                      dims: R,
                      type: M[0].type,
                      textureType: J.TextureType.packed,
                    },
                    shaderSource: N0,
                    hasMain: !0,
                  });
                })(K, L, V, W.axis),
            });
          };
          let B = (K, V, W) => {
            let L = K.indexOf(V);
            return K.map((H, F) => (F === L ? `${H} - ${W}` : H)).join();
          };
        },
        2069: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseConcatAttributes = Y.concat = void 0));
          let G = Q(246),
            J = Q(2039),
            U = Q(1163);
          Y.concat = (H, F, N) => (
            L(F),
            H.session.pack && F[0].dims.length > 1
              ? [H.run((0, U.createPackedConcatProgramInfoLoader)(H, F, N), F)]
              : [H.run($(H, F, N), F)]
          );
          let $ = (H, F, N) => {
              let q =
                ((M = F.length),
                (A = N.cacheKey),
                {
                  name: "Concat",
                  inputNames: Array.from({ length: M }, (D, R) => `X${R}`),
                  inputTypes: Array(M).fill(J.TextureType.unpacked),
                  cacheHint: A,
                });
              var M, A;
              return Object.assign(Object.assign({}, q), {
                get: () =>
                  ((D, R, z, E) => {
                    let O = z[0].dims.slice();
                    if (E >= O.length || E < -1 * O.length)
                      throw Error(
                        "axis specified for concat doesn't match input dimensionality"
                      );
                    E < 0 && (E = O.length + E);
                    let Z = O.slice(0);
                    for (let _ = 1; _ < z.length; _++) {
                      let f = z[_].dims.slice();
                      for (let l = 0; l < O.length; l++)
                        if (l === E) Z[E] += f[l];
                        else if (O[l] !== f[l])
                          throw Error("non concat dimensions must match");
                    }
                    let j = Z.length,
                      w = Array(z.length),
                      I = 0;
                    for (let _ = 0; _ < w.length; ++_)
                      ((I += z[_].dims[E]), (w[_] = I));
                    let T = "";
                    T = z.length < 5 ? B(w) : K(w);
                    let y = `
        ${V(z.length, j)}
        ${W(w)}
        ${T}
        float process(int indices[${j}]) {
          int textureIndex = getTextureWhereDataResides (indices[${E}]);

          if(textureIndex != 0) {
            indices[${E}] = indices[${E}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
                    return Object.assign(Object.assign({}, R), {
                      output: {
                        dims: Z,
                        type: z[0].type,
                        textureType: J.TextureType.unpacked,
                      },
                      shaderSource: y,
                    });
                  })(0, q, F, N.axis),
              });
            },
            B = (H) => {
              return `int getTextureWhereDataResides(int index) {
      ${H.map(
        (N, q) => `if(index<${N}) {return ${q};}
`
      ).join("")}
    }`;
            },
            K = (H) => B(H),
            V = (H, F) => {
              let N = [
                `float fetchDataFromCorrectTexture(int textureIndex, int indices[${F}]) {`,
              ];
              for (let q = 0; q < H; ++q)
                q === 0
                  ? N.push(
                      `	if (textureIndex == ${q}) { return _X${q}(indices); }`
                    )
                  : q === H - 1
                    ? N.push(`	else { return _X${q}(indices); }`)
                    : N.push(
                        `	else if (textureIndex == ${q}) { return _X${q}(indices); }`
                      );
              return (
                N.push("\t}"),
                N.join(`
`)
              );
            },
            W = (H) => {
              let F = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
              for (let N = 0; N < H.length; ++N)
                N === 0
                  ? F.push(`	if (index == ${N}) { return ${H[N]}; }`)
                  : N === H.length - 1
                    ? F.push(`	else { return ${H[N]}; }`)
                    : F.push(`	else if (index == ${N}) { return ${H[N]}; }`);
              return (
                F.push("\t}"),
                F.join(`
`)
              );
            };
          Y.parseConcatAttributes = (H) =>
            (0, G.createAttributeWithCacheKey)({
              axis: H.attributes.getInt("axis"),
            });
          let L = (H) => {
            if (!H || H.length < 1) throw Error("too few inputs");
            let F = H[0].type,
              N = H[0].dims.length;
            if (F === "string")
              throw Error("string tensor is not supported yet");
            for (let q of H) {
              if (q.type !== F) throw Error("input tensors should be one type");
              if (q.dims.length !== N)
                throw Error("input tensors should have the same shape");
            }
          };
        },
        4770: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.createUnpackedGroupedConvProgramInfoLoader = void 0));
          let G = Q(3694),
            J = Q(5060),
            U = Q(2039),
            $ = Q(8138),
            B = Q(2823);
          Y.createUnpackedGroupedConvProgramInfoLoader = (K, V, W) => {
            let L =
              ((H = V.length > 2),
              (F = W.cacheKey),
              {
                name: "GroupedConv",
                inputNames: H ? ["X", "W", "Bias"] : ["X", "W"],
                inputTypes: H
                  ? [
                      U.TextureType.unpacked,
                      U.TextureType.unpacked,
                      U.TextureType.unpacked,
                    ]
                  : [U.TextureType.unpacked, U.TextureType.unpacked],
                cacheHint: F,
              });
            var H, F;
            return Object.assign(Object.assign({}, L), {
              get: () =>
                ((N, q, M, A) => {
                  let D =
                      q.length > 2 ? "value += getBias(output_channel);" : "",
                    R = q[0].dims.slice(),
                    z = q[1].dims.slice(),
                    E = z[0] / A.group;
                  G.Logger.verbose(
                    "GroupedConv",
                    `autpPad:${A.autoPad}, dilations:${A.dilations}, group:${A.group}, kernelShape:${A.kernelShape}, pads:${A.pads}, strides:${A.strides}`
                  );
                  let O = (0, $.calculateOutputShape)(
                      R,
                      z,
                      A.dilations,
                      A.pads,
                      A.strides
                    ),
                    Z = (0, J.getGlsl)(N.session.backend.glContext.version),
                    { activationFunction: j, applyActivation: w } = (0,
                    B.getActivationSnippet)(A),
                    I = `
  const ivec2 strides = ivec2(${A.strides[0]}, ${A.strides[1]});
  const ivec2 pads = ivec2(${A.pads[0]}, ${A.pads[1]});
  ${j}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${E};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${z[1]}; wInChannel++) {
      int input_channel = group_id * ${z[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${z[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${A.dilations[0]};

        if (xHeight < 0 || xHeight >= ${R[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${z[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${A.dilations[1]};
          if (xWidth < 0 || xWidth >= ${R[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${D}
    ${w}
    ${Z.output} = vec4(value, .0, .0, .0);
  }
`;
                  return Object.assign(Object.assign({}, M), {
                    output: {
                      dims: O,
                      type: q[0].type,
                      textureType: U.TextureType.unpacked,
                    },
                    shaderSource: I,
                    hasMain: !0,
                  });
                })(K, V, L, W),
            });
          };
        },
        1386: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.conv2DPacked = Y.conv2DPackedPointwise = void 0));
          let G = Q(8138),
            J = Q(8555),
            U = Q(708);
          ((Y.conv2DPackedPointwise = ($, B, K) => {
            let V = B[0].dims,
              W = B[1].dims,
              L = (0, G.calculateOutputShape)(
                V,
                W,
                K.dilations,
                K.pads,
                K.strides
              ),
              H = $.reshapePacked(B[0], [V[1], V[2] * V[3]]),
              F = $.reshapePacked(B[1], [W[0], W[1]]),
              N = B.length > 2 ? [F, H, B[2]] : [F, H],
              q = $.run((0, U.createPackedMatmulProgramInfoLoader)($, N, K), N);
            return $.reshapePacked(q, L);
          }),
            (Y.conv2DPacked = ($, B, K) => {
              let V = B[0].dims,
                W = B[1].dims,
                L = (0, G.calculateOutputShape)(
                  V,
                  W,
                  K.dilations,
                  K.pads,
                  K.strides
                ),
                H = $.run(
                  (0, J.createPackedIm2ColProgramInfoLoader)(
                    $,
                    B[0],
                    B[1],
                    L,
                    K
                  ),
                  [B[0]]
                ),
                F = $.reshapePacked(B[1], [W[0], W[1] * W[2] * W[3]]),
                N = B.length === 3 ? [F, H, B[2]] : [F, H],
                q = $.run(
                  (0, U.createPackedMatmulProgramInfoLoader)($, N, K),
                  N
                );
              return $.reshapePacked(q, L);
            }));
        },
        9663: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseConvTransposeAttributes = Y.convTranspose = void 0));
          let G = Q(246),
            J = Q(5060),
            U = Q(2039),
            $ = Q(2823),
            B = (F, N, q, M, A, D) => (F - 1) * N + q + (M - 1) * A + 1 - D,
            K = (F, N, q, M, A) => {
              let D = Math.floor(F / 2);
              N === "SAME_UPPER"
                ? ((q[M] = D), (q[A] = F - D))
                : N === "SAME_LOWER" && ((q[M] = F - D), (q[A] = D));
            };
          Y.convTranspose = (F, N, q) => (H(N, q), V(F, N, q));
          let V = (F, N, q) => {
              let M = L(q, N);
              return [W(F, N, M)];
            },
            W = (F, N, q) =>
              F.run(
                ((M, A, D) => {
                  let R =
                    ((z = A.length > 2),
                    (E = D.cacheKey),
                    {
                      name: "ConvTranspose",
                      inputNames: z ? ["X", "W", "B"] : ["X", "W"],
                      inputTypes: z
                        ? [
                            U.TextureType.unpacked,
                            U.TextureType.unpacked,
                            U.TextureType.unpacked,
                          ]
                        : [U.TextureType.unpacked, U.TextureType.unpacked],
                      cacheHint: E,
                    });
                  var z, E;
                  return Object.assign(Object.assign({}, R), {
                    get: () =>
                      ((O, Z, j, w) => {
                        let I = Z.length > 2 ? "getB(output_channel)" : "0.0",
                          T = Z[0].dims,
                          y = Z[1].dims,
                          _ = y[1],
                          f = y[0] / w.group,
                          l = [
                            Z[0].dims[0],
                            Z[1].dims[1] * w.group,
                            ...w.outputShape,
                          ],
                          h = (0, J.getGlsl)(
                            O.session.backend.glContext.version
                          ),
                          { activationFunction: p, applyActivation: N0 } = (0,
                          $.getActivationSnippet)(w),
                          e = `
  const ivec2 strides = ivec2(${w.strides[0]}, ${w.strides[1]});
  const ivec2 pads = ivec2(${w.pads[0]}, ${w.pads[1]});
  ${p}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${_};
    int wOutChannel = output_channel - group_id * ${_};

    float value = ${I};
    for (int inChannelOffset = 0; inChannelOffset < ${f}; inChannelOffset++) {
      int input_channel = group_id * ${f} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${y[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${y[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${w.dilations[0]}, wHOff * ${w.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${T[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${T[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${N0}
    ${h.output} = vec4(value, .0, .0, .0);
  }
`;
                        return Object.assign(Object.assign({}, j), {
                          output: {
                            dims: l,
                            type: Z[0].type,
                            textureType: U.TextureType.unpacked,
                          },
                          shaderSource: e,
                          hasMain: !0,
                        });
                      })(M, A, R, D),
                  });
                })(F, N, q),
                N
              ),
            L = (F, N) => {
              let q = F.kernelShape.slice();
              if (F.kernelShape.length === 0)
                for (let R = 2; R < N[1].dims.length; ++R) q.push(N[1].dims[R]);
              let M = F.pads.slice(),
                A = F.outputShape.slice();
              ((R, z, E, O, Z, j, w, I) => {
                let T = R.length - 2,
                  y = I.length === 0;
                for (let _ = 0; _ < T; ++_) {
                  let f = y ? R[_ + 2] * j[_] : I[_],
                    l = B(R[_ + 2], j[_], Z[_], z[_], E[_], f);
                  (K(l, O, Z, _, _ + T),
                    y &&
                      I.push(
                        j[_] * (R[_ + 2] - 1) +
                          w[_] +
                          (z[_] - 1) * E[_] +
                          1 -
                          Z[_] -
                          Z[_ + T]
                      ));
                }
              })(
                N[0].dims,
                q,
                F.dilations,
                F.autoPad,
                M,
                F.strides,
                F.outputPadding,
                A
              );
              let D = Object.assign({}, F);
              return (
                Object.assign(D, {
                  kernelShape: q,
                  pads: M,
                  outputShape: A,
                  cacheKey: F.cacheKey,
                }),
                D
              );
            };
          Y.parseConvTransposeAttributes = (F) => {
            let N = F.attributes,
              q = (0, $.parseInternalActivationAttributes)(N),
              M = N.getString("auto_pad", "NOTSET"),
              A = N.getInts("dilations", [1, 1]),
              D = N.getInt("group", 1),
              R = N.getInts("kernel_shape", []),
              z = N.getInts("output_padding", [0, 0]),
              E = N.getInts("output_shape", []),
              O = N.getInts("pads", [0, 0, 0, 0]),
              Z = N.getInts("strides", [1, 1]);
            return (0, G.createAttributeWithCacheKey)(
              Object.assign(
                {
                  autoPad: M,
                  dilations: A,
                  group: D,
                  kernelShape: R,
                  outputPadding: z,
                  outputShape: E,
                  pads: O,
                  strides: Z,
                },
                q
              )
            );
          };
          let H = (F, N) => {
            if (!F || (F.length !== 2 && F.length !== 3))
              throw Error("Conv requires 2 or 3 inputs");
            if (F[0].dims.length !== 4 || F[1].dims.length !== 4)
              throw Error("currently only support 2-dimensional conv");
            if (F[0].dims[1] !== F[1].dims[0])
              throw Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
            let q = F[1].dims[1] * N.group;
            if (
              F.length === 3 &&
              (F[2].dims.length !== 1 || F[2].dims[0] !== q)
            )
              throw Error("invalid bias");
            let M = F[0].dims.length - 2;
            if (N.dilations.length !== M)
              throw Error(`dilations should be ${M}D`);
            if (N.strides.length !== M) throw Error(`strides should be ${M}D`);
            if (N.pads.length !== 2 * M)
              throw Error(`pads should be ${2 * M}D`);
            if (N.outputPadding.length !== M)
              throw Error(`output_padding should be ${M}D`);
            if (
              N.kernelShape.length !== 0 &&
              N.kernelShape.length !== F[1].dims.length - 2
            )
              throw Error("invalid kernel shape");
            if (
              N.outputShape.length !== 0 &&
              N.outputShape.length !== F[0].dims.length - 2
            )
              throw Error("invalid output shape");
            if (F[0].type !== "float32" || F[1].type !== "float32")
              throw Error("ConvTranspose input(X,W) should be float tensor");
            if (F.length === 3 && F[2].type !== "float32")
              throw Error("ConvTranspose input(bias) should be float tensor");
          };
        },
        8138: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseConvAttributes = Y.conv = Y.calculateOutputShape = void 0));
          let G = Q(246),
            J = Q(2517),
            U = Q(4770),
            $ = Q(1386),
            B = Q(9828),
            K = Q(2823),
            V = Q(3248),
            W = Q(5623);
          ((Y.calculateOutputShape = (M, A, D, R, z) => {
            let E = M[0],
              O = M.slice(2),
              Z = O.length,
              j = A[0],
              w = A.slice(2).map((y, _) => y + (y - 1) * (D[_] - 1)),
              I = O.map((y, _) => y + R[_] + R[_ + Z]),
              T = I.map((y, _) => Math.floor((y - w[_] + z[_]) / z[_]));
            return [E, j].concat(...T);
          }),
            (Y.conv = (M, A, D) => (q(A, D), L(M, A, D))));
          let L = (M, A, D) => {
              let R = N(D, A),
                z = M.session.pack,
                E = R.kernelShape[0] === 1 && R.kernelShape[1] === 1;
              return R.group > 1
                ? [
                    M.run(
                      (0, U.createUnpackedGroupedConvProgramInfoLoader)(
                        M,
                        A,
                        R
                      ),
                      A
                    ),
                  ]
                : E && z
                  ? [H(M, A, R)]
                  : z && A[0].dims.length === 4 && A[0].dims[0] === 1 && !E
                    ? [(0, $.conv2DPacked)(M, A, R)]
                    : [F(M, A, R)];
            },
            H = (M, A, D) => {
              let R = A[0].dims,
                z = A[1].dims,
                E = (0, Y.calculateOutputShape)(
                  R,
                  z,
                  D.dilations,
                  D.pads,
                  D.strides
                ),
                O = M.reshapeUnpacked(A[0], [R[1], R[2] * R[3]]),
                Z = M.reshapeUnpacked(A[1], [z[0], z[1]]),
                j = A.length > 2 ? [Z, O, A[2]] : [Z, O],
                w = M.run((0, W.createMatmulProgramInfoLoader)(j, D), j);
              return M.reshapeUnpacked(w, E);
            },
            F = (M, A, D) => {
              let R = A[0].dims,
                z = A[1].dims,
                E = (0, Y.calculateOutputShape)(
                  R,
                  z,
                  D.dilations,
                  D.pads,
                  D.strides
                ),
                O = M.run(
                  (0, V.createIm2ColProgramInfoLoader)(M, A[0], A[1], E, D),
                  [A[0]]
                ),
                Z = A.length === 3 ? [O, A[1], A[2]] : [O, A[1]];
              return M.run(
                (0, B.createDotProductProgramInfoLoader)(M, A, E, D),
                Z
              );
            },
            N = (M, A) => {
              let D = M.kernelShape.slice();
              if (M.kernelShape.length === 0)
                for (let E = 2; E < A[1].dims.length; ++E) D.push(A[1].dims[E]);
              let R = M.pads.slice();
              J.PoolConvUtil.adjustPadsBasedOnAutoPad(
                A[0].dims,
                M.strides,
                M.dilations,
                D,
                R,
                M.autoPad
              );
              let z = Object.assign({}, M);
              return (
                Object.assign(z, {
                  kernelShape: D,
                  pads: R,
                  cacheKey: M.cacheKey,
                }),
                z
              );
            };
          Y.parseConvAttributes = (M) => {
            let A = M.attributes,
              D = (0, K.parseInternalActivationAttributes)(A),
              R = A.getString("auto_pad", "NOTSET"),
              z = A.getInts("dilations", [1, 1]),
              E = A.getInt("group", 1),
              O = A.getInts("kernel_shape", []),
              Z = A.getInts("pads", [0, 0, 0, 0]),
              j = A.getInts("strides", [1, 1]);
            return (0, G.createAttributeWithCacheKey)(
              Object.assign(
                {
                  autoPad: R,
                  dilations: z,
                  group: E,
                  kernelShape: O,
                  pads: Z,
                  strides: j,
                },
                D
              )
            );
          };
          let q = (M, A) => {
            if (!M || (M.length !== 2 && M.length !== 3))
              throw Error("Conv requires 2 or 3 inputs");
            if (M[0].dims.length !== 4 || M[1].dims.length !== 4)
              throw Error("currently only support 2-dimensional conv");
            if (M[0].dims[1] !== M[1].dims[1] * A.group)
              throw Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
            if (
              M.length === 3 &&
              (M[2].dims.length !== 1 || M[1].dims[0] !== M[2].dims[0])
            )
              throw Error("invalid bias");
            let D = M[0].dims.length - 2;
            if (A.dilations.length !== D)
              throw Error(`dilations should be ${D}D`);
            if (A.strides.length !== D) throw Error(`strides should be ${D}D`);
            if (A.pads.length !== 2 * D)
              throw Error(`pads should be ${2 * D}D`);
            if (
              A.kernelShape.length !== 0 &&
              A.kernelShape.length !== M[1].dims.length - 2
            )
              throw Error("invalid kernel shape");
            if (M[0].type !== "float32" || M[1].type !== "float32")
              throw Error("Conv input(X,W) should be float tensor");
            if (M.length === 3 && M[2].type !== "float32")
              throw Error("Conv input(bias) should be float tensor");
          };
        },
        5193: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseDepthToSpaceAttributes = Y.depthToSpace = void 0));
          let G = Q(3738);
          ((Y.depthToSpace = (U, $, B) => {
            J($);
            let K = B.blocksize,
              V = K * K,
              W = B.mode === "DCR" ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3],
              L =
                B.mode === "DCR"
                  ? [
                      $[0].dims[0],
                      K,
                      K,
                      $[0].dims[1] / V,
                      $[0].dims[2],
                      $[0].dims[3],
                    ]
                  : [
                      $[0].dims[0],
                      $[0].dims[1] / V,
                      K,
                      K,
                      $[0].dims[2],
                      $[0].dims[3],
                    ],
              H = U.reshapeUnpacked($[0], L),
              F = { perm: W, cacheKey: `${W}` },
              [N] = (0, G.transpose)(U, [H], F),
              q = [
                $[0].dims[0],
                $[0].dims[1] / V,
                $[0].dims[2] * K,
                $[0].dims[3] * K,
              ];
            return [U.reshapeUnpacked(N, q)];
          }),
            (Y.parseDepthToSpaceAttributes = (U) => {
              let $ = U.attributes.getInt("blocksize");
              if ($ < 1)
                throw Error(
                  `blocksize must be >= 1, but got : ${$} for DepthToSpace`
                );
              let B = U.attributes.getString("mode", "DCR");
              if (B !== "DCR" && B !== "CRD")
                throw Error(`unrecognized mode: ${B} for DepthToSpace`);
              return { mode: B, blocksize: $ };
            }));
          let J = (U) => {
            if (U.length !== 1)
              throw Error(`DepthToSpace expect 1 inputs, but got ${U.length}`);
            if (U[0].type === "string" || U[0].dims.length !== 4)
              throw TypeError(
                "DepthToSpace input should be a 4-D numeric tensor"
              );
          };
        },
        9828: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.createDotProductProgramInfoLoader = void 0));
          let G = Q(2517),
            J = Q(5060),
            U = Q(2039),
            $ = Q(2823),
            B = Q(3248);
          Y.createDotProductProgramInfoLoader = (K, V, W, L) => {
            let H = ((F, N) => ({
              name: "ConvDotProduct",
              inputNames: F ? ["Im2Col", "K", "B"] : ["Im2Col", "K"],
              inputTypes: F
                ? [
                    U.TextureType.unpacked,
                    U.TextureType.packedLastDimension,
                    U.TextureType.unpacked,
                  ]
                : [U.TextureType.unpacked, U.TextureType.packedLastDimension],
              cacheKey: N.activationCacheKey,
            }))(V.length > 2, L);
            return Object.assign(Object.assign({}, H), {
              get: () =>
                ((F, N, q, M, A) => {
                  let D = q[0].dims,
                    R = q[1].dims,
                    z = [R[0], Math.ceil((D[1] * R[2] * R[3]) / 4)],
                    E = (0, B.calculateIm2ColDims)(D, R, M),
                    [O, Z] = F.calculateTextureWidthAndHeight(
                      z,
                      U.TextureType.packedLastDimension
                    ),
                    j = G.ShapeUtil.computeStrides(E),
                    [w, I] = F.calculateTextureWidthAndHeight(
                      E,
                      U.TextureType.packedLastDimension
                    ),
                    T = M.length,
                    y = q.length < 3 ? "0.0" : "_B(b)",
                    _ = Math.ceil((D[1] * R[2] * R[3]) / 4),
                    { activationFunction: f, applyActivation: l } = (0,
                    $.getActivationSnippet)(A),
                    h = (0, J.getGlsl)(F.session.backend.glContext.version),
                    p = `
${f}
float process(int indices[${T}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${j[0]} + im2col[1] * ${j[1]} + im2col[2] * ${j[2]};
  int kernelOffset = indices[1] * ${z[1]};
  float value = ${y};
  for (int i = 0; i < ${_}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${w}, ${I});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${O}, ${Z});
    value += dot(${h.texture2D}(Im2Col, im2colCoords), ${h.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${l}
  return value;
}`;
                  return Object.assign(Object.assign({}, N), {
                    output: {
                      dims: M,
                      type: q[0].type,
                      textureType: U.TextureType.unpacked,
                    },
                    shaderSource: p,
                  });
                })(K, H, V, W, L),
            });
          };
        },
        7992: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseFlattenAttributes = Y.flatten = void 0));
          let G = Q(2517);
          ((Y.flatten = (U, $, B) => {
            J($, B);
            let K = G.ShapeUtil.flattenShape($[0].dims, B);
            return [U.reshapeUnpacked($[0], K)];
          }),
            (Y.parseFlattenAttributes = (U) => U.attributes.getInt("axis", 1)));
          let J = (U, $) => {
            if (!U || U.length !== 1) throw Error("Flatten requires 1 input.");
            let B = U[0].dims.length;
            if (B === 0) throw Error("scalar tensor is not supported.");
            if ($ < -B || $ > B) throw Error("Invalid axis");
            if (U[0].type === "string")
              throw Error("string tensor is not supported.");
          };
        },
        2823: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseInternalActivationAttributes = Y.getActivationSnippet =
              void 0));
          let G = Q(2517),
            J = Q(4909);
          ((Y.getActivationSnippet = function (U) {
            let $;
            switch (U.activation) {
              case "Relu":
                $ = (0, J.glslRelu)();
                break;
              case "Sigmoid":
                $ = (0, J.glslSigmoid)();
                break;
              case "Clip":
                $ = (0, J.glslClip)(U.clipMin, U.clipMax);
                break;
              default:
                return { activationFunction: "", applyActivation: "" };
            }
            let B = $.name;
            return {
              activationFunction: $.body,
              applyActivation: `value = ${B}_(value);`,
            };
          }),
            (Y.parseInternalActivationAttributes = (U) => {
              let $ = U.getString("activation", "");
              if ($ === "Clip") {
                let [B, K] = U.getFloats("activation_params", [
                  G.MIN_CLIP,
                  G.MAX_CLIP,
                ]);
                return {
                  activation: $,
                  clipMax: K,
                  clipMin: B,
                  activationCacheKey: `${$}:${B},${K}`,
                };
              }
              return { activation: $, activationCacheKey: $ };
            }));
        },
        1253: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseGatherAttributes = Y.gather = void 0));
          let G = Q(246),
            J = Q(782),
            U = Q(2517),
            $ = Q(2039);
          ((Y.gather = (W, L, H) => (V(L, H.axis), [W.run(K(W, L, H), L)])),
            (Y.parseGatherAttributes = (W) =>
              (0, G.createAttributeWithCacheKey)({
                axis: W.attributes.getInt("axis", 0),
              })));
          let B = {
              name: "Gather",
              inputNames: ["A", "B"],
              inputTypes: [$.TextureType.unpacked, $.TextureType.unpacked],
            },
            K = (W, L, H) => {
              let F = Object.assign(Object.assign({}, B), {
                cacheHint: H.cacheKey,
              });
              return Object.assign(Object.assign({}, F), {
                get: () =>
                  ((N, q, M, A) => {
                    let D = M[0].dims.slice(),
                      R = M[1].dims.slice(),
                      z = Array(D.length + R.length - 1);
                    A = U.ShapeUtil.normalizeAxis(A, D.length);
                    let E = [];
                    for (let Z = 0; Z < z.length; Z++)
                      Z < A
                        ? ((z[Z] = D[Z]),
                          E.push(`inputIdx[${Z}] = outputIdx[${Z}];`))
                        : Z < A + R.length
                          ? ((z[Z] = R[Z - A]),
                            E.push(`indexDataIdx[${Z - A}] = outputIdx[${Z}];`))
                          : ((z[Z] = D[Z - R.length + 1]),
                            E.push(
                              `inputIdx[${Z - R.length + 1}] = outputIdx[${Z}];`
                            ));
                    let O = `
      float process(int outputIdx[${z.length || 1}]) {
        int inputIdx[${D.length}];
        int indexDataIdx[${R.length || 1}];
        indexDataIdx[0] = 0;
        ${E.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${A}] = idx < 0 ? idx + ${D[A]} : idx;
        return _A(inputIdx);
      }`;
                    return Object.assign(Object.assign({}, q), {
                      output: {
                        dims: z,
                        type: M[0].type,
                        textureType: $.TextureType.unpacked,
                      },
                      shaderSource: O,
                    });
                  })(0, F, L, H.axis),
              });
            },
            V = (W, L) => {
              if (!W || W.length !== 2)
                throw Error("Gather requires 2 inputs.");
              let H = W[0].dims.length;
              if (H < 1) throw Error("Invalid input shape.");
              if (L < -H || L > H - 1) throw Error("Invalid axis.");
              if (J.NUMBER_TYPES.indexOf(W[0].type) === -1)
                throw Error("Invaid input type.");
              if (W[1].type !== "int32" && W[1].type !== "int16")
                throw Error("Invaid input type.");
            };
        },
        4776: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseGemmAttributesV11 =
              Y.parseGemmAttributesV7 =
              Y.gemm =
                void 0));
          let G = Q(246),
            J = Q(2517),
            U = Q(2039);
          Y.gemm = (W, L, H) => (V(L, H), [W.run(B(L, H), L)]);
          let $ = (W, L) => {
            let H = W.attributes.getInt("transA", 0) !== 0,
              F = W.attributes.getInt("transB", 0) !== 0,
              N = W.attributes.getFloat("alpha", 1),
              q = W.attributes.getFloat("beta", 1);
            return (0, G.createAttributeWithCacheKey)({
              transA: H,
              transB: F,
              alpha: N,
              beta: q,
              isOptionalC: L,
            });
          };
          ((Y.parseGemmAttributesV7 = (W) => $(W, !1)),
            (Y.parseGemmAttributesV11 = (W) => $(W, !0)));
          let B = (W, L) => {
              let H = {
                name: "Gemm",
                inputNames: W.length === 3 ? ["A", "B", "C"] : ["A", "B"],
                inputTypes:
                  W.length === 3
                    ? [
                        U.TextureType.unpacked,
                        U.TextureType.unpacked,
                        U.TextureType.unpacked,
                      ]
                    : [U.TextureType.unpacked, U.TextureType.unpacked],
                key: L.cacheKey,
              };
              return Object.assign(Object.assign({}, H), {
                get: () => K(H, W, L),
              });
            },
            K = (W, L, H) => {
              let F = L[0].dims.slice(),
                N = L[1].dims.slice(),
                [q, M] = J.GemmUtil.getShapeOfGemmResult(
                  F,
                  H.transA,
                  N,
                  H.transB,
                  L.length === 3 ? L[2].dims : void 0
                ),
                A = [q, M];
              if (!A) throw Error("Can't use gemm on the given tensors");
              let D = F[F.length - 1],
                R = "";
              (H.transA && (D = F[0]),
                H.transA && H.transB
                  ? (R = "value += _A_T(a) * _B_T(b);")
                  : H.transA && !H.transB
                    ? (R = "value += _A_T(a) * _B(b);")
                    : !H.transA && H.transB
                      ? (R = "value += _A(a) * _B_T(b);")
                      : H.transA ||
                        H.transB ||
                        (R = "value += _A(a) * _B(b);"));
              let z = A.length,
                E = `
      float process(int indices[${z}]) {
          int a[${z}];
          int b[${z}];
          ${L.length === 3 ? `int c[${L[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${L.length === 3 ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${D}; ++k) {
              a[${z - 1}] = k;
              b[${z - 2}] = k;
              ${R}
          }

          value = value * alpha;
          ${L.length === 3 ? "value += beta * _C(c);" : ""}
          return value;
      }`;
              return Object.assign(Object.assign({}, W), {
                output: {
                  dims: A,
                  type: L[0].type,
                  textureType: U.TextureType.unpacked,
                },
                variables: [
                  { name: "alpha", type: "float", data: H.alpha },
                  { name: "beta", type: "float", data: H.beta },
                ],
                shaderSource: E,
              });
            },
            V = (W, L) => {
              if (!W) throw Error("Input is missing");
              if (L.isOptionalC && (W.length < 2 || W.length > 3))
                throw Error("Invaid input shape.");
              if (!L.isOptionalC && W.length !== 3)
                throw Error("Gemm requires 3 inputs");
              if (
                W.length === 3 &&
                W[2].dims.length !== 1 &&
                W[2].dims.length !== 2
              )
                throw Error("Invalid input shape of C");
              if (
                (W[0].type !== "float32" && W[0].type !== "float64") ||
                (W[1].type !== "float32" && W[1].type !== "float64") ||
                (W.length === 3 &&
                  W[2].type !== "float32" &&
                  W[2].type !== "float64")
              )
                throw Error("Invalid input type.");
              if (
                W[0].type !== W[1].type ||
                (W.length === 3 && W[0].type !== W[2].type)
              )
                throw Error("Input types are mismatched");
            };
        },
        8555: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.createPackedIm2ColProgramInfoLoader = void 0));
          let G = Q(5060),
            J = Q(2039),
            U = Q(2827);
          Y.createPackedIm2ColProgramInfoLoader = ($, B, K, V, W) => {
            let L =
              ((H = W.cacheKey),
              {
                name: "Im2Col (packed)",
                inputNames: ["A"],
                inputTypes: [J.TextureType.packed],
                cacheHint: H,
              });
            var H;
            return Object.assign(Object.assign({}, L), {
              get: () =>
                ((F, N, q, M, A, D) => {
                  let R = q.dims,
                    z = M.dims,
                    E = A.length,
                    O = [z[1] * z[2] * z[3], A[2] * A[3]],
                    Z = z[2] * z[3],
                    j = (0, U.unpackFromChannel)(),
                    w = (0, G.getGlsl)(F.session.backend.glContext.version),
                    I = "";
                  for (let y = 0; y <= 1; y++)
                    for (let _ = 0; _ <= 1; _++)
                      I += `
            blockIndex = rc.x + ${_};
            pos = rc.y + ${y};

            if(blockIndex < ${O[1]} && pos < ${O[0]}) {
              offsetY = int(blockIndex / (${A[E - 1]})) * ${D.strides[0]} -
                ${D.pads[0]};
              d0 = offsetY + ${D.dilations[0]} * (imod(pos, ${Z}) / ${z[2]});

              if(d0 < ${R[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${A[E - 1]}) * ${D.strides[1]} -
                  ${D.pads[1]};
                d1 = offsetX + ${D.dilations[1]} * imod(imod(pos, ${Z}), ${z[2]});

                if(d1 < ${R[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${Z}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * y + _}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
                  let T = `
      ${j}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${I}
          ${w.output} = result;
      }
            `;
                  return Object.assign(Object.assign({}, N), {
                    output: {
                      dims: O,
                      type: q.type,
                      textureType: J.TextureType.packed,
                    },
                    shaderSource: T,
                    hasMain: !0,
                  });
                })($, L, B, K, V, W),
            });
          };
        },
        3248: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.calculateIm2ColDims = Y.createIm2ColProgramInfoLoader = void 0));
          let G = Q(2039);
          ((Y.createIm2ColProgramInfoLoader = (J, U, $, B, K) => {
            let V =
              ((W = K.cacheKey),
              {
                name: "Im2Col",
                inputNames: ["X"],
                inputTypes: [G.TextureType.unpacked],
                cacheHint: W,
              });
            var W;
            return Object.assign(Object.assign({}, V), {
              get: () =>
                ((L, H, F, N, q, M) => {
                  let A = F.dims,
                    D = N.dims,
                    R = q.length,
                    z = (0, Y.calculateIm2ColDims)(A, D, q, 4),
                    E = `
        const int XC = ${A[1]};
        const int XH = ${A[2]};
        const int XW = ${A[3]};
        const int KH = ${M.kernelShape[0]};
        const int KW = ${M.kernelShape[1]};
        const int dilationH = ${M.dilations[0]};
        const int dilationW = ${M.dilations[1]};
        const int strideH = ${M.strides[0]};
        const int strideW = ${M.strides[1]};
        const int padH = ${M.pads[0]};
        const int padW = ${M.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${R}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${A.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
                  return Object.assign(Object.assign({}, H), {
                    output: {
                      dims: z,
                      type: F.type,
                      textureType: G.TextureType.packedLastDimension,
                    },
                    shaderSource: E,
                  });
                })(0, V, U, $, B, K),
            });
          }),
            (Y.calculateIm2ColDims = (J, U, $, B = 4) => [
              $[0],
              $[2],
              $[3],
              Math.ceil((J[1] * U[2] * U[3]) / B),
            ]));
        },
        6572: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseImageScalerAttributes = Y.imageScaler = void 0));
          let G = Q(246),
            J = Q(2039);
          ((Y.imageScaler = (V, W, L) => (K(W), [V.run($(V, W, L), W)])),
            (Y.parseImageScalerAttributes = (V) => {
              let W = V.attributes.getFloat("scale"),
                L = V.attributes.getFloats("bias");
              return (0, G.createAttributeWithCacheKey)({ scale: W, bias: L });
            }));
          let U = {
              name: "ImageScaler",
              inputNames: ["X"],
              inputTypes: [J.TextureType.unpacked],
            },
            $ = (V, W, L) => {
              let H = Object.assign(Object.assign({}, U), {
                cacheHint: L.cacheKey,
              });
              return Object.assign(Object.assign({}, H), {
                get: () =>
                  ((F, N, q, M) => {
                    let A = q[0].dims.slice(),
                      D = A.length,
                      R = `
      ${B(M.bias.length)}
      float process(int indices[${D}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
                    return Object.assign(Object.assign({}, N), {
                      output: {
                        dims: A,
                        type: q[0].type,
                        textureType: J.TextureType.unpacked,
                      },
                      variables: [
                        {
                          name: "bias",
                          type: "float",
                          arrayLength: M.bias.length,
                          data: M.bias,
                        },
                        { name: "scale", type: "float", data: M.scale },
                      ],
                      shaderSource: R,
                    });
                  })(0, H, W, L),
              });
            },
            B = (V) => {
              let W = [`float getBias(float bias[${V}], int channel) {`];
              for (let L = 0; L < V; ++L)
                L === 0
                  ? W.push(`	if (channel == ${L}) { return bias[${L}]; }`)
                  : L === V - 1
                    ? W.push(`	else { return bias[${L}]; }`)
                    : W.push(
                        `	else if (channel == ${L}) { return bias[${L}]; }`
                      );
              return (
                W.push("\t}"),
                W.join(`
`)
              );
            },
            K = (V) => {
              if (!V || V.length !== 1)
                throw Error("ImageScaler requires 1 input.");
              if (V[0].dims.length !== 4) throw Error("Invalid input shape.");
              if (V[0].type !== "float32" && V[0].type !== "float64")
                throw Error("Invalid input type.");
            };
        },
        3346: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseInstanceNormalizationAttributes = Y.instanceNormalization =
              void 0));
          let G = Q(5060),
            J = Q(2039);
          ((Y.instanceNormalization = (W, L, H) => {
            V(L);
            let F = W.run($(L[0]), L);
            return [W.run(K(W, L[0], H, F.dims), [L[0], F, L[1], L[2]])];
          }),
            (Y.parseInstanceNormalizationAttributes = (W) =>
              W.attributes.getFloat("epsilon", 0.00001)));
          let U = {
              name: "InstanceNormalization_MeanAndVariance",
              inputNames: ["X"],
              inputTypes: [J.TextureType.unpacked],
            },
            $ = (W) =>
              Object.assign(Object.assign({}, U), {
                get: () =>
                  ((L, H) => {
                    let F = H.dims.slice(),
                      N = F[1],
                      q = F[2] * F[3],
                      M = [F[0], N],
                      A = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${F[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${F[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${q});
        temp = 0.0;
        for(int a2=0; a2<${F[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${F[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${q});

        return v;
      }`;
                    return Object.assign(Object.assign({}, L), {
                      output: {
                        dims: M,
                        type: H.type,
                        textureType: J.TextureType.packedLastDimension,
                      },
                      shaderSource: A,
                    });
                  })(U, W),
              }),
            B = {
              name: "InstanceNormalization_ComputeOutput",
              inputNames: ["X", "MeanAndVariance", "Scale", "B"],
              inputTypes: [
                J.TextureType.unpacked,
                J.TextureType.packedLastDimension,
                J.TextureType.unpacked,
                J.TextureType.unpacked,
              ],
            },
            K = (W, L, H, F) => {
              let N = Object.assign(Object.assign({}, B), {
                cacheHint: `${H}`,
              });
              return Object.assign(Object.assign({}, N), {
                get: () =>
                  ((q, M, A, D, R) => {
                    let z = (0, G.getGlsl)(q.session.backend.glContext.version),
                      [E, O] = q.calculateTextureWidthAndHeight(
                        R,
                        J.TextureType.packedLastDimension
                      ),
                      [Z, j] = [E / 4, O],
                      w = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${Z}, ${j});
        return ${z.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
                    return Object.assign(Object.assign({}, M), {
                      output: {
                        dims: A.dims,
                        type: A.type,
                        textureType: J.TextureType.unpacked,
                      },
                      variables: [{ name: "epsilon", type: "float", data: D }],
                      shaderSource: w,
                    });
                  })(W, N, L, H, F),
              });
            },
            V = (W) => {
              if (!W || W.length !== 3)
                throw Error("InstanceNormalization requires 3 inputs.");
              let L = W[0],
                H = W[1],
                F = W[2];
              if (
                L.dims.length < 3 ||
                H.dims.length !== 1 ||
                F.dims.length !== 1
              )
                throw Error("Invalid input shape.");
              if (H.dims[0] !== L.dims[1] || F.dims[0] !== L.dims[1])
                throw Error("Input shapes are mismatched.");
              if (
                (L.type !== "float32" && L.type !== "float64") ||
                (H.type !== "float32" && H.type !== "float64") ||
                (F.type !== "float32" && F.type !== "float64")
              )
                throw Error("Invalid input type.");
              if (W[0].dims.length !== 4)
                throw Error("Only support 4-D input shape.");
            };
        },
        708: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.createPackedMatmulProgramInfoLoader = void 0));
          let G = Q(2517),
            J = Q(5060),
            U = Q(2039),
            $ = Q(9390),
            B = Q(2823),
            K = Q(5623);
          Y.createPackedMatmulProgramInfoLoader = (V, W, L) => {
            let H =
              ((F = W.length > 2),
              (N = L.activationCacheKey),
              {
                name: "MatMul (packed)",
                inputNames: F ? ["A", "B", "Bias"] : ["A", "B"],
                inputTypes: F
                  ? [
                      U.TextureType.packed,
                      U.TextureType.packed,
                      U.TextureType.packed,
                    ]
                  : [U.TextureType.packed, U.TextureType.packed],
                cacheHint: N,
              });
            var F, N;
            return Object.assign(Object.assign({}, H), {
              get: () =>
                ((q, M, A, D) => {
                  let R = A.length > 2,
                    z = R ? "value += getBiasForMatmul();" : "",
                    E = A[0].dims,
                    O = A[1].dims,
                    Z = G.BroadcastUtil.calcShape(E, O, !0),
                    j = !G.ShapeUtil.areEqual(A[0].dims, A[1].dims);
                  if (!Z) throw Error("Can't use matmul on the given tensors");
                  let w = E[E.length - 1],
                    I = Math.ceil(w / 2),
                    T = E.length,
                    y = O.length,
                    _ = (0, J.getGlsl)(q.session.backend.glContext.version),
                    f = (0, $.getCoordsDataType)(Z.length),
                    l = Z.length,
                    h = (0, $.getGlChannels)(),
                    { activationFunction: p, applyActivation: N0 } = (0,
                    B.getActivationSnippet)(D),
                    e = R
                      ? `${(0, K.getBiasForMatmul)(f, h, A[2].dims, Z, !0)}`
                      : "",
                    P = j
                      ? `${(function (v, k, o, J0) {
                          let z0 = [],
                            A0 = [],
                            w0 = o[0].dims,
                            Y1 = o[1].dims,
                            b = w0.length,
                            m = Y1.length,
                            n = J0.length,
                            M0 = n - b,
                            D0 = n - m;
                          ((z0 = w0.map((x0, h1) => `coords.${k[h1 + M0]}`)),
                            (z0[b - 1] = "i*2"),
                            z0.join(", "),
                            (A0 = Y1.map((x0, h1) => `coords.${k[h1 + D0]}`)),
                            (A0[m - 2] = "i*2"),
                            A0.join(", "));
                          let Z0 = G.BroadcastUtil.getBroadcastDims(w0, J0),
                            B1 = G.BroadcastUtil.getBroadcastDims(Y1, J0),
                            j1 = Z0.map((x0) => `coords.${k[x0 + M0]} = 0;`)
                              .join(`
`),
                            v1 = B1.map((x0) => `coords.${k[x0 + D0]} = 0;`)
                              .join(`
`),
                            M1 = `int lastDim = coords.${k[n - 1]};
  coords.${k[n - 1]} = coords.${k[n - 2]};
  coords.${k[n - 2]} = lastDim;`;
                          return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${v} coords = getOutputCoords();
  ${M1}
  ${j1}
  vec4 outputValue = getA(${z0});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${v} coords = getOutputCoords();
  ${M1}
  ${v1}
  vec4 outputValue = getB(${A0});
  return outputValue;
}`;
                        })(f, h, A, Z)}`
                      : "",
                    x = j
                      ? "getAAtOutCoordsMatmul(i)"
                      : `getA(${(function (v, k) {
                          let o = "";
                          for (let J0 = 0; J0 < k - 2; J0++)
                            o += `rc.${v[J0]}, `;
                          return ((o += `rc.${v[k - 2]}, i*2`), o);
                        })(h, T)})`,
                    r = j
                      ? "getBAtOutCoordsMatmul(i)"
                      : `getB(${(function (v, k) {
                          let o = "";
                          for (let J0 = 0; J0 < k - 2; J0++)
                            o += `rc.${v[J0]}, `;
                          return ((o += `i*2, rc.${v[k - 1]}`), o);
                        })(h, y)})`,
                    C = `
            ${P}
            ${e}
            ${p}
            void main() {
              ${
                j
                  ? ""
                  : `${f} rc =
          getOutputCoords(); int lastDim = rc.${h[l - 1]}; rc.${h[l - 1]} =
          rc.${h[l - 2]}; rc.${h[l - 2]} = lastDim;
      `
              }

              vec4 value = vec4(0);
              for (int i = 0; i < ${I}; i++) {
                vec4 a = ${x};
                vec4 b = ${r};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${z}
              ${N0}
              ${_.output} = value;
            }`;
                  return Object.assign(Object.assign({}, M), {
                    output: {
                      dims: Z,
                      type: A[0].type,
                      textureType: U.TextureType.packed,
                    },
                    shaderSource: C,
                    hasMain: !0,
                  });
                })(V, H, W, L),
            });
          };
        },
        5623: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.getBiasForMatmul =
              Y.createMatmulProgramInfoLoader =
              Y.parseMatMulAttributes =
              Y.matMul =
                void 0));
          let G = Q(2517),
            J = Q(2039),
            U = Q(9390),
            $ = Q(2823),
            B = Q(708);
          function K(L, H) {
            let F =
              ((N = L.length > 2),
              (q = H.activationCacheKey),
              {
                name: "MatMul",
                inputNames: N ? ["A", "B", "Bias"] : ["A", "B"],
                inputTypes: N
                  ? [
                      J.TextureType.unpacked,
                      J.TextureType.unpacked,
                      J.TextureType.unpacked,
                    ]
                  : [J.TextureType.unpacked, J.TextureType.unpacked],
                cacheHint: q,
              });
            var N, q;
            return Object.assign(Object.assign({}, F), {
              get: () =>
                (function (M, A, D) {
                  let R = A[0].dims,
                    z = A[1].dims,
                    E = G.BroadcastUtil.calcShape(R, z, !0);
                  if (!E) throw Error("Can't use matmul on the given tensors");
                  let O = (0, U.getCoordsDataType)(E.length),
                    Z = (0, U.getGlChannels)(),
                    { activationFunction: j, applyActivation: w } = (0,
                    $.getActivationSnippet)(D),
                    I = A.length > 2,
                    T = I ? "value += getBiasForMatmul();" : "",
                    y = I ? `${W(O, Z, A[2].dims, E, !1)}` : "",
                    _ = E.length,
                    f = R.length,
                    l = z.length,
                    h = `
    ${j}
    ${y}
    float process(int indices[${_}]) {
        int a[${f}];
        int b[${l}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${R[R.length - 1]}; ++k) {
            a[${f - 1}] = k;
            b[${l - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${T}
        ${w}
        return value;
    }`;
                  return Object.assign(Object.assign({}, M), {
                    output: {
                      dims: E,
                      type: A[0].type,
                      textureType: J.TextureType.unpacked,
                    },
                    shaderSource: h,
                  });
                })(F, L, H),
            });
          }
          ((Y.matMul = (L, H, F) => (
            V(H),
            L.session.pack
              ? [L.run((0, B.createPackedMatmulProgramInfoLoader)(L, H, F), H)]
              : [L.run(K(H, F), H)]
          )),
            (Y.parseMatMulAttributes = (L) =>
              (0, $.parseInternalActivationAttributes)(L.attributes)),
            (Y.createMatmulProgramInfoLoader = K));
          let V = (L) => {
            if (!L || L.length !== 2) throw Error("MatMul requires 2 inputs.");
            if (
              L[0].dims[L[0].dims.length - 1] !==
              L[1].dims[L[1].dims.length - 2]
            )
              throw Error("shared dimension does not match.");
            if (
              (L[0].type !== "float32" && L[0].type !== "float64") ||
              (L[1].type !== "float32" && L[1].type !== "float64")
            )
              throw Error("inputs should be float type");
            if (L[0].type !== L[1].type)
              throw Error("inputs types should match");
          };
          function W(L, H, F, N, q) {
            let M = "",
              A = F.length,
              D = N.length,
              R = D - A;
            M =
              D < 2 && A > 0
                ? "coords"
                : F.map((O, Z) => `coords.${H[Z + R]}`).join(", ");
            let z = G.BroadcastUtil.getBroadcastDims(F, N).map(
                (O) => `coords.${H[O + R]} = 0;`
              ).join(`
`),
              E = "vec4(outputValue.xx, outputValue.yy)";
            return (
              G.ShapeUtil.size(F) === 1 && (E = "vec4(outputValue.x)"),
              q
                ? `
vec4 getBiasForMatmul() {
  ${L} coords = getOutputCoords();
  ${z}
  vec4 outputValue = getBias(${M});
  return ${E};
}`
                : `
float getBiasForMatmul() {
  ${L} coords = getOutputCoords();
  ${z}
  return getBias(coords.x);
}`
            );
          }
          Y.getBiasForMatmul = W;
        },
        2403: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.createPackProgramInfoLoader = void 0));
          let G = Q(5060),
            J = Q(2039),
            U = Q(9390),
            $ = Q(2827),
            B = {
              name: "pack",
              inputNames: ["A"],
              inputTypes: [J.TextureType.unpackedReversed],
            };
          Y.createPackProgramInfoLoader = (K, V) =>
            Object.assign(Object.assign({}, B), {
              get: () =>
                ((W, L) => {
                  let H = (0, G.getGlsl)(W.session.backend.glContext.version),
                    F = L.dims,
                    N = F.length,
                    q = L.dims.length,
                    M = (0, U.getCoordsDataType)(q),
                    A = (0, $.getChannels)("rc", q),
                    D =
                      ((R = q),
                      (z = A),
                      (E = F[F.length - 2]),
                      (O = F[F.length - 1]),
                      R === 0 || R === 1
                        ? ""
                        : `
    int r = ${z[R - 2]};
    int c = ${z[R - 1]};
    int rp1 = ${z[R - 2]} + 1;
    int cp1 = ${z[R - 1]} + 1;
    bool rEdge = rp1 >= ${O};
    bool cEdge = cp1 >= ${E};
    `);
                  var R, z, E, O;
                  let Z;
                  Z =
                    N === 0
                      ? [1, 1]
                      : N === 1
                        ? [F[0], 1]
                        : [F[q - 1], F[q - 2]];
                  let j = (function (T, y, _) {
                      if (T === 0) return "false";
                      if (T === 1) return `rc > ${y[0]}`;
                      let f = "";
                      for (let l = T - 2; l < T; l++)
                        ((f += `${_[l]} >= ${y[l - T + 2]}`),
                          l < T - 1 && (f += "||"));
                      return f;
                    })(q, Z, A),
                    w = (function (T, y) {
                      let _ = T.length;
                      if (_ === 0) return "getA(), 0, 0, 0";
                      if (_ === 1)
                        return `getA(rc),
            rc + 1 >= ${T[0]} ? 0. : getA(rc + 1),
            0, 0`;
                      let f = "";
                      if (_ > 2)
                        for (let l = 0; l < _ - 2; ++l) f += `${y[l]},`;
                      return `getA(${f}r, c),
          rEdge ? 0. : getA(${f}rp1, c),
          cEdge ? 0. : getA(${f}r, cp1),
          rEdge || cEdge ? 0. : getA(${f}rp1, cp1)`;
                    })(F, A),
                    I = `
        void main() {
          ${M} rc = getOutputCoords();

          if(${j}) {
            ${H.output} = vec4(0);
          } else {
            ${D}

            ${H.output} = vec4(${w});
          }
        }
      `;
                  return Object.assign(Object.assign({}, B), {
                    hasMain: !0,
                    output: {
                      dims: L.dims,
                      type: L.type,
                      textureType: J.TextureType.packed,
                    },
                    shaderSource: I,
                  });
                })(K, V),
            });
        },
        2827: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.unpackFromChannel = Y.getChannels = Y.getVecChannels = void 0));
          let G = Q(9390);
          function J(U, $) {
            return (0, G.getGlChannels)($).map((B) => `${U}.${B}`);
          }
          ((Y.getVecChannels = J),
            (Y.getChannels = function (U, $) {
              return $ === 1 ? [U] : J(U, $);
            }),
            (Y.unpackFromChannel = function () {
              return `
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `;
            }));
        },
        2870: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parsePadAttributesV11 =
              Y.padV11 =
              Y.parsePadAttributesV2 =
              Y.padV2 =
                void 0));
          let G = Q(246),
            J = Q(2517),
            U = Q(5060),
            $ = Q(2039),
            B = {
              name: "Pad",
              inputNames: ["A"],
              inputTypes: [$.TextureType.unpacked],
            };
          ((Y.padV2 = (M, A, D) => (
            W(A),
            [
              M.run(
                Object.assign(Object.assign({}, B), {
                  cacheHint: D.cacheKey,
                  get: () => V(M, A[0], D),
                }),
                A
              ),
            ]
          )),
            (Y.parsePadAttributesV2 = (M) => {
              let A = M.attributes.getString("mode", "constant"),
                D = M.attributes.getFloat("value", 0),
                R = M.attributes.getInts("pads");
              return (0, G.createAttributeWithCacheKey)({
                mode: A,
                value: D,
                pads: R,
              });
            }),
            (Y.padV11 = (M, A, D) => {
              L(A);
              let R = K(M, A, D);
              return (0, Y.padV2)(M, [A[0]], R);
            }),
            (Y.parsePadAttributesV11 = (M) =>
              M.attributes.getString("mode", "constant")));
          let K = (M, A, D) => {
              if (
                !M.session.isInitializer(A[1].dataId) ||
                (A.length >= 3 && !M.session.isInitializer(A[2].dataId))
              )
                throw Error("dynamic pad attributes are not allowed");
              let R = Array.from(A[1].integerData),
                z = A.length >= 3 ? A[2].floatData[0] : 0;
              return (0, G.createAttributeWithCacheKey)({
                mode: D,
                pads: R,
                value: z,
              });
            },
            V = (M, A, D) => {
              let R = J.ShapeUtil.padShape(A.dims.slice(), D.pads),
                z = R.length,
                E = `
      ${H(M, A, D)}
      float process(int[${z}] indices) {
          return padA(indices);
      }`;
              return {
                name: "Pad",
                inputNames: ["A"],
                inputTypes: [$.TextureType.unpacked],
                output: {
                  dims: R,
                  type: A.type,
                  textureType: $.TextureType.unpacked,
                },
                shaderSource: E,
              };
            },
            W = (M) => {
              if (!M || M.length !== 1) throw Error("Pad requires 1 input");
              if (M[0].type !== "float32" && M[0].type !== "float64")
                throw Error("Invalid input type.");
            },
            L = (M) => {
              if (!M || (M.length !== 2 && M.length !== 3))
                throw Error("Pad requires 2 or 3 inputs");
              if (M[1].type !== "int32") throw Error("Invalid input type.");
              if (M.length >= 3 && M[2].type === "string")
                throw Error("Invalid input type.");
            },
            H = (M, A, D) => {
              let R = (0, U.getGlsl)(M.session.backend.glContext.version),
                [z, E] = M.calculateTextureWidthAndHeight(
                  A.dims,
                  $.TextureType.unpacked
                ),
                O = J.ShapeUtil.computeStrides(A.dims);
              switch (D.mode) {
                case "constant":
                  return F(R, A.dims, O, z, E, D.pads, D.value);
                case "reflect":
                  return N(R, A.dims, O, z, E, D.pads);
                case "edge":
                  return q(R, A.dims, O, z, E, D.pads);
                default:
                  throw Error("Invalid mode");
              }
            },
            F = (M, A, D, R, z, E, O) => {
              let Z = A.length,
                j = "";
              for (let w = Z - 1; w >= 0; --w)
                j += `
        k = m[${w}] - ${E[w]};
        if (k < 0)  return constant;
        if (k >= ${A[w]}) return constant;
        offset += k * ${D[w]};
        `;
              return `
      float padA(int m[${Z}]) {
        const float constant = float(${O});
        int offset = 0;
        int k = 0;
        ${j}
        vec2 coords = offsetToCoords(offset, ${R}, ${z});
        float value = getColorAsFloat(${M.texture2D}(A, coords));
        return value;
      }
      `;
            },
            N = (M, A, D, R, z, E) => {
              let O = A.length,
                Z = "";
              for (let j = O - 1; j >= 0; --j)
                Z += `
        k = m[${j}] - ${E[j]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (A[j] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${A[j]}) { k = _2n_1 - k; }
        }
        offset += k * ${D[j]};
        `;
              return `
      float padA(int m[${O}]) {
        int offset = 0;
        int k = 0;
        ${Z}
        vec2 coords = offsetToCoords(offset, ${R}, ${z});
        float value = getColorAsFloat(${M.texture2D}(A, coords));
        return value;
      }
      `;
            },
            q = (M, A, D, R, z, E) => {
              let O = A.length,
                Z = "";
              for (let j = O - 1; j >= 0; --j)
                Z += `
        k = m[${j}] - ${E[j]};
        if (k < 0)  k = 0;
        if (k >= ${A[j]}) k = ${A[j] - 1};
        offset += k * ${D[j]};
      `;
              return `
      float padA(int m[${O}]) {
        int offset = 0;
        int k = 0;
        ${Z}
        vec2 coords = offsetToCoords(offset, ${R}, ${z});
        float value = getColorAsFloat(${M.texture2D}(A, coords));
        return value;
      }
      `;
            };
        },
        2143: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.globalMaxPool =
              Y.parseMaxPoolAttributes =
              Y.maxPool =
              Y.parseGlobalAveragePoolAttributes =
              Y.globalAveragePool =
              Y.parseAveragePoolAttributes =
              Y.averagePool =
                void 0));
          let G = Q(246),
            J = Q(2517),
            U = Q(2039);
          ((Y.averagePool = (q, M, A) => {
            L(M);
            let D = {
              name: "AveragePool",
              inputNames: ["X"],
              inputTypes: [U.TextureType.unpacked],
              cacheHint: A.cacheKey,
            };
            return [
              q.run(
                Object.assign(Object.assign({}, D), {
                  get: () => $(M, D, !1, A),
                }),
                M
              ),
            ];
          }),
            (Y.parseAveragePoolAttributes = (q) => {
              let M = q.attributes.getString("auto_pad", "NOTSET"),
                A = q.attributes.getInt("ceil_mode", 0),
                D = q.attributes.getInt("count_include_pad", 0) !== 0,
                R = q.attributes.getInts("kernel_shape"),
                z = q.attributes.getInts("strides", []),
                E = q.attributes.getInts("pads", []);
              if (A !== 0)
                throw Error(
                  "using ceil() in shape computation is not yet supported for AveragePool"
                );
              return (0, G.createAttributeWithCacheKey)({
                autoPad: M,
                ceilMode: A,
                countIncludePad: D,
                kernelShape: R,
                strides: z,
                pads: E,
              });
            }));
          let $ = (q, M, A, D) => {
            let [R, z] = K(q, D, A),
              E = J.ShapeUtil.size(R.kernelShape),
              O = "";
            R.countIncludePad
              ? (O += `value /= float(${E});`)
              : (O += `value /= float(${E} - pad);`);
            let Z = `
        ${H(q[0].dims, R, "value += _X(x);", O, "0.0")}
      `;
            return Object.assign(Object.assign({}, M), {
              output: {
                dims: z,
                type: q[0].type,
                textureType: U.TextureType.unpacked,
              },
              shaderSource: Z,
            });
          };
          ((Y.globalAveragePool = (q, M, A) => {
            L(M);
            let D = {
              name: "GlobalAveragePool",
              inputNames: ["X"],
              inputTypes: [U.TextureType.unpacked],
              cacheHint: `${A.countIncludePad}`,
            };
            return [
              q.run(
                Object.assign(Object.assign({}, D), {
                  get: () => $(M, D, !0, A),
                }),
                M
              ),
            ];
          }),
            (Y.parseGlobalAveragePoolAttributes = (q) => {
              let M = q.attributes.getInt("count_include_pad", 0) !== 0;
              return (0, G.createAttributeWithCacheKey)({
                autoPad: "",
                ceilMode: 0,
                countIncludePad: M,
                kernelShape: [],
                strides: [],
                pads: [],
              });
            }),
            (Y.maxPool = (q, M, A) => {
              L(M);
              let D = {
                name: "MaxPool",
                inputNames: ["X"],
                inputTypes: [U.TextureType.unpacked],
                cacheHint: A.cacheKey,
              };
              return [
                q.run(
                  Object.assign(Object.assign({}, D), {
                    get: () => B(M, D, !1, A),
                  }),
                  M
                ),
              ];
            }),
            (Y.parseMaxPoolAttributes = (q) => {
              let M = q.attributes.getString("auto_pad", "NOTSET"),
                A = q.attributes.getInt("ceil_mode", 0),
                D = q.attributes.getInts("kernel_shape"),
                R = q.attributes.getInts("strides", []),
                z = q.attributes.getInts("pads", []),
                E = q.attributes.getInt("storage_order", 0),
                O = q.attributes.getInts("dilations", []);
              if (E !== 0)
                throw Error(
                  "column major storage order is not yet supported for MaxPool"
                );
              if (A !== 0)
                throw Error(
                  "using ceil() in shape computation is not yet supported for MaxPool"
                );
              return (0, G.createAttributeWithCacheKey)({
                autoPad: M,
                ceilMode: A,
                countIncludePad: !1,
                kernelShape: D,
                strides: R,
                pads: z,
                storageOrder: E,
                dilations: O,
              });
            }));
          let B = (q, M, A, D) => {
              let [R, z] = K(q, D, A),
                E = `
      ${H(
        q[0].dims,
        R,
        `
      value = max(_X(x), value);
    `,
        "",
        "-1e5"
      )}
    `;
              return Object.assign(Object.assign({}, M), {
                output: {
                  dims: z,
                  type: q[0].type,
                  textureType: U.TextureType.unpacked,
                },
                shaderSource: E,
              });
            },
            K = (q, M, A) => {
              let D = q[0].dims.slice(),
                R = Object.hasOwnProperty.call(M, "dilations"),
                z = M.kernelShape.slice(),
                E = M.strides.slice(),
                O = R ? M.dilations.slice() : [],
                Z = M.pads.slice();
              J.PoolConvUtil.adjustPoolAttributes(A, D, z, E, O, Z);
              let j = J.PoolConvUtil.computePoolOutputShape(
                  A,
                  D,
                  E,
                  O,
                  z,
                  Z,
                  M.autoPad
                ),
                w = Object.assign({}, M);
              return (
                R
                  ? Object.assign(w, {
                      kernelShape: z,
                      strides: E,
                      pads: Z,
                      dilations: O,
                      cacheKey: M.cacheKey,
                    })
                  : Object.assign(w, {
                      kernelShape: z,
                      strides: E,
                      pads: Z,
                      cacheKey: M.cacheKey,
                    }),
                [w, j]
              );
            },
            V = {
              autoPad: "",
              ceilMode: 0,
              countIncludePad: !1,
              kernelShape: [],
              strides: [],
              pads: [],
              storageOrder: 0,
              dilations: [],
              cacheKey: "",
            },
            W = {
              name: "GlobalMaxPool",
              inputNames: ["X"],
              inputTypes: [U.TextureType.unpacked],
            };
          Y.globalMaxPool = (q, M) => (
            L(M),
            [
              q.run(
                Object.assign(Object.assign({}, W), {
                  get: () => B(M, W, !0, V),
                }),
                M
              ),
            ]
          );
          let L = (q) => {
              if (!q || q.length !== 1)
                throw Error("Pool ops requires 1 input.");
              if (q[0].type !== "float32" && q[0].type !== "float64")
                throw Error("Invalid input type.");
            },
            H = (q, M, A, D, R) => {
              let z = q.length;
              if (M.kernelShape.length <= 2) {
                let E = M.kernelShape[M.kernelShape.length - 1],
                  O = M.strides[M.strides.length - 1],
                  Z = M.pads[M.pads.length / 2 - 1],
                  j = M.pads[M.pads.length - 1],
                  w = q[z - 1],
                  I = "",
                  T = "",
                  y = "";
                if (
                  ((I =
                    Z + j !== 0
                      ? `
          for (int i = 0; i < ${E}; i++) {
            x[${z} - 1] = indices[${z} - 1] * ${O} - ${Z} + i;
            if (x[${z} - 1] < 0 || x[${z} - 1] >= ${w}) {
              pad++;
              continue;
            }
            ${A}
          }`
                      : `
          for (int i = 0; i < ${E}; i++) {
            x[${z} - 1] = indices[${z} - 1] * ${O} - ${Z} + i;
            ${A}
          }`),
                  M.kernelShape.length === 2)
                ) {
                  let _ = M.kernelShape[M.kernelShape.length - 2],
                    f = M.strides[M.strides.length - 2],
                    l = M.pads[M.pads.length / 2 - 2],
                    h = M.pads[M.pads.length - 2],
                    p = q[z - 2];
                  ((T =
                    l + h !== 0
                      ? `
            for (int j = 0; j < ${_}; j++) {
              x[${z} - 2] = indices[${z} - 2] * ${f} - ${l} + j;
              if (x[${z} - 2] < 0 || x[${z} - 2] >= ${p}) {
                pad+= ${E};
                continue;
              }
          `
                      : `
            for (int j = 0; j < ${_}; j++) {
              x[${z} - 2] = indices[${z} - 2] * ${f} - ${l} + j;
            `),
                    (y = `
          }
        `));
                }
                return `
        float process(int indices[${z}]) {
          int x[${z}];
          copyVec(indices, x);

          float value = ${R};
          int pad = 0;
          ${T}
          ${I}
          ${y}
          ${D}
          return value;
        }
      `;
              }
              {
                let E = J.ShapeUtil.size(M.kernelShape),
                  O = J.ShapeUtil.computeStrides(M.kernelShape),
                  Z = O.length,
                  j = M.pads.length,
                  w = N(Z),
                  I = F(q, "inputDims"),
                  T = F(M.pads, "pads"),
                  y = F(O, "kernelStrides"),
                  _ = F(M.strides, "strides"),
                  f = "";
                return (
                  (f = M.pads.reduce((l, h) => l + h)
                    ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${A}
          }`
                    : `
          }
          ${A}
        `),
                  `
        ${w}
        float process(int indices[${z}]) {
          int x[${z}];
          copyVec(indices, x);
          int offset[${Z}];
          int pads[${j}];
          int inputDims[${z}];
          int kernelStrides[${Z}];
          int strides[${Z}];
          ${T}
          ${I}
          ${_}
          ${y}

          float value = ${R};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${E}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${z} - ${Z}; j < ${z}; j++) {
              x[j] = indices[j] * strides[j - ${z} + ${Z}]
                + offset[j - ${z} + ${Z}] - pads[j - 2];
              ${f}
          }
          ${D}

          return value;
        }
      `
                );
              }
            },
            F = (q, M) => {
              let A = "";
              for (let D = 0; D < q.length; D++)
                A += `
      ${M}[${D}] = ${q[D]};
    `;
              return A;
            },
            N = (q) => `
  void offsetToIndices(int offset, int[${q}] strides, out int[${q}] indices) {
    if (${q} == 0) {
      return;
    }
    for (int i = 0; i < ${q} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${q} - 1] = offset;
  }`;
        },
        4939: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.reduceLogSumSquare =
              Y.reduceLogSum =
              Y.reduceProd =
              Y.reduceMin =
              Y.reduceMax =
              Y.reduceMean =
              Y.reduceSum =
              Y.parseReduceAttributes =
                void 0));
          let G = Q(246),
            J = Q(782),
            U = Q(2517),
            $ = Q(2039),
            B = (W, L, H, F, N) => {
              V(L);
              let q = {
                name: F,
                inputNames: ["A"],
                inputTypes: [$.TextureType.unpacked],
              };
              return [
                W.run(
                  Object.assign(Object.assign({}, q), {
                    cacheHint: H.cacheKey,
                    get: () => K(W, L, H, F, N, q),
                  }),
                  L
                ),
              ];
            };
          Y.parseReduceAttributes = (W) => {
            let L = W.attributes.getInts("axes", []),
              H = W.attributes.getInt("keepdims", 1) === 1;
            return (0, G.createAttributeWithCacheKey)({ axes: L, keepDims: H });
          };
          let K = (W, L, H, F, N, q) => {
              let M = [],
                A = L[0].dims.length || 1,
                D = [],
                R = U.ShapeUtil.normalizeAxes(H.axes, L[0].dims.length),
                z = N(L, R),
                E = z[1];
              for (let Z = 0; Z < L[0].dims.length; Z++)
                R.indexOf(Z) >= 0 || R.length === 0
                  ? (H.keepDims && M.push(1),
                    (E = `
          for(int j${Z} = 0; j${Z} < ${L[0].dims[Z]}; j${Z}++) {
            inputIdx[${Z}] = j${Z};
            ${E}
          }`))
                  : (D.push(`inputIdx[${Z}] = outputIdx[${M.length}];`),
                    M.push(L[0].dims[Z]));
              let O = `
      float process(int outputIdx[${M.length || 1}]) {
        float value;                 // final result
        int inputIdx[${A}];      // addressing input data
        ${D.join(`
`)}
        ${z[0]}       // init ops for reduce max/min
        ${E}
        ${z[2]}       // final computation for reduce mean
        return value;
      }`;
              return Object.assign(Object.assign({}, q), {
                output: {
                  dims: M,
                  type: L[0].type,
                  textureType: $.TextureType.unpacked,
                },
                shaderSource: O,
              });
            },
            V = (W) => {
              if (!W || W.length !== 1)
                throw Error("Reduce op requires 1 input.");
              if (J.NUMBER_TYPES.indexOf(W[0].type) === -1)
                throw Error("Invalid input type.");
            };
          ((Y.reduceSum = (W, L, H) =>
            B(W, L, H, "ReduceSum", () => [
              "value = 0.0;",
              "value += _A(inputIdx);",
              "",
            ])),
            (Y.reduceMean = (W, L, H) =>
              B(W, L, H, "ReduceMean", (F, N) => {
                let q = 1;
                for (let M = 0; M < F[0].dims.length; M++)
                  (N.indexOf(M) >= 0 || N.length === 0) && (q *= F[0].dims[M]);
                return [
                  "value = 0.0;",
                  "value += _A(inputIdx);",
                  `value /= ${q}.;`,
                ];
              })),
            (Y.reduceMax = (W, L, H) =>
              B(W, L, H, "ReduceMax", (F, N) => {
                let q = [];
                for (let M = 0; M < F[0].dims.length; M++)
                  (N.indexOf(M) >= 0 || N.length === 0) &&
                    q.push(`inputIdx[${M}] = 0;`);
                return [
                  `${q.join(`
`)}
value = _A(inputIdx);`,
                  "value = max(value, _A(inputIdx));",
                  "",
                ];
              })),
            (Y.reduceMin = (W, L, H) =>
              B(W, L, H, "ReduceMin", (F, N) => {
                let q = [];
                for (let M = 0; M < F[0].dims.length; M++)
                  (N.indexOf(M) >= 0 || N.length === 0) &&
                    q.push(`inputIdx[${M}] = 0;`);
                return [
                  `${q.join(`
`)}
value = _A(inputIdx);`,
                  "value = min(value, _A(inputIdx));",
                  "",
                ];
              })),
            (Y.reduceProd = (W, L, H) =>
              B(W, L, H, "ReduceProd", () => [
                "value = 1.0;",
                "value *= _A(inputIdx);",
                "",
              ])),
            (Y.reduceLogSum = (W, L, H) =>
              B(W, L, H, "ReduceLogSum", () => [
                "value = 0.0;",
                "value += _A(inputIdx);",
                "value = log(value);",
              ])),
            (Y.reduceLogSumSquare = (W, L, H) =>
              B(W, L, H, "ReduceLogSumSquare", () => [
                "float t; value = 0.0;",
                "t = _A(inputIdx); value += t * t;",
                "",
              ])));
        },
        7019: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.isReshapeCheap =
              Y.processDims3D =
              Y.createPackedReshape3DProgramInfoLoader =
                void 0));
          let G = Q(2517),
            J = Q(5060),
            U = Q(2039),
            $ = Q(2827);
          ((Y.createPackedReshape3DProgramInfoLoader = (B, K, V) => {
            let W = ((L) => ({
              name: "Reshape (packed)",
              inputTypes: [U.TextureType.packed],
              inputNames: ["A"],
              cacheHint: `${L}`,
            }))(V);
            return Object.assign(Object.assign({}, W), {
              get: () =>
                ((L, H, F, N) => {
                  let q = H.dims,
                    M = N,
                    A = "";
                  for (let z = 0; z < 4; z++) {
                    let E = "";
                    switch (z) {
                      case 0:
                        E = "outputCoords = rc;";
                        break;
                      case 1:
                        E = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                        break;
                      case 2:
                        E = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                        break;
                      case 3:
                        E = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                        break;
                      default:
                        throw Error();
                    }
                    A += `
        ${E}
        ${z > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${z}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${z > 0 ? "}" : ""}
      `;
                  }
                  let D = (0, J.getGlsl)(L.session.backend.glContext.version),
                    R = `
      ${(function (z) {
        let E = G.ShapeUtil.computeStrides(z),
          O = ["b", "r", "c"];
        return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${E.map((w, I) => `int ${O[I]} = index / ${w}; ${I === E.length - 1 ? `int ${O[I + 1]} = index - ${O[I]} * ${w}` : `index -= ${O[I]} * ${w}`};`).join("")}
      return ivec3(b, r, c);
    }
  `;
      })(q)}
      ${(function (z) {
        let E = G.ShapeUtil.computeStrides(z);
        return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${E[0]} + coords.z * ${E[1]} + coords.y;
  }
`;
      })(M)}
      ${(0, $.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${M[2]};
        int cols = ${M[1]};

        ${A}
        ${D.output} = result;
      }
    `;
                  return Object.assign(Object.assign({}, F), {
                    output: {
                      dims: M,
                      type: H.type,
                      textureType: U.TextureType.packed,
                    },
                    shaderSource: R,
                    hasMain: !0,
                  });
                })(B, K, W, V),
            });
          }),
            (Y.processDims3D = function (B) {
              if (B.length === 0) return [1, 1, 1];
              let K = 1;
              for (let V = 0; V < B.length - 2; ++V) K *= B[V];
              return [K, B.length > 1 ? B[B.length - 2] : 1, B[B.length - 1]];
            }),
            (Y.isReshapeCheap = function (B, K) {
              let V = !1;
              return (
                (V =
                  B.length === 0 ||
                  K.length === 0 ||
                  (B.length < 2 || K.length < 2
                    ? B[B.length - 1] === K[K.length - 1]
                    : B[B.length - 1] === K[K.length - 1] &&
                      B[B.length - 2] === K[K.length - 2])),
                V
              );
            }));
        },
        718: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.reshape = void 0));
          let G = Q(2517);
          Y.reshape = (J, U) => {
            let $ = G.ShapeUtil.calculateReshapedDims(
              U[0].dims,
              U[1].integerData
            );
            return J.session.pack
              ? [J.reshapePacked(U[0], $)]
              : [J.reshapeUnpacked(U[0], $)];
          };
        },
        2268: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseResizeAttributesV11 =
              Y.parseResizeAttributesV10 =
              Y.resize =
                void 0));
          let G = Q(5060),
            J = Q(2039),
            U = Q(9390),
            $ = Q(2827),
            B = Q(9793),
            K = {
              name: "Resize",
              inputNames: ["A"],
              inputTypes: [J.TextureType.packed],
            };
          ((Y.resize = (F, N, q) => (
            (0, B.validateInputs)(N, q),
            [
              F.run(
                Object.assign(Object.assign({}, K), {
                  cacheHint: q.cacheKey,
                  get: () => V(F, N, q),
                }),
                N
              ),
            ]
          )),
            (Y.parseResizeAttributesV10 = (F) =>
              (0, B.parseUpsampleAttributes)(F, 10)),
            (Y.parseResizeAttributesV11 = (F) =>
              (0, B.parseUpsampleAttributes)(F, 11)));
          let V = (F, N, q) => {
              let M = (0, G.getGlsl)(F.session.backend.glContext.version),
                [A, D] = W(N, q);
              if (
                A.every((f) => f === 1) &&
                q.coordinateTransformMode !== "tf_crop_and_resize"
              )
                return Object.assign(Object.assign({}, K), {
                  output: {
                    dims: D,
                    type: N[0].type,
                    textureType: J.TextureType.packed,
                  },
                  hasMain: !0,
                  shaderSource: `void main() {
                    vec4 v = ${M.texture2D}(X, TexCoords);
                    ${M.output} = v;
                }`,
                });
              let R = D.length;
              if (R < 2)
                throw Error(
                  `output dimension should be at least 2, but got ${R}`
                );
              let z = D[R - 2],
                E = D[R - 1],
                O = N[0].dims;
              if (R !== O.length)
                throw Error(
                  `output dimension should match input ${O.length}, but got ${R}`
                );
              let Z = O[R - 2],
                j = O[R - 1],
                w = A[R - 2],
                I = A[R - 1],
                T = "";
              if (q.mode !== "linear")
                throw Error(
                  `resize (packed) does not support mode: '${q.mode}'`
                );
              switch (q.coordinateTransformMode) {
                case "asymmetric":
                  T = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;
                  break;
                case "half_pixel":
                  T = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;
                  break;
                case "pytorch_half_pixel":
                  T = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${E}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${z}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${E}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${z}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
                  break;
                case "align_corners":
                  T = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${E}.0 - 1.0, ${z}.0 - 1.0, ${E}.0 - 1.0,
                            ${z}.0 - 1.0);
                        vec4 original = vec4(${j}.0 - 1.0, ${Z}.0 - 1.0, ${j}.0 - 1.0,
                            ${Z}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
                  break;
                default:
                  throw Error(
                    `resize (packed) does not support coordinateTransformMode:                                 '${q.coordinateTransformMode}'`
                  );
              }
              let y = (0, U.getCoordsDataType)(R),
                _ = `
            const vec2 inputWH = vec2(${Z}.0, ${j}.0);
            const vec4 scaleWHWH = vec4(float(${w}), float(${I}), float(${w}), float(${I}));
            ${(0, $.unpackFromChannel)()}
            ${T}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${y} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${z - 1};
                bool hasNextCol = rc.z < ${E - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${M.output} = vec4(newValue);
            }
        `;
              return Object.assign(Object.assign({}, K), {
                output: {
                  dims: D,
                  type: N[0].type,
                  textureType: J.TextureType.packed,
                },
                hasMain: !0,
                shaderSource: _,
              });
            },
            W = (F, N) => {
              let q = F[0].dims,
                M,
                A = N.scales;
              if (A.length === 0) {
                let R = F[N.scalesInputIdx];
                if (R && R.size !== 0) {
                  if (F[N.sizesInputIdx])
                    throw Error(
                      "Only one of scales or sizes must be provided as input."
                    );
                  A = L(R, N.mode, N.isResize);
                } else {
                  let z = F[N.sizesInputIdx];
                  if (!z || z.size === 0)
                    throw Error(
                      "Either scales or sizes MUST be provided as input."
                    );
                  ((M = Array.from(z.integerData)),
                    (A = H(M, q, N.mode, N.isResize)));
                }
              } else if (F[N.sizesInputIdx])
                throw Error(
                  "Only one of scales or sizes must be provided as input."
                );
              let D = M || q.map((R, z) => Math.floor(R * A[z]));
              return [A, D];
            },
            L = (F, N, q) => {
              let M = Array.from(F.floatData);
              return ((0, B.scalesValidation)(M, N, q), M);
            },
            H = (F, N, q, M) => {
              let A = N.length,
                D = Array(A);
              for (let R = 0, z = A; R < z; R++)
                if (N[R] === 0) {
                  if (F[R] !== 0)
                    throw Error(
                      "Input dim is zero but required output dim is non-zero."
                    );
                  D[R] = 1;
                } else D[R] = F[R] / N[R];
              return ((0, B.scalesValidation)(D, q, M), D);
            };
        },
        8117: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.shape = void 0));
          let G = Q(9162);
          Y.shape = (U, $) => (
            J($),
            [
              new G.Tensor(
                [$[0].dims.length],
                "int32",
                void 0,
                void 0,
                new Int32Array($[0].dims)
              ),
            ]
          );
          let J = (U) => {
            if (!U || U.length !== 1) throw Error("Shape requires 1 input.");
          };
        },
        2278: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.sliceV10 = Y.parseSliceAttributes = Y.slice = void 0));
          let G = Q(246),
            J = Q(782),
            U = Q(2517),
            $ = Q(2039),
            B = {
              name: "Slice",
              inputNames: ["A"],
              inputTypes: [$.TextureType.unpacked],
            };
          ((Y.slice = (H, F, N) => (
            V(F),
            [
              H.run(
                Object.assign(Object.assign({}, B), {
                  cacheHint: N.cacheKey,
                  get: () => K(H, F[0], N),
                }),
                F
              ),
            ]
          )),
            (Y.parseSliceAttributes = (H) => {
              let F = H.attributes.getInts("starts"),
                N = H.attributes.getInts("ends"),
                q = H.attributes.getInts("axes", []);
              return (0, G.createAttributeWithCacheKey)({
                starts: F,
                ends: N,
                axes: q,
              });
            }));
          let K = (H, F, N) => {
              let q =
                  N.axes.length === 0
                    ? F.dims.slice(0).map((O, Z) => Z)
                    : N.axes,
                M = U.ShapeUtil.normalizeAxes(q, F.dims.length),
                A = N.starts.map((O, Z) =>
                  O > F.dims[M[Z]] - 1
                    ? F.dims[M[Z]]
                    : U.ShapeUtil.normalizeAxis(O, F.dims[M[Z]])
                ),
                D = N.ends.map((O, Z) =>
                  O > F.dims[M[Z]] - 1
                    ? F.dims[M[Z]]
                    : U.ShapeUtil.normalizeAxis(O, F.dims[M[Z]])
                ),
                R = F.dims.slice(),
                z = [];
              for (let O = 0; O < M.length; O++)
                ((R[M[O]] = D[O] - A[O]),
                  A[O] > 0 && z.push(`outputIdx[${M[O]}] += ${A[O]};`));
              let E = `
      float process(int outputIdx[${R.length}]) {
        ${z.join(`
      `)}
        return _A(outputIdx);
      }`;
              return Object.assign(Object.assign({}, B), {
                output: {
                  dims: R,
                  type: F.type,
                  textureType: $.TextureType.unpacked,
                },
                shaderSource: E,
              });
            },
            V = (H) => {
              if (!H || H.length !== 1) throw Error("Slice requires 1 input.");
              if (J.NUMBER_TYPES.indexOf(H[0].type) === -1)
                throw Error("Invalid input type.");
            };
          Y.sliceV10 = (H, F) => {
            L(F);
            let N = W(H, F);
            return [
              H.run(
                Object.assign(Object.assign({}, B), {
                  cacheHint: N.cacheKey,
                  get: () => K(H, F[0], N),
                }),
                [F[0]]
              ),
            ];
          };
          let W = (H, F) => {
              if (
                !H.session.isInitializer(F[1].dataId) ||
                !H.session.isInitializer(F[2].dataId) ||
                (F.length >= 4 && !H.session.isInitializer(F[3].dataId)) ||
                (F.length >= 5 && !H.session.isInitializer(F[4].dataId))
              )
                throw Error("dynamic slice attributes are not allowed");
              if (F.length >= 5 && F[4].integerData.some((A) => A !== 1))
                throw Error("currently non-1 steps is not supported for Slice");
              let N = Array.from(F[1].integerData),
                q = Array.from(F[2].integerData),
                M = F.length >= 4 ? Array.from(F[3].integerData) : [];
              return {
                starts: N,
                ends: q,
                axes: M,
                cacheKey: `${M};${N};${q}`,
              };
            },
            L = (H) => {
              if (!H || H.length < 3 || H.length > 5)
                throw Error("Invalid input number.");
              if (H[1].type !== "int32" || H[1].dims.length !== 1)
                throw Error("Invalid input type.");
              if (H[2].type !== "int32" || H[2].dims.length !== 1)
                throw Error("Invalid input type.");
              if (
                H.length >= 4 &&
                (H[3].type !== "int32" || H[3].dims.length !== 1)
              )
                throw Error("Invalid input type.");
              if (
                H.length >= 5 &&
                (H[4].type !== "int32" || H[4].dims.length !== 1)
              )
                throw Error("Invalid input type.");
            };
        },
        5524: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.softmaxV13 =
              Y.parseSoftmaxAttributesV13 =
              Y.parseSoftmaxAttributes =
              Y.softmax =
                void 0));
          let G = Q(246),
            J = Q(2517),
            U = Q(5060),
            $ = Q(2039),
            B = Q(3738),
            K = {
              name: "SoftmaxComputeMax",
              inputNames: ["A"],
              inputTypes: [$.TextureType.unpacked],
            },
            V = {
              name: "SoftmaxComputeScale",
              inputNames: ["A", "Max"],
              inputTypes: [$.TextureType.unpacked, $.TextureType.unpacked],
            },
            W = {
              name: "SoftMax",
              inputNames: ["A", "Max", "Norm"],
              inputTypes: [
                $.TextureType.unpacked,
                $.TextureType.unpacked,
                $.TextureType.unpacked,
              ],
            };
          ((Y.softmax = (M, A, D) => {
            q(A);
            let R = A[0].dims.slice(),
              z = J.ShapeUtil.normalizeAxis(D.axis, R.length),
              E = J.ShapeUtil.sizeToDimension(R, z),
              O = J.ShapeUtil.sizeFromDimension(R, z);
            return L(M, A, D, E, O);
          }),
            (Y.parseSoftmaxAttributes = (M) =>
              (0, G.createAttributeWithCacheKey)({
                axis: M.attributes.getInt("axis", 1),
              })),
            (Y.parseSoftmaxAttributesV13 = (M) =>
              (0, G.createAttributeWithCacheKey)({
                axis: M.attributes.getInt("axis", -1),
              })),
            (Y.softmaxV13 = (M, A, D) => {
              q(A);
              let R = A[0].dims.slice(),
                z = J.ShapeUtil.normalizeAxis(D.axis, R.length),
                E = R.length,
                O = z !== E - 1,
                Z = [],
                j,
                w = [],
                I = [];
              O &&
                ((w = Array.from({ length: E }).map((f, l) => l)),
                (w[z] = E - 1),
                (w[E - 1] = z),
                w.map((f) => Z.push(R[f])),
                (j = (0, G.createAttributeWithCacheKey)({ perm: w })),
                (I = (0, B.transpose)(M, A, j)));
              let T = O
                  ? J.ShapeUtil.sizeToDimension(Z, E - 1)
                  : J.ShapeUtil.sizeToDimension(R, E - 1),
                y = O
                  ? J.ShapeUtil.sizeFromDimension(Z, E - 1)
                  : J.ShapeUtil.sizeFromDimension(R, E - 1),
                _ = L(M, O ? I : A, D, T, y);
              return O ? (0, B.transpose)(M, _, j) : _;
            }));
          let L = (M, A, D, R, z) => {
              let E = H(M, A[0], R, z, [R]),
                O = M.run(
                  Object.assign(Object.assign({}, K), {
                    cacheHint: D.cacheKey,
                    get: () => E,
                  }),
                  A
                ),
                Z = F(M, A[0], R, z, E.output.dims, [R]),
                j = M.run(
                  Object.assign(Object.assign({}, V), {
                    cacheHint: D.cacheKey,
                    get: () => Z,
                  }),
                  [A[0], O]
                ),
                w = N(M, A[0], R, z, E.output.dims, Z.output.dims);
              return [
                M.run(
                  Object.assign(Object.assign({}, W), {
                    cacheHint: D.cacheKey,
                    get: () => w,
                  }),
                  [A[0], O, j]
                ),
              ];
            },
            H = (M, A, D, R, z) => {
              let [E, O] = M.calculateTextureWidthAndHeight(
                  A.dims,
                  $.TextureType.unpacked
                ),
                Z = z.length;
              if (D < 1 || R < 1)
                throw Error(
                  "Logical row count N and feature count D must be greater than or equal to 1"
                );
              if (z.length !== 1)
                throw Error("Dimensionality of the output should be 1");
              if (z[0] !== D)
                throw Error(
                  "Shape of the output should be equal to logical row count"
                );
              let j = (0, U.getGlsl)(M.session.backend.glContext.version),
                w = `
      float process(int[${Z}] indices) {
        int logical_row_start_offset = indices[0] * ${R};

        float max = getColorAsFloat(${j.texture2D}(A, offsetToCoords(logical_row_start_offset, ${E},
        ${O} )));
        for(int i=1; i<${R}; ++i)
        {
          float current = getColorAsFloat(${j.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${E}, ${O})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
              return Object.assign(Object.assign({}, K), {
                output: {
                  dims: z,
                  type: A.type,
                  textureType: $.TextureType.unpacked,
                },
                shaderSource: w,
              });
            },
            F = (M, A, D, R, z, E) => {
              let [O, Z] = M.calculateTextureWidthAndHeight(
                  A.dims,
                  $.TextureType.unpacked
                ),
                j = E.length;
              if (D < 1 || R < 1)
                throw Error(
                  "Logical row count N and feature count D must be greater than or equal to 1"
                );
              if (E.length !== 1)
                throw Error("Dimensionality of the output should be 1");
              if (E[0] !== D)
                throw Error(
                  "Shape of the output should be equal to logical row count"
                );
              if (z.length !== 1)
                throw Error(
                  "Dimensionality of the intermediate results should be 1"
                );
              if (z[0] !== D)
                throw Error(
                  "Shape of the intermediate results should be equal to logical row count"
                );
              let w = `
      float process(int[${j}] indices) {
        int logical_row_start_offset = indices[0] * ${R};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${R}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0, U.getGlsl)(M.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${O}, ${Z}))) - max);
        }

        return norm_factor;
      }`;
              return Object.assign(Object.assign({}, V), {
                output: {
                  dims: E,
                  type: A.type,
                  textureType: $.TextureType.unpacked,
                },
                shaderSource: w,
              });
            },
            N = (M, A, D, R, z, E) => {
              let [O, Z] = M.calculateTextureWidthAndHeight(
                  A.dims,
                  $.TextureType.unpacked
                ),
                j = A.dims.length;
              if (D < 1 || R < 1)
                throw Error(
                  "Logical row count N and feature count D must be greater than or equal to 1"
                );
              if (z.length !== 1 || E.length !== 1)
                throw Error(
                  "Dimensionality of the intermediate results should be 1"
                );
              if (z[0] !== D || E[0] !== D)
                throw Error(
                  "Shape of the intermediate results should be equal to logical row count"
                );
              let w = `
      float process(int[${j}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${O}, ${Z});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${R};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
              return Object.assign(Object.assign({}, W), {
                output: {
                  dims: A.dims,
                  type: A.type,
                  textureType: $.TextureType.unpacked,
                },
                shaderSource: w,
              });
            },
            q = (M) => {
              if (!M || M.length !== 1)
                throw Error("Softmax requires 1 input.");
              if (M[0].type !== "float32" && M[0].type !== "float64")
                throw Error("Invalid input type");
            };
        },
        5975: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseSplitAttributes = Y.split = void 0));
          let G = Q(246),
            J = Q(2517),
            U = Q(2039),
            $ = {
              name: "Split",
              inputNames: ["A"],
              inputTypes: [U.TextureType.unpacked],
            };
          ((Y.split = (W, L, H) => {
            V(L);
            let F = J.ShapeUtil.normalizeAxis(H.axis, L[0].dims.length),
              N = B(W, L, F, H),
              q = [];
            for (let M = 0; M < N; ++M)
              q.push(
                W.run(
                  Object.assign(Object.assign({}, $), {
                    cacheHint: `${H.cacheKey};${M}`,
                    get: () => K(W, L[0], H, F, M),
                  }),
                  L
                )
              );
            return q;
          }),
            (Y.parseSplitAttributes = (W) => {
              let L = W.attributes.getInt("axis", 0),
                H = W.attributes.getInts("split", []),
                F = W.outputs.length;
              return (0, G.createAttributeWithCacheKey)({
                axis: L,
                split: H,
                numOutputs: F,
              });
            }));
          let B = (W, L, H, F) => {
              let [, N] = J.SplitUtil.splitShape(
                L[0].dims,
                H,
                F.split,
                F.numOutputs
              );
              return N.length;
            },
            K = (W, L, H, F, N) => {
              let [q, M] = J.SplitUtil.splitShape(
                  L.dims,
                  F,
                  H.split,
                  H.numOutputs
                ),
                A = M[N],
                D = q[N],
                R = `
      float process(int indices[${D.length}]) {
        indices[${F}] += ${A};
        return _A(indices);
      }
    `;
              return Object.assign(Object.assign({}, $), {
                cacheHint: `${H.cacheKey}:${N}`,
                output: {
                  dims: D,
                  type: L.type,
                  textureType: U.TextureType.unpacked,
                },
                shaderSource: R,
              });
            },
            V = (W) => {
              if (!W || W.length !== 1)
                throw Error("Split requires one input.");
              if (
                W[0].type !== "int8" &&
                W[0].type !== "uint8" &&
                W[0].type !== "int16" &&
                W[0].type !== "uint16" &&
                W[0].type !== "int32" &&
                W[0].type !== "uint32" &&
                W[0].type !== "float32" &&
                W[0].type !== "float64" &&
                W[0].type !== "bool"
              )
                throw Error("Invalid input type.");
            };
        },
        3933: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseSqueezeAttributes = Y.squeezeV13 = Y.squeeze = void 0));
          let G = Q(2517);
          ((Y.squeeze = ($, B, K) => {
            J(B);
            let V = G.ShapeUtil.squeezeShape(B[0].dims, K);
            return [$.reshapeUnpacked(B[0], V)];
          }),
            (Y.squeezeV13 = ($, B) => (
              U(B),
              (0, Y.squeeze)($, [B[0]], Array.from(B[1].integerData))
            )),
            (Y.parseSqueezeAttributes = ($) => $.attributes.getInts("axes")));
          let J = ($) => {
              if (!$ || $.length !== 1)
                throw Error("Squeeze requires 1 input.");
              if ($[0].type === "string")
                throw Error("invalid input tensor types.");
            },
            U = ($) => {
              if (!$ || $.length !== 2)
                throw Error("Squeeze requires 2 inputs.");
              if ($[1].type !== "int32") throw Error("Invalid input type.");
            };
        },
        6558: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.sum = void 0));
          let G = Q(5060),
            J = Q(2039);
          Y.sum = (B, K) => {
            $(K);
            let V = {
              name: "Sum",
              inputNames: K.map((W, L) => `X${L}`),
              inputTypes: Array(K.length).fill(J.TextureType.unpacked),
            };
            return [
              B.run(
                Object.assign(Object.assign({}, V), { get: () => U(B, K, V) }),
                K
              ),
            ];
          };
          let U = (B, K, V) => {
              let W = (0, G.getGlsl)(B.session.backend.glContext.version),
                L = K[0].dims.slice(),
                H = K.map((N, q) => `${W.texture2D}(X${q},TexCoords)`).join(
                  " + "
                ),
                F = `
      void main() {
        vec4 result = ${H};
        ${W.output} = result;
      }
    `;
              return Object.assign(Object.assign({}, V), {
                output: {
                  dims: L,
                  type: K[0].type,
                  textureType: J.TextureType.unpacked,
                },
                hasMain: !0,
                shaderSource: F,
              });
            },
            $ = (B) => {
              if (!B || B.length === 0) throw Error("Sum requires inputs.");
              let K = B[0].dims.length;
              for (let V = 1; V < B.length; V++) {
                if (K !== B[V].dims.length)
                  throw Error("Input shapes are mismatched.");
                for (let W = 0; W < K; W++)
                  if (B[0].dims[W] !== B[V].dims[W])
                    throw Error("Input shapes are not matched.");
              }
              if (B[0].type !== "float32" && B[0].type !== "float64")
                throw Error("Invalid input type.");
              for (let V = 1; V < B.length; V++)
                if (B[0].type !== B[V].type)
                  throw Error("Input types are not matched.");
            };
        },
        5723: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.tile = void 0));
          let G = Q(782),
            J = Q(2039);
          Y.tile = (B, K) => {
            $(K);
            let V = {
              name: "Tile",
              inputNames: ["A"],
              inputTypes: [J.TextureType.unpacked],
            };
            return [
              B.run(
                Object.assign(Object.assign({}, V), { get: () => U(B, K, V) }),
                K
              ),
            ];
          };
          let U = (B, K, V) => {
              let W = K[0].dims.slice(),
                L = Array(W.length),
                H = [];
              for (let q = 0; q < W.length; q++)
                ((L[q] = W[q] * K[1].numberData[q]),
                  H.push(
                    `inputIdx[${q}] = int(mod(float(outputIdx[${q}]), ${W[q]}.));`
                  ));
              let F = L.length,
                N = `
      float process(int outputIdx[${F}]) {
        int inputIdx[${F}];
        ${H.join(`
`)}
        return _A(inputIdx);
      }
    `;
              return Object.assign(Object.assign({}, V), {
                output: {
                  dims: L,
                  type: K[0].type,
                  textureType: J.TextureType.unpacked,
                },
                shaderSource: N,
              });
            },
            $ = (B) => {
              if (!B || B.length !== 2) throw Error("Tile requires 2 input.");
              if (B[1].dims.length !== 1)
                throw Error("The second input shape must 1 dimension.");
              if (B[1].dims[0] !== B[0].dims.length)
                throw Error("Invalid input shape.");
              if (G.NUMBER_TYPES.indexOf(B[0].type) === -1)
                throw Error("Invalid input type.");
              if (B[1].type !== "int32" && B[1].type !== "int16")
                throw Error("Invalid repeat type.");
            };
        },
        3738: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseTransposeAttributes = Y.transpose = void 0));
          let G = Q(246),
            J = Q(2517),
            U = Q(2039),
            $ = {
              name: "Transpose",
              inputNames: ["A"],
              inputTypes: [U.TextureType.unpacked],
            };
          ((Y.transpose = (H, F, N) => (
            L(F),
            [
              H.run(
                Object.assign(Object.assign({}, $), {
                  cacheHint: N.cacheKey,
                  get: () => B(H, F[0], N.perm),
                }),
                F
              ),
            ]
          )),
            (Y.parseTransposeAttributes = (H) =>
              (0, G.createAttributeWithCacheKey)({
                perm: H.attributes.getInts("perm", []),
              })));
          let B = (H, F, N) => {
              let q = F.dims;
              N = K(q, N);
              let M = V(q, N),
                A = q.length,
                D = `
      ${W("perm", N, A)}
      float process(int indices[${A}]) {
        int a[${A}];
        perm(a, indices);
        return _A(a);
      }`;
              return Object.assign(Object.assign({}, $), {
                output: {
                  dims: M,
                  type: F.type,
                  textureType: U.TextureType.unpacked,
                },
                shaderSource: D,
              });
            },
            K = (H, F) => (
              F && F.length !== H.length && (F = [...H.keys()].reverse()),
              F
            ),
            V = (H, F) => ((F = K(H, F)), J.ShapeUtil.sortBasedOnPerm(H, F)),
            W = (H, F, N) => {
              let q = [];
              q.push(`void ${H}(out int a[${N}], int src[${N}]) {`);
              for (let M = 0; M < N; ++M) q.push(`	a[${F[M]}]=src[${M}];`);
              return (
                q.push("\t}"),
                q.join(`
`)
              );
            },
            L = (H) => {
              if (!H || H.length !== 1)
                throw Error("Transpose requires 1 input.");
              if (H[0].type !== "float32" && H[0].type !== "float64")
                throw Error("input should be float tensor");
            };
        },
        8710: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.encodeAsUint8 = void 0));
          let G = Q(5060),
            J = Q(2039);
          Y.encodeAsUint8 = (U, $) => {
            let B = $.shape,
              K = (0, G.getGlsl)(U.session.backend.glContext.version),
              V = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${K.texture2D}(X,TexCoords).r;
      ${K.output} = encodeAsUint8(value);
    }`,
              W = {
                name: "Uint8Encode",
                inputTypes: [J.TextureType.unpacked],
                inputNames: ["X"],
                output: {
                  dims: B,
                  type: $.tensor.type,
                  textureType: J.TextureType.downloadUint8AsFloat,
                },
                shaderSource: V,
                hasMain: !0,
              };
            return U.executeProgram(W, [$.tensor]);
          };
        },
        4909: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.tanh =
              Y.tan =
              Y.sqrt =
              Y.sin =
              Y.sigmoid =
              Y.relu =
              Y.not =
              Y.neg =
              Y.log =
              Y.parseLeakyReluAttributes =
              Y.leakyRelu =
              Y.identity =
              Y.floor =
              Y.exp =
              Y.parseEluAttributes =
              Y.elu =
              Y.cos =
              Y.ceil =
              Y.clipV11 =
              Y.parseClipAttributes =
              Y.clip =
              Y.atan =
              Y.asin =
              Y.acos =
              Y.abs =
              Y.glslTanh =
              Y.glslTan =
              Y.glslSqrt =
              Y.glslSigmoid =
              Y.glslRelu =
              Y.glslSin =
              Y.glslNot =
              Y.glslNeg =
              Y.glslLog =
              Y.glslLeakyRelu =
              Y.glslIdentity =
              Y.glslClip =
              Y.glslFloor =
              Y.glslExp =
              Y.glslElu =
              Y.glslCos =
              Y.glslCeil =
              Y.glslAtan =
              Y.glslAsin =
              Y.glslAcos =
              Y.glslAbs =
                void 0));
          let G = Q(246),
            J = Q(2517),
            U = Q(8520),
            $ = Q(5060),
            B = Q(2039);
          function K() {
            return _("abs");
          }
          function V() {
            return _("acos");
          }
          function W() {
            return _("asin");
          }
          function L() {
            return _("atan");
          }
          function H() {
            return _("ceil");
          }
          function F() {
            return _("cos");
          }
          function N(h) {
            return {
              body: `
  const float alpha = float(${h});

  float elu_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 elu_(vec4 v) {
    return vec4(elu_(v.x), elu_(v.y), elu_(v.z), elu_(v.w));
  }
  `,
              name: "elu",
              type: U.FunctionType.ValueBased,
            };
          }
          function q() {
            return _("exp");
          }
          function M() {
            return _("floor");
          }
          function A(h, p) {
            return {
              body: `
  const float min = float(${h});
  const float max = float(${p});

  float clip_(float a) {
    return clamp(a, min, max);
  }
  vec4 clip_(vec4 v) {
    return clamp(v, min, max);
  }
  `,
              name: "clip",
              type: U.FunctionType.ValueBased,
            };
          }
          function D() {
            return {
              body: `
  float indentity_(float a) {
    return a;
  }
  vec4 indentity_(vec4 v) {
    return v;
  }
  `,
              name: "indentity",
              type: U.FunctionType.ValueBased,
            };
          }
          function R(h) {
            return {
              body: `
  const float alpha = float(${h});

  float leakyRelu_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 leakyRelu_(vec4 v) {
    return vec4(leakyRelu_(v.x), leakyRelu_(v.y), leakyRelu_(v.z), leakyRelu_(v.w));
  }
  `,
              name: "leakyRelu",
              type: U.FunctionType.ValueBased,
            };
          }
          function z() {
            return _("log");
          }
          function E() {
            return {
              body: `
  float neg_(float a) {
    return -a;
  }
  vec4 neg_(vec4 v) {
    return -v;
  }
  `,
              name: "neg",
              type: U.FunctionType.ValueBased,
            };
          }
          function O() {
            return {
              body: `
  float not_(float a) {
    return float( ! bool(a) );
  }
  bool not_(bool a) {
    return !a;
  }
  vec4 not_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 not_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,
              name: "not",
              type: U.FunctionType.ValueBased,
            };
          }
          function Z() {
            return _("sin");
          }
          function j() {
            return {
              body: `
  float relu_(float a) {
    return max( a, 0.0 );
  }
  vec4 relu_(vec4 v) {
    return max( v, 0.0 );
  }
  `,
              name: "relu",
              type: U.FunctionType.ValueBased,
            };
          }
          function w() {
            return {
              body: `
  float sigmoid_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 sigmoid_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,
              name: "sigmoid",
              type: U.FunctionType.ValueBased,
            };
          }
          function I() {
            return _("sqrt");
          }
          function T() {
            return _("tan");
          }
          function y() {
            return {
              body: `
  float tanh_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 tanh_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,
              name: "tanh",
              type: U.FunctionType.ValueBased,
            };
          }
          function _(h) {
            return {
              body: `
  float ${h}_(float a) {
    return ${h}(a);
  }
  vec4 ${h}_(vec4 v) {
    return ${h}(v);
  }
  `,
              name: h,
              type: U.FunctionType.ValueBased,
            };
          }
          ((Y.glslAbs = K),
            (Y.glslAcos = V),
            (Y.glslAsin = W),
            (Y.glslAtan = L),
            (Y.glslCeil = H),
            (Y.glslCos = F),
            (Y.glslElu = N),
            (Y.glslExp = q),
            (Y.glslFloor = M),
            (Y.glslClip = A),
            (Y.glslIdentity = D),
            (Y.glslLeakyRelu = R),
            (Y.glslLog = z),
            (Y.glslNeg = E),
            (Y.glslNot = O),
            (Y.glslSin = Z),
            (Y.glslRelu = j),
            (Y.glslSigmoid = w),
            (Y.glslSqrt = I),
            (Y.glslTan = T),
            (Y.glslTanh = y));
          let f = (h, p, N0, e) => {
            let P = h.session.pack
                ? B.TextureType.packed
                : B.TextureType.unpacked,
              x = {
                name: N0.name,
                inputTypes: [P],
                inputNames: ["A"],
                cacheHint: e,
              };
            return Object.assign(Object.assign({}, x), {
              get: () =>
                ((r, C, v, k) => {
                  let o = r.session.pack
                      ? B.TextureType.packed
                      : B.TextureType.unpacked,
                    J0 = (0, $.getGlsl)(r.session.backend.glContext.version);
                  return Object.assign(Object.assign({}, C), {
                    output: { dims: v.dims, type: v.type, textureType: o },
                    shaderSource: `
     ${k.body}
     void main() {
       vec4 v = ${J0.texture2D}(A, TexCoords);
       v = ${k.name}_(v);
       ${J0.output} = v;
     }
     `,
                    hasMain: !0,
                  });
                })(h, x, p, N0),
            });
          };
          ((Y.abs = (h, p) => [h.run(f(h, p[0], K()), p)]),
            (Y.acos = (h, p) => [h.run(f(h, p[0], V()), p)]),
            (Y.asin = (h, p) => [h.run(f(h, p[0], W()), p)]),
            (Y.atan = (h, p) => [h.run(f(h, p[0], L()), p)]),
            (Y.clip = (h, p, N0) => [
              h.run(f(h, p[0], A(N0.min, N0.max), N0.cacheKey), p),
            ]),
            (Y.parseClipAttributes = (h) =>
              (0, G.createAttributeWithCacheKey)({
                min: h.attributes.getFloat("min", J.MIN_CLIP),
                max: h.attributes.getFloat("max", J.MAX_CLIP),
              })),
            (Y.clipV11 = (h, p) => {
              let N0 = l(h, p);
              return (0, Y.clip)(h, [p[0]], N0);
            }));
          let l = (h, p) => {
            if (
              p.length >= 3 &&
              (!h.session.isInitializer(p[1].dataId) ||
                !h.session.isInitializer(p[2].dataId))
            )
              throw Error("dynamic clip attributes are not allowed");
            let N0 = p.length >= 3 ? p[1].numberData[0] : J.MIN_CLIP,
              e = p.length >= 3 ? p[2].numberData[0] : J.MAX_CLIP;
            return (0, G.createAttributeWithCacheKey)({ min: N0, max: e });
          };
          ((Y.ceil = (h, p) => [h.run(f(h, p[0], H()), p)]),
            (Y.cos = (h, p) => [h.run(f(h, p[0], F()), p)]),
            (Y.elu = (h, p, N0) => [
              h.run(f(h, p[0], N(N0.alpha), N0.cacheKey), p),
            ]),
            (Y.parseEluAttributes = (h) =>
              (0, G.createAttributeWithCacheKey)({
                alpha: h.attributes.getFloat("alpha", 1),
              })),
            (Y.exp = (h, p) => [h.run(f(h, p[0], q()), p)]),
            (Y.floor = (h, p) => [h.run(f(h, p[0], M()), p)]),
            (Y.identity = (h, p) => [h.run(f(h, p[0], D()), p)]),
            (Y.leakyRelu = (h, p, N0) => [
              h.run(f(h, p[0], R(N0.alpha), N0.cacheKey), p),
            ]),
            (Y.parseLeakyReluAttributes = (h) =>
              (0, G.createAttributeWithCacheKey)({
                alpha: h.attributes.getFloat("alpha", 0.01),
              })),
            (Y.log = (h, p) => [h.run(f(h, p[0], z()), p)]),
            (Y.neg = (h, p) => [h.run(f(h, p[0], E()), p)]),
            (Y.not = (h, p) => [h.run(f(h, p[0], O()), p)]),
            (Y.relu = (h, p) => [h.run(f(h, p[0], j()), p)]),
            (Y.sigmoid = (h, p) => [h.run(f(h, p[0], w()), p)]),
            (Y.sin = (h, p) => [h.run(f(h, p[0], Z()), p)]),
            (Y.sqrt = (h, p) => [h.run(f(h, p[0], I()), p)]),
            (Y.tan = (h, p) => [h.run(f(h, p[0], T()), p)]),
            (Y.tanh = (h, p) => [h.run(f(h, p[0], y()), p)]));
        },
        5611: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.createUnpackProgramInfoLoader = Y.createUnpackProgramInfo =
              void 0));
          let G = Q(5060),
            J = Q(2039),
            U = Q(9390),
            $ = Q(2827),
            B = {
              name: "unpack",
              inputNames: ["A"],
              inputTypes: [J.TextureType.packed],
            };
          ((Y.createUnpackProgramInfo = (K, V) => {
            let W = V.dims.length,
              L = (0, $.getChannels)("rc", W),
              H = L.slice(-2),
              F = (0, U.getCoordsDataType)(W),
              N = (0, $.unpackFromChannel)(),
              q =
                V.dims.length === 0
                  ? ""
                  : (function (D, R) {
                      if (D === 1) return "rc";
                      let z = "";
                      for (let E = 0; E < D; E++)
                        ((z += R[E]), E < D - 1 && (z += ","));
                      return z;
                    })(W, L),
              M = W <= 1 ? "rc" : `vec2(${H.join(",")})`,
              A = `
    ${N}
    void main() {
      ${F} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${q});

       ${(0, G.getGlsl)(K.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${M}), 0, 0, 0);
     }
   `;
            return Object.assign(Object.assign({}, B), {
              hasMain: !0,
              output: {
                dims: V.dims,
                type: V.type,
                textureType: J.TextureType.unpacked,
              },
              shaderSource: A,
            });
          }),
            (Y.createUnpackProgramInfoLoader = (K, V) =>
              Object.assign(Object.assign({}, B), {
                get: () => (0, Y.createUnpackProgramInfo)(K, V),
              })));
        },
        8428: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.parseUnsqueezeAttributes =
              Y.unsqueezeV13 =
              Y.unsqueeze =
                void 0));
          let G = Q(2517);
          ((Y.unsqueeze = ($, B, K) => {
            J(B);
            let V = G.ShapeUtil.unsqueezeShape(B[0].dims, K);
            return [$.reshapeUnpacked(B[0], V)];
          }),
            (Y.unsqueezeV13 = ($, B) => (
              U(B),
              (0, Y.unsqueeze)($, [B[0]], Array.from(B[1].integerData))
            )),
            (Y.parseUnsqueezeAttributes = ($) => $.attributes.getInts("axes")));
          let J = ($) => {
              if (!$ || $.length !== 1)
                throw Error("Unsqueeze requires 1 input.");
              if ($[0].type === "string")
                throw Error("invalid input tensor types.");
            },
            U = ($) => {
              if (!$ || $.length !== 2)
                throw Error("Unsqueeze requires 2 inputs.");
              if ($[1].type !== "int32") throw Error("Invalid input type.");
            };
        },
        9793: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.scalesValidation =
              Y.validateInputs =
              Y.parseUpsampleAttributes =
              Y.parseUpsampleAttributesV9 =
              Y.parseUpsampleAttributesV7 =
              Y.upsample =
                void 0));
          let G = Q(246),
            J = Q(5060),
            U = Q(2039),
            $ = {
              name: "Upsample",
              inputNames: ["X"],
              inputTypes: [U.TextureType.unpacked],
            };
          ((Y.upsample = (K, V, W) => (
            (0, Y.validateInputs)(V, W),
            [
              K.run(
                Object.assign(Object.assign({}, $), {
                  cacheHint: W.cacheKey,
                  get: () => B(K, V, W),
                }),
                V
              ),
            ]
          )),
            (Y.parseUpsampleAttributesV7 = (K) =>
              (0, Y.parseUpsampleAttributes)(K, 7)),
            (Y.parseUpsampleAttributesV9 = (K) =>
              (0, Y.parseUpsampleAttributes)(K, 9)),
            (Y.parseUpsampleAttributes = (K, V) => {
              let W = V >= 10,
                L = K.attributes.getString("mode", "nearest");
              if (
                L !== "nearest" &&
                L !== "linear" &&
                (V < 11 || L !== "cubic")
              )
                throw Error(`unrecognized mode: ${L}`);
              let H = [];
              V < 9 &&
                ((H = K.attributes.getFloats("scales")),
                (0, Y.scalesValidation)(H, L, W));
              let F = K.attributes.getFloat("extrapolation_value", 0),
                N =
                  V > 10
                    ? K.attributes.getString(
                        "coordinate_transformation_mode",
                        "half_pixel"
                      )
                    : "asymmetric";
              if (
                [
                  "asymmetric",
                  "pytorch_half_pixel",
                  "tf_half_pixel_for_nn",
                  "align_corners",
                  "tf_crop_and_resize",
                  "half_pixel",
                ].indexOf(N) === -1
              )
                throw Error(
                  `coordinate_transform_mode '${N}' is not supported`
                );
              let q = N === "tf_crop_and_resize",
                M = q,
                A =
                  L === "nearest" && V >= 11
                    ? K.attributes.getString(
                        "nearest_mode",
                        "round_prefer_floor"
                      )
                    : "";
              if (
                [
                  "round_prefer_floor",
                  "round_prefer_ceil",
                  "floor",
                  "ceil",
                  "",
                ].indexOf(A) === -1
              )
                throw Error(`nearest_mode '${A}' is not supported`);
              let D = K.attributes.getFloat("cubic_coeff_a", -0.75),
                R = K.attributes.getInt("exclude_outside", 0) !== 0;
              if (R && L !== "cubic")
                throw Error(
                  "exclude_outside can be set to 1 only when mode is CUBIC."
                );
              let z =
                  V < 11 ||
                  (L === "nearest" && N === "asymmetric" && A === "floor"),
                E = 0,
                O = 0,
                Z = 0;
              return (
                V > 10
                  ? K.inputs.length > 2
                    ? ((E = 1), (O = 2), (Z = 3))
                    : ((O = 1), (Z = 2))
                  : V === 9 && (O = 1),
                (0, G.createAttributeWithCacheKey)({
                  opset: V,
                  isResize: W,
                  mode: L,
                  scales: H,
                  extrapolationValue: F,
                  coordinateTransformMode: N,
                  useExtrapolation: M,
                  needRoiInput: q,
                  nearestMode: A,
                  cubicCoefficientA: D,
                  excludeOutside: R,
                  useNearest2xOptimization: z,
                  roiInputIdx: E,
                  scalesInputIdx: O,
                  sizesInputIdx: Z,
                })
              );
            }));
          let B = (K, V, W) => {
            let L = (0, J.getGlsl)(K.session.backend.glContext.version),
              [H, F] = K.calculateTextureWidthAndHeight(
                V[0].dims,
                U.TextureType.unpacked
              ),
              N = V[0].dims.map((Z, j) => Math.floor(Z * W.scales[j])),
              [q, M] = K.calculateTextureWidthAndHeight(
                N,
                U.TextureType.unpacked
              ),
              A = N.length,
              D = Array(A),
              R = Array(A),
              z = `
      int output_pitches[${A}];
      int input_pitches[${A}];
      `;
            for (let Z = A - 1; Z >= 0; Z--)
              ((D[Z] = Z === A - 1 ? 1 : D[Z + 1] * N[Z + 1]),
                (R[Z] = Z === A - 1 ? 1 : R[Z + 1] * V[0].dims[Z + 1]),
                (z += `
        output_pitches[${Z}] = ${D[Z]};
        input_pitches[${Z}] = ${R[Z]};
        `));
            let E = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${H}, ${F});
        float value = getColorAsFloat(${L.texture2D}(X, coords));
        return value;
      }
      `,
              O =
                W.mode === "nearest"
                  ? `
    ${E}
    float process(int indices[${A}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${q}, ${M});

      ${z}

      int d, m;
      for (int dim = 0; dim < ${A}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`
                  : A === 4
                    ? `
    ${E}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${q}, ${M});

      ${z}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${V[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`
                    : `
    ${E}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${q}, ${M});

      ${z}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${V[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
            return Object.assign(Object.assign({}, $), {
              output: {
                dims: N,
                type: V[0].type,
                textureType: U.TextureType.unpacked,
              },
              shaderSource: O,
              variables: [
                {
                  name: "scales",
                  type: "int",
                  arrayLength: W.scales.length,
                  data: W.scales.map((Z) => Math.ceil(Z)),
                },
              ],
            });
          };
          ((Y.validateInputs = (K, V) => {
            if (
              !K ||
              (V.opset < 9 && K.length !== 1) ||
              (V.opset >= 9 && V.opset < 11 && K.length !== 2) ||
              (V.opset >= 11 && K.length < 2)
            )
              throw Error("invalid inputs.");
            if (V.scales.length > 0 && K[0].dims.length !== V.scales.length)
              throw Error("Invalid input shape.");
            if (K[0].type === "string")
              throw Error("Invalid input tensor types.");
          }),
            (Y.scalesValidation = (K, V, W) => {
              if (W) {
                for (let L of K)
                  if (L <= 0)
                    throw Error("Scale value should be greater than 0.");
              } else
                for (let L of K)
                  if (L < 1)
                    throw Error(
                      "Scale value should be greater than or equal to 1."
                    );
              if (
                !(
                  (V !== "linear" && V !== "cubic") ||
                  K.length === 2 ||
                  (K.length === 4 && K[0] === 1 && K[1] === 1)
                )
              )
                throw Error(
                  `'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${W ? "Resize" : "Upsample"} opeartor.`
                );
            }));
        },
        1958: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.ProgramManager = void 0));
          let G = Q(6207),
            J = Q(3694),
            U = Q(8879),
            $ = Q(5060);
          Y.ProgramManager = class {
            constructor(B, K, V) {
              ((this.profiler = B),
                (this.glContext = K),
                (this.textureLayoutStrategy = V),
                (this.repo = new Map()),
                (this.attributesBound = !1));
            }
            getArtifact(B) {
              return this.repo.get(B);
            }
            setArtifact(B, K) {
              this.repo.set(B, K);
            }
            run(B, K, V) {
              var W;
              this.profiler.event(
                "op",
                `ProgramManager.run ${(W = B.programInfo.name) !== null && W !== void 0 ? W : "unknown kernel"}`,
                () => {
                  var L;
                  let H = this.glContext.gl,
                    F = B.program;
                  H.useProgram(F);
                  try {
                    (this.bindOutput(V),
                      this.attributesBound ||
                        this.bindAttributes(B.attribLocations),
                      this.bindUniforms(
                        B.uniformLocations,
                        (L = B.programInfo.variables) !== null && L !== void 0
                          ? L
                          : [],
                        K
                      ));
                  } catch (N) {
                    throw (
                      J.Logger.error(
                        "ProgramManager",
                        B.programInfo.shaderSource
                      ),
                      N
                    );
                  }
                  this.profiler.event("backend", "GlContext.draw()", () => {
                    this.glContext.draw();
                  });
                },
                this.glContext
              );
            }
            dispose() {
              (this.vertexShader &&
                this.glContext.deleteShader(this.vertexShader),
                this.repo.forEach((B) =>
                  this.glContext.deleteProgram(B.program)
                ));
            }
            build(B, K, V) {
              return this.profiler.event(
                "backend",
                "ProgramManager.build",
                () => {
                  let W = new U.GlslPreprocessor(this.glContext, B, K, V),
                    L = W.preprocess(),
                    H = this.compile(L);
                  return {
                    programInfo: B,
                    program: H,
                    uniformLocations: this.getUniformLocations(
                      H,
                      W.context.programInfo.inputNames,
                      W.context.programInfo.variables
                    ),
                    attribLocations: this.getAttribLocations(H),
                  };
                }
              );
            }
            compile(B) {
              if (!this.vertexShader) {
                J.Logger.verbose(
                  "ProrgramManager",
                  "Compiling and caching Vertex shader for the first time"
                );
                let W = (0, $.getVertexShaderSource)(this.glContext.version);
                this.vertexShader = this.glContext.compileShader(
                  W,
                  this.glContext.gl.VERTEX_SHADER
                );
              }
              G.env.debug &&
                J.Logger.verbose(
                  "ProrgramManager",
                  `FragShader:
${B}
`
                );
              let K = this.glContext.compileShader(
                  B,
                  this.glContext.gl.FRAGMENT_SHADER
                ),
                V = this.glContext.createProgram(this.vertexShader, K);
              return (this.glContext.deleteShader(K), V);
            }
            bindOutput(B) {
              let { width: K, height: V } = B;
              (J.Logger.verbose(
                "ProrgramManager",
                `Binding output texture to Framebuffer: w/h=${K}/${V}, shape=${B.shape}, type=${B.tensor.type}`
              ),
                this.glContext.attachFramebuffer(B.texture, K, V));
            }
            bindAttributes(B) {
              let { position: K, textureCoord: V } = B;
              (this.glContext.setVertexAttributes(K, V),
                (this.attributesBound = !0));
            }
            bindUniforms(B, K, V) {
              var W;
              let L = this.glContext.gl,
                H = 0;
              for (let { name: F, type: N, location: q, arrayLength: M } of B) {
                let A =
                  (W = K.find((D) => D.name === F)) === null || W === void 0
                    ? void 0
                    : W.data;
                if (N !== "sampler2D" && !A)
                  throw Error(
                    `variable '${F}' does not have data defined in program info`
                  );
                switch (N) {
                  case "sampler2D":
                    (this.bindTexture(V[H], q, H), H++);
                    break;
                  case "float":
                    M ? L.uniform1fv(q, A) : L.uniform1f(q, A);
                    break;
                  case "int":
                    M ? L.uniform1iv(q, A) : L.uniform1i(q, A);
                    break;
                  default:
                    throw Error(`Uniform not implemented: ${N}`);
                }
              }
            }
            bindTexture(B, K, V) {
              this.glContext.bindTextureToUniform(B.texture, V, K);
            }
            getAttribLocations(B) {
              return {
                position: this.getAttribLocation(B, "position"),
                textureCoord: this.getAttribLocation(B, "textureCoord"),
              };
            }
            getUniformLocations(B, K, V) {
              let W = [];
              if (K)
                for (let L of K)
                  W.push({
                    name: L,
                    type: "sampler2D",
                    location: this.getUniformLocation(B, L),
                  });
              if (V)
                for (let L of V)
                  W.push(
                    Object.assign(Object.assign({}, L), {
                      location: this.getUniformLocation(B, L.name),
                    })
                  );
              return W;
            }
            getUniformLocation(B, K) {
              let V = this.glContext.gl.getUniformLocation(B, K);
              if (V === null) throw Error(`Uniform ${K} not found.`);
              return V;
            }
            getAttribLocation(B, K) {
              return this.glContext.gl.getAttribLocation(B, K);
            }
          };
        },
        6416: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.WebGLSessionHandler = void 0));
          let G = Q(3694),
            J = Q(1047),
            U = Q(8316),
            $ = Q(1640),
            B = Q(1958),
            K = Q(7859),
            V = Q(5702);
          Y.WebGLSessionHandler = class {
            constructor(W, L) {
              ((this.backend = W),
                (this.context = L),
                (this.layoutStrategy = new K.PreferLogicalStrategy(
                  W.glContext.maxTextureSize
                )),
                (this.programManager = new B.ProgramManager(
                  this.context.profiler,
                  W.glContext,
                  this.layoutStrategy
                )),
                (this.textureManager = new V.TextureManager(
                  W.glContext,
                  this.layoutStrategy,
                  this.context.profiler,
                  { reuseTextures: W.textureCacheMode === "full" }
                )),
                (this.packedTextureDataCache = new Map()),
                (this.unpackedTextureDataCache = new Map()),
                (this.pack = W.pack),
                (this.pack2unpackMap = new Map()),
                (this.unpack2packMap = new Map()));
            }
            createInferenceHandler() {
              return new U.WebGLInferenceHandler(this);
            }
            onGraphInitialized(W) {
              let L = W.getValues()
                .filter((H) => H.from === -1 && H.tensor)
                .map((H) => H.tensor.dataId);
              this.initializers = new Set(L);
            }
            isInitializer(W) {
              return !!this.initializers && this.initializers.has(W);
            }
            addInitializer(W) {
              this.initializers.add(W);
            }
            getTextureData(W, L) {
              return L
                ? this.packedTextureDataCache.get(W)
                : this.unpackedTextureDataCache.get(W);
            }
            setTextureData(W, L, H = !1) {
              (G.Logger.verbose(
                "WebGLSessionHandler",
                "Storing Texture data in cache"
              ),
                H
                  ? this.packedTextureDataCache.set(W, L)
                  : this.unpackedTextureDataCache.set(W, L));
            }
            dispose() {
              (this.programManager.dispose(),
                this.textureManager.clearActiveTextures(),
                this.packedTextureDataCache.forEach((W) =>
                  this.textureManager.releaseTexture(W, !0)
                ),
                (this.packedTextureDataCache = new Map()),
                this.unpackedTextureDataCache.forEach((W) =>
                  this.textureManager.releaseTexture(W, !0)
                ),
                (this.unpackedTextureDataCache = new Map()));
            }
            resolve(W, L, H) {
              let F = (0, J.resolveOperator)(W, L, $.WEBGL_OP_RESOLVE_RULES);
              return { impl: F.opImpl, context: F.opInit ? F.opInit(W, H) : W };
            }
          };
        },
        7769: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.Uint8DataEncoder =
              Y.RGBAFloatDataEncoder =
              Y.RedFloat32DataEncoder =
                void 0));
          let G = Q(3694);
          ((Y.RedFloat32DataEncoder = class {
            constructor(J, U = 1) {
              if (U === 1)
                ((this.internalFormat = J.R32F),
                  (this.format = J.RED),
                  (this.textureType = J.FLOAT),
                  (this.channelSize = U));
              else {
                if (U !== 4) throw Error(`Invalid number of channels: ${U}`);
                ((this.internalFormat = J.RGBA32F),
                  (this.format = J.RGBA),
                  (this.textureType = J.FLOAT),
                  (this.channelSize = U));
              }
            }
            encode(J, U) {
              let $, B;
              return (
                J.constructor !== Float32Array &&
                  (G.Logger.warning(
                    "Encoder",
                    "data was not of type Float32; creating new Float32Array"
                  ),
                  (B = new Float32Array(J))),
                U * this.channelSize > J.length
                  ? (G.Logger.warning(
                      "Encoder",
                      "Source data too small. Allocating larger array"
                    ),
                    (B = J),
                    ($ = this.allocate(U * this.channelSize)),
                    B.forEach((K, V) => ($[V] = K)))
                  : ((B = J), ($ = B)),
                $
              );
            }
            allocate(J) {
              return new Float32Array(4 * J);
            }
            decode(J, U) {
              return this.channelSize === 1
                ? J.filter(($, B) => B % 4 == 0).subarray(0, U)
                : J.subarray(0, U);
            }
          }),
            (Y.RGBAFloatDataEncoder = class {
              constructor(J, U = 1, $) {
                if (U !== 1 && U !== 4)
                  throw Error(`Invalid number of channels: ${U}`);
                ((this.internalFormat = J.RGBA),
                  (this.format = J.RGBA),
                  (this.channelSize = U),
                  (this.textureType = $ || J.FLOAT));
              }
              encode(J, U) {
                let $ = J;
                return (
                  this.channelSize === 1 &&
                    (G.Logger.verbose(
                      "Encoder",
                      "Exploding into a larger array"
                    ),
                    ($ = this.allocate(U)),
                    J.forEach((B, K) => ($[4 * K] = B))),
                  $
                );
              }
              allocate(J) {
                return new Float32Array(4 * J);
              }
              decode(J, U) {
                return this.channelSize === 1
                  ? J.filter(($, B) => B % 4 == 0).subarray(0, U)
                  : J.subarray(0, U);
              }
            }),
            (Y.Uint8DataEncoder = class {
              constructor(J, U = 1) {
                if (((this.channelSize = 4), U === 1))
                  ((this.internalFormat = J.ALPHA),
                    (this.format = J.ALPHA),
                    (this.textureType = J.UNSIGNED_BYTE),
                    (this.channelSize = U));
                else {
                  if (U !== 4) throw Error(`Invalid number of channels: ${U}`);
                  ((this.internalFormat = J.RGBA),
                    (this.format = J.RGBA),
                    (this.textureType = J.UNSIGNED_BYTE),
                    (this.channelSize = U));
                }
              }
              encode(J, U) {
                return new Uint8Array(J.buffer, J.byteOffset, J.byteLength);
              }
              allocate(J) {
                return new Uint8Array(J * this.channelSize);
              }
              decode(J, U) {
                if (J instanceof Uint8Array) return J.subarray(0, U);
                throw Error(`Invalid array type: ${J.constructor}`);
              }
            }));
        },
        7859: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.getBatchDim =
              Y.sizeToSquarishShape =
              Y.getRowsCols =
              Y.sizeFromShape =
              Y.isInt =
              Y.parseAxisParam =
              Y.squeezeShape =
              Y.PreferLogicalStrategy =
              Y.AlwaysKeepOriginalSizeStrategy =
                void 0));
          let G = Q(3694),
            J = Q(2517);
          function U(W, L) {
            let H = [],
              F = [],
              N = L != null && Array.isArray(L) && L.length === 0,
              q = L == null || N ? null : $(L, W).sort(),
              M = 0;
            for (let A = 0; A < W.length; ++A) {
              if (q != null) {
                if (q[M] === A && W[A] !== 1)
                  throw Error(
                    `Can't squeeze axis ${A} since its dim '${W[A]}' is not 1`
                  );
                ((q[M] == null || q[M] > A) &&
                  W[A] === 1 &&
                  (H.push(W[A]), F.push(A)),
                  q[M] <= A && M++);
              }
              W[A] !== 1 && (H.push(W[A]), F.push(A));
            }
            return { newShape: H, keptDims: F };
          }
          function $(W, L) {
            let H = L.length;
            return (
              (W = W == null ? L.map((F, N) => N) : [].concat(W)),
              (0, J.assert)(
                W.every((F) => F >= -H && F < H),
                () =>
                  `All values in axis param must be in range [-${H}, ${H}) but got axis ${W}`
              ),
              (0, J.assert)(
                W.every(B),
                () =>
                  `All values in axis param must be integers but got axis ${W}`
              ),
              W.map((F) => (F < 0 ? H + F : F))
            );
          }
          function B(W) {
            return W % 1 == 0;
          }
          function K(W) {
            if (W.length === 0) return 1;
            let L = W[0];
            for (let H = 1; H < W.length; H++) L *= W[H];
            return L;
          }
          function V(W) {
            let L = Math.ceil(Math.sqrt(W));
            return [L, Math.ceil(W / L)];
          }
          ((Y.AlwaysKeepOriginalSizeStrategy = class {
            constructor(W) {
              this.maxTextureSize = W;
            }
            computeTextureWH(W, L) {
              if (W.length === 0) return [1, 1];
              let H = this.maxTextureSize;
              if (L && L.breakAxis !== void 0) {
                let q =
                    L.breakAxis >= W.length
                      ? 1
                      : W.slice(L.breakAxis).reduce((A, D) => A * D),
                  M =
                    L.breakAxis <= 0
                      ? 1
                      : W.slice(0, L.breakAxis).reduce((A, D) => A * D);
                if (!(q > H || M > H)) return [q, M];
                G.Logger.verbose(
                  "TextureLayout",
                  `Given width/height preferences were unattainable: shape:${W}, breakAxis:${L.breakAxis}`
                );
              }
              let F = W.reduce((q, M) => q * M),
                N = Math.floor(Math.sqrt(F));
              for (; N < H && N < F && F % N != 0; N++);
              if (N >= H || F % N != 0)
                throw Error(
                  `The given dimensions are outside this GPU's boundaries: ${W}`
                );
              return [N, F / N];
            }
          }),
            (Y.PreferLogicalStrategy = class {
              constructor(W) {
                this.maxTextureSize = W;
              }
              computeTextureWH(W, L) {
                let H = this.computeTexture(W, L);
                return (
                  L && L.isPacked && ((H[0] /= 2), (H[1] /= 2)),
                  L && L.reverseWH ? [H[1], H[0]] : H
                );
              }
              computeTexture(W, L) {
                let H = L && L.isPacked;
                if (W.length === 0) return H ? [2, 2] : [1, 1];
                let F = this.maxTextureSize;
                if (L && L.breakAxis !== void 0) {
                  let M =
                      L.breakAxis >= W.length
                        ? 1
                        : W.slice(L.breakAxis).reduce((D, R) => D * R),
                    A =
                      L.breakAxis <= 0
                        ? 1
                        : W.slice(0, L.breakAxis).reduce((D, R) => D * R);
                  if (!(M > F || A > F)) return [M, A];
                  G.Logger.verbose(
                    "TextureLayout",
                    `Given width/height preferences were unattainable: shape:${W}, breakAxis:${L.breakAxis}`
                  );
                }
                let N = W.slice(0);
                if (
                  (H &&
                    ((F *= 2),
                    (N = N.map((M, A) =>
                      A >= N.length - 2
                        ? N[A] % 2 == 0
                          ? N[A]
                          : N[A] + 1
                        : N[A]
                    )),
                    N.length === 1 && (N = [2, N[0]])),
                  N.length !== 2)
                )
                  N = U(N).newShape;
                let q = K(N);
                return N.length <= 1 && q <= F
                  ? [1, q]
                  : N.length === 2 && N[0] <= F && N[1] <= F
                    ? N
                    : N.length === 3 && N[0] * N[1] <= F && N[2] <= F
                      ? [N[0] * N[1], N[2]]
                      : N.length === 3 && N[0] <= F && N[1] * N[2] <= F
                        ? [N[0], N[1] * N[2]]
                        : N.length === 4 && N[0] * N[1] * N[2] <= F && N[3] <= F
                          ? [N[0] * N[1] * N[2], N[3]]
                          : N.length === 4 &&
                              N[0] <= F &&
                              N[1] * N[2] * N[3] <= F
                            ? [N[0], N[1] * N[2] * N[3]]
                            : H
                              ? V(q / 4).map((M) => 2 * M)
                              : V(q);
              }
            }),
            (Y.squeezeShape = U),
            (Y.parseAxisParam = $),
            (Y.isInt = B),
            (Y.sizeFromShape = K),
            (Y.getRowsCols = function (W) {
              if (W.length === 0)
                throw Error(
                  "Cannot get rows and columns of an empty shape array."
                );
              return [W.length > 1 ? W[W.length - 2] : 1, W[W.length - 1]];
            }),
            (Y.sizeToSquarishShape = V),
            (Y.getBatchDim = function (W, L = 2) {
              return K(W.slice(0, W.length - L));
            }));
        },
        4057: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.createTextureLayoutFromShape =
              Y.calculateTextureWidthAndHeight =
              Y.createTextureLayoutFromTextureType =
                void 0));
          let G = Q(2517),
            J = Q(2039);
          ((Y.createTextureLayoutFromTextureType = (U, $, B) => {
            let K =
                B === J.TextureType.unpacked ||
                B === J.TextureType.unpackedReversed
                  ? 1
                  : 4,
              V = B === J.TextureType.packed,
              W =
                B === J.TextureType.unpackedReversed ||
                B === J.TextureType.packed,
              L =
                B === J.TextureType.packedLastDimension ? $.length - 1 : void 0,
              H =
                B === J.TextureType.packedLastDimension
                  ? $.map((F, N) => (N === $.length - 1 ? 4 * F : F))
                  : void 0;
            return (0, Y.createTextureLayoutFromShape)(U, $, K, H, {
              isPacked: V,
              reverseWH: W,
              breakAxis: L,
            });
          }),
            (Y.calculateTextureWidthAndHeight = (U, $, B) => {
              let K = (0, Y.createTextureLayoutFromTextureType)(U, $, B);
              return [K.width, K.height];
            }),
            (Y.createTextureLayoutFromShape = (U, $, B = 1, K, V) => {
              let W = !(!V || !V.isPacked),
                [L, H] = U.computeTextureWH((W && K) || $, V),
                F = $.length,
                N = $.slice(0);
              if ((F === 0 && (N = [1]), B === 1)) K = $;
              else if (W) {
                if (B !== 4) throw Error("a packed texture must be 4-channel");
                ((K = $),
                  F > 0 && (N[F - 1] = Math.ceil(N[F - 1] / 2)),
                  F > 1 && (N[F - 2] = Math.ceil(N[F - 2] / 2)));
              } else if (!K)
                throw Error("Unpacked shape is needed when using channels > 1");
              return {
                width: L,
                height: H,
                channels: B,
                isPacked: W,
                shape: N,
                strides: G.ShapeUtil.computeStrides(N),
                unpackedShape: K,
                reversedWH: V && V.reverseWH,
              };
            }));
        },
        5702: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.TextureManager = void 0));
          let G = Q(3694);
          Y.TextureManager = class {
            constructor(J, U, $, B) {
              ((this.glContext = J),
                (this.layoutStrategy = U),
                (this.profiler = $),
                (this.config = B),
                (this.pendingRead = new Map()),
                B.reuseTextures &&
                  ((this.inUseTextures = new Map()),
                  (this.idleTextures = new Map()),
                  (this.textureLookup = new Map())));
            }
            createTextureFromLayout(J, U, $, B) {
              let K = this.toEncoderType(J),
                V = this.glContext.getEncoder(K, U.channels || 1, B);
              if (U.isPacked && B === 1) throw Error("not implemented");
              let { width: W, height: L } = U,
                H,
                F;
              if (this.config.reuseTextures) {
                ((H = `${W}x${L}_${V.format}_${V.internalFormat}_${V.textureType}`),
                  (F = this.inUseTextures.get(H)),
                  F || ((F = []), this.inUseTextures.set(H, F)));
                let q = this.idleTextures.get(H);
                if (q && q.length > 0) {
                  let M = q.pop();
                  return (
                    F.push(M),
                    B === 1 &&
                      this.glContext.updateTexture(
                        M,
                        W,
                        L,
                        V,
                        this.toTextureData(J, $)
                      ),
                    M
                  );
                }
              }
              G.Logger.verbose(
                "TextureManager",
                `Creating new texture of size ${U.width}x${U.height}`
              );
              let N = this.glContext.allocateTexture(
                W,
                L,
                V,
                this.toTextureData(J, $)
              );
              return (
                this.config.reuseTextures &&
                  (F.push(N), this.textureLookup.set(N, H)),
                N
              );
            }
            readTexture(J, U, $) {
              return (
                $ || ($ = 1),
                this.profiler.event(
                  "backend",
                  "TextureManager.readTexture",
                  () => {
                    let B = J.shape.reduce((V, W) => V * W) * $,
                      K = this.glContext.readTexture(
                        J.texture,
                        J.width,
                        J.height,
                        B,
                        this.toEncoderType(U),
                        $
                      );
                    return this.toTensorData(U, K);
                  }
                )
              );
            }
            async readTextureAsync(J, U, $) {
              let B = J.tensor.dataId;
              if (($ || ($ = 1), this.pendingRead.has(B))) {
                let K = this.pendingRead.get(B);
                return new Promise((V) => (K == null ? void 0 : K.push(V)));
              }
              return this.profiler.event(
                "backend",
                "TextureManager.readTextureAsync",
                async () => {
                  this.pendingRead.set(B, []);
                  let K = J.shape.reduce((H, F) => H * F) * $;
                  await this.glContext.createAndWaitForFence();
                  let V = this.glContext.readTexture(
                      J.texture,
                      J.width,
                      J.height,
                      K,
                      this.toEncoderType(U),
                      $
                    ),
                    W = this.toTensorData(U, V),
                    L = this.pendingRead.get(B);
                  return (
                    this.pendingRead.delete(B),
                    L == null || L.forEach((H) => H(W)),
                    W
                  );
                }
              );
            }
            readUint8TextureAsFloat(J) {
              return this.profiler.event(
                "backend",
                "TextureManager.readUint8TextureAsFloat",
                () => {
                  let U = J.shape.reduce((B, K) => B * K),
                    $ = this.glContext.readTexture(
                      J.texture,
                      J.width,
                      J.height,
                      4 * U,
                      "byte",
                      4
                    );
                  return new Float32Array($.buffer, $.byteOffset, U);
                }
              );
            }
            releaseTexture(J, U) {
              let $;
              if (
                this.config.reuseTextures &&
                (($ = this.textureLookup.get(J.texture)), $)
              ) {
                U && this.textureLookup.delete($);
                let B = this.inUseTextures.get($);
                if (B) {
                  let K = B.indexOf(J.texture);
                  if (K !== -1) {
                    B.splice(K, 1);
                    let V = this.idleTextures.get($);
                    (V || ((V = []), this.idleTextures.set($, V)),
                      V.push(J.texture));
                  }
                }
              }
              ($ && !U) ||
                (G.Logger.verbose(
                  "TextureManager",
                  `Deleting texture of size ${J.width}x${J.height}`
                ),
                this.glContext.deleteTexture(J.texture));
            }
            toTensorData(J, U) {
              switch (J) {
                case "int16":
                  return U instanceof Int16Array ? U : Int16Array.from(U);
                case "int32":
                  return U instanceof Int32Array ? U : Int32Array.from(U);
                case "int8":
                  return U instanceof Int8Array ? U : Int8Array.from(U);
                case "uint16":
                  return U instanceof Uint16Array ? U : Uint16Array.from(U);
                case "uint32":
                  return U instanceof Uint32Array ? U : Uint32Array.from(U);
                case "uint8":
                case "bool":
                  return U instanceof Uint8Array ? U : Uint8Array.from(U);
                case "float32":
                  return U instanceof Float32Array ? U : Float32Array.from(U);
                case "float64":
                  return U instanceof Float64Array ? U : Float64Array.from(U);
                default:
                  throw Error(`TensorData type ${J} is not supported`);
              }
            }
            toTextureData(J, U) {
              if (U) return U instanceof Float32Array ? U : new Float32Array(U);
            }
            toEncoderType(J) {
              return "float";
            }
            clearActiveTextures() {
              this.glContext.clearActiveTextures();
            }
          };
        },
        2039: (X, Y) => {
          var Q;
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.TextureType = void 0),
            ((Q = Y.TextureType || (Y.TextureType = {}))[(Q.unpacked = 0)] =
              "unpacked"),
            (Q[(Q.unpackedReversed = 1)] = "unpackedReversed"),
            (Q[(Q.packed = 2)] = "packed"),
            (Q[(Q.downloadUint8AsFloat = 3)] = "downloadUint8AsFloat"),
            (Q[(Q.packedLastDimension = 4)] = "packedLastDimension"));
        },
        9390: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.getGlChannels =
              Y.getCoordsDataType =
              Y.getSqueezedParams =
              Y.squeezeInputShape =
              Y.generateShaderFuncNameFromInputSamplerNameAtOutCoords =
              Y.generateShaderFuncNameFromInputSamplerName =
              Y.repeatedTry =
              Y.getPackedShape =
                void 0));
          let G = Q(2517);
          ((Y.getPackedShape = function (J) {
            let U = J.length;
            return J.slice(0, U - 1).concat(J[U - 1] / 4);
          }),
            (Y.repeatedTry = async function (J, U = (B) => 0, $) {
              return new Promise((B, K) => {
                let V = 0,
                  W = () => {
                    if (J()) return void B();
                    V++;
                    let L = U(V);
                    $ != null && V >= $ ? K() : setTimeout(W, L);
                  };
                W();
              });
            }),
            (Y.generateShaderFuncNameFromInputSamplerName = function (J) {
              return (
                (0, G.assert)(
                  J !== void 0 && J.length !== 0,
                  () => "empty string found for sampler name"
                ),
                "get" + J.charAt(0).toUpperCase() + J.slice(1)
              );
            }),
            (Y.generateShaderFuncNameFromInputSamplerNameAtOutCoords =
              function (J) {
                return (
                  (0, G.assert)(
                    J !== void 0 && J.length !== 0,
                    () => "empty string found for sampler name"
                  ),
                  "get" + J.charAt(0).toUpperCase() + J.slice(1) + "AtOutCoords"
                );
              }),
            (Y.squeezeInputShape = function (J, U) {
              let $ = JSON.parse(JSON.stringify(J));
              return (($ = U), $);
            }),
            (Y.getSqueezedParams = function (J, U) {
              return U.map(($) => J[$]).join(", ");
            }),
            (Y.getCoordsDataType = function (J) {
              if (J <= 1) return "int";
              if (J === 2) return "ivec2";
              if (J === 3) return "ivec3";
              if (J === 4) return "ivec4";
              if (J === 5) return "ivec5";
              if (J === 6) return "ivec6";
              throw Error(`GPU for rank ${J} is not yet supported`);
            }),
            (Y.getGlChannels = function (J = 6) {
              return ["x", "y", "z", "w", "u", "v"].slice(0, J);
            }));
        },
        7305: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.createNewWebGLContext = Y.createWebGLContext = void 0));
          let G = Q(3694),
            J = Q(1713),
            U = {};
          function $(B) {
            let K = (function () {
                if (typeof document > "u") {
                  if (typeof OffscreenCanvas > "u")
                    throw TypeError(
                      "failed to create canvas: OffscreenCanvas is not supported"
                    );
                  return new OffscreenCanvas(1, 1);
                }
                let L = document.createElement("canvas");
                return ((L.width = 1), (L.height = 1), L);
              })(),
              V,
              W = {
                alpha: !1,
                depth: !1,
                antialias: !1,
                stencil: !1,
                preserveDrawingBuffer: !1,
                premultipliedAlpha: !1,
                failIfMajorPerformanceCaveat: !1,
              };
            if ((!B || B === "webgl2") && ((V = K.getContext("webgl2", W)), V))
              try {
                return new J.WebGLContext(V, 2);
              } catch (L) {
                G.Logger.warning(
                  "GlContextFactory",
                  `failed to create WebGLContext using contextId 'webgl2'. Error: ${L}`
                );
              }
            if (
              (!B || B === "webgl") &&
              ((V =
                K.getContext("webgl", W) ||
                K.getContext("experimental-webgl", W)),
              V)
            )
              try {
                return new J.WebGLContext(V, 1);
              } catch (L) {
                G.Logger.warning(
                  "GlContextFactory",
                  `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${L}`
                );
              }
            throw Error("WebGL is not supported");
          }
          ((Y.createWebGLContext = function B(K) {
            let V;
            ((K && K !== "webgl2") || !("webgl2" in U)
              ? (K && K !== "webgl") || !("webgl" in U) || (V = U.webgl)
              : (V = U.webgl2),
              (V = V || $(K)),
              (K = K || V.version === 1 ? "webgl" : "webgl2"));
            let W = V.gl;
            return (
              (U[K] = V),
              W.isContextLost()
                ? (delete U[K], B(K))
                : (W.disable(W.DEPTH_TEST),
                  W.disable(W.STENCIL_TEST),
                  W.disable(W.BLEND),
                  W.disable(W.DITHER),
                  W.disable(W.POLYGON_OFFSET_FILL),
                  W.disable(W.SAMPLE_COVERAGE),
                  W.enable(W.SCISSOR_TEST),
                  W.enable(W.CULL_FACE),
                  W.cullFace(W.BACK),
                  V)
            );
          }),
            (Y.createNewWebGLContext = $));
        },
        1713: function (X, Y, Q) {
          var G =
              (this && this.__createBinding) ||
              (Object.create
                ? function (W, L, H, F) {
                    F === void 0 && (F = H);
                    var N = Object.getOwnPropertyDescriptor(L, H);
                    ((N &&
                      !("get" in N
                        ? !L.__esModule
                        : N.writable || N.configurable)) ||
                      (N = {
                        enumerable: !0,
                        get: function () {
                          return L[H];
                        },
                      }),
                      Object.defineProperty(W, F, N));
                  }
                : function (W, L, H, F) {
                    (F === void 0 && (F = H), (W[F] = L[H]));
                  }),
            J =
              (this && this.__setModuleDefault) ||
              (Object.create
                ? function (W, L) {
                    Object.defineProperty(W, "default", {
                      enumerable: !0,
                      value: L,
                    });
                  }
                : function (W, L) {
                    W.default = L;
                  }),
            U =
              (this && this.__importStar) ||
              function (W) {
                if (W && W.__esModule) return W;
                var L = {};
                if (W != null)
                  for (var H in W)
                    H !== "default" &&
                      Object.prototype.hasOwnProperty.call(W, H) &&
                      G(L, W, H);
                return (J(L, W), L);
              };
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.WebGLContext = Y.linearSearchLastTrue = void 0));
          let $ = Q(6207),
            B = U(Q(7769)),
            K = Q(9390);
          function V(W) {
            let L = 0;
            for (; L < W.length && W[L](); ++L);
            return L - 1;
          }
          ((Y.linearSearchLastTrue = V),
            (Y.WebGLContext = class {
              constructor(W, L) {
                ((this.frameBufferBound = !1),
                  (this.itemsToPoll = []),
                  (this.gl = W),
                  (this.version = L),
                  this.getExtensions(),
                  (this.vertexbuffer = this.createVertexbuffer()),
                  (this.framebuffer = this.createFramebuffer()),
                  this.queryVitalParameters());
              }
              allocateTexture(W, L, H, F) {
                let N = this.gl,
                  q = N.createTexture();
                (N.bindTexture(N.TEXTURE_2D, q),
                  N.texParameteri(
                    N.TEXTURE_2D,
                    N.TEXTURE_MIN_FILTER,
                    N.NEAREST
                  ),
                  N.texParameteri(
                    N.TEXTURE_2D,
                    N.TEXTURE_MAG_FILTER,
                    N.NEAREST
                  ),
                  N.texParameteri(
                    N.TEXTURE_2D,
                    N.TEXTURE_WRAP_S,
                    N.CLAMP_TO_EDGE
                  ),
                  N.texParameteri(
                    N.TEXTURE_2D,
                    N.TEXTURE_WRAP_T,
                    N.CLAMP_TO_EDGE
                  ));
                let M = F ? H.encode(F, W * L) : null;
                return (
                  N.texImage2D(
                    N.TEXTURE_2D,
                    0,
                    H.internalFormat,
                    W,
                    L,
                    0,
                    H.format,
                    H.textureType,
                    M
                  ),
                  this.checkError(),
                  q
                );
              }
              updateTexture(W, L, H, F, N) {
                let q = this.gl;
                q.bindTexture(q.TEXTURE_2D, W);
                let M = F.encode(N, L * H);
                (q.texSubImage2D(
                  q.TEXTURE_2D,
                  0,
                  0,
                  0,
                  L,
                  H,
                  F.format,
                  F.textureType,
                  M
                ),
                  this.checkError());
              }
              attachFramebuffer(W, L, H) {
                let F = this.gl;
                (F.bindTexture(F.TEXTURE_2D, W),
                  F.bindFramebuffer(F.FRAMEBUFFER, this.framebuffer),
                  F.framebufferTexture2D(
                    F.FRAMEBUFFER,
                    F.COLOR_ATTACHMENT0,
                    F.TEXTURE_2D,
                    W,
                    0
                  ),
                  this.checkError(),
                  F.viewport(0, 0, L, H),
                  F.scissor(0, 0, L, H));
              }
              readTexture(W, L, H, F, N, q) {
                let M = this.gl;
                (q || (q = 1),
                  this.frameBufferBound || this.attachFramebuffer(W, L, H));
                let A = this.getEncoder(N, q),
                  D = A.allocate(L * H);
                return (
                  M.bindTexture(M.TEXTURE_2D, W),
                  M.framebufferTexture2D(
                    M.FRAMEBUFFER,
                    M.COLOR_ATTACHMENT0,
                    M.TEXTURE_2D,
                    W,
                    0
                  ),
                  M.readPixels(0, 0, L, H, M.RGBA, A.textureType, D),
                  this.checkError(),
                  A.decode(D, F)
                );
              }
              isFramebufferReady() {
                return !0;
              }
              getActiveTexture() {
                let W = this.gl;
                return (
                  "TEXTURE" +
                  (W.getParameter(this.gl.ACTIVE_TEXTURE) - W.TEXTURE0)
                );
              }
              getTextureBinding() {
                return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
              }
              getFramebufferBinding() {
                return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
              }
              setVertexAttributes(W, L) {
                let H = this.gl;
                (H.vertexAttribPointer(W, 3, H.FLOAT, !1, 20, 0),
                  H.enableVertexAttribArray(W),
                  L !== -1 &&
                    (H.vertexAttribPointer(L, 2, H.FLOAT, !1, 20, 12),
                    H.enableVertexAttribArray(L)),
                  this.checkError());
              }
              createProgram(W, L) {
                let H = this.gl,
                  F = H.createProgram();
                return (
                  H.attachShader(F, W),
                  H.attachShader(F, L),
                  H.linkProgram(F),
                  F
                );
              }
              compileShader(W, L) {
                let H = this.gl,
                  F = H.createShader(L);
                if (!F)
                  throw Error(`createShader() returned null with type ${L}`);
                if (
                  (H.shaderSource(F, W),
                  H.compileShader(F),
                  H.getShaderParameter(F, H.COMPILE_STATUS) === !1)
                )
                  throw Error(`Failed to compile shader: ${H.getShaderInfoLog(F)}
Shader source:
${W}`);
                return F;
              }
              deleteShader(W) {
                this.gl.deleteShader(W);
              }
              bindTextureToUniform(W, L, H) {
                let F = this.gl;
                (F.activeTexture(F.TEXTURE0 + L),
                  this.checkError(),
                  F.bindTexture(F.TEXTURE_2D, W),
                  this.checkError(),
                  F.uniform1i(H, L),
                  this.checkError());
              }
              draw() {
                (this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4),
                  this.checkError());
              }
              checkError() {
                if ($.env.debug) {
                  let W = this.gl,
                    L = W.getError(),
                    H = "";
                  switch (L) {
                    case W.NO_ERROR:
                      return;
                    case W.INVALID_ENUM:
                      H = "INVALID_ENUM";
                      break;
                    case W.INVALID_VALUE:
                      H = "INVALID_VALUE";
                      break;
                    case W.INVALID_OPERATION:
                      H = "INVALID_OPERATION";
                      break;
                    case W.INVALID_FRAMEBUFFER_OPERATION:
                      H = "INVALID_FRAMEBUFFER_OPERATION";
                      break;
                    case W.OUT_OF_MEMORY:
                      H = "OUT_OF_MEMORY";
                      break;
                    case W.CONTEXT_LOST_WEBGL:
                      H = "CONTEXT_LOST_WEBGL";
                      break;
                    default:
                      H = `Unknown WebGL Error: ${L.toString(16)}`;
                  }
                  throw Error(H);
                }
              }
              deleteTexture(W) {
                this.gl.deleteTexture(W);
              }
              deleteProgram(W) {
                this.gl.deleteProgram(W);
              }
              getEncoder(W, L, H = 0) {
                if (this.version === 2)
                  return new B.RedFloat32DataEncoder(this.gl, L);
                switch (W) {
                  case "float":
                    return H === 1 || this.isRenderFloat32Supported
                      ? new B.RGBAFloatDataEncoder(this.gl, L)
                      : new B.RGBAFloatDataEncoder(
                          this.gl,
                          L,
                          this.textureHalfFloatExtension.HALF_FLOAT_OES
                        );
                  case "int":
                    throw Error("not implemented");
                  case "byte":
                    return new B.Uint8DataEncoder(this.gl, L);
                  default:
                    throw Error(`Invalid dataType: ${W}`);
                }
              }
              clearActiveTextures() {
                let W = this.gl;
                for (let L = 0; L < this.maxTextureImageUnits; ++L)
                  (W.activeTexture(W.TEXTURE0 + L),
                    W.bindTexture(W.TEXTURE_2D, null));
              }
              dispose() {
                if (this.disposed) return;
                let W = this.gl;
                (W.bindFramebuffer(W.FRAMEBUFFER, null),
                  W.deleteFramebuffer(this.framebuffer),
                  W.bindBuffer(W.ARRAY_BUFFER, null),
                  W.deleteBuffer(this.vertexbuffer),
                  W.bindBuffer(W.ELEMENT_ARRAY_BUFFER, null),
                  W.finish(),
                  (this.disposed = !0));
              }
              createDefaultGeometry() {
                return new Float32Array([
                  -1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1,
                  0,
                ]);
              }
              createVertexbuffer() {
                let W = this.gl,
                  L = W.createBuffer();
                if (!L) throw Error("createBuffer() returned null");
                let H = this.createDefaultGeometry();
                return (
                  W.bindBuffer(W.ARRAY_BUFFER, L),
                  W.bufferData(W.ARRAY_BUFFER, H, W.STATIC_DRAW),
                  this.checkError(),
                  L
                );
              }
              createFramebuffer() {
                let W = this.gl.createFramebuffer();
                if (!W) throw Error("createFramebuffer returned null");
                return W;
              }
              queryVitalParameters() {
                let W = this.gl;
                if (
                  ((this.isFloatTextureAttachableToFrameBuffer =
                    this.checkFloatTextureAttachableToFrameBuffer()),
                  (this.isRenderFloat32Supported = this.checkRenderFloat32()),
                  (this.isFloat32DownloadSupported =
                    this.checkFloat32Download()),
                  this.version === 1 &&
                    !this.textureHalfFloatExtension &&
                    !this.isRenderFloat32Supported)
                )
                  throw Error(
                    "both float32 and float16 TextureType are not supported"
                  );
                ((this.isBlendSupported =
                  !this.isRenderFloat32Supported || this.checkFloat32Blend()),
                  (this.maxTextureSize = W.getParameter(W.MAX_TEXTURE_SIZE)),
                  (this.maxTextureImageUnits = W.getParameter(
                    W.MAX_TEXTURE_IMAGE_UNITS
                  )),
                  this.version);
              }
              getExtensions() {
                this.version === 2
                  ? ((this.colorBufferFloatExtension = this.gl.getExtension(
                      "EXT_color_buffer_float"
                    )),
                    (this.disjointTimerQueryWebgl2Extension =
                      this.gl.getExtension("EXT_disjoint_timer_query_webgl2")))
                  : ((this.textureFloatExtension =
                      this.gl.getExtension("OES_texture_float")),
                    (this.textureHalfFloatExtension = this.gl.getExtension(
                      "OES_texture_half_float"
                    )));
              }
              checkFloatTextureAttachableToFrameBuffer() {
                let W = this.gl,
                  L = W.createTexture();
                W.bindTexture(W.TEXTURE_2D, L);
                let H = this.version === 2 ? W.RGBA32F : W.RGBA;
                W.texImage2D(
                  W.TEXTURE_2D,
                  0,
                  H,
                  1,
                  1,
                  0,
                  W.RGBA,
                  W.FLOAT,
                  null
                );
                let F = W.createFramebuffer();
                (W.bindFramebuffer(W.FRAMEBUFFER, F),
                  W.framebufferTexture2D(
                    W.FRAMEBUFFER,
                    W.COLOR_ATTACHMENT0,
                    W.TEXTURE_2D,
                    L,
                    0
                  ));
                let N =
                  W.checkFramebufferStatus(W.FRAMEBUFFER) ===
                  W.FRAMEBUFFER_COMPLETE;
                return (
                  W.bindTexture(W.TEXTURE_2D, null),
                  W.bindFramebuffer(W.FRAMEBUFFER, null),
                  W.deleteTexture(L),
                  W.deleteFramebuffer(F),
                  N
                );
              }
              checkRenderFloat32() {
                if (this.version === 2) {
                  if (!this.colorBufferFloatExtension) return !1;
                } else if (!this.textureFloatExtension) return !1;
                return this.isFloatTextureAttachableToFrameBuffer;
              }
              checkFloat32Download() {
                if (this.version === 2) {
                  if (!this.colorBufferFloatExtension) return !1;
                } else {
                  if (!this.textureFloatExtension) return !1;
                  if (!this.gl.getExtension("WEBGL_color_buffer_float"))
                    return !1;
                }
                return this.isFloatTextureAttachableToFrameBuffer;
              }
              checkFloat32Blend() {
                let W = this.gl,
                  L,
                  H,
                  F,
                  N,
                  q;
                try {
                  ((L = W.createTexture()),
                    (H = W.createFramebuffer()),
                    W.bindTexture(W.TEXTURE_2D, L));
                  let M = this.version === 2 ? W.RGBA32F : W.RGBA;
                  return (
                    W.texImage2D(
                      W.TEXTURE_2D,
                      0,
                      M,
                      1,
                      1,
                      0,
                      W.RGBA,
                      W.FLOAT,
                      null
                    ),
                    W.bindFramebuffer(W.FRAMEBUFFER, H),
                    W.framebufferTexture2D(
                      W.FRAMEBUFFER,
                      W.COLOR_ATTACHMENT0,
                      W.TEXTURE_2D,
                      L,
                      0
                    ),
                    W.enable(W.BLEND),
                    (F = W.createShader(W.VERTEX_SHADER)),
                    !!F &&
                      (W.shaderSource(F, "void main(){}"),
                      W.compileShader(F),
                      (N = W.createShader(W.FRAGMENT_SHADER)),
                      !!N &&
                        (W.shaderSource(
                          N,
                          "precision highp float;void main(){gl_FragColor=vec4(0.5);}"
                        ),
                        W.compileShader(N),
                        (q = W.createProgram()),
                        !!q &&
                          (W.attachShader(q, F),
                          W.attachShader(q, N),
                          W.linkProgram(q),
                          W.useProgram(q),
                          W.drawArrays(W.POINTS, 0, 1),
                          W.getError() === W.NO_ERROR)))
                  );
                } finally {
                  (W.disable(W.BLEND),
                    q && W.deleteProgram(q),
                    F && W.deleteShader(F),
                    N && W.deleteShader(N),
                    H &&
                      (W.bindFramebuffer(W.FRAMEBUFFER, null),
                      W.deleteFramebuffer(H)),
                    L &&
                      (W.bindTexture(W.TEXTURE_2D, null), W.deleteTexture(L)));
                }
              }
              beginTimer() {
                if (
                  this.version === 2 &&
                  this.disjointTimerQueryWebgl2Extension
                ) {
                  let W = this.gl,
                    L = this.disjointTimerQueryWebgl2Extension,
                    H = W.createQuery();
                  return (W.beginQuery(L.TIME_ELAPSED_EXT, H), H);
                }
                throw Error("WebGL1 profiling currently not supported.");
              }
              endTimer() {
                if (
                  this.version !== 2 ||
                  !this.disjointTimerQueryWebgl2Extension
                )
                  throw Error("WebGL1 profiling currently not supported");
                {
                  let W = this.gl,
                    L = this.disjointTimerQueryWebgl2Extension;
                  W.endQuery(L.TIME_ELAPSED_EXT);
                }
              }
              isTimerResultAvailable(W) {
                let L = !1,
                  H = !1;
                if (
                  this.version !== 2 ||
                  !this.disjointTimerQueryWebgl2Extension
                )
                  throw Error("WebGL1 profiling currently not supported");
                {
                  let F = this.gl,
                    N = this.disjointTimerQueryWebgl2Extension;
                  ((L = F.getQueryParameter(W, F.QUERY_RESULT_AVAILABLE)),
                    (H = F.getParameter(N.GPU_DISJOINT_EXT)));
                }
                return L && !H;
              }
              getTimerResult(W) {
                let L = 0;
                if (this.version !== 2)
                  throw Error("WebGL1 profiling currently not supported");
                {
                  let H = this.gl;
                  ((L = H.getQueryParameter(W, H.QUERY_RESULT)),
                    H.deleteQuery(W));
                }
                return L / 1e6;
              }
              async waitForQueryAndGetTime(W) {
                return (
                  await (0, K.repeatedTry)(() =>
                    this.isTimerResultAvailable(W)
                  ),
                  this.getTimerResult(W)
                );
              }
              async createAndWaitForFence() {
                let W = this.createFence(this.gl);
                return this.pollFence(W);
              }
              createFence(W) {
                let L,
                  H = W,
                  F = H.fenceSync(H.SYNC_GPU_COMMANDS_COMPLETE, 0);
                return (
                  W.flush(),
                  (L =
                    F === null
                      ? () => !0
                      : () => {
                          let N = H.clientWaitSync(F, 0, 0);
                          return (
                            N === H.ALREADY_SIGNALED ||
                            N === H.CONDITION_SATISFIED
                          );
                        }),
                  { query: F, isFencePassed: L }
                );
              }
              async pollFence(W) {
                return new Promise((L) => {
                  this.addItemToPoll(
                    () => W.isFencePassed(),
                    () => L()
                  );
                });
              }
              pollItems() {
                let W = V(this.itemsToPoll.map((L) => L.isDoneFn));
                for (let L = 0; L <= W; ++L) {
                  let { resolveFn: H } = this.itemsToPoll[L];
                  H();
                }
                this.itemsToPoll = this.itemsToPoll.slice(W + 1);
              }
              async addItemToPoll(W, L) {
                (this.itemsToPoll.push({ isDoneFn: W, resolveFn: L }),
                  this.itemsToPoll.length > 1 ||
                    (await (0, K.repeatedTry)(
                      () => (this.pollItems(), this.itemsToPoll.length === 0)
                    )));
              }
            }));
        },
        1036: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.ExecutionPlan = void 0));
          let G = Q(3694);
          class J {
            constructor(U, $) {
              ((this.op = U), (this.node = $));
            }
          }
          Y.ExecutionPlan = class {
            constructor(U, $, B) {
              ((this.graph = U), (this.profiler = B), this.initialize($));
            }
            initialize(U) {
              this.profiler.event("session", "ExecutionPlan.initialize", () => {
                let $ = this.graph.getNodes();
                if ($.length !== U.length)
                  throw Error("The size of nodes and OPs do not match.");
                ((this._ops = U.map((B, K) => new J(B, $[K]))),
                  this.reset(),
                  (this._starter = []),
                  this._ops.forEach((B, K) => {
                    let V = !0;
                    for (let W of B.node.inputs)
                      if (
                        !this._values[W] &&
                        this.graph.getInputIndices().indexOf(W) === -1
                      ) {
                        V = !1;
                        break;
                      }
                    V && this._starter.push(K);
                  }));
              });
            }
            reset() {
              this._values = this.graph.getValues().map((U) => U.tensor);
            }
            async execute(U, $) {
              return this.profiler.event(
                "session",
                "ExecutionPlan.execute",
                async () => {
                  this.reset();
                  let B = U.createInferenceHandler(),
                    K = this.graph.getInputIndices();
                  if ($.length !== K.length)
                    throw Error(
                      `number of input tensors don't match the number of inputs to the model: actual: ${$.length} expected: ${K.length}`
                    );
                  $.forEach((N, q) => {
                    let M = K[q];
                    this._values[M] = N;
                  });
                  let V = this._starter.slice(0),
                    W = this.graph.getValues(),
                    L = this.graph.getNodes(),
                    H = 0;
                  for (; H < V.length; ) {
                    let N = V[H++],
                      q = this._ops[N],
                      M = q.node.inputs.map((z) => this._values[z]);
                    if (M.indexOf(void 0) !== -1)
                      throw Error(`unresolved input detected: op: ${q.node}`);
                    let A = M;
                    G.Logger.verbose(
                      "ExecPlan",
                      `Runing op:${q.node.name} (${A.map((z, E) => `'${q.node.inputs[E]}': ${z.type}[${z.dims.join(",")}]`).join(", ")})`
                    );
                    let D = await this.profiler.event(
                      "node",
                      q.node.name,
                      async () => q.op.impl(B, A, q.op.context)
                    );
                    if (D.length !== q.node.outputs.length)
                      throw Error(
                        "the size of output does not match model definition."
                      );
                    D.forEach((z, E) => {
                      let O = q.node.outputs[E];
                      if (this._values[O])
                        throw Error(
                          `output [${O}] already has value: op:${q.node.name}`
                        );
                      this._values[O] = z;
                    });
                    let R = new Set();
                    (D.forEach((z, E) => {
                      let O = q.node.outputs[E];
                      for (let Z of W[O].to) {
                        let j = L[Z],
                          w = !0;
                        for (let I of j.inputs)
                          if (!this._values[I]) {
                            w = !1;
                            break;
                          }
                        w && R.add(Z);
                      }
                    }),
                      V.push(...R));
                  }
                  let F = [];
                  for (
                    let N = 0;
                    N < this.graph.getOutputIndices().length;
                    N++
                  ) {
                    let q = this.graph.getOutputIndices()[N],
                      M = this._values[q];
                    if (M === void 0)
                      throw Error(`required output [${q}] does not have value`);
                    (q === 0 ? await M.getData() : M.data, F.push(M));
                  }
                  return (
                    G.Logger.verbose(
                      "ExecPlan",
                      "disposing of inferenceHandler"
                    ),
                    B.dispose(),
                    F
                  );
                }
              );
            }
          };
        },
        7070: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.Graph = void 0));
          let G = Q(1446),
            J = Q(7778),
            U = Q(9395),
            $ = Q(9162),
            B = Q(2517);
          var K = U.onnxruntime.experimental.fbs;
          Y.Graph = { from: (H, F) => new L(H, F) };
          class V {
            constructor(H) {
              ((this._from = void 0),
                (this._to = []),
                (this.tensor = void 0),
                (this.type = void 0),
                H &&
                  (this.type = B.ProtoUtil.tensorValueTypeFromProto(
                    H.type.tensorType
                  )));
            }
            get from() {
              return this._from;
            }
            get to() {
              return this._to;
            }
          }
          class W {
            constructor(H, F) {
              (H instanceof G.onnx.NodeProto
                ? ((this.name = H.name),
                  (this.opType = H.opType),
                  (this.attributes = new J.Attribute(H.attribute)))
                : H instanceof K.Node &&
                  ((this.name = F != null ? F : H.name()),
                  (this.opType = H.opType()),
                  (this.attributes = new J.Attribute(
                    B.ProtoUtil.tensorAttributesFromORTFormat(H)
                  ))),
                (this.inputs = []),
                (this.outputs = []),
                (this.executeNode = !0));
            }
          }
          class L {
            constructor(H, F) {
              if (!H) throw TypeError("graph is empty");
              (this.buildGraph(H),
                this.transformGraph(F),
                this.checkIsAcyclic());
            }
            getInputIndices() {
              return this._allInputIndices;
            }
            getInputNames() {
              return this._allInputNames;
            }
            getOutputIndices() {
              return this._allOutputIndices;
            }
            getOutputNames() {
              return this._allOutputNames;
            }
            getValues() {
              return this._allData;
            }
            getNodes() {
              return this._nodes;
            }
            buildGraph(H) {
              if (H instanceof G.onnx.GraphProto)
                this.buildGraphFromOnnxFormat(H);
              else {
                if (!(H instanceof K.Graph))
                  throw TypeError("Graph type is not supported.");
                this.buildGraphFromOrtFormat(H);
              }
            }
            buildGraphFromOnnxFormat(H) {
              let F = new Map();
              ((this._allData = []),
                (this._allInputIndices = []),
                (this._allInputNames = []),
                (this._allOutputIndices = []),
                (this._allOutputNames = []),
                (this._nodes = []));
              let N = new Map();
              if (!H.input) throw Error("missing information in graph: input");
              let q = [];
              for (let M of H.input) {
                if (F.has(M.name))
                  throw Error(`duplicated input name: ${M.name}`);
                let A = this._allData.push(new V(M)) - 1;
                (F.set(M.name, A), q.push(M.name));
              }
              if (!H.initializer)
                throw Error("missing information in graph: initializer");
              for (let M of H.initializer) {
                let A = F.get(M.name);
                if (A === void 0) {
                  let D = new V();
                  ((D.type = {
                    shape: { dims: B.ProtoUtil.tensorDimsFromProto(M.dims) },
                    tensorType: B.ProtoUtil.tensorDataTypeFromProto(M.dataType),
                  }),
                    (A = this._allData.push(D) - 1),
                    F.set(M.name, A));
                }
                ((this._allData[A]._from = -1),
                  (this._allData[A].tensor = $.Tensor.fromProto(M)));
              }
              for (let M = 0; M < this._allData.length; M++)
                this._allData[M].tensor ||
                  (this._allInputIndices.push(M),
                  this._allInputNames.push(q[M]));
              if (!H.output)
                throw Error("missing information in graph: output");
              for (let M of H.output) {
                if (F.has(M.name))
                  throw Error(`duplicated output name: ${M.name}`);
                let A = this._allData.push(new V(M)) - 1;
                (F.set(M.name, A),
                  this._allOutputIndices.push(A),
                  this._allOutputNames.push(M.name));
              }
              if (!H.node) throw Error("missing information in graph: node");
              for (let M of H.node) {
                if (!M.name)
                  for (let D = 0; ; D++) {
                    let R = `unnamed_${M.opType}_${D}`;
                    if (!N.has(R)) {
                      M.name = R;
                      break;
                    }
                  }
                if (N.has(M.name))
                  throw Error(`duplicated node name: ${M.name}`);
                let A = this._nodes.push(new W(M)) - 1;
                N.set(M.name, A);
              }
              for (let M = 0; M < this._nodes.length; M++) {
                let A = this._nodes[M],
                  D = H.node[M];
                if (!D.output)
                  throw Error(`missing output for node: ${D.name}`);
                for (let R of D.output) {
                  let z = F.get(R);
                  if (
                    (z === void 0 &&
                      ((z = this._allData.push(new V()) - 1), F.set(R, z)),
                    A.outputs.push(z),
                    this._allData[z]._from !== void 0)
                  )
                    throw Error(
                      `multiple nodes output to one data value: ${z}`
                    );
                  if (((this._allData[z]._from = M), D.opType === "Constant")) {
                    if (
                      !D.attribute ||
                      D.attribute.length !== 1 ||
                      !D.attribute[0].t
                    )
                      throw Error(
                        "missing attributes or missing tensor value in attributes for this Constant operator"
                      );
                    if (!D.output || D.output.length !== 1)
                      throw Error(
                        "missing output or incorrect number of outputs for this Constant operator"
                      );
                    (A.outputs.pop(),
                      (A.executeNode = !1),
                      (this._allData[z]._from = -1),
                      (this._allData[z].tensor = $.Tensor.fromProto(
                        D.attribute[0].t
                      )));
                  }
                }
              }
              for (let M = 0; M < this._nodes.length; M++) {
                let A = this._nodes[M],
                  D = H.node[M];
                if (!D.input) throw Error(`missing input for node: ${D.name}`);
                for (let R of D.input) {
                  let z = F.get(R);
                  if (z === void 0) {
                    if (
                      R === "" &&
                      D.input.length === 3 &&
                      D.opType === "Resize"
                    )
                      continue;
                    throw Error(
                      `unrecognized input '${R}' for node: ${D.name}`
                    );
                  }
                  (A.inputs.push(z), this._allData[z]._to.push(M));
                }
              }
              return !0;
            }
            buildGraphFromOrtFormat(H) {
              var F, N, q;
              let M = new Map();
              ((this._allData = []),
                (this._allInputIndices = []),
                (this._allInputNames = []),
                (this._allOutputIndices = []),
                (this._allOutputNames = []),
                (this._nodes = []));
              let A = new Map(),
                D = [];
              for (let R = 0; R < H.inputsLength(); R++) {
                let z = H.inputs(R);
                if (M.has(z)) throw Error(`duplicated input name: ${z}`);
                for (let E = 0; E < H.nodeArgsLength(); E++)
                  if (
                    ((F = H.nodeArgs(E)) === null || F === void 0
                      ? void 0
                      : F.name()) === z
                  ) {
                    let O = new V();
                    if (
                      ((q =
                        (N = H.nodeArgs(E)) === null || N === void 0
                          ? void 0
                          : N.type()) === null || q === void 0
                        ? void 0
                        : q.valueType()) !== K.TypeInfoValue.tensor_type
                    )
                      throw Error("Unexpected value type for the nodeArg.");
                    let Z = H.nodeArgs(E)
                        .type()
                        .value(new K.TensorTypeAndShape()),
                      j = B.ProtoUtil.tensorDataTypeFromProto(Z.elemType()),
                      w = Z.shape(),
                      I = [];
                    for (let y = 0; y < w.dimLength(); y++)
                      I.push(
                        B.LongUtil.longToNumber(w.dim(y).value().dimValue())
                      );
                    O.type = { shape: { dims: I }, tensorType: j };
                    let T = this._allData.push(O) - 1;
                    (M.set(z, T), D.push(z));
                  }
              }
              for (let R = 0; R < H.initializersLength(); R++) {
                let z = H.initializers(R),
                  E = M.get(z.name());
                if (E === void 0) {
                  let O = new V(),
                    Z = B.ProtoUtil.tensorDimsFromORTFormat(z),
                    j = B.ProtoUtil.tensorDataTypeFromProto(z.dataType());
                  ((O.type = { shape: { dims: Z }, tensorType: j }),
                    (E = this._allData.push(O) - 1),
                    M.set(z.name(), E));
                }
                ((this._allData[E]._from = -1),
                  (this._allData[E].tensor = $.Tensor.fromOrtTensor(z)));
              }
              for (let R = 0; R < this._allData.length; R++)
                this._allData[R].tensor ||
                  (this._allInputIndices.push(R),
                  this._allInputNames.push(D[R]));
              for (let R = 0; R < H.outputsLength(); R++) {
                let z = H.outputs(R);
                if (M.has(z)) throw Error(`duplicated output name: ${z}`);
                let E = this._allData.push(new V()) - 1;
                (M.set(z, E),
                  this._allOutputIndices.push(E),
                  this._allOutputNames.push(z));
              }
              if (!H.nodes) throw Error("missing information in graph: node");
              for (let R = 0; R < H.nodesLength(); R++) {
                let z = H.nodes(R),
                  E = z.name();
                if (!E)
                  for (
                    let Z = 0;
                    (E = `unnamed_${z.opType()}_${Z}`), A.has(E);
                    Z++
                  );
                if (A.has(E)) throw Error(`duplicated node name: ${E}`);
                let O = this._nodes.push(new W(z, E)) - 1;
                A.set(E, O);
              }
              for (let R = 0; R < this._nodes.length; R++) {
                let z = this._nodes[R],
                  E = H.nodes(R);
                if (E == null) throw Error(`No node exists at index ${R}`);
                if ((E == null ? void 0 : E.outputsLength()) === 0)
                  throw Error(`missing output for node: ${E.name}`);
                for (
                  let O = 0;
                  O < (E == null ? void 0 : E.outputsLength());
                  O++
                ) {
                  let Z = E == null ? void 0 : E.outputs(O),
                    j = M.get(Z);
                  if (
                    (j === void 0 &&
                      ((j = this._allData.push(new V()) - 1), M.set(Z, j)),
                    z.outputs.push(j),
                    this._allData[j]._from !== void 0)
                  )
                    throw Error(
                      `multiple nodes output to one data value: ${j}`
                    );
                  if (
                    ((this._allData[j]._from = R), E.opType() === "Constant")
                  ) {
                    if (E.attributesLength() !== 1 || !E.attributes(0).t())
                      throw Error(
                        "missing attributes or missing tensor value in attributes for this Constant operator"
                      );
                    if (E.outputsLength() !== 1)
                      throw Error(
                        "missing output or incorrect number of outputs for this Constant operator"
                      );
                    (z.outputs.pop(),
                      (z.executeNode = !1),
                      (this._allData[j]._from = -1),
                      (this._allData[j].tensor = $.Tensor.fromOrtTensor(
                        E.attributes(0).t()
                      )));
                  }
                }
              }
              for (let R = 0; R < this._nodes.length; R++) {
                let z = this._nodes[R],
                  E = H.nodes(R);
                if (E.inputsLength() === 0)
                  throw Error(`missing input for node: ${E.name}`);
                for (let O = 0; O < E.inputsLength(); O++) {
                  let Z = E.inputs(O),
                    j = M.get(Z);
                  if (j === void 0)
                    throw Error(
                      `unrecognized input '${Z}' for node: ${E.name()}`
                    );
                  (z.inputs.push(j), this._allData[j]._to.push(R));
                }
              }
            }
            checkIsAcyclic() {
              let H = new Set();
              this._allInputIndices.forEach((q) => {
                this._allData[q]._to.forEach((M) => {
                  H.add(M);
                });
              });
              let F = Array.from(H),
                N = Array(this._nodes.length).fill("white");
              for (; F.length > 0; ) {
                let q = F.pop();
                N[q] === "gray"
                  ? (N[q] = "black")
                  : (F.push(q),
                    (N[q] = "gray"),
                    this._nodes[q].outputs.forEach((M) => {
                      let A = this._allData[M];
                      if (A.tensor !== void 0)
                        throw Error("node outputs should not be initialized");
                      if (A._from !== q)
                        throw Error(
                          "from property of the Value object doesn't match index of Node being processed"
                        );
                      A._to.forEach((D) => {
                        if (N[D] === "gray")
                          throw Error("model graph is cyclic");
                        N[D] === "white" && F.push(D);
                      });
                    }));
              }
            }
            transformGraph(H) {
              (this.removeAllIdentityNodes(),
                this.removeAllDropoutNodes(),
                this.fuseConvActivationNodes(),
                H && H.transformGraph(this),
                this.finalizeGraph());
            }
            finalizeGraph() {
              let H = 0;
              for (let F = 0; F < this._nodes.length; F++)
                this._nodes[F].executeNode
                  ? H > 0 &&
                    (this._nodes[F].inputs.forEach((N) => {
                      let q = this._allData[N]._to.indexOf(F + H);
                      q !== -1 && (this._allData[N]._to[q] = F);
                    }),
                    this._nodes[F].outputs.forEach((N) => {
                      this._allData[N]._from &&
                        this._allData[N]._from === F + H &&
                        (this._allData[N]._from = F);
                    }))
                  : (H++,
                    this._nodes[F].outputs.forEach((N) => {
                      this._allData[N]._from = -2;
                    }),
                    this._nodes.splice(F, 1),
                    F--);
              H = 0;
              for (let F = 0; F < this._allData.length; F++)
                if (
                  this._allData[F].from !== -2 ||
                  this._allOutputIndices.indexOf(F + H) !== -1
                ) {
                  if (H > 0) {
                    let N = -1;
                    (this._allData[F].from !== void 0 &&
                    this._allData[F].from !== -1
                      ? ((N = this._nodes[
                          this._allData[F].from
                        ].outputs.indexOf(F + H)),
                        N !== -1 &&
                          (this._nodes[this._allData[F].from].outputs[N] = F))
                      : ((N = this._allInputIndices.indexOf(F + H)),
                        N !== -1 && (this._allInputIndices[N] = F)),
                      this._allData[F].to.forEach((q) => {
                        ((N = this._nodes[q].inputs.indexOf(F + H)),
                          N !== -1 && (this._nodes[q].inputs[N] = F));
                      }),
                      this._allData[F].to.length === 0 &&
                        ((N = this._allOutputIndices.indexOf(F + H)),
                        N !== -1 && (this._allOutputIndices[N] = F)));
                  }
                } else (H++, this._allData.splice(F, 1), F--);
            }
            deleteNode(H) {
              let F = this._nodes[H];
              if (F.outputs.length > 1) {
                for (let R = 1; R < F.outputs.length; R++)
                  if (this._allData[F.outputs[R]].to.length > 0)
                    throw Error(
                      "Node deletion with more than one output connected to other nodes is not supported. "
                    );
              }
              F.executeNode = !1;
              let N = F.inputs[0],
                q = F.outputs[0],
                M = this._allData[q].to,
                A = this._allData[N].to.indexOf(H);
              if (A === -1)
                throw Error(
                  "The Value object doesn't have the current Node in it's 'to' property "
                );
              (this._allData[N].to.splice(A, 1), (this._allData[q]._to = []));
              let D = this._allOutputIndices.indexOf(q);
              if (
                (D !== -1 && (this._allOutputIndices[D] = N), M && M.length > 0)
              )
                for (let R of M) {
                  let z = this._nodes[R].inputs.indexOf(q);
                  if (z === -1)
                    throw Error(
                      "The Node object doesn't have the output Value in it's 'inputs' property "
                    );
                  ((this._nodes[R].inputs[z] = N), this._allData[N].to.push(R));
                }
            }
            removeAllDropoutNodes() {
              let H = 0;
              for (let F of this._nodes) {
                if (F.opType === "Dropout") {
                  if (F.inputs.length !== 1)
                    throw Error(
                      "Dropout nodes should only contain one input. "
                    );
                  if (F.outputs.length !== 1 && F.outputs.length !== 2)
                    throw Error(
                      "Dropout nodes should contain either 1 or 2 output(s)"
                    );
                  if (
                    F.outputs.length === 2 &&
                    this._allData[F.outputs[1]]._to.length !== 0
                  )
                    throw Error(
                      "Dropout nodes's second output should not be referenced by other nodes"
                    );
                  this.deleteNode(H);
                }
                H++;
              }
            }
            removeAllIdentityNodes() {
              let H = 0;
              for (let F of this._nodes)
                (F.opType === "Identity" && this.deleteNode(H), H++);
            }
            isActivation(H) {
              switch (H.opType) {
                case "Relu":
                case "Sigmoid":
                case "Clip":
                  return !0;
                default:
                  return !1;
              }
            }
            fuseConvActivationNodes() {
              for (let H of this._nodes)
                if (H.opType === "Conv") {
                  let F = this._allData[H.outputs[0]]._to;
                  if (F.length === 1 && this.isActivation(this._nodes[F[0]])) {
                    let N = this._nodes[F[0]];
                    if (N.opType === "Clip")
                      if (N.inputs.length === 1)
                        try {
                          H.attributes.set("activation_params", "floats", [
                            N.attributes.getFloat("min"),
                            N.attributes.getFloat("max"),
                          ]);
                        } catch (q) {
                          H.attributes.set("activation_params", "floats", [
                            B.MIN_CLIP,
                            B.MAX_CLIP,
                          ]);
                        }
                      else {
                        if (
                          !(
                            N.inputs.length >= 3 &&
                            this._allData[N.inputs[1]].tensor !== void 0 &&
                            this._allData[N.inputs[2]].tensor !== void 0
                          )
                        )
                          continue;
                        H.attributes.set("activation_params", "floats", [
                          this._allData[N.inputs[1]].tensor.floatData[0],
                          this._allData[N.inputs[2]].tensor.floatData[0],
                        ]);
                      }
                    (H.attributes.set("activation", "string", N.opType),
                      this.deleteNode(F[0]));
                  }
                }
            }
          }
        },
        3694: (X, Y) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.now = Y.Profiler = Y.Logger = void 0));
          let Q = {
              verbose: 1000,
              info: 2000,
              warning: 4000,
              error: 5000,
              fatal: 6000,
            },
            G = {
              none: new (class {
                log(W, L, H) {}
              })(),
              console: new (class {
                log(W, L, H) {
                  console.log(
                    `${this.color(W)} ${H ? "\x1B[35m" + H + "\x1B[0m " : ""}${L}`
                  );
                }
                color(W) {
                  switch (W) {
                    case "verbose":
                      return "\x1B[34;40mv\x1B[0m";
                    case "info":
                      return "\x1B[32mi\x1B[0m";
                    case "warning":
                      return "\x1B[30;43mw\x1B[0m";
                    case "error":
                      return "\x1B[31;40me\x1B[0m";
                    case "fatal":
                      return "\x1B[101mf\x1B[0m";
                    default:
                      throw Error(`unsupported severity: ${W}`);
                  }
                }
              })(),
            },
            J = {
              provider: "console",
              minimalSeverity: "warning",
              logDateTime: !0,
              logSourceLocation: !1,
            },
            U = { "": J };
          function $(W, L, H, F) {
            if (L === void 0)
              return (
                (N = W),
                {
                  verbose: $.verbose.bind(null, N),
                  info: $.info.bind(null, N),
                  warning: $.warning.bind(null, N),
                  error: $.error.bind(null, N),
                  fatal: $.fatal.bind(null, N),
                }
              );
            if (H === void 0) B(W, L);
            else if (typeof H == "number" && F === void 0) B(W, L);
            else if (typeof H == "string" && F === void 0) B(W, H, 0, L);
            else {
              if (typeof H != "string" || typeof F != "number")
                throw TypeError("input is valid");
              B(W, H, 0, L);
            }
            var N;
          }
          function B(W, L, H, F) {
            let N = U[F || ""] || U[""];
            Q[W] < Q[N.minimalSeverity] ||
              (N.logDateTime && (L = `${new Date().toISOString()}|${L}`),
              N.logSourceLocation,
              G[N.provider].log(W, L, F));
          }
          ((function (W) {
            function L(F) {
              ((U = {}), H("", F || {}));
            }
            function H(F, N) {
              if (F === "*") L(N);
              else {
                let q = U[F] || J;
                U[F] = {
                  provider: N.provider || q.provider,
                  minimalSeverity: N.minimalSeverity || q.minimalSeverity,
                  logDateTime:
                    N.logDateTime === void 0 ? q.logDateTime : N.logDateTime,
                  logSourceLocation:
                    N.logSourceLocation === void 0
                      ? q.logSourceLocation
                      : N.logSourceLocation,
                };
              }
            }
            ((W.verbose = function (F, N) {
              W("verbose", F, N);
            }),
              (W.info = function (F, N) {
                W("info", F, N);
              }),
              (W.warning = function (F, N) {
                W("warning", F, N);
              }),
              (W.error = function (F, N) {
                W("error", F, N);
              }),
              (W.fatal = function (F, N) {
                W("fatal", F, N);
              }),
              (W.reset = L),
              (W.set = H),
              (W.setWithEnv = function (F) {
                let N = {};
                (F.logLevel && (N.minimalSeverity = F.logLevel), H("", N));
              }));
          })($ || ($ = {})),
            (Y.Logger = $));
          class K {
            constructor(W, L, H, F, N, q) {
              ((this.category = W),
                (this.name = L),
                (this.startTime = H),
                (this.endCallback = F),
                (this.timer = N),
                (this.ctx = q));
            }
            end() {
              return this.endCallback(this);
            }
            async checkTimer() {
              if (this.ctx === void 0 || this.timer === void 0)
                throw Error("No webgl timer found");
              return (
                this.ctx.endTimer(),
                this.ctx.waitForQueryAndGetTime(this.timer)
              );
            }
          }
          class V {
            constructor(W, L, H, F) {
              ((this.category = W),
                (this.name = L),
                (this.startTime = H),
                (this.endTime = F));
            }
          }
          ((Y.Profiler = class {
            static create(W) {
              return W === void 0
                ? new this()
                : new this(
                    W.maxNumberEvents,
                    W.flushBatchSize,
                    W.flushIntervalInMilliseconds
                  );
            }
            constructor(W, L, H) {
              ((this._started = !1),
                (this._flushPointer = 0),
                (this._started = !1),
                (this._maxNumberEvents = W === void 0 ? 1e4 : W),
                (this._flushBatchSize = L === void 0 ? 10 : L),
                (this._flushIntervalInMilliseconds = H === void 0 ? 5000 : H));
            }
            start() {
              ((this._started = !0),
                (this._timingEvents = []),
                (this._flushTime = (0, Y.now)()),
                (this._flushPointer = 0));
            }
            stop() {
              for (
                this._started = !1;
                this._flushPointer < this._timingEvents.length;
                this._flushPointer++
              )
                this.logOneEvent(this._timingEvents[this._flushPointer]);
            }
            event(W, L, H, F) {
              let N = this._started ? this.begin(W, L, F) : void 0,
                q = !1,
                M = H();
              if (M && typeof M.then == "function")
                return (
                  (q = !0),
                  new Promise((A, D) => {
                    M.then(
                      async (R) => {
                        (N && (await N.end()), A(R));
                      },
                      async (R) => {
                        (N && (await N.end()), D(R));
                      }
                    );
                  })
                );
              if (!q && N) {
                let A = N.end();
                if (A && typeof A.then == "function")
                  return new Promise((D, R) => {
                    A.then(
                      () => {
                        D(M);
                      },
                      (z) => {
                        R(z);
                      }
                    );
                  });
              }
              return M;
            }
            begin(W, L, H) {
              if (!this._started) throw Error("profiler is not started yet");
              if (H === void 0) {
                let F = (0, Y.now)();
                return (this.flush(F), new K(W, L, F, (N) => this.endSync(N)));
              }
              {
                let F = H.beginTimer();
                return new K(W, L, 0, async (N) => this.end(N), F, H);
              }
            }
            async end(W) {
              let L = await W.checkTimer();
              this._timingEvents.length < this._maxNumberEvents &&
                (this._timingEvents.push(
                  new V(W.category, W.name, W.startTime, L)
                ),
                this.flush(L));
            }
            endSync(W) {
              let L = (0, Y.now)();
              this._timingEvents.length < this._maxNumberEvents &&
                (this._timingEvents.push(
                  new V(W.category, W.name, W.startTime, L)
                ),
                this.flush(L));
            }
            logOneEvent(W) {
              Y.Logger.verbose(
                `Profiler.${W.category}`,
                `${(W.endTime - W.startTime).toFixed(2)}ms on event '${W.name}' at ${W.endTime.toFixed(2)}`
              );
            }
            flush(W) {
              if (
                this._timingEvents.length - this._flushPointer >=
                  this._flushBatchSize ||
                W - this._flushTime >= this._flushIntervalInMilliseconds
              ) {
                for (
                  let L = this._flushPointer;
                  this._flushPointer < L + this._flushBatchSize &&
                  this._flushPointer < this._timingEvents.length;
                  this._flushPointer++
                )
                  this.logOneEvent(this._timingEvents[this._flushPointer]);
                this._flushTime = (0, Y.now)();
              }
            }
            get started() {
              return this._started;
            }
          }),
            (Y.now =
              typeof performance < "u" && performance.now
                ? () => performance.now()
                : Date.now));
        },
        2644: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.Model = void 0));
          let G = Q(5686),
            J = Q(1446),
            U = Q(7070),
            $ = Q(9395),
            B = Q(2517);
          var K = $.onnxruntime.experimental.fbs;
          Y.Model = class {
            constructor() {}
            load(V, W, L) {
              if (!L)
                try {
                  return void this.loadFromOnnxFormat(V, W);
                } catch (H) {
                  if (L !== void 0) throw H;
                }
              this.loadFromOrtFormat(V, W);
            }
            loadFromOnnxFormat(V, W) {
              let L = J.onnx.ModelProto.decode(V);
              if (B.LongUtil.longToNumber(L.irVersion) < 3)
                throw Error("only support ONNX model with IR_VERSION>=3");
              ((this._opsets = L.opsetImport.map((H) => ({
                domain: H.domain,
                version: B.LongUtil.longToNumber(H.version),
              }))),
                (this._graph = U.Graph.from(L.graph, W)));
            }
            loadFromOrtFormat(V, W) {
              let L = new G.flatbuffers.ByteBuffer(V),
                H = K.InferenceSession.getRootAsInferenceSession(L).model();
              if (B.LongUtil.longToNumber(H.irVersion()) < 3)
                throw Error("only support ONNX model with IR_VERSION>=3");
              this._opsets = [];
              for (let F = 0; F < H.opsetImportLength(); F++) {
                let N = H.opsetImport(F);
                this._opsets.push({
                  domain: N == null ? void 0 : N.domain(),
                  version: B.LongUtil.longToNumber(N.version()),
                });
              }
              this._graph = U.Graph.from(H.graph(), W);
            }
            get graph() {
              return this._graph;
            }
            get opsets() {
              return this._opsets;
            }
          };
        },
        782: (X, Y) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.FLOAT_TYPES = Y.INT_TYPES = Y.NUMBER_TYPES = void 0),
            (Y.NUMBER_TYPES = [
              "float32",
              "float64",
              "int32",
              "int16",
              "int8",
              "uint16",
              "uint32",
              "uint8",
            ]),
            (Y.INT_TYPES = [
              "int32",
              "int16",
              "int8",
              "uint16",
              "uint32",
              "uint8",
            ]),
            (Y.FLOAT_TYPES = ["float32", "float64"]));
        },
        1047: (X, Y) => {
          function Q(G, J) {
            if (J.endsWith("+")) {
              let U = Number.parseInt(J.substring(0, J.length - 1), 10);
              return !isNaN(U) && U <= G;
            }
            if (J.split("-").length === 2) {
              let U = J.split("-"),
                $ = Number.parseInt(U[0], 10),
                B = Number.parseInt(U[1], 10);
              return !isNaN($) && !isNaN(B) && $ <= G && G <= B;
            }
            return Number.parseInt(J, 10) === G;
          }
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.resolveOperator = void 0),
            (Y.resolveOperator = function (G, J, U) {
              for (let $ of U) {
                let B = $[0],
                  K = $[1],
                  V = $[2],
                  W = $[3],
                  L = $[4];
                if (G.opType === B) {
                  for (let H of J)
                    if (
                      (H.domain === K ||
                        (H.domain === "ai.onnx" && K === "")) &&
                      Q(H.version, V)
                    )
                      return { opImpl: W, opInit: L };
                }
              }
              throw TypeError(
                `cannot resolve operator '${G.opType}' with opsets: ${J.map(($) => `${$.domain || "ai.onnx"} v${$.version}`).join(", ")}`
              );
            }));
        },
        9395: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.onnxruntime = void 0));
          let G = Q(5686);
          var J, U;
          ((J = Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              let B;
              (function (K) {
                ((K[(K.UNDEFINED = 0)] = "UNDEFINED"),
                  (K[(K.FLOAT = 1)] = "FLOAT"),
                  (K[(K.INT = 2)] = "INT"),
                  (K[(K.STRING = 3)] = "STRING"),
                  (K[(K.TENSOR = 4)] = "TENSOR"),
                  (K[(K.GRAPH = 5)] = "GRAPH"),
                  (K[(K.FLOATS = 6)] = "FLOATS"),
                  (K[(K.INTS = 7)] = "INTS"),
                  (K[(K.STRINGS = 8)] = "STRINGS"),
                  (K[(K.TENSORS = 9)] = "TENSORS"),
                  (K[(K.GRAPHS = 10)] = "GRAPHS"),
                  (K[(K.SPARSE_TENSOR = 11)] = "SPARSE_TENSOR"),
                  (K[(K.SPARSE_TENSORS = 12)] = "SPARSE_TENSORS"));
              })((B = $.AttributeType || ($.AttributeType = {})));
            })(
              (U = J.experimental || (J.experimental = {})).fbs || (U.fbs = {})
            ),
            (function ($) {
              (function (B) {
                (function (K) {
                  let V;
                  (function (W) {
                    ((W[(W.UNKNOWN = 0)] = "UNKNOWN"),
                      (W[(W.VALUE = 1)] = "VALUE"),
                      (W[(W.PARAM = 2)] = "PARAM"));
                  })((V = K.DimensionValueType || (K.DimensionValueType = {})));
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  let V;
                  (function (W) {
                    ((W[(W.UNDEFINED = 0)] = "UNDEFINED"),
                      (W[(W.FLOAT = 1)] = "FLOAT"),
                      (W[(W.UINT8 = 2)] = "UINT8"),
                      (W[(W.INT8 = 3)] = "INT8"),
                      (W[(W.UINT16 = 4)] = "UINT16"),
                      (W[(W.INT16 = 5)] = "INT16"),
                      (W[(W.INT32 = 6)] = "INT32"),
                      (W[(W.INT64 = 7)] = "INT64"),
                      (W[(W.STRING = 8)] = "STRING"),
                      (W[(W.BOOL = 9)] = "BOOL"),
                      (W[(W.FLOAT16 = 10)] = "FLOAT16"),
                      (W[(W.DOUBLE = 11)] = "DOUBLE"),
                      (W[(W.UINT32 = 12)] = "UINT32"),
                      (W[(W.UINT64 = 13)] = "UINT64"),
                      (W[(W.COMPLEX64 = 14)] = "COMPLEX64"),
                      (W[(W.COMPLEX128 = 15)] = "COMPLEX128"),
                      (W[(W.BFLOAT16 = 16)] = "BFLOAT16"));
                  })((V = K.TensorDataType || (K.TensorDataType = {})));
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  let V;
                  (function (W) {
                    ((W[(W.Primitive = 0)] = "Primitive"),
                      (W[(W.Fused = 1)] = "Fused"));
                  })((V = K.NodeType || (K.NodeType = {})));
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  let V;
                  (function (W) {
                    ((W[(W.NONE = 0)] = "NONE"),
                      (W[(W.tensor_type = 1)] = "tensor_type"),
                      (W[(W.sequence_type = 2)] = "sequence_type"),
                      (W[(W.map_type = 3)] = "map_type"));
                  })((V = K.TypeInfoValue || (K.TypeInfoValue = {})));
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsShape(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsShape(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    dim(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 4);
                      return H
                        ? (L || new $.experimental.fbs.Dimension()).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    dimLength() {
                      let W = this.bb.__offset(this.bb_pos, 4);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    static startShape(W) {
                      W.startObject(1);
                    }
                    static addDim(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static createDimVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startDimVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static endShape(W) {
                      return W.endObject();
                    }
                    static createShape(W, L) {
                      return (V.startShape(W), V.addDim(W, L), V.endShape(W));
                    }
                  }
                  K.Shape = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsDimension(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsDimension(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    value(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L
                        ? (W || new $.experimental.fbs.DimensionValue()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    denotation(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    static startDimension(W) {
                      W.startObject(2);
                    }
                    static addValue(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addDenotation(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static endDimension(W) {
                      return W.endObject();
                    }
                    static createDimension(W, L, H) {
                      return (
                        V.startDimension(W),
                        V.addValue(W, L),
                        V.addDenotation(W, H),
                        V.endDimension(W)
                      );
                    }
                  }
                  K.Dimension = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsDimensionValue(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsDimensionValue(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    dimType() {
                      let W = this.bb.__offset(this.bb_pos, 4);
                      return W
                        ? this.bb.readInt8(this.bb_pos + W)
                        : $.experimental.fbs.DimensionValueType.UNKNOWN;
                    }
                    dimValue() {
                      let W = this.bb.__offset(this.bb_pos, 6);
                      return W
                        ? this.bb.readInt64(this.bb_pos + W)
                        : this.bb.createLong(0, 0);
                    }
                    dimParam(W) {
                      let L = this.bb.__offset(this.bb_pos, 8);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    static startDimensionValue(W) {
                      W.startObject(3);
                    }
                    static addDimType(W, L) {
                      W.addFieldInt8(
                        0,
                        L,
                        $.experimental.fbs.DimensionValueType.UNKNOWN
                      );
                    }
                    static addDimValue(W, L) {
                      W.addFieldInt64(1, L, W.createLong(0, 0));
                    }
                    static addDimParam(W, L) {
                      W.addFieldOffset(2, L, 0);
                    }
                    static endDimensionValue(W) {
                      return W.endObject();
                    }
                    static createDimensionValue(W, L, H, F) {
                      return (
                        V.startDimensionValue(W),
                        V.addDimType(W, L),
                        V.addDimValue(W, H),
                        V.addDimParam(W, F),
                        V.endDimensionValue(W)
                      );
                    }
                  }
                  K.DimensionValue = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsTensorTypeAndShape(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsTensorTypeAndShape(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    elemType() {
                      let W = this.bb.__offset(this.bb_pos, 4);
                      return W
                        ? this.bb.readInt32(this.bb_pos + W)
                        : $.experimental.fbs.TensorDataType.UNDEFINED;
                    }
                    shape(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L
                        ? (W || new $.experimental.fbs.Shape()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    static startTensorTypeAndShape(W) {
                      W.startObject(2);
                    }
                    static addElemType(W, L) {
                      W.addFieldInt32(
                        0,
                        L,
                        $.experimental.fbs.TensorDataType.UNDEFINED
                      );
                    }
                    static addShape(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static endTensorTypeAndShape(W) {
                      return W.endObject();
                    }
                    static createTensorTypeAndShape(W, L, H) {
                      return (
                        V.startTensorTypeAndShape(W),
                        V.addElemType(W, L),
                        V.addShape(W, H),
                        V.endTensorTypeAndShape(W)
                      );
                    }
                  }
                  K.TensorTypeAndShape = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsMapType(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsMapType(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    keyType() {
                      let W = this.bb.__offset(this.bb_pos, 4);
                      return W
                        ? this.bb.readInt32(this.bb_pos + W)
                        : $.experimental.fbs.TensorDataType.UNDEFINED;
                    }
                    valueType(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L
                        ? (W || new $.experimental.fbs.TypeInfo()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    static startMapType(W) {
                      W.startObject(2);
                    }
                    static addKeyType(W, L) {
                      W.addFieldInt32(
                        0,
                        L,
                        $.experimental.fbs.TensorDataType.UNDEFINED
                      );
                    }
                    static addValueType(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static endMapType(W) {
                      return W.endObject();
                    }
                    static createMapType(W, L, H) {
                      return (
                        V.startMapType(W),
                        V.addKeyType(W, L),
                        V.addValueType(W, H),
                        V.endMapType(W)
                      );
                    }
                  }
                  K.MapType = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsSequenceType(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsSequenceType(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    elemType(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L
                        ? (W || new $.experimental.fbs.TypeInfo()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    static startSequenceType(W) {
                      W.startObject(1);
                    }
                    static addElemType(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static endSequenceType(W) {
                      return W.endObject();
                    }
                    static createSequenceType(W, L) {
                      return (
                        V.startSequenceType(W),
                        V.addElemType(W, L),
                        V.endSequenceType(W)
                      );
                    }
                  }
                  K.SequenceType = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (B.fbs || (B.fbs = {})).EdgeEnd = class {
                  constructor() {
                    ((this.bb = null), (this.bb_pos = 0));
                  }
                  __init(K, V) {
                    return ((this.bb_pos = K), (this.bb = V), this);
                  }
                  nodeIndex() {
                    return this.bb.readUint32(this.bb_pos);
                  }
                  srcArgIndex() {
                    return this.bb.readInt32(this.bb_pos + 4);
                  }
                  dstArgIndex() {
                    return this.bb.readInt32(this.bb_pos + 8);
                  }
                  static createEdgeEnd(K, V, W, L) {
                    return (
                      K.prep(4, 12),
                      K.writeInt32(L),
                      K.writeInt32(W),
                      K.writeInt32(V),
                      K.offset()
                    );
                  }
                };
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsNodeEdge(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsNodeEdge(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    nodeIndex() {
                      let W = this.bb.__offset(this.bb_pos, 4);
                      return W ? this.bb.readUint32(this.bb_pos + W) : 0;
                    }
                    inputEdges(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 6);
                      return H
                        ? (L || new $.experimental.fbs.EdgeEnd()).__init(
                            this.bb.__vector(this.bb_pos + H) + 12 * W,
                            this.bb
                          )
                        : null;
                    }
                    inputEdgesLength() {
                      let W = this.bb.__offset(this.bb_pos, 6);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    outputEdges(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 8);
                      return H
                        ? (L || new $.experimental.fbs.EdgeEnd()).__init(
                            this.bb.__vector(this.bb_pos + H) + 12 * W,
                            this.bb
                          )
                        : null;
                    }
                    outputEdgesLength() {
                      let W = this.bb.__offset(this.bb_pos, 8);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    static startNodeEdge(W) {
                      W.startObject(3);
                    }
                    static addNodeIndex(W, L) {
                      W.addFieldInt32(0, L, 0);
                    }
                    static addInputEdges(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static startInputEdgesVector(W, L) {
                      W.startVector(12, L, 4);
                    }
                    static addOutputEdges(W, L) {
                      W.addFieldOffset(2, L, 0);
                    }
                    static startOutputEdgesVector(W, L) {
                      W.startVector(12, L, 4);
                    }
                    static endNodeEdge(W) {
                      return W.endObject();
                    }
                    static createNodeEdge(W, L, H, F) {
                      return (
                        V.startNodeEdge(W),
                        V.addNodeIndex(W, L),
                        V.addInputEdges(W, H),
                        V.addOutputEdges(W, F),
                        V.endNodeEdge(W)
                      );
                    }
                  }
                  K.NodeEdge = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsNode(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsNode(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    name(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    docString(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    domain(W) {
                      let L = this.bb.__offset(this.bb_pos, 8);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    sinceVersion() {
                      let W = this.bb.__offset(this.bb_pos, 10);
                      return W ? this.bb.readInt32(this.bb_pos + W) : 0;
                    }
                    index() {
                      let W = this.bb.__offset(this.bb_pos, 12);
                      return W ? this.bb.readUint32(this.bb_pos + W) : 0;
                    }
                    opType(W) {
                      let L = this.bb.__offset(this.bb_pos, 14);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    type() {
                      let W = this.bb.__offset(this.bb_pos, 16);
                      return W
                        ? this.bb.readInt32(this.bb_pos + W)
                        : $.experimental.fbs.NodeType.Primitive;
                    }
                    executionProviderType(W) {
                      let L = this.bb.__offset(this.bb_pos, 18);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    inputs(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 20);
                      return H
                        ? this.bb.__string(
                            this.bb.__vector(this.bb_pos + H) + 4 * W,
                            L
                          )
                        : null;
                    }
                    inputsLength() {
                      let W = this.bb.__offset(this.bb_pos, 20);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    outputs(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 22);
                      return H
                        ? this.bb.__string(
                            this.bb.__vector(this.bb_pos + H) + 4 * W,
                            L
                          )
                        : null;
                    }
                    outputsLength() {
                      let W = this.bb.__offset(this.bb_pos, 22);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    attributes(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 24);
                      return H
                        ? (L || new $.experimental.fbs.Attribute()).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    attributesLength() {
                      let W = this.bb.__offset(this.bb_pos, 24);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    inputArgCounts(W) {
                      let L = this.bb.__offset(this.bb_pos, 26);
                      return L
                        ? this.bb.readInt32(
                            this.bb.__vector(this.bb_pos + L) + 4 * W
                          )
                        : 0;
                    }
                    inputArgCountsLength() {
                      let W = this.bb.__offset(this.bb_pos, 26);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    inputArgCountsArray() {
                      let W = this.bb.__offset(this.bb_pos, 26);
                      return W
                        ? new Int32Array(
                            this.bb.bytes().buffer,
                            this.bb.bytes().byteOffset +
                              this.bb.__vector(this.bb_pos + W),
                            this.bb.__vector_len(this.bb_pos + W)
                          )
                        : null;
                    }
                    implicitInputs(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 28);
                      return H
                        ? this.bb.__string(
                            this.bb.__vector(this.bb_pos + H) + 4 * W,
                            L
                          )
                        : null;
                    }
                    implicitInputsLength() {
                      let W = this.bb.__offset(this.bb_pos, 28);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    static startNode(W) {
                      W.startObject(13);
                    }
                    static addName(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addDocString(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static addDomain(W, L) {
                      W.addFieldOffset(2, L, 0);
                    }
                    static addSinceVersion(W, L) {
                      W.addFieldInt32(3, L, 0);
                    }
                    static addIndex(W, L) {
                      W.addFieldInt32(4, L, 0);
                    }
                    static addOpType(W, L) {
                      W.addFieldOffset(5, L, 0);
                    }
                    static addType(W, L) {
                      W.addFieldInt32(
                        6,
                        L,
                        $.experimental.fbs.NodeType.Primitive
                      );
                    }
                    static addExecutionProviderType(W, L) {
                      W.addFieldOffset(7, L, 0);
                    }
                    static addInputs(W, L) {
                      W.addFieldOffset(8, L, 0);
                    }
                    static createInputsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startInputsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addOutputs(W, L) {
                      W.addFieldOffset(9, L, 0);
                    }
                    static createOutputsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startOutputsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addAttributes(W, L) {
                      W.addFieldOffset(10, L, 0);
                    }
                    static createAttributesVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startAttributesVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addInputArgCounts(W, L) {
                      W.addFieldOffset(11, L, 0);
                    }
                    static createInputArgCountsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addInt32(L[H]);
                      return W.endVector();
                    }
                    static startInputArgCountsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addImplicitInputs(W, L) {
                      W.addFieldOffset(12, L, 0);
                    }
                    static createImplicitInputsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startImplicitInputsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static endNode(W) {
                      return W.endObject();
                    }
                    static createNode(
                      W,
                      L,
                      H,
                      F,
                      N,
                      q,
                      M,
                      A,
                      D,
                      R,
                      z,
                      E,
                      O,
                      Z
                    ) {
                      return (
                        V.startNode(W),
                        V.addName(W, L),
                        V.addDocString(W, H),
                        V.addDomain(W, F),
                        V.addSinceVersion(W, N),
                        V.addIndex(W, q),
                        V.addOpType(W, M),
                        V.addType(W, A),
                        V.addExecutionProviderType(W, D),
                        V.addInputs(W, R),
                        V.addOutputs(W, z),
                        V.addAttributes(W, E),
                        V.addInputArgCounts(W, O),
                        V.addImplicitInputs(W, Z),
                        V.endNode(W)
                      );
                    }
                  }
                  K.Node = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsValueInfo(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsValueInfo(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    name(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    docString(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    type(W) {
                      let L = this.bb.__offset(this.bb_pos, 8);
                      return L
                        ? (W || new $.experimental.fbs.TypeInfo()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    static startValueInfo(W) {
                      W.startObject(3);
                    }
                    static addName(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addDocString(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static addType(W, L) {
                      W.addFieldOffset(2, L, 0);
                    }
                    static endValueInfo(W) {
                      return W.endObject();
                    }
                    static createValueInfo(W, L, H, F) {
                      return (
                        V.startValueInfo(W),
                        V.addName(W, L),
                        V.addDocString(W, H),
                        V.addType(W, F),
                        V.endValueInfo(W)
                      );
                    }
                  }
                  K.ValueInfo = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsTypeInfo(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsTypeInfo(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    denotation(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    valueType() {
                      let W = this.bb.__offset(this.bb_pos, 6);
                      return W
                        ? this.bb.readUint8(this.bb_pos + W)
                        : $.experimental.fbs.TypeInfoValue.NONE;
                    }
                    value(W) {
                      let L = this.bb.__offset(this.bb_pos, 8);
                      return L ? this.bb.__union(W, this.bb_pos + L) : null;
                    }
                    static startTypeInfo(W) {
                      W.startObject(3);
                    }
                    static addDenotation(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addValueType(W, L) {
                      W.addFieldInt8(
                        1,
                        L,
                        $.experimental.fbs.TypeInfoValue.NONE
                      );
                    }
                    static addValue(W, L) {
                      W.addFieldOffset(2, L, 0);
                    }
                    static endTypeInfo(W) {
                      return W.endObject();
                    }
                    static createTypeInfo(W, L, H, F) {
                      return (
                        V.startTypeInfo(W),
                        V.addDenotation(W, L),
                        V.addValueType(W, H),
                        V.addValue(W, F),
                        V.endTypeInfo(W)
                      );
                    }
                  }
                  K.TypeInfo = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsOperatorSetId(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsOperatorSetId(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    domain(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    version() {
                      let W = this.bb.__offset(this.bb_pos, 6);
                      return W
                        ? this.bb.readInt64(this.bb_pos + W)
                        : this.bb.createLong(0, 0);
                    }
                    static startOperatorSetId(W) {
                      W.startObject(2);
                    }
                    static addDomain(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addVersion(W, L) {
                      W.addFieldInt64(1, L, W.createLong(0, 0));
                    }
                    static endOperatorSetId(W) {
                      return W.endObject();
                    }
                    static createOperatorSetId(W, L, H) {
                      return (
                        V.startOperatorSetId(W),
                        V.addDomain(W, L),
                        V.addVersion(W, H),
                        V.endOperatorSetId(W)
                      );
                    }
                  }
                  K.OperatorSetId = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsTensor(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsTensor(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    name(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    docString(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    dims(W) {
                      let L = this.bb.__offset(this.bb_pos, 8);
                      return L
                        ? this.bb.readInt64(
                            this.bb.__vector(this.bb_pos + L) + 8 * W
                          )
                        : this.bb.createLong(0, 0);
                    }
                    dimsLength() {
                      let W = this.bb.__offset(this.bb_pos, 8);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    dataType() {
                      let W = this.bb.__offset(this.bb_pos, 10);
                      return W
                        ? this.bb.readInt32(this.bb_pos + W)
                        : $.experimental.fbs.TensorDataType.UNDEFINED;
                    }
                    rawData(W) {
                      let L = this.bb.__offset(this.bb_pos, 12);
                      return L
                        ? this.bb.readUint8(
                            this.bb.__vector(this.bb_pos + L) + W
                          )
                        : 0;
                    }
                    rawDataLength() {
                      let W = this.bb.__offset(this.bb_pos, 12);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    rawDataArray() {
                      let W = this.bb.__offset(this.bb_pos, 12);
                      return W
                        ? new Uint8Array(
                            this.bb.bytes().buffer,
                            this.bb.bytes().byteOffset +
                              this.bb.__vector(this.bb_pos + W),
                            this.bb.__vector_len(this.bb_pos + W)
                          )
                        : null;
                    }
                    stringData(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 14);
                      return H
                        ? this.bb.__string(
                            this.bb.__vector(this.bb_pos + H) + 4 * W,
                            L
                          )
                        : null;
                    }
                    stringDataLength() {
                      let W = this.bb.__offset(this.bb_pos, 14);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    static startTensor(W) {
                      W.startObject(6);
                    }
                    static addName(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addDocString(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static addDims(W, L) {
                      W.addFieldOffset(2, L, 0);
                    }
                    static createDimsVector(W, L) {
                      W.startVector(8, L.length, 8);
                      for (let H = L.length - 1; H >= 0; H--) W.addInt64(L[H]);
                      return W.endVector();
                    }
                    static startDimsVector(W, L) {
                      W.startVector(8, L, 8);
                    }
                    static addDataType(W, L) {
                      W.addFieldInt32(
                        3,
                        L,
                        $.experimental.fbs.TensorDataType.UNDEFINED
                      );
                    }
                    static addRawData(W, L) {
                      W.addFieldOffset(4, L, 0);
                    }
                    static createRawDataVector(W, L) {
                      W.startVector(1, L.length, 1);
                      for (let H = L.length - 1; H >= 0; H--) W.addInt8(L[H]);
                      return W.endVector();
                    }
                    static startRawDataVector(W, L) {
                      W.startVector(1, L, 1);
                    }
                    static addStringData(W, L) {
                      W.addFieldOffset(5, L, 0);
                    }
                    static createStringDataVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startStringDataVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static endTensor(W) {
                      return W.endObject();
                    }
                    static createTensor(W, L, H, F, N, q, M) {
                      return (
                        V.startTensor(W),
                        V.addName(W, L),
                        V.addDocString(W, H),
                        V.addDims(W, F),
                        V.addDataType(W, N),
                        V.addRawData(W, q),
                        V.addStringData(W, M),
                        V.endTensor(W)
                      );
                    }
                  }
                  K.Tensor = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsSparseTensor(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsSparseTensor(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    values(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L
                        ? (W || new $.experimental.fbs.Tensor()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    indices(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L
                        ? (W || new $.experimental.fbs.Tensor()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    dims(W) {
                      let L = this.bb.__offset(this.bb_pos, 8);
                      return L
                        ? this.bb.readInt64(
                            this.bb.__vector(this.bb_pos + L) + 8 * W
                          )
                        : this.bb.createLong(0, 0);
                    }
                    dimsLength() {
                      let W = this.bb.__offset(this.bb_pos, 8);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    static startSparseTensor(W) {
                      W.startObject(3);
                    }
                    static addValues(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addIndices(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static addDims(W, L) {
                      W.addFieldOffset(2, L, 0);
                    }
                    static createDimsVector(W, L) {
                      W.startVector(8, L.length, 8);
                      for (let H = L.length - 1; H >= 0; H--) W.addInt64(L[H]);
                      return W.endVector();
                    }
                    static startDimsVector(W, L) {
                      W.startVector(8, L, 8);
                    }
                    static endSparseTensor(W) {
                      return W.endObject();
                    }
                    static createSparseTensor(W, L, H, F) {
                      return (
                        V.startSparseTensor(W),
                        V.addValues(W, L),
                        V.addIndices(W, H),
                        V.addDims(W, F),
                        V.endSparseTensor(W)
                      );
                    }
                  }
                  K.SparseTensor = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsAttribute(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsAttribute(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    name(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    docString(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    type() {
                      let W = this.bb.__offset(this.bb_pos, 8);
                      return W
                        ? this.bb.readInt32(this.bb_pos + W)
                        : $.experimental.fbs.AttributeType.UNDEFINED;
                    }
                    f() {
                      let W = this.bb.__offset(this.bb_pos, 10);
                      return W ? this.bb.readFloat32(this.bb_pos + W) : 0;
                    }
                    i() {
                      let W = this.bb.__offset(this.bb_pos, 12);
                      return W
                        ? this.bb.readInt64(this.bb_pos + W)
                        : this.bb.createLong(0, 0);
                    }
                    s(W) {
                      let L = this.bb.__offset(this.bb_pos, 14);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    t(W) {
                      let L = this.bb.__offset(this.bb_pos, 16);
                      return L
                        ? (W || new $.experimental.fbs.Tensor()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    g(W) {
                      let L = this.bb.__offset(this.bb_pos, 18);
                      return L
                        ? (W || new $.experimental.fbs.Graph()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    floats(W) {
                      let L = this.bb.__offset(this.bb_pos, 20);
                      return L
                        ? this.bb.readFloat32(
                            this.bb.__vector(this.bb_pos + L) + 4 * W
                          )
                        : 0;
                    }
                    floatsLength() {
                      let W = this.bb.__offset(this.bb_pos, 20);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    floatsArray() {
                      let W = this.bb.__offset(this.bb_pos, 20);
                      return W
                        ? new Float32Array(
                            this.bb.bytes().buffer,
                            this.bb.bytes().byteOffset +
                              this.bb.__vector(this.bb_pos + W),
                            this.bb.__vector_len(this.bb_pos + W)
                          )
                        : null;
                    }
                    ints(W) {
                      let L = this.bb.__offset(this.bb_pos, 22);
                      return L
                        ? this.bb.readInt64(
                            this.bb.__vector(this.bb_pos + L) + 8 * W
                          )
                        : this.bb.createLong(0, 0);
                    }
                    intsLength() {
                      let W = this.bb.__offset(this.bb_pos, 22);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    strings(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 24);
                      return H
                        ? this.bb.__string(
                            this.bb.__vector(this.bb_pos + H) + 4 * W,
                            L
                          )
                        : null;
                    }
                    stringsLength() {
                      let W = this.bb.__offset(this.bb_pos, 24);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    tensors(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 26);
                      return H
                        ? (L || new $.experimental.fbs.Tensor()).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    tensorsLength() {
                      let W = this.bb.__offset(this.bb_pos, 26);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    graphs(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 28);
                      return H
                        ? (L || new $.experimental.fbs.Graph()).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    graphsLength() {
                      let W = this.bb.__offset(this.bb_pos, 28);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    static startAttribute(W) {
                      W.startObject(13);
                    }
                    static addName(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addDocString(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static addType(W, L) {
                      W.addFieldInt32(
                        2,
                        L,
                        $.experimental.fbs.AttributeType.UNDEFINED
                      );
                    }
                    static addF(W, L) {
                      W.addFieldFloat32(3, L, 0);
                    }
                    static addI(W, L) {
                      W.addFieldInt64(4, L, W.createLong(0, 0));
                    }
                    static addS(W, L) {
                      W.addFieldOffset(5, L, 0);
                    }
                    static addT(W, L) {
                      W.addFieldOffset(6, L, 0);
                    }
                    static addG(W, L) {
                      W.addFieldOffset(7, L, 0);
                    }
                    static addFloats(W, L) {
                      W.addFieldOffset(8, L, 0);
                    }
                    static createFloatsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--)
                        W.addFloat32(L[H]);
                      return W.endVector();
                    }
                    static startFloatsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addInts(W, L) {
                      W.addFieldOffset(9, L, 0);
                    }
                    static createIntsVector(W, L) {
                      W.startVector(8, L.length, 8);
                      for (let H = L.length - 1; H >= 0; H--) W.addInt64(L[H]);
                      return W.endVector();
                    }
                    static startIntsVector(W, L) {
                      W.startVector(8, L, 8);
                    }
                    static addStrings(W, L) {
                      W.addFieldOffset(10, L, 0);
                    }
                    static createStringsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startStringsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addTensors(W, L) {
                      W.addFieldOffset(11, L, 0);
                    }
                    static createTensorsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startTensorsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addGraphs(W, L) {
                      W.addFieldOffset(12, L, 0);
                    }
                    static createGraphsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startGraphsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static endAttribute(W) {
                      return W.endObject();
                    }
                    static createAttribute(
                      W,
                      L,
                      H,
                      F,
                      N,
                      q,
                      M,
                      A,
                      D,
                      R,
                      z,
                      E,
                      O,
                      Z
                    ) {
                      return (
                        V.startAttribute(W),
                        V.addName(W, L),
                        V.addDocString(W, H),
                        V.addType(W, F),
                        V.addF(W, N),
                        V.addI(W, q),
                        V.addS(W, M),
                        V.addT(W, A),
                        V.addG(W, D),
                        V.addFloats(W, R),
                        V.addInts(W, z),
                        V.addStrings(W, E),
                        V.addTensors(W, O),
                        V.addGraphs(W, Z),
                        V.endAttribute(W)
                      );
                    }
                  }
                  K.Attribute = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsGraph(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsGraph(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    initializers(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 4);
                      return H
                        ? (L || new $.experimental.fbs.Tensor()).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    initializersLength() {
                      let W = this.bb.__offset(this.bb_pos, 4);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    nodeArgs(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 6);
                      return H
                        ? (L || new $.experimental.fbs.ValueInfo()).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    nodeArgsLength() {
                      let W = this.bb.__offset(this.bb_pos, 6);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    nodes(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 8);
                      return H
                        ? (L || new $.experimental.fbs.Node()).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    nodesLength() {
                      let W = this.bb.__offset(this.bb_pos, 8);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    maxNodeIndex() {
                      let W = this.bb.__offset(this.bb_pos, 10);
                      return W ? this.bb.readUint32(this.bb_pos + W) : 0;
                    }
                    nodeEdges(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 12);
                      return H
                        ? (L || new $.experimental.fbs.NodeEdge()).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    nodeEdgesLength() {
                      let W = this.bb.__offset(this.bb_pos, 12);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    inputs(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 14);
                      return H
                        ? this.bb.__string(
                            this.bb.__vector(this.bb_pos + H) + 4 * W,
                            L
                          )
                        : null;
                    }
                    inputsLength() {
                      let W = this.bb.__offset(this.bb_pos, 14);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    outputs(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 16);
                      return H
                        ? this.bb.__string(
                            this.bb.__vector(this.bb_pos + H) + 4 * W,
                            L
                          )
                        : null;
                    }
                    outputsLength() {
                      let W = this.bb.__offset(this.bb_pos, 16);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    sparseInitializers(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 18);
                      return H
                        ? (L || new $.experimental.fbs.SparseTensor()).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    sparseInitializersLength() {
                      let W = this.bb.__offset(this.bb_pos, 18);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    static startGraph(W) {
                      W.startObject(8);
                    }
                    static addInitializers(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static createInitializersVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startInitializersVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addNodeArgs(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static createNodeArgsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startNodeArgsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addNodes(W, L) {
                      W.addFieldOffset(2, L, 0);
                    }
                    static createNodesVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startNodesVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addMaxNodeIndex(W, L) {
                      W.addFieldInt32(3, L, 0);
                    }
                    static addNodeEdges(W, L) {
                      W.addFieldOffset(4, L, 0);
                    }
                    static createNodeEdgesVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startNodeEdgesVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addInputs(W, L) {
                      W.addFieldOffset(5, L, 0);
                    }
                    static createInputsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startInputsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addOutputs(W, L) {
                      W.addFieldOffset(6, L, 0);
                    }
                    static createOutputsVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startOutputsVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addSparseInitializers(W, L) {
                      W.addFieldOffset(7, L, 0);
                    }
                    static createSparseInitializersVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startSparseInitializersVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static endGraph(W) {
                      return W.endObject();
                    }
                    static createGraph(W, L, H, F, N, q, M, A, D) {
                      return (
                        V.startGraph(W),
                        V.addInitializers(W, L),
                        V.addNodeArgs(W, H),
                        V.addNodes(W, F),
                        V.addMaxNodeIndex(W, N),
                        V.addNodeEdges(W, q),
                        V.addInputs(W, M),
                        V.addOutputs(W, A),
                        V.addSparseInitializers(W, D),
                        V.endGraph(W)
                      );
                    }
                  }
                  K.Graph = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsModel(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsModel(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    irVersion() {
                      let W = this.bb.__offset(this.bb_pos, 4);
                      return W
                        ? this.bb.readInt64(this.bb_pos + W)
                        : this.bb.createLong(0, 0);
                    }
                    opsetImport(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 6);
                      return H
                        ? (L || new $.experimental.fbs.OperatorSetId()).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    opsetImportLength() {
                      let W = this.bb.__offset(this.bb_pos, 6);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    producerName(W) {
                      let L = this.bb.__offset(this.bb_pos, 8);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    producerVersion(W) {
                      let L = this.bb.__offset(this.bb_pos, 10);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    domain(W) {
                      let L = this.bb.__offset(this.bb_pos, 12);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    modelVersion() {
                      let W = this.bb.__offset(this.bb_pos, 14);
                      return W
                        ? this.bb.readInt64(this.bb_pos + W)
                        : this.bb.createLong(0, 0);
                    }
                    docString(W) {
                      let L = this.bb.__offset(this.bb_pos, 16);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    graph(W) {
                      let L = this.bb.__offset(this.bb_pos, 18);
                      return L
                        ? (W || new $.experimental.fbs.Graph()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    graphDocString(W) {
                      let L = this.bb.__offset(this.bb_pos, 20);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    static startModel(W) {
                      W.startObject(9);
                    }
                    static addIrVersion(W, L) {
                      W.addFieldInt64(0, L, W.createLong(0, 0));
                    }
                    static addOpsetImport(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static createOpsetImportVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startOpsetImportVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addProducerName(W, L) {
                      W.addFieldOffset(2, L, 0);
                    }
                    static addProducerVersion(W, L) {
                      W.addFieldOffset(3, L, 0);
                    }
                    static addDomain(W, L) {
                      W.addFieldOffset(4, L, 0);
                    }
                    static addModelVersion(W, L) {
                      W.addFieldInt64(5, L, W.createLong(0, 0));
                    }
                    static addDocString(W, L) {
                      W.addFieldOffset(6, L, 0);
                    }
                    static addGraph(W, L) {
                      W.addFieldOffset(7, L, 0);
                    }
                    static addGraphDocString(W, L) {
                      W.addFieldOffset(8, L, 0);
                    }
                    static endModel(W) {
                      return W.endObject();
                    }
                    static createModel(W, L, H, F, N, q, M, A, D, R) {
                      return (
                        V.startModel(W),
                        V.addIrVersion(W, L),
                        V.addOpsetImport(W, H),
                        V.addProducerName(W, F),
                        V.addProducerVersion(W, N),
                        V.addDomain(W, q),
                        V.addModelVersion(W, M),
                        V.addDocString(W, A),
                        V.addGraph(W, D),
                        V.addGraphDocString(W, R),
                        V.endModel(W)
                      );
                    }
                  }
                  K.Model = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsKernelCreateInfos(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsKernelCreateInfos(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    nodeIndices(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L
                        ? this.bb.readUint32(
                            this.bb.__vector(this.bb_pos + L) + 4 * W
                          )
                        : 0;
                    }
                    nodeIndicesLength() {
                      let W = this.bb.__offset(this.bb_pos, 4);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    nodeIndicesArray() {
                      let W = this.bb.__offset(this.bb_pos, 4);
                      return W
                        ? new Uint32Array(
                            this.bb.bytes().buffer,
                            this.bb.bytes().byteOffset +
                              this.bb.__vector(this.bb_pos + W),
                            this.bb.__vector_len(this.bb_pos + W)
                          )
                        : null;
                    }
                    kernelDefHashes(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L
                        ? this.bb.readUint64(
                            this.bb.__vector(this.bb_pos + L) + 8 * W
                          )
                        : this.bb.createLong(0, 0);
                    }
                    kernelDefHashesLength() {
                      let W = this.bb.__offset(this.bb_pos, 6);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    static startKernelCreateInfos(W) {
                      W.startObject(2);
                    }
                    static addNodeIndices(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static createNodeIndicesVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addInt32(L[H]);
                      return W.endVector();
                    }
                    static startNodeIndicesVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static addKernelDefHashes(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static createKernelDefHashesVector(W, L) {
                      W.startVector(8, L.length, 8);
                      for (let H = L.length - 1; H >= 0; H--) W.addInt64(L[H]);
                      return W.endVector();
                    }
                    static startKernelDefHashesVector(W, L) {
                      W.startVector(8, L, 8);
                    }
                    static endKernelCreateInfos(W) {
                      return W.endObject();
                    }
                    static createKernelCreateInfos(W, L, H) {
                      return (
                        V.startKernelCreateInfos(W),
                        V.addNodeIndices(W, L),
                        V.addKernelDefHashes(W, H),
                        V.endKernelCreateInfos(W)
                      );
                    }
                  }
                  K.KernelCreateInfos = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsSubGraphSessionState(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsSubGraphSessionState(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    graphId(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    sessionState(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L
                        ? (W || new $.experimental.fbs.SessionState()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    static startSubGraphSessionState(W) {
                      W.startObject(2);
                    }
                    static addGraphId(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addSessionState(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static endSubGraphSessionState(W) {
                      let L = W.endObject();
                      return (W.requiredField(L, 4), L);
                    }
                    static createSubGraphSessionState(W, L, H) {
                      return (
                        V.startSubGraphSessionState(W),
                        V.addGraphId(W, L),
                        V.addSessionState(W, H),
                        V.endSubGraphSessionState(W)
                      );
                    }
                  }
                  K.SubGraphSessionState = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsSessionState(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsSessionState(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    kernels(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L
                        ? (
                            W || new $.experimental.fbs.KernelCreateInfos()
                          ).__init(this.bb.__indirect(this.bb_pos + L), this.bb)
                        : null;
                    }
                    subGraphSessionStates(W, L) {
                      let H = this.bb.__offset(this.bb_pos, 6);
                      return H
                        ? (
                            L || new $.experimental.fbs.SubGraphSessionState()
                          ).__init(
                            this.bb.__indirect(
                              this.bb.__vector(this.bb_pos + H) + 4 * W
                            ),
                            this.bb
                          )
                        : null;
                    }
                    subGraphSessionStatesLength() {
                      let W = this.bb.__offset(this.bb_pos, 6);
                      return W ? this.bb.__vector_len(this.bb_pos + W) : 0;
                    }
                    static startSessionState(W) {
                      W.startObject(2);
                    }
                    static addKernels(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addSubGraphSessionStates(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static createSubGraphSessionStatesVector(W, L) {
                      W.startVector(4, L.length, 4);
                      for (let H = L.length - 1; H >= 0; H--) W.addOffset(L[H]);
                      return W.endVector();
                    }
                    static startSubGraphSessionStatesVector(W, L) {
                      W.startVector(4, L, 4);
                    }
                    static endSessionState(W) {
                      return W.endObject();
                    }
                    static createSessionState(W, L, H) {
                      return (
                        V.startSessionState(W),
                        V.addKernels(W, L),
                        V.addSubGraphSessionStates(W, H),
                        V.endSessionState(W)
                      );
                    }
                  }
                  K.SessionState = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})),
            (function ($) {
              (function (B) {
                (function (K) {
                  class V {
                    constructor() {
                      ((this.bb = null), (this.bb_pos = 0));
                    }
                    __init(W, L) {
                      return ((this.bb_pos = W), (this.bb = L), this);
                    }
                    static getRootAsInferenceSession(W, L) {
                      return (L || new V()).__init(
                        W.readInt32(W.position()) + W.position(),
                        W
                      );
                    }
                    static getSizePrefixedRootAsInferenceSession(W, L) {
                      return (
                        W.setPosition(
                          W.position() + G.flatbuffers.SIZE_PREFIX_LENGTH
                        ),
                        (L || new V()).__init(
                          W.readInt32(W.position()) + W.position(),
                          W
                        )
                      );
                    }
                    static bufferHasIdentifier(W) {
                      return W.__has_identifier("ORTM");
                    }
                    ortVersion(W) {
                      let L = this.bb.__offset(this.bb_pos, 4);
                      return L ? this.bb.__string(this.bb_pos + L, W) : null;
                    }
                    model(W) {
                      let L = this.bb.__offset(this.bb_pos, 6);
                      return L
                        ? (W || new $.experimental.fbs.Model()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    sessionState(W) {
                      let L = this.bb.__offset(this.bb_pos, 8);
                      return L
                        ? (W || new $.experimental.fbs.SessionState()).__init(
                            this.bb.__indirect(this.bb_pos + L),
                            this.bb
                          )
                        : null;
                    }
                    static startInferenceSession(W) {
                      W.startObject(3);
                    }
                    static addOrtVersion(W, L) {
                      W.addFieldOffset(0, L, 0);
                    }
                    static addModel(W, L) {
                      W.addFieldOffset(1, L, 0);
                    }
                    static addSessionState(W, L) {
                      W.addFieldOffset(2, L, 0);
                    }
                    static endInferenceSession(W) {
                      return W.endObject();
                    }
                    static finishInferenceSessionBuffer(W, L) {
                      W.finish(L, "ORTM");
                    }
                    static finishSizePrefixedInferenceSessionBuffer(W, L) {
                      W.finish(L, "ORTM", !0);
                    }
                    static createInferenceSession(W, L, H, F) {
                      return (
                        V.startInferenceSession(W),
                        V.addOrtVersion(W, L),
                        V.addModel(W, H),
                        V.addSessionState(W, F),
                        V.endInferenceSession(W)
                      );
                    }
                  }
                  K.InferenceSession = V;
                })(B.fbs || (B.fbs = {}));
              })($.experimental || ($.experimental = {}));
            })(Y.onnxruntime || (Y.onnxruntime = {})));
        },
        7448: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.OnnxjsSessionHandler = void 0));
          let G = Q(6207),
            J = Q(9162);
          Y.OnnxjsSessionHandler = class {
            constructor(U) {
              ((this.session = U),
                (this.inputNames = this.session.inputNames),
                (this.outputNames = this.session.outputNames));
            }
            async dispose() {}
            async run(U, $, B) {
              let K = new Map();
              for (let L in U)
                if (Object.hasOwnProperty.call(U, L)) {
                  let H = U[L];
                  K.set(
                    L,
                    new J.Tensor(H.dims, H.type, void 0, void 0, H.data)
                  );
                }
              let V = await this.session.run(K),
                W = {};
              return (
                V.forEach((L, H) => {
                  W[H] = new G.Tensor(L.type, L.data, L.dims);
                }),
                W
              );
            }
            startProfiling() {
              this.session.startProfiling();
            }
            endProfiling() {
              this.session.endProfiling();
            }
          };
        },
        6919: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.Session = void 0));
          let G = Q(6231),
            J = Q(6464),
            U = Q(7091),
            $ = Q(1036),
            B = Q(3694),
            K = Q(2644);
          Y.Session = class {
            constructor(V = {}) {
              ((this._initialized = !1),
                (this.backendHint = V.backendHint),
                (this.profiler = B.Profiler.create(V.profiler)),
                (this.context = {
                  profiler: this.profiler,
                  graphInputTypes: [],
                  graphInputDims: [],
                }));
            }
            get inputNames() {
              return this._model.graph.getInputNames();
            }
            get outputNames() {
              return this._model.graph.getOutputNames();
            }
            startProfiling() {
              this.profiler.start();
            }
            endProfiling() {
              this.profiler.stop();
            }
            async loadModel(V, W, L) {
              await this.profiler.event(
                "session",
                "Session.loadModel",
                async () => {
                  let H = await (0, U.resolveBackend)(this.backendHint);
                  if (
                    ((this.sessionHandler = H.createSessionHandler(
                      this.context
                    )),
                    (this._model = new K.Model()),
                    typeof V == "string")
                  ) {
                    let F = V.endsWith(".ort");
                    if (typeof fetch > "u") {
                      let N = await (0, J.promisify)(G.readFile)(V);
                      this.initialize(N, F);
                    } else {
                      let N = await fetch(V),
                        q = await N.arrayBuffer();
                      this.initialize(new Uint8Array(q), F);
                    }
                  } else if (ArrayBuffer.isView(V)) this.initialize(V);
                  else {
                    let F = new Uint8Array(V, W || 0, L || V.byteLength);
                    this.initialize(F);
                  }
                }
              );
            }
            initialize(V, W) {
              if (this._initialized) throw Error("already initialized");
              (this.profiler.event("session", "Session.initialize", () => {
                let L = this.sessionHandler.transformGraph
                  ? this.sessionHandler
                  : void 0;
                (this._model.load(V, L, W),
                  this.sessionHandler.onGraphInitialized &&
                    this.sessionHandler.onGraphInitialized(this._model.graph),
                  this.initializeOps(this._model.graph),
                  (this._executionPlan = new $.ExecutionPlan(
                    this._model.graph,
                    this._ops,
                    this.profiler
                  )));
              }),
                (this._initialized = !0));
            }
            async run(V) {
              if (!this._initialized)
                throw Error("session not initialized yet");
              return this.profiler.event("session", "Session.run", async () => {
                let W = this.normalizeAndValidateInputs(V),
                  L = await this._executionPlan.execute(this.sessionHandler, W);
                return this.createOutput(L);
              });
            }
            normalizeAndValidateInputs(V) {
              let W = this._model.graph.getInputNames();
              if (Array.isArray(V)) {
                if (V.length !== W.length)
                  throw Error(
                    `incorrect input array length: expected ${W.length} but got ${V.length}`
                  );
              } else {
                if (V.size !== W.length)
                  throw Error(
                    `incorrect input map size: expected ${W.length} but got ${V.size}`
                  );
                let L = Array(V.size),
                  H = 0;
                for (let F = 0; F < W.length; ++F) {
                  let N = V.get(W[F]);
                  if (!N) throw Error(`missing input tensor for: '${name}'`);
                  L[H++] = N;
                }
                V = L;
              }
              if (
                this.context.graphInputTypes &&
                this.context.graphInputTypes.length !== 0 &&
                this.context.graphInputDims &&
                this.context.graphInputDims.length !== 0
              )
                this.validateInputTensorDims(
                  this.context.graphInputDims,
                  V,
                  !1
                );
              else {
                let L = this._model.graph.getInputIndices(),
                  H = this._model.graph.getValues(),
                  F = Array(L.length);
                for (let N = 0; N < L.length; ++N) {
                  let q = H[L[N]];
                  ((F[N] = q.type.shape.dims),
                    this.context.graphInputTypes.push(q.type.tensorType),
                    this.context.graphInputDims.push(V[N].dims));
                }
                this.validateInputTensorDims(F, V, !0);
              }
              return (
                this.validateInputTensorTypes(this.context.graphInputTypes, V),
                V
              );
            }
            validateInputTensorTypes(V, W) {
              for (let L = 0; L < W.length; L++) {
                let H = V[L],
                  F = W[L].type;
                if (H !== F)
                  throw Error(
                    `input tensor[${L}] check failed: expected type '${H}' but got ${F}`
                  );
              }
            }
            validateInputTensorDims(V, W, L) {
              for (let H = 0; H < W.length; H++) {
                let F = V[H],
                  N = W[H].dims;
                if (!this.compareTensorDims(F, N, L))
                  throw Error(
                    `input tensor[${H}] check failed: expected shape '[${F.join(",")}]' but got [${N.join(",")}]`
                  );
              }
            }
            compareTensorDims(V, W, L) {
              if (V.length !== W.length) return !1;
              for (let H = 0; H < V.length; ++H)
                if (V[H] !== W[H] && (!L || V[H] !== 0)) return !1;
              return !0;
            }
            createOutput(V) {
              let W = this._model.graph.getOutputNames();
              if (V.length !== W.length)
                throw Error(
                  "expected number of outputs do not match number of generated outputs"
                );
              let L = new Map();
              for (let H = 0; H < W.length; ++H) L.set(W[H], V[H]);
              return L;
            }
            initializeOps(V) {
              let W = V.getNodes();
              this._ops = Array(W.length);
              for (let L = 0; L < W.length; L++)
                this._ops[L] = this.sessionHandler.resolve(
                  W[L],
                  this._model.opsets,
                  V
                );
            }
          };
        },
        9162: function (X, Y, Q) {
          var G =
            (this && this.__importDefault) ||
            function (q) {
              return q && q.__esModule ? q : { default: q };
            };
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.Tensor = void 0));
          let J = Q(3442),
            U = G(Q(3720)),
            $ = Q(1446),
            B = Q(9395),
            K = Q(2517);
          var V = B.onnxruntime.experimental.fbs;
          class W {
            get data() {
              if (this.cache === void 0) {
                let q = this.dataProvider(this.dataId);
                if (q.length !== this.size)
                  throw Error(
                    "Length of data provided by the Data Provider is inconsistent with the dims of this Tensor."
                  );
                this.cache = q;
              }
              return this.cache;
            }
            get stringData() {
              if (this.type !== "string")
                throw TypeError("data type is not string");
              return this.data;
            }
            get integerData() {
              switch (this.type) {
                case "uint8":
                case "int8":
                case "uint16":
                case "int16":
                case "int32":
                case "uint32":
                case "bool":
                  return this.data;
                default:
                  throw TypeError(
                    "data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)"
                  );
              }
            }
            get floatData() {
              switch (this.type) {
                case "float32":
                case "float64":
                  return this.data;
                default:
                  throw TypeError("data type is not float (float32, float64)");
              }
            }
            get numberData() {
              if (this.type !== "string") return this.data;
              throw TypeError("type cannot be non-number (string)");
            }
            get(q) {
              return this.data[K.ShapeUtil.indicesToOffset(q, this.strides)];
            }
            set(q, M) {
              this.data[K.ShapeUtil.indicesToOffset(q, this.strides)] = M;
            }
            async getData() {
              return (
                this.cache === void 0 &&
                  (this.cache = await this.asyncDataProvider(this.dataId)),
                this.cache
              );
            }
            get strides() {
              return (
                this._strides ||
                  (this._strides = K.ShapeUtil.computeStrides(this.dims)),
                this._strides
              );
            }
            constructor(q, M, A, D, R, z = J.Guid.create()) {
              ((this.dims = q),
                (this.type = M),
                (this.dataProvider = A),
                (this.asyncDataProvider = D),
                (this.cache = R),
                (this.dataId = z),
                (this.size = K.ShapeUtil.validateDimsAndCalcSize(q)));
              let E = this.size,
                O = A === void 0 && D === void 0 && R === void 0;
              if (R !== void 0 && R.length !== E)
                throw RangeError("Input dims doesn't match data length.");
              if (M === "string") {
                if (
                  !(
                    R === void 0 ||
                    (Array.isArray(R) && R.every((Z) => typeof Z == "string"))
                  )
                )
                  throw TypeError("cache should be a string array");
                O && (this.cache = Array(E));
              } else {
                if (R !== void 0) {
                  let Z = H(M);
                  if (!(R instanceof Z))
                    throw TypeError(`cache should be type ${Z.name}`);
                }
                if (O) {
                  let Z = new ArrayBuffer(
                    E *
                      (function (j) {
                        switch (j) {
                          case "bool":
                          case "int8":
                          case "uint8":
                            return 1;
                          case "int16":
                          case "uint16":
                            return 2;
                          case "int32":
                          case "uint32":
                          case "float32":
                            return 4;
                          case "float64":
                            return 8;
                          default:
                            throw Error(
                              `cannot calculate sizeof() on type ${j}`
                            );
                        }
                      })(M)
                  );
                  this.cache = (function (j, w) {
                    return new (H(w))(j);
                  })(Z, M);
                }
              }
            }
            static fromProto(q) {
              if (!q)
                throw Error("cannot construct Value from an empty tensor");
              let M = K.ProtoUtil.tensorDataTypeFromProto(q.dataType),
                A = K.ProtoUtil.tensorDimsFromProto(q.dims),
                D = new W(A, M);
              if (M === "string")
                q.stringData.forEach((R, z) => {
                  D.data[z] = (0, K.decodeUtf8String)(R);
                });
              else if (
                q.rawData &&
                typeof q.rawData.byteLength == "number" &&
                q.rawData.byteLength > 0
              ) {
                let R = D.data,
                  z = new DataView(
                    q.rawData.buffer,
                    q.rawData.byteOffset,
                    q.rawData.byteLength
                  ),
                  E = L(q.dataType),
                  O = q.rawData.byteLength / E;
                if (q.rawData.byteLength % E != 0)
                  throw Error("invalid buffer length");
                if (R.length !== O) throw Error("buffer length mismatch");
                for (let Z = 0; Z < O; Z++) {
                  let j = N(z, q.dataType, Z * E);
                  R[Z] = j;
                }
              } else {
                let R;
                switch (q.dataType) {
                  case $.onnx.TensorProto.DataType.FLOAT:
                    R = q.floatData;
                    break;
                  case $.onnx.TensorProto.DataType.INT32:
                  case $.onnx.TensorProto.DataType.INT16:
                  case $.onnx.TensorProto.DataType.UINT16:
                  case $.onnx.TensorProto.DataType.INT8:
                  case $.onnx.TensorProto.DataType.UINT8:
                  case $.onnx.TensorProto.DataType.BOOL:
                    R = q.int32Data;
                    break;
                  case $.onnx.TensorProto.DataType.INT64:
                    R = q.int64Data;
                    break;
                  case $.onnx.TensorProto.DataType.DOUBLE:
                    R = q.doubleData;
                    break;
                  case $.onnx.TensorProto.DataType.UINT32:
                  case $.onnx.TensorProto.DataType.UINT64:
                    R = q.uint64Data;
                    break;
                  default:
                    throw Error("unspecific error");
                }
                if (R == null)
                  throw Error(
                    "failed to populate data from a tensorproto value"
                  );
                let z = D.data;
                if (z.length !== R.length) throw Error("array length mismatch");
                for (let E = 0; E < R.length; E++) {
                  let O = R[E];
                  U.default.isLong(O) ? (z[E] = F(O, q.dataType)) : (z[E] = O);
                }
              }
              return D;
            }
            static fromData(q, M, A) {
              return new W(M, A, void 0, void 0, q);
            }
            static fromOrtTensor(q) {
              if (!q)
                throw Error("cannot construct Value from an empty tensor");
              let M = K.ProtoUtil.tensorDimsFromORTFormat(q),
                A = K.ProtoUtil.tensorDataTypeFromProto(q.dataType()),
                D = new W(M, A);
              if (A === "string")
                for (let R = 0; R < q.stringDataLength(); R++)
                  D.data[R] = q.stringData(R);
              else if (
                q.rawDataArray() &&
                typeof q.rawDataLength() == "number" &&
                q.rawDataLength() > 0
              ) {
                let R = D.data,
                  z = new DataView(
                    q.rawDataArray().buffer,
                    q.rawDataArray().byteOffset,
                    q.rawDataLength()
                  ),
                  E = L(q.dataType()),
                  O = q.rawDataLength() / E;
                if (q.rawDataLength() % E != 0)
                  throw Error("invalid buffer length");
                if (R.length !== O) throw Error("buffer length mismatch");
                for (let Z = 0; Z < O; Z++) {
                  let j = N(z, q.dataType(), Z * E);
                  R[Z] = j;
                }
              }
              return D;
            }
          }
          function L(q) {
            switch (q) {
              case $.onnx.TensorProto.DataType.UINT8:
              case $.onnx.TensorProto.DataType.INT8:
              case $.onnx.TensorProto.DataType.BOOL:
                return 1;
              case $.onnx.TensorProto.DataType.UINT16:
              case $.onnx.TensorProto.DataType.INT16:
                return 2;
              case $.onnx.TensorProto.DataType.FLOAT:
              case $.onnx.TensorProto.DataType.INT32:
              case $.onnx.TensorProto.DataType.UINT32:
                return 4;
              case $.onnx.TensorProto.DataType.INT64:
              case $.onnx.TensorProto.DataType.DOUBLE:
              case $.onnx.TensorProto.DataType.UINT64:
                return 8;
              default:
                throw Error(
                  `cannot calculate sizeof() on type ${$.onnx.TensorProto.DataType[q]}`
                );
            }
          }
          function H(q) {
            switch (q) {
              case "bool":
              case "uint8":
                return Uint8Array;
              case "int8":
                return Int8Array;
              case "int16":
                return Int16Array;
              case "uint16":
                return Uint16Array;
              case "int32":
                return Int32Array;
              case "uint32":
                return Uint32Array;
              case "float32":
                return Float32Array;
              case "float64":
                return Float64Array;
              default:
                throw Error("unspecified error");
            }
          }
          function F(q, M) {
            if (
              M === $.onnx.TensorProto.DataType.INT64 ||
              M === V.TensorDataType.INT64
            ) {
              if (q.greaterThanOrEqual(2147483648) || q.lessThan(-2147483648))
                throw TypeError("int64 is not supported");
            } else {
              if (
                M !== $.onnx.TensorProto.DataType.UINT32 &&
                M !== V.TensorDataType.UINT32 &&
                M !== $.onnx.TensorProto.DataType.UINT64 &&
                M !== V.TensorDataType.UINT64
              )
                throw TypeError(
                  `not a LONG type: ${$.onnx.TensorProto.DataType[M]}`
                );
              if (q.greaterThanOrEqual(4294967296) || q.lessThan(0))
                throw TypeError("uint64 is not supported");
            }
            return q.toNumber();
          }
          function N(q, M, A) {
            switch (M) {
              case $.onnx.TensorProto.DataType.BOOL:
              case $.onnx.TensorProto.DataType.UINT8:
                return q.getUint8(A);
              case $.onnx.TensorProto.DataType.INT8:
                return q.getInt8(A);
              case $.onnx.TensorProto.DataType.UINT16:
                return q.getUint16(A, !0);
              case $.onnx.TensorProto.DataType.INT16:
                return q.getInt16(A, !0);
              case $.onnx.TensorProto.DataType.FLOAT:
                return q.getFloat32(A, !0);
              case $.onnx.TensorProto.DataType.INT32:
                return q.getInt32(A, !0);
              case $.onnx.TensorProto.DataType.UINT32:
                return q.getUint32(A, !0);
              case $.onnx.TensorProto.DataType.INT64:
                return F(
                  U.default.fromBits(
                    q.getUint32(A, !0),
                    q.getUint32(A + 4, !0),
                    !1
                  ),
                  M
                );
              case $.onnx.TensorProto.DataType.DOUBLE:
                return q.getFloat64(A, !0);
              case $.onnx.TensorProto.DataType.UINT64:
                return F(
                  U.default.fromBits(
                    q.getUint32(A, !0),
                    q.getUint32(A + 4, !0),
                    !0
                  ),
                  M
                );
              default:
                throw Error(
                  `cannot read from DataView for type ${$.onnx.TensorProto.DataType[M]}`
                );
            }
          }
          Y.Tensor = W;
        },
        2517: function (X, Y, Q) {
          var G =
            (this && this.__importDefault) ||
            function (M) {
              return M && M.__esModule ? M : { default: M };
            };
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.decodeUtf8String =
              Y.MAX_CLIP =
              Y.MIN_CLIP =
              Y.PoolConvUtil =
              Y.ReduceUtil =
              Y.SplitUtil =
              Y.MathUtil =
              Y.ShapeUtil =
              Y.LongUtil =
              Y.ProtoUtil =
              Y.GemmUtil =
              Y.arrayCopyHelper =
              Y.BroadcastUtil =
              Y.MatMulUtil =
              Y.ArrayUtil =
              Y.assert =
              Y.checkInputsShape =
                void 0));
          let J = Q(5686),
            U = G(Q(3720)),
            $ = Q(1446),
            B = Q(9162);
          ((Y.checkInputsShape = function (M, ...A) {
            if (!M || M.length !== A.length) return !1;
            for (let D = 0; D < M.length; D++)
              if (!M[D].dims || M[D].dims.length !== A[D]) return !1;
            return !0;
          }),
            (Y.assert = function (M, A) {
              if (!M) throw Error(typeof A == "string" ? A : A());
            }),
            (Y.ArrayUtil = class {
              static arraysEqual(M, A) {
                if (M.length !== A.length) return !1;
                for (let D = 0; D < M.length; D++) if (M[D] !== A[D]) return !1;
                return !0;
              }
            }));
          class K {
            static preprocessInputShapes(M, A) {
              return [
                M.length === 1 ? [1, M[0]] : M,
                A.length === 1 ? [A[0], 1] : A,
              ];
            }
            static postprocessOutputShape(M, A, D) {
              (A === 1 && M.splice(M.length - 2, 1), D === 1 && M.pop());
            }
            static calcMatMulShape(M, A) {
              return M[1] !== A[0] ? void 0 : [M[0], A[1]];
            }
          }
          Y.MatMulUtil = K;
          class V {
            static calcShape(M, A, D = !1) {
              let R = M.length,
                z = A.length;
              if (R === 0) return A;
              if (z === 0) return M;
              let E = Math.max(M.length, A.length),
                O = Array(E);
              if (D) {
                if (R < 2 || z < 2) return;
                let Z = K.calcMatMulShape(
                  [M[R - 2], M[R - 1]],
                  [A[z - 2], A[z - 1]]
                );
                if (Z === void 0) return;
                [O[E - 2], O[E - 1]] = Z;
              }
              for (let Z = D ? 3 : 1; Z <= E; Z++) {
                let j = R - Z < 0 ? 1 : M[R - Z],
                  w = z - Z < 0 ? 1 : A[z - Z];
                if (j !== w && j > 1 && w > 1) return;
                O[E - Z] = Math.max(j, w);
              }
              return O;
            }
            static index(M, A) {
              let D = Array(A.length);
              return (V.fillIndex(M, A, D), D);
            }
            static fillIndex(M, A, D) {
              let R = M.length - A.length;
              for (let z = 0; z < A.length; z++) D[z] = M[R + z] % A[z];
            }
            static calc(M, A, D, R, z) {
              let E = V.calcShape(M.dims, A.dims);
              if (E) {
                if (R && !H.areEqual(E, M.dims)) return;
                let O = H.size(E),
                  Z = R ? M : new B.Tensor(E, z || M.type);
                if (E.length === 0) Z.set([], D(M.get([]), A.get([])));
                else {
                  let j = Array(E.length),
                    w = Array(M.dims.length),
                    I = Array(A.dims.length),
                    T,
                    y = 0,
                    _ = 0,
                    f = !1,
                    l = !1;
                  (M.dims.length === 0 && ((y = M.get([])), (f = !0)),
                    A.dims.length === 0 && ((_ = A.get([])), (l = !0)));
                  for (let h = 0; h < O; h++) {
                    T = h;
                    for (let p = E.length - 1; p >= 0; p--)
                      ((j[p] = T % E[p]), (T = Math.floor(T / E[p])));
                    (f || (V.fillIndex(j, M.dims, w), (y = M.get(w))),
                      l || (V.fillIndex(j, A.dims, I), (_ = A.get(I))),
                      Z.set(j, D(y, _)));
                  }
                }
                return Z;
              }
            }
            static isValidBroadcast(M, A) {
              let D = M.length,
                R = A.length;
              if (D > R) return !1;
              for (let z = 1; z <= D; z++)
                if (M[D - z] !== 1 && M[D - z] !== A[R - z]) return !1;
              return !0;
            }
            static getBroadcastDims(M, A) {
              let D = M.length,
                R = [];
              for (let z = 0; z < D; z++) {
                let E = D - 1 - z,
                  O = M[E] || 1;
                (A[A.length - 1 - z] || 1) > 1 && O === 1 && R.unshift(E);
              }
              return R;
            }
          }
          ((Y.BroadcastUtil = V),
            (Y.arrayCopyHelper = function (M, A, D, R, z) {
              if (R < 0 || R >= A.length)
                throw Error("sourceIndex out of bounds");
              if (D < 0 || D >= M.length)
                throw Error("targetIndex out of bounds");
              if (R + z > A.length)
                throw Error("source indices to be copied are outside bounds");
              if (D + z > M.length)
                throw Error("target array is too small to hold result");
              for (let E = 0; E < z; E++) M[D + E] = A[R + E];
            }),
            (Y.GemmUtil = class {
              static getShapeOfGemmResult(M, A, D, R, z) {
                if (M.length !== 2 || D.length !== 2)
                  throw Error("shape need to be of size 2");
                let E, O, Z;
                A ? ((E = M[1]), (O = M[0])) : ((E = M[0]), (O = M[1]));
                let j = -1;
                if (
                  (R ? ((Z = D[0]), (j = 1)) : ((Z = D[1]), (j = 0)),
                  D[j] !== O)
                )
                  throw Error("dimension mismatch");
                if (E <= 0 || Z <= 0 || O <= 0)
                  throw Error("invalid shape specified");
                if (z && !V.isValidBroadcast(z, [E, Z]))
                  throw Error("gemm: invalid bias shape for broadcast");
                return [E, Z, O];
              }
            }));
          class W {
            static tensorDataTypeFromProto(M) {
              switch (M) {
                case $.onnx.TensorProto.DataType.INT8:
                  return "int8";
                case $.onnx.TensorProto.DataType.UINT8:
                  return "uint8";
                case $.onnx.TensorProto.DataType.BOOL:
                  return "bool";
                case $.onnx.TensorProto.DataType.INT16:
                  return "int16";
                case $.onnx.TensorProto.DataType.UINT16:
                  return "uint16";
                case $.onnx.TensorProto.DataType.INT32:
                  return "int32";
                case $.onnx.TensorProto.DataType.UINT32:
                  return "uint32";
                case $.onnx.TensorProto.DataType.FLOAT:
                  return "float32";
                case $.onnx.TensorProto.DataType.DOUBLE:
                  return "float64";
                case $.onnx.TensorProto.DataType.STRING:
                  return "string";
                case $.onnx.TensorProto.DataType.INT64:
                  return "int32";
                case $.onnx.TensorProto.DataType.UINT64:
                  return "uint32";
                default:
                  throw Error(
                    `unsupported data type: ${$.onnx.TensorProto.DataType[M]}`
                  );
              }
            }
            static tensorDataTypeStringToEnum(M) {
              switch (M) {
                case "int8":
                  return $.onnx.TensorProto.DataType.INT8;
                case "uint8":
                  return $.onnx.TensorProto.DataType.UINT8;
                case "bool":
                  return $.onnx.TensorProto.DataType.BOOL;
                case "int16":
                  return $.onnx.TensorProto.DataType.INT16;
                case "uint16":
                  return $.onnx.TensorProto.DataType.UINT16;
                case "int32":
                  return $.onnx.TensorProto.DataType.INT32;
                case "uint32":
                  return $.onnx.TensorProto.DataType.UINT32;
                case "float32":
                  return $.onnx.TensorProto.DataType.FLOAT;
                case "float64":
                  return $.onnx.TensorProto.DataType.DOUBLE;
                case "string":
                  return $.onnx.TensorProto.DataType.STRING;
                case "int64":
                  return $.onnx.TensorProto.DataType.INT64;
                case "uint64":
                  return $.onnx.TensorProto.DataType.UINT64;
                default:
                  throw Error(`unsupported data type: ${M}`);
              }
            }
            static tensorDimsFromProto(M) {
              return M.map((A) => (U.default.isLong(A) ? A.toNumber() : A));
            }
            static tensorValueTypeFromProto(M) {
              return {
                tensorType: W.tensorDataTypeFromProto(M.elemType),
                shape: {
                  dims: W.tensorDimsFromProto(
                    M.shape.dim.map((A) => A.dimValue)
                  ),
                },
              };
            }
            static tensorDimsFromORTFormat(M) {
              let A = [];
              for (let D = 0; D < M.dimsLength(); D++)
                A.push(L.longToNumber(M.dims(D)));
              return A;
            }
            static tensorAttributesFromORTFormat(M) {
              let A = [];
              for (let D = 0; D < M.attributesLength(); D++)
                A.push(M.attributes(D));
              return A;
            }
          }
          Y.ProtoUtil = W;
          class L {
            static longToNumber(M, A) {
              return U.default.isLong(M)
                ? M.toNumber()
                : M instanceof J.flatbuffers.Long
                  ? U.default
                      .fromValue({
                        low: M.low,
                        high: M.high,
                        unsigned: A != null && A,
                      })
                      .toNumber()
                  : M;
            }
            static isLong(M) {
              return U.default.isLong(M) || M instanceof J.flatbuffers.Long;
            }
          }
          Y.LongUtil = L;
          class H {
            static size(M) {
              return H.getSizeFromDimensionRange(M, 0, M.length);
            }
            static sizeFromDimension(M, A) {
              if (A < 0 || A > M.length)
                throw Error(
                  `invalid dimension of ${A} for sizeFromDimension as Tensor has ${M.length} dimensions.`
                );
              return H.getSizeFromDimensionRange(M, A, M.length);
            }
            static sizeToDimension(M, A) {
              if (A < 0 || A > M.length)
                throw Error(
                  `invalid dimension of ${A} for sizeToDimension as Tensor has ${M.length} dimensions.`
                );
              return H.getSizeFromDimensionRange(M, 0, A);
            }
            static getSizeFromDimensionRange(M, A, D) {
              let R = 1;
              for (let z = A; z < D; z++) {
                if (M[z] <= 0)
                  throw Error(
                    "cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them."
                  );
                R *= M[z];
              }
              return R;
            }
            static computeStrides(M) {
              let A = M.length;
              if (A === 0) return [];
              if (A === 1) return [1];
              let D = Array(A);
              ((D[A - 1] = 1), (D[A - 2] = M[A - 1]));
              for (let R = A - 3; R >= 0; --R) D[R] = D[R + 1] * M[R + 1];
              return D;
            }
            static transpose(M) {
              return M.slice().reverse();
            }
            static indicesToOffset(M, A, D) {
              D === void 0 && (D = M.length);
              let R = 0;
              for (let z = 0; z < D; ++z) R += A[z] * M[z];
              return R;
            }
            static offsetToIndices(M, A) {
              let D = A.length;
              if (D === 0) return [];
              if (D === 1) return [M * A[0]];
              let R = Array(A.length);
              for (let z = 0; z < R.length - 1; ++z)
                ((R[z] = Math.floor(M / A[z])), (M -= R[z] * A[z]));
              return ((R[R.length - 1] = M), R);
            }
            static normalizeAxis(M, A) {
              if (M < -A && M >= A)
                throw Error("unsupported axis for this operation.");
              return M < 0 ? M + A : M;
            }
            static normalizeAxes(M, A) {
              return M.map((D) => this.normalizeAxis(D, A));
            }
            static incrementIndex(M, A, D) {
              if (A.length === 0 || M.length === 0)
                throw Error("Index incrementing unsupported for scalar Tensor");
              if (D === void 0) D = A.length;
              else if (D <= 0 || D > A.length)
                throw Error("Incorrect axis to increment on");
              for (let R = D - 1; R >= 0 && (M[R]++, !(M[R] < A[R])); --R)
                M[R] = 0;
            }
            static calculateReshapedDims(M, A) {
              if (A.length === 0) {
                if (M.length === 0 || H.size(M) === 1) return [];
                throw Error("cannot reshape to a scalar Tensor");
              }
              let D = A.length,
                R = Array(D),
                z = -1,
                E = 1;
              for (let Z = 0; Z < D; Z++) {
                if (A[Z] < -1)
                  throw Error(
                    "a dimension in shape hints cannot be less than -1"
                  );
                if (A[Z] === -1) {
                  if (z !== -1)
                    throw Error(
                      "at most one dimension in shape hints can be -1"
                    );
                  z = Z;
                } else {
                  if (A[Z] === 0) {
                    if (Z >= M.length)
                      throw Error(
                        "the dimension with value zero exceeds the dimension size of the input tensor"
                      );
                    R[Z] = M[Z];
                  } else R[Z] = A[Z];
                  E *= R[Z];
                }
              }
              let O = H.size(M);
              if (z !== -1) {
                if (O % E != 0)
                  throw Error(
                    `the input tensor cannot be reshaped to the requested shape. Input shape: [${M}] Output shape: [${A}]`
                  );
                R[z] = O / E;
              } else if (E !== O)
                throw Error(
                  "reshapedDims and originalDims don't have matching sizes"
                );
              return R;
            }
            static sortBasedOnPerm(M, A) {
              return A ? A.map((D) => M[D]) : M.slice().reverse();
            }
            static padShape(M, A) {
              let D = M.length;
              return M.map((R, z) => R + A[z] + A[z + D]);
            }
            static areEqual(M, A) {
              return M.length === A.length && M.every((D, R) => D === A[R]);
            }
            static validateDimsAndCalcSize(M) {
              if (M.length > 6)
                throw TypeError(
                  "Only rank 0 to 6 is supported for tensor shape."
                );
              let A = 1;
              for (let D of M) {
                if (!Number.isInteger(D))
                  throw TypeError(`Invalid shape: ${D} is not an integer`);
                if (D < 0 || D > 2147483647)
                  throw TypeError(`Invalid shape: length ${D} is not allowed`);
                A *= D;
              }
              return A;
            }
            static flattenShape(M, A) {
              A < 0 && (A += M.length);
              let D = M.reduce((z, E) => z * E, 1),
                R = M.slice(A).reduce((z, E) => z * E, 1);
              return [D / R, R];
            }
            static squeezeShape(M, A) {
              let D = [];
              A = H.normalizeAxes(A, M.length);
              for (let R = 0; R < M.length; R++) {
                let z = A.indexOf(R) >= 0;
                if (z && M[R] !== 1)
                  throw Error("squeeze an axis of size different than 1");
                ((A.length === 0 && M[R] > 1) || (A.length > 0 && !z)) &&
                  D.push(M[R]);
              }
              return D;
            }
            static unsqueezeShape(M, A) {
              let D = Array(M.length + A.length);
              D.fill(0);
              for (let z = 0; z < A.length; z++) {
                let E = H.normalizeAxis(A[z], D.length);
                if (E >= D.length)
                  throw Error("'axes' has an out of range axis");
                if (D[E] !== 0) throw Error("'axes' has a duplicate axis");
                D[E] = 1;
              }
              let R = 0;
              for (let z = 0; z < D.length; z++) D[z] === 0 && (D[z] = M[R++]);
              if (R !== M.length)
                throw Error(
                  "the unsqueezed dimension could not be established"
                );
              return D;
            }
          }
          ((Y.ShapeUtil = H),
            (Y.MathUtil = class {
              static sqr(M, A, D, R, z) {
                if (R < 0 || R >= A.length)
                  throw Error("sourceIndex out of bounds");
                if (D < 0 || D >= M.length)
                  throw Error("targetIndex out of bounds");
                if (R + z > A.length)
                  throw Error("source indices to be copied are outside bounds");
                if (D + z > M.length)
                  throw Error("target array is too small to hold result");
                for (let E = 0; E < z; E++) M[D + E] += Math.pow(A[R + E], 2);
              }
              static axpy(M, A, D, R, z, E) {
                if (R < 0 || R >= A.length)
                  throw Error("sourceIndex out of bounds");
                if (D < 0 || D >= M.length)
                  throw Error("targetIndex out of bounds");
                if (R + z > A.length)
                  throw Error("source indices to be copied are outside bounds");
                if (D + z > M.length)
                  throw Error("target array is too small to hold result");
                for (let O = 0; O < z; O++) M[D + O] += E * A[R + O];
              }
              static powx(M, A, D, R, z, E) {
                if (R < 0 || R >= A.length)
                  throw Error("sourceIndex out of bounds");
                if (D < 0 || D >= M.length)
                  throw Error("targetIndex out of bounds");
                if (R + z > A.length)
                  throw Error("source indices to be copied are outside bounds");
                if (D + z > M.length)
                  throw Error("target array is too small to hold result");
                for (let O = 0; O < z; O++) M[D + O] = Math.pow(A[R + O], E);
              }
              static mul(M, A, D, R, z) {
                if (R < 0 || R >= A.length)
                  throw Error("sourceIndex out of bounds");
                if (D < 0 || D >= M.length)
                  throw Error("targetIndex out of bounds");
                if (R + z > A.length)
                  throw Error("source indices to be copied are outside bounds");
                if (D + z > M.length)
                  throw Error("target array is too small to hold result");
                for (let E = 0; E < z; E++) M[D + E] = A[R + E] * M[D + E];
              }
            }));
          class F {
            static splitShape(M, A, D, R) {
              if (D.length === 0) {
                if (!R)
                  throw Error(
                    "need to know number of outputs when the 'split' attribute is not specified"
                  );
                F.determineSplit(M[A], R, D);
              }
              let z = [],
                E = [0];
              for (let O = 0; O < D.length; ++O) {
                O !== 0 && E.push(E[O - 1] + D[O - 1]);
                let Z = M.slice();
                ((Z[A] = D[O]), z.push(Z));
              }
              return [z, E];
            }
            static determineSplit(M, A, D) {
              if (M % A != 0)
                throw Error("cannot split tensor to equal sized parts");
              for (let R = 0; R < A; ++R) D.push(M / A);
            }
          }
          Y.SplitUtil = F;
          class N {
            static calcReduce(M, A, D, R, z) {
              let E = M.dims.slice(0);
              A.length === 0 && E.forEach((y, _) => A.push(_));
              let O = N.calcReduceShape(E, A, !0),
                Z = H.size(O),
                j = new B.Tensor(O, M.type),
                w = H.computeStrides(O),
                I = H.computeStrides(E),
                T = Array(E.length);
              for (let y = 0; y < Z; y++) {
                let _ = H.offsetToIndices(y, w);
                (V.fillIndex(_, E, T),
                  j.set(
                    _,
                    N.calcReduceByAxis(
                      M.numberData,
                      A,
                      E,
                      0,
                      H.indicesToOffset(T, I),
                      R,
                      z
                    )
                  ));
              }
              return D
                ? j
                : new B.Tensor(
                    N.calcReduceShape(E, A, D),
                    j.type,
                    void 0,
                    void 0,
                    j.data,
                    j.dataId
                  );
            }
            static calcReduceByAxis(M, A, D, R, z, E, O) {
              let Z = 0;
              if (R >= A.length) return E(M[z]);
              let j = A[R],
                w = j >= D.length ? 1 : H.size(D.slice(j + 1));
              for (let I = 0; I < D[j]; I++)
                ((Z =
                  I === 0
                    ? N.calcReduceByAxis(M, A, D, R + 1, z, E, O)
                    : O(Z, N.calcReduceByAxis(M, A, D, R + 1, z, E, O))),
                  (z += w));
              return Z;
            }
            static calcReduceShape(M, A, D) {
              let R = M.slice();
              for (let z = 0; z < A.length; z++) R[A[z]] = D ? 1 : 0;
              return R.filter((z) => z !== 0);
            }
          }
          Y.ReduceUtil = N;
          class q {
            static adjustPoolAttributes(M, A, D, R, z, E) {
              if (!M && D.length !== A.length - 2)
                throw Error(
                  "length of specified kernel shapes should be 2 less than length of input dimensions"
                );
              if (M)
                for (let O = 0; O < A.length - 2; O++)
                  O >= D.length ? D.push(A[O + 2]) : (D[O] = A[O + 2]);
              for (let O = 0; O < D.length; O++)
                if (O < R.length) {
                  if (R[O] < 0)
                    throw Error("strides should be greater than or equal to 1");
                } else R.push(1);
              for (let O = 0; O < D.length; O++)
                if (O < z.length) {
                  if (z[O] < 0)
                    throw Error(
                      "dilations should be greater than or equal to 1"
                    );
                } else z.push(1);
              for (let O = 0; O < 2 * D.length; O++)
                if (O < E.length) {
                  if (E[O] < 0)
                    throw Error("pad should be greater than or equal to 1");
                } else E.push(0);
              for (let O = 0; O < D.length; O++) {
                if (D[O] <= 0)
                  throw Error("kernel shapes need to be greater than 0");
                if (E[O] >= D[O] || E[O + D.length] >= D[O])
                  throw Error("pads should be smaller than kernel");
              }
            }
            static adjustPadsBasedOnAutoPad(M, A, D, R, z, E) {
              if (E) {
                if (z.length !== 2 * (M.length - 2))
                  throw Error(
                    "length of pads should be twice the length of data dimensions"
                  );
                if (A.length !== M.length - 2)
                  throw Error(
                    "length of strides should be the length of data dimensions"
                  );
                if (R.length !== M.length - 2)
                  throw Error(
                    "length of kernel shapes should be the length of data dimensions"
                  );
                for (let O = 0; O < M.length - 2; O++)
                  q.adjustPadAndReturnShape(
                    M[O + 2],
                    A[O],
                    D[O],
                    R[O],
                    z,
                    O,
                    O + M.length - 2,
                    E
                  );
              }
            }
            static computePoolOutputShape(M, A, D, R, z, E, O) {
              if (A.length <= 0)
                throw Error("input shape must be of size greater than 0");
              let Z = [A[0], A[1]];
              return (q.computeShapeHelper(M, A, Z, D, R, z, E, O), Z);
            }
            static computeConvOutputShape(M, A, D, R, z, E, O) {
              if (M.length <= 0 || A.length <= 0)
                throw Error(
                  "invalid input tensor dims or invalid filter tensor dims"
                );
              let Z = [M[0], A[0]];
              return (q.computeShapeHelper(!1, M, Z, D, R, z, E, O), Z);
            }
            static computeShapeHelper(M, A, D, R, z, E, O, Z) {
              if (M) for (let j = 0; j < A.length - 2; j++) D.push(1);
              else
                for (let j = 0; j < A.length - 2; j++)
                  D.push(
                    q.adjustPadAndReturnShape(
                      A[j + 2],
                      R[j],
                      z[j],
                      E[j],
                      O,
                      j,
                      j + A.length - 2,
                      Z
                    )
                  );
            }
            static adjustPadAndReturnShape(M, A, D, R, z, E, O, Z) {
              let j = D * (R - 1) + 1;
              if (!Z || Z === "NOTSET")
                return Math.floor((M + z[E] + z[O] - j) / A + 1);
              switch (Z) {
                case "VALID":
                  return ((z[E] = 0), (z[O] = 0), Math.floor((M - j) / A + 1));
                case "SAME_LOWER":
                case "SAME_UPPER":
                  if (D !== 1)
                    throw Error(
                      "Dilation not supported for SAME_UPPER or SAME_LOWER"
                    );
                  {
                    let w = ((M + A - 1) / A - 1) * A + R - M;
                    return (
                      (z[E] =
                        Z === "SAME_LOWER"
                          ? Math.floor((w + 1) / 2)
                          : Math.floor(w / 2)),
                      (z[O] = w - z[E]),
                      Math.floor((M + w - R) / A + 1)
                    );
                  }
                default:
                  throw Error("Unsupported AutoPad type");
              }
            }
          }
          ((Y.PoolConvUtil = q),
            (Y.MIN_CLIP = -340282346638528860000000000000000000000),
            (Y.MAX_CLIP = 340282346638528860000000000000000000000),
            (Y.decodeUtf8String = function (M) {
              return new TextDecoder().decode(M);
            }));
        },
        7967: (X, Y) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.iterateExtraOptions = void 0),
            (Y.iterateExtraOptions = (Q, G, J, U) => {
              if (typeof Q == "object" && Q !== null) {
                if (J.has(Q)) throw Error("Circular reference in options");
                J.add(Q);
              }
              Object.entries(Q).forEach(([$, B]) => {
                let K = G ? G + $ : $;
                if (typeof B == "object")
                  (0, Y.iterateExtraOptions)(B, K + ".", J, U);
                else if (typeof B == "string" || typeof B == "number")
                  U(K, B.toString());
                else {
                  if (typeof B != "boolean")
                    throw Error("Can't handle extra config type: " + typeof B);
                  U(K, B ? "1" : "0");
                }
              });
            }));
        },
        2157: function (X, Y, Q) {
          var G,
            J =
              (this && this.__createBinding) ||
              (Object.create
                ? function (I, T, y, _) {
                    _ === void 0 && (_ = y);
                    var f = Object.getOwnPropertyDescriptor(T, y);
                    ((f &&
                      !("get" in f
                        ? !T.__esModule
                        : f.writable || f.configurable)) ||
                      (f = {
                        enumerable: !0,
                        get: function () {
                          return T[y];
                        },
                      }),
                      Object.defineProperty(I, _, f));
                  }
                : function (I, T, y, _) {
                    (_ === void 0 && (_ = y), (I[_] = T[y]));
                  }),
            U =
              (this && this.__setModuleDefault) ||
              (Object.create
                ? function (I, T) {
                    Object.defineProperty(I, "default", {
                      enumerable: !0,
                      value: T,
                    });
                  }
                : function (I, T) {
                    I.default = T;
                  }),
            $ =
              (this && this.__importStar) ||
              function (I) {
                if (I && I.__esModule) return I;
                var T = {};
                if (I != null)
                  for (var y in I)
                    y !== "default" &&
                      Object.prototype.hasOwnProperty.call(I, y) &&
                      J(T, I, y);
                return (U(T, I), T);
              };
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.endProfiling =
              Y.run =
              Y.releaseSession =
              Y.createSession =
              Y.createSessionFinalize =
              Y.createSessionAllocate =
              Y.initOrt =
              Y.initWasm =
                void 0));
          let B = Q(6207),
            K = $(Q(349)),
            V = Q(6361),
            W = () => !!B.env.wasm.proxy && typeof document < "u",
            L,
            H,
            F,
            N = !1,
            q = !1,
            M = !1,
            A = [],
            D = [],
            R = [],
            z = [],
            E = [],
            O = [],
            Z = () => {
              if (N || !q || M || !L) throw Error("worker not ready");
            },
            j = (I) => {
              switch (I.data.type) {
                case "init-wasm":
                  ((N = !1),
                    I.data.err
                      ? ((M = !0), H[1](I.data.err))
                      : ((q = !0), H[0]()));
                  break;
                case "init-ort":
                  I.data.err ? F[1](I.data.err) : F[0]();
                  break;
                case "create_allocate":
                  I.data.err
                    ? A.shift()[1](I.data.err)
                    : A.shift()[0](I.data.out);
                  break;
                case "create_finalize":
                  I.data.err
                    ? D.shift()[1](I.data.err)
                    : D.shift()[0](I.data.out);
                  break;
                case "create":
                  I.data.err
                    ? R.shift()[1](I.data.err)
                    : R.shift()[0](I.data.out);
                  break;
                case "release":
                  I.data.err ? z.shift()[1](I.data.err) : z.shift()[0]();
                  break;
                case "run":
                  I.data.err
                    ? E.shift()[1](I.data.err)
                    : E.shift()[0](I.data.out);
                  break;
                case "end-profiling":
                  I.data.err ? O.shift()[1](I.data.err) : O.shift()[0]();
              }
            },
            w =
              typeof document < "u"
                ? (G =
                    document === null || document === void 0
                      ? void 0
                      : document.currentScript) === null || G === void 0
                  ? void 0
                  : G.src
                : void 0;
          ((Y.initWasm = async () => {
            if (W()) {
              if (q) return;
              if (N) throw Error("multiple calls to 'initWasm()' detected.");
              if (M) throw Error("previous call to 'initWasm()' failed.");
              return (
                (N = !0),
                B.env.wasm.wasmPaths === void 0 &&
                  w &&
                  w.indexOf("blob:") !== 0 &&
                  (B.env.wasm.wasmPaths = w.substr(0, +w.lastIndexOf("/") + 1)),
                new Promise((I, T) => {
                  (L == null || L.terminate(),
                    (L = Q(9710).Z()),
                    (L.onmessage = j),
                    (H = [I, T]));
                  let y = { type: "init-wasm", in: B.env.wasm };
                  L.postMessage(y);
                })
              );
            }
            return (0, V.initializeWebAssembly)(B.env.wasm);
          }),
            (Y.initOrt = async (I, T) => {
              if (W())
                return (
                  Z(),
                  new Promise((y, _) => {
                    F = [y, _];
                    let f = {
                      type: "init-ort",
                      in: { numThreads: I, loggingLevel: T },
                    };
                    L.postMessage(f);
                  })
                );
              K.initOrt(I, T);
            }),
            (Y.createSessionAllocate = async (I) =>
              W()
                ? (Z(),
                  new Promise((T, y) => {
                    A.push([T, y]);
                    let _ = { type: "create_allocate", in: { model: I } };
                    L.postMessage(_, [I.buffer]);
                  }))
                : K.createSessionAllocate(I)),
            (Y.createSessionFinalize = async (I, T) =>
              W()
                ? (Z(),
                  new Promise((y, _) => {
                    D.push([y, _]);
                    let f = {
                      type: "create_finalize",
                      in: { modeldata: I, options: T },
                    };
                    L.postMessage(f);
                  }))
                : K.createSessionFinalize(I, T)),
            (Y.createSession = async (I, T) =>
              W()
                ? (Z(),
                  new Promise((y, _) => {
                    R.push([y, _]);
                    let f = { type: "create", in: { model: I, options: T } };
                    L.postMessage(f, [I.buffer]);
                  }))
                : K.createSession(I, T)),
            (Y.releaseSession = async (I) => {
              if (W())
                return (
                  Z(),
                  new Promise((T, y) => {
                    z.push([T, y]);
                    let _ = { type: "release", in: I };
                    L.postMessage(_);
                  })
                );
              K.releaseSession(I);
            }),
            (Y.run = async (I, T, y, _, f) =>
              W()
                ? (Z(),
                  new Promise((l, h) => {
                    E.push([l, h]);
                    let p = {
                      type: "run",
                      in: {
                        sessionId: I,
                        inputIndices: T,
                        inputs: y,
                        outputIndices: _,
                        options: f,
                      },
                    };
                    L.postMessage(p, K.extractTransferableBuffers(y));
                  }))
                : K.run(I, T, y, _, f)),
            (Y.endProfiling = async (I) => {
              if (W())
                return (
                  Z(),
                  new Promise((T, y) => {
                    O.push([T, y]);
                    let _ = { type: "end-profiling", in: I };
                    L.postMessage(_);
                  })
                );
              K.endProfiling(I);
            }));
        },
        586: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.setRunOptions = void 0));
          let G = Q(7967),
            J = Q(4983),
            U = Q(6361);
          Y.setRunOptions = ($) => {
            let B = (0, U.getInstance)(),
              K = 0,
              V = [],
              W = $ || {};
            try {
              if (($ == null ? void 0 : $.logSeverityLevel) === void 0)
                W.logSeverityLevel = 2;
              else if (
                typeof $.logSeverityLevel != "number" ||
                !Number.isInteger($.logSeverityLevel) ||
                $.logSeverityLevel < 0 ||
                $.logSeverityLevel > 4
              )
                throw Error(
                  `log serverity level is not valid: ${$.logSeverityLevel}`
                );
              if (($ == null ? void 0 : $.logVerbosityLevel) === void 0)
                W.logVerbosityLevel = 0;
              else if (
                typeof $.logVerbosityLevel != "number" ||
                !Number.isInteger($.logVerbosityLevel)
              )
                throw Error(
                  `log verbosity level is not valid: ${$.logVerbosityLevel}`
                );
              ($ == null ? void 0 : $.terminate) === void 0 &&
                (W.terminate = !1);
              let L = 0;
              if (
                (($ == null ? void 0 : $.tag) !== void 0 &&
                  (L = (0, J.allocWasmString)($.tag, V)),
                (K = B._OrtCreateRunOptions(
                  W.logSeverityLevel,
                  W.logVerbosityLevel,
                  !!W.terminate,
                  L
                )),
                K === 0)
              )
                throw Error("Can't create run options");
              return (
                ($ == null ? void 0 : $.extra) !== void 0 &&
                  (0, G.iterateExtraOptions)(
                    $.extra,
                    "",
                    new WeakSet(),
                    (H, F) => {
                      let N = (0, J.allocWasmString)(H, V),
                        q = (0, J.allocWasmString)(F, V);
                      if (B._OrtAddRunConfigEntry(K, N, q) !== 0)
                        throw Error(
                          `Can't set a run config entry: ${H} - ${F}`
                        );
                    }
                  ),
                [K, V]
              );
            } catch (L) {
              throw (
                K !== 0 && B._OrtReleaseRunOptions(K),
                V.forEach(B._free),
                L
              );
            }
          };
        },
        2306: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.OnnxruntimeWebAssemblySessionHandler = void 0));
          let G = Q(6231),
            J = Q(6207),
            U = Q(6464),
            $ = Q(2157),
            B;
          Y.OnnxruntimeWebAssemblySessionHandler = class {
            async createSessionAllocate(K) {
              let V = await fetch(K),
                W = await V.arrayBuffer();
              return (0, $.createSessionAllocate)(new Uint8Array(W));
            }
            async loadModel(K, V) {
              if (
                (B ||
                  (await (0, $.initOrt)(
                    J.env.wasm.numThreads,
                    ((W) => {
                      switch (W) {
                        case "verbose":
                          return 0;
                        case "info":
                          return 1;
                        case "warning":
                          return 2;
                        case "error":
                          return 3;
                        case "fatal":
                          return 4;
                        default:
                          throw Error(`unsupported logging level: ${W}`);
                      }
                    })(J.env.logLevel)
                  ),
                  (B = !0)),
                typeof K == "string")
              )
                if (typeof fetch > "u") {
                  let W = await (0, U.promisify)(G.readFile)(K);
                  [this.sessionId, this.inputNames, this.outputNames] =
                    await (0, $.createSession)(W, V);
                } else {
                  let W = await this.createSessionAllocate(K);
                  [this.sessionId, this.inputNames, this.outputNames] =
                    await (0, $.createSessionFinalize)(W, V);
                }
              else
                [this.sessionId, this.inputNames, this.outputNames] = await (0,
                $.createSession)(K, V);
            }
            async dispose() {
              return (0, $.releaseSession)(this.sessionId);
            }
            async run(K, V, W) {
              let L = [],
                H = [];
              Object.entries(K).forEach((M) => {
                let A = M[0],
                  D = M[1],
                  R = this.inputNames.indexOf(A);
                if (R === -1) throw Error(`invalid input '${A}'`);
                (L.push(D), H.push(R));
              });
              let F = [];
              Object.entries(V).forEach((M) => {
                let A = M[0],
                  D = this.outputNames.indexOf(A);
                if (D === -1) throw Error(`invalid output '${A}'`);
                F.push(D);
              });
              let N = await (0, $.run)(
                  this.sessionId,
                  H,
                  L.map((M) => [M.type, M.dims, M.data]),
                  F,
                  W
                ),
                q = {};
              for (let M = 0; M < N.length; M++)
                q[this.outputNames[F[M]]] = new J.Tensor(
                  N[M][0],
                  N[M][2],
                  N[M][1]
                );
              return q;
            }
            startProfiling() {}
            endProfiling() {
              (0, $.endProfiling)(this.sessionId);
            }
          };
        },
        4919: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.setSessionOptions = void 0));
          let G = Q(7967),
            J = Q(4983),
            U = Q(6361);
          Y.setSessionOptions = ($) => {
            let B = (0, U.getInstance)(),
              K = 0,
              V = [],
              W = $ || {};
            ((L) => {
              (L.extra || (L.extra = {}),
                L.extra.session || (L.extra.session = {}));
              let H = L.extra.session;
              H.use_ort_model_bytes_directly ||
                (H.use_ort_model_bytes_directly = "1");
            })(W);
            try {
              ($ == null ? void 0 : $.graphOptimizationLevel) === void 0 &&
                (W.graphOptimizationLevel = "all");
              let L = ((N) => {
                switch (N) {
                  case "disabled":
                    return 0;
                  case "basic":
                    return 1;
                  case "extended":
                    return 2;
                  case "all":
                    return 99;
                  default:
                    throw Error(`unsupported graph optimization level: ${N}`);
                }
              })(W.graphOptimizationLevel);
              (($ == null ? void 0 : $.enableCpuMemArena) === void 0 &&
                (W.enableCpuMemArena = !0),
                ($ == null ? void 0 : $.enableMemPattern) === void 0 &&
                  (W.enableMemPattern = !0),
                ($ == null ? void 0 : $.executionMode) === void 0 &&
                  (W.executionMode = "sequential"));
              let H = ((N) => {
                  switch (N) {
                    case "sequential":
                      return 0;
                    case "parallel":
                      return 1;
                    default:
                      throw Error(`unsupported execution mode: ${N}`);
                  }
                })(W.executionMode),
                F = 0;
              if (
                (($ == null ? void 0 : $.logId) !== void 0 &&
                  (F = (0, J.allocWasmString)($.logId, V)),
                ($ == null ? void 0 : $.logSeverityLevel) === void 0)
              )
                W.logSeverityLevel = 2;
              else if (
                typeof $.logSeverityLevel != "number" ||
                !Number.isInteger($.logSeverityLevel) ||
                $.logSeverityLevel < 0 ||
                $.logSeverityLevel > 4
              )
                throw Error(
                  `log serverity level is not valid: ${$.logSeverityLevel}`
                );
              if (($ == null ? void 0 : $.logVerbosityLevel) === void 0)
                W.logVerbosityLevel = 0;
              else if (
                typeof $.logVerbosityLevel != "number" ||
                !Number.isInteger($.logVerbosityLevel)
              )
                throw Error(
                  `log verbosity level is not valid: ${$.logVerbosityLevel}`
                );
              if (
                (($ == null ? void 0 : $.enableProfiling) === void 0 &&
                  (W.enableProfiling = !1),
                (K = B._OrtCreateSessionOptions(
                  L,
                  !!W.enableCpuMemArena,
                  !!W.enableMemPattern,
                  H,
                  !!W.enableProfiling,
                  0,
                  F,
                  W.logSeverityLevel,
                  W.logVerbosityLevel
                )),
                K === 0)
              )
                throw Error("Can't create session options");
              return (
                ($ == null ? void 0 : $.executionProviders) &&
                  ((N, q, M) => {
                    for (let A of q) {
                      let D = typeof A == "string" ? A : A.name;
                      switch (D) {
                        case "xnnpack":
                          D = "XNNPACK";
                          break;
                        case "wasm":
                        case "cpu":
                          continue;
                        default:
                          throw Error(`not supported EP: ${D}`);
                      }
                      let R = (0, J.allocWasmString)(D, M);
                      if (
                        (0, U.getInstance)()._OrtAppendExecutionProvider(
                          N,
                          R
                        ) !== 0
                      )
                        throw Error(`Can't append execution provider: ${D}`);
                    }
                  })(K, $.executionProviders, V),
                ($ == null ? void 0 : $.extra) !== void 0 &&
                  (0, G.iterateExtraOptions)(
                    $.extra,
                    "",
                    new WeakSet(),
                    (N, q) => {
                      let M = (0, J.allocWasmString)(N, V),
                        A = (0, J.allocWasmString)(q, V);
                      if (B._OrtAddSessionConfigEntry(K, M, A) !== 0)
                        throw Error(
                          `Can't set a session config entry: ${N} - ${q}`
                        );
                    }
                  ),
                [K, V]
              );
            } catch (L) {
              throw (
                K !== 0 && B._OrtReleaseSessionOptions(K),
                V.forEach(B._free),
                L
              );
            }
          };
        },
        4983: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.allocWasmString = void 0));
          let G = Q(6361);
          Y.allocWasmString = (J, U) => {
            let $ = (0, G.getInstance)(),
              B = $.lengthBytesUTF8(J) + 1,
              K = $._malloc(B);
            return ($.stringToUTF8(J, K, B), U.push(K), K);
          };
        },
        349: (X, Y, Q) => {
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.extractTransferableBuffers =
              Y.endProfiling =
              Y.run =
              Y.releaseSession =
              Y.createSession =
              Y.createSessionFinalize =
              Y.createSessionAllocate =
              Y.initOrt =
                void 0));
          let G = Q(586),
            J = Q(4919),
            U = Q(4983),
            $ = Q(6361);
          Y.initOrt = (L, H) => {
            let F = (0, $.getInstance)()._OrtInit(L, H);
            if (F !== 0)
              throw Error(`Can't initialize onnxruntime. error code = ${F}`);
          };
          let B = new Map();
          ((Y.createSessionAllocate = (L) => {
            let H = (0, $.getInstance)(),
              F = H._malloc(L.byteLength);
            return (H.HEAPU8.set(L, F), [F, L.byteLength]);
          }),
            (Y.createSessionFinalize = (L, H) => {
              let F = (0, $.getInstance)(),
                N = 0,
                q = 0,
                M = [];
              try {
                if (
                  (([q, M] = (0, J.setSessionOptions)(H)),
                  (N = F._OrtCreateSession(L[0], L[1], q)),
                  N === 0)
                )
                  throw Error("Can't create a session");
              } finally {
                (F._free(L[0]),
                  F._OrtReleaseSessionOptions(q),
                  M.forEach(F._free));
              }
              let A = F._OrtGetInputCount(N),
                D = F._OrtGetOutputCount(N),
                R = [],
                z = [],
                E = [],
                O = [];
              for (let Z = 0; Z < A; Z++) {
                let j = F._OrtGetInputName(N, Z);
                if (j === 0) throw Error("Can't get an input name");
                (z.push(j), R.push(F.UTF8ToString(j)));
              }
              for (let Z = 0; Z < D; Z++) {
                let j = F._OrtGetOutputName(N, Z);
                if (j === 0) throw Error("Can't get an output name");
                (O.push(j), E.push(F.UTF8ToString(j)));
              }
              return (B.set(N, [N, z, O]), [N, R, E]);
            }),
            (Y.createSession = (L, H) => {
              let F = (0, Y.createSessionAllocate)(L);
              return (0, Y.createSessionFinalize)(F, H);
            }),
            (Y.releaseSession = (L) => {
              let H = (0, $.getInstance)(),
                F = B.get(L);
              if (!F) throw Error("invalid session id");
              let N = F[0],
                q = F[1],
                M = F[2];
              (q.forEach(H._OrtFree),
                M.forEach(H._OrtFree),
                H._OrtReleaseSession(N),
                B.delete(L));
            }));
          let K = (L) => {
              switch (L) {
                case "int8":
                  return 3;
                case "uint8":
                  return 2;
                case "bool":
                  return 9;
                case "int16":
                  return 5;
                case "uint16":
                  return 4;
                case "int32":
                  return 6;
                case "uint32":
                  return 12;
                case "float32":
                  return 1;
                case "float64":
                  return 11;
                case "string":
                  return 8;
                case "int64":
                  return 7;
                case "uint64":
                  return 13;
                default:
                  throw Error(`unsupported data type: ${L}`);
              }
            },
            V = (L) => {
              switch (L) {
                case 3:
                  return "int8";
                case 2:
                  return "uint8";
                case 9:
                  return "bool";
                case 5:
                  return "int16";
                case 4:
                  return "uint16";
                case 6:
                  return "int32";
                case 12:
                  return "uint32";
                case 1:
                  return "float32";
                case 11:
                  return "float64";
                case 8:
                  return "string";
                case 7:
                  return "int64";
                case 13:
                  return "uint64";
                default:
                  throw Error(`unsupported data type: ${L}`);
              }
            },
            W = (L) => {
              switch (L) {
                case "float32":
                  return Float32Array;
                case "uint8":
                case "bool":
                  return Uint8Array;
                case "int8":
                  return Int8Array;
                case "uint16":
                  return Uint16Array;
                case "int16":
                  return Int16Array;
                case "int32":
                  return Int32Array;
                case "float64":
                  return Float64Array;
                case "uint32":
                  return Uint32Array;
                case "int64":
                  return BigInt64Array;
                case "uint64":
                  return BigUint64Array;
                default:
                  throw Error(`unsupported type: ${L}`);
              }
            };
          ((Y.run = (L, H, F, N, q) => {
            let M = (0, $.getInstance)(),
              A = B.get(L);
            if (!A) throw Error("invalid session id");
            let D = A[0],
              R = A[1],
              z = A[2],
              E = H.length,
              O = N.length,
              Z = 0,
              j = [],
              w = [],
              I = [];
            try {
              [Z, j] = (0, G.setRunOptions)(q);
              for (let h = 0; h < E; h++) {
                let p = F[h][0],
                  N0 = F[h][1],
                  e = F[h][2],
                  P,
                  x;
                if (Array.isArray(e)) {
                  ((x = 4 * e.length), (P = M._malloc(x)), I.push(P));
                  let v = P / 4;
                  for (let k = 0; k < e.length; k++) {
                    if (typeof e[k] != "string")
                      throw TypeError(
                        `tensor data at index ${k} is not a string`
                      );
                    M.HEAPU32[v++] = (0, U.allocWasmString)(e[k], I);
                  }
                } else
                  ((x = e.byteLength),
                    (P = M._malloc(x)),
                    I.push(P),
                    M.HEAPU8.set(new Uint8Array(e.buffer, e.byteOffset, x), P));
                let r = M.stackSave(),
                  C = M.stackAlloc(4 * N0.length);
                try {
                  let v = C / 4;
                  N0.forEach((o) => (M.HEAP32[v++] = o));
                  let k = M._OrtCreateTensor(K(p), P, x, C, N0.length);
                  if (k === 0) throw Error("Can't create a tensor");
                  w.push(k);
                } finally {
                  M.stackRestore(r);
                }
              }
              let T = M.stackSave(),
                y = M.stackAlloc(4 * E),
                _ = M.stackAlloc(4 * E),
                f = M.stackAlloc(4 * O),
                l = M.stackAlloc(4 * O);
              try {
                let h = y / 4,
                  p = _ / 4,
                  N0 = f / 4,
                  e = l / 4;
                for (let r = 0; r < E; r++)
                  ((M.HEAPU32[h++] = w[r]), (M.HEAPU32[p++] = R[H[r]]));
                for (let r = 0; r < O; r++)
                  ((M.HEAPU32[N0++] = 0), (M.HEAPU32[e++] = z[N[r]]));
                let P = M._OrtRun(D, _, y, E, l, O, f, Z),
                  x = [];
                if (P === 0)
                  for (let r = 0; r < O; r++) {
                    let C = M.HEAPU32[f / 4 + r],
                      v = M.stackSave(),
                      k = M.stackAlloc(16),
                      o,
                      J0 = 0;
                    try {
                      if (
                        ((P = M._OrtGetTensorData(C, k, k + 4, k + 8, k + 12)),
                        P !== 0)
                      )
                        throw Error(
                          `Can't access output tensor data. error code = ${P}`
                        );
                      let z0 = k / 4,
                        A0 = M.HEAPU32[z0++];
                      J0 = M.HEAPU32[z0++];
                      let w0 = M.HEAPU32[z0++],
                        Y1 = M.HEAPU32[z0++],
                        b = [];
                      for (let n = 0; n < Y1; n++)
                        b.push(M.HEAPU32[w0 / 4 + n]);
                      M._OrtFree(w0);
                      let m = b.length === 0 ? 1 : b.reduce((n, M0) => n * M0);
                      if (((o = V(A0)), o === "string")) {
                        let n = [],
                          M0 = J0 / 4;
                        for (let D0 = 0; D0 < m; D0++) {
                          let Z0 = M.HEAPU32[M0++],
                            B1 = D0 === m - 1 ? void 0 : M.HEAPU32[M0] - Z0;
                          n.push(M.UTF8ToString(Z0, B1));
                        }
                        x.push([o, b, n]);
                      } else {
                        let n = new (W(o))(m);
                        (new Uint8Array(
                          n.buffer,
                          n.byteOffset,
                          n.byteLength
                        ).set(M.HEAPU8.subarray(J0, J0 + n.byteLength)),
                          x.push([o, b, n]));
                      }
                    } finally {
                      (M.stackRestore(v),
                        o === "string" && J0 && M._free(J0),
                        M._OrtReleaseTensor(C));
                    }
                  }
                if (P === 0) return x;
                throw Error(`failed to call OrtRun(). error code = ${P}.`);
              } finally {
                M.stackRestore(T);
              }
            } finally {
              (w.forEach(M._OrtReleaseTensor),
                I.forEach(M._free),
                M._OrtReleaseRunOptions(Z),
                j.forEach(M._free));
            }
          }),
            (Y.endProfiling = (L) => {
              let H = (0, $.getInstance)(),
                F = B.get(L);
              if (!F) throw Error("invalid session id");
              let N = F[0],
                q = H._OrtEndProfiling(N);
              if (q === 0) throw Error("Can't get an profile file name");
              H._OrtFree(q);
            }),
            (Y.extractTransferableBuffers = (L) => {
              let H = [];
              for (let F of L) {
                let N = F[2];
                !Array.isArray(N) && N.buffer && H.push(N.buffer);
              }
              return H;
            }));
        },
        6361: function (X, Y, Q) {
          var G =
              (this && this.__createBinding) ||
              (Object.create
                ? function (q, M, A, D) {
                    D === void 0 && (D = A);
                    var R = Object.getOwnPropertyDescriptor(M, A);
                    ((R &&
                      !("get" in R
                        ? !M.__esModule
                        : R.writable || R.configurable)) ||
                      (R = {
                        enumerable: !0,
                        get: function () {
                          return M[A];
                        },
                      }),
                      Object.defineProperty(q, D, R));
                  }
                : function (q, M, A, D) {
                    (D === void 0 && (D = A), (q[D] = M[A]));
                  }),
            J =
              (this && this.__setModuleDefault) ||
              (Object.create
                ? function (q, M) {
                    Object.defineProperty(q, "default", {
                      enumerable: !0,
                      value: M,
                    });
                  }
                : function (q, M) {
                    q.default = M;
                  }),
            U =
              (this && this.__importStar) ||
              function (q) {
                if (q && q.__esModule) return q;
                var M = {};
                if (q != null)
                  for (var A in q)
                    A !== "default" &&
                      Object.prototype.hasOwnProperty.call(q, A) &&
                      G(M, q, A);
                return (J(M, q), M);
              },
            $ =
              (this && this.__importDefault) ||
              function (q) {
                return q && q.__esModule ? q : { default: q };
              };
          (Object.defineProperty(Y, "__esModule", { value: !0 }),
            (Y.dispose = Y.getInstance = Y.initializeWebAssembly = void 0));
          let B = U(Q(1423)),
            K = $(Q(932)),
            V = Q(3474),
            W,
            L = !1,
            H = !1,
            F = !1,
            N = (q, M) =>
              M
                ? q
                  ? "ort-wasm-simd-threaded.wasm"
                  : "ort-wasm-threaded.wasm"
                : q
                  ? "ort-wasm-simd.wasm"
                  : "ort-wasm.wasm";
          ((Y.initializeWebAssembly = async (q) => {
            if (L) return Promise.resolve();
            if (H)
              throw Error(
                "multiple calls to 'initializeWebAssembly()' detected."
              );
            if (F)
              throw Error("previous call to 'initializeWebAssembly()' failed.");
            H = !0;
            let { initTimeout: M, numThreads: A, simd: D } = q,
              R =
                A > 1 &&
                (() => {
                  try {
                    return (
                      typeof SharedArrayBuffer < "u" &&
                      (typeof MessageChannel < "u" &&
                        new MessageChannel().port1.postMessage(
                          new SharedArrayBuffer(1)
                        ),
                      WebAssembly.validate(
                        new Uint8Array([
                          0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2,
                          1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254,
                          16, 2, 0, 26, 11,
                        ])
                      ))
                    );
                  } catch (T) {
                    return !1;
                  }
                })(),
              z =
                D &&
                (() => {
                  try {
                    return WebAssembly.validate(
                      new Uint8Array([
                        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1,
                        0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26,
                        11,
                      ])
                    );
                  } catch (T) {
                    return !1;
                  }
                })(),
              E = typeof q.wasmPaths == "string" ? q.wasmPaths : void 0,
              O = N(!1, R),
              Z = N(z, R),
              j = typeof q.wasmPaths == "object" ? q.wasmPaths[Z] : void 0,
              w = !1,
              I = [];
            if (
              (M > 0 &&
                I.push(
                  new Promise((T) => {
                    setTimeout(() => {
                      ((w = !0), T());
                    }, M);
                  })
                ),
              I.push(
                new Promise((T, y) => {
                  let _ = R ? V : K.default,
                    f = {
                      locateFile: (l, h) =>
                        R && l.endsWith(".worker.js") && typeof Blob < "u"
                          ? URL.createObjectURL(
                              new Blob([Q(4154)], { type: "text/javascript" })
                            )
                          : l === O
                            ? j != null
                              ? j
                              : (E != null ? E : h) + Z
                            : h + l,
                    };
                  if (R)
                    if (typeof Blob > "u")
                      f.mainScriptUrlOrBlob = B.join(
                        __dirname,
                        "ort-wasm-threaded.js"
                      );
                    else {
                      let l = `var ortWasmThreaded=(function(){var _scriptDir;return ${_.toString()}})();`;
                      f.mainScriptUrlOrBlob = new Blob([l], {
                        type: "text/javascript",
                      });
                    }
                  _(f).then(
                    (l) => {
                      ((H = !1), (L = !0), (W = l), T());
                    },
                    (l) => {
                      ((H = !1), (F = !0), y(l));
                    }
                  );
                })
              ),
              await Promise.race(I),
              w)
            )
              throw Error(
                `WebAssembly backend initializing failed due to timeout: ${M}ms`
              );
          }),
            (Y.getInstance = () => {
              if (L && W) return W;
              throw Error("WebAssembly is not initialized yet.");
            }),
            (Y.dispose = () => {
              var q;
              !L ||
                H ||
                F ||
                ((H = !0),
                (q = W.PThread) === null ||
                  q === void 0 ||
                  q.terminateAllThreads(),
                (W = void 0),
                (H = !1),
                (L = !1),
                (F = !0));
            }));
        },
        9710: (X, Y, Q) => {
          Q.d(Y, { Z: () => U });
          var G = Q(477),
            J = Q.n(G);
          function U() {
            return J()(
              `/*!
* ONNX Runtime Web v1.14.0
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||__filename,function(t){function e(){return k.buffer!=D&&N(k.buffer),P}function r(){return k.buffer!=D&&N(k.buffer),U}function a(){return k.buffer!=D&&N(k.buffer),F}function i(){return k.buffer!=D&&N(k.buffer),I}function o(){return k.buffer!=D&&N(k.buffer),W}var u,s,c;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){s=t,c=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,_="function"==typeof importScripts,w="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(w){let e;A=_?n(17).dirname(A)+"/":__dirname+"/",y=()=>{d||(h=n(147),d=n(17))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof st))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof st||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(267)}catch(t){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),t}global.Worker=e.Worker}else(v||_)&&(_?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",w||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},_&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));w&&"undefined"==typeof performance&&(global.performance=n(74).performance);var T=console.log.bind(console),E=console.warn.bind(console);w&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var k,j,D,P,U,F,I,W,H=!1,z="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function L(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&z)return z.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?L(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)k=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)k=u.wasmMemory;else if(!((k=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");k&&(D=k.buffer),V=D.byteLength,N(D);var q,$=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();$.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),c(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function st(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function ct(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return qt(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new st(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x('Internal error! Worker sent a message "'+r+'" to target pthread '+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?Lt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?ct(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},w&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:k,wasmModule:j})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return qt(2,0,t);try{pt(t)}catch(t){t instanceof st||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=q.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,_t,wt=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?qt(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?qt(4,1,t,e,n):0}function xt(t,e){if(O)return qt(5,1,t,e)}function Rt(t,e){if(O)return qt(6,1,t,e)}function kt(t,e,n){if(O)return qt(7,1,t,e,n)}function jt(t,e,n){return O?qt(8,1,t,e,n):0}function Dt(t,e){if(O)return qt(9,1,t,e)}function Pt(t,e,n){if(O)return qt(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return qt(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return qt(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return qt(13,1,t,e,n,r)}function Wt(t){if(O)return qt(14,1,t)}function Ht(t,e){if(O)return qt(15,1,t,e)}function zt(t,e,n){if(O)return qt(16,1,t,e,n)}function Lt(t){Atomics.store(a(),t>>2,1),he()&&we(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?qt(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return qt(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return qt(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),s=new Date(o,6,1);o=u.getTimezoneOffset();var c=s.getTimezoneOffset(),l=Math.max(o,c);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=c),t=r(u),e=r(s),t=Nt(t),e=Nt(e),c<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function qt(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var s=r[2+u];o()[i+u>>>0]=s}return _e(t,n,a,e)}))}u.executeNotifiedProxyingQueue=Lt,_t=w?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var $t,Xt=[],Jt={};function Zt(){if(!$t){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);$t=n}return $t}function Qt(t,n){if(O)return qt(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return qt(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?qt(22,1,t):52}function ee(t,e,n,r){return O?qt(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?qt(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(L(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return qt(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var s=i()[e>>2>>>0],c=i()[e+4>>2>>>0];e+=8;for(var l=0;l<c;l++)ae(t,r()[s+l>>>0]);o+=c}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var se=[31,29,31,30,31,30,31,31,30,31,30,31],ce=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function s(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function c(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?se:ce)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=c(new Date(t.getFullYear(),0,4)),n=c(n),0>=s(e,t)?0>=s(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?se:ce)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,kt,jt,Dt,Pt,Ut,Ft,It,Wt,Ht,zt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),wt.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=wt.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=wt.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(wt.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!_,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):ct(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:kt,oa:jt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:zt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>Lt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),s=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&s==r):0<n!=(s==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?s:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!w&&!_){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,w&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:_t,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return w?n(37).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{k.grow(i-D.byteLength+65535>>>16),N(k.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(w)try{var e=n(113);return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var s=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var s=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return je(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return ze(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return ke(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var s=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,s){var c=Ee();try{gt(t)(e,n,r,a,i,o,u,s)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,s,c,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,s,c,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,s,c,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,s,c,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var s=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:k||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),q=u.asm.ub,X.unshift(u.asm.Va),j=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||_)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at '"+tt+"'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||w||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(c)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,_e=u._emscripten_run_in_main_runtime_thread_js=function(){return(_e=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},we=u.__emscripten_proxy_execute_task_queue=function(){return(we=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},ke=u.dynCall_j=function(){return(ke=u.dynCall_j=u.asm.Ib).apply(null,arguments)},je=u.dynCall_iiiiij=function(){return(je=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},ze=u.dynCall_iiij=function(){return(ze=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function Le(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),s(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)s(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt($),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=k,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=st,u.PThread=ht,rt=function t(){ve||Le(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return Le(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||__filename,function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,s,c,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(17).dirname(m)+"/":__dirname+"/",l=()=>{c||(s=n(147),c=n(17))},i=function(t,e){return l(),t=c.normalize(t),s.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=c.normalize(t),s.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(w||0<z)throw process.exitCode=t,e;e instanceof J||_("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),_=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var w=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function k(t,e){return(t>>>=0)?R(T,t,e):""}function j(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],z=0;function L(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),_(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function q(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!q()){var $=Y;Y=e.locateFile?e.locateFile($,m):m+$}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&j(t,S,n,e),n}var ot={};function ut(){if(!st){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);st=n}return st}var st,ct=[null,[],[]];function lt(t,e){var n=ct[t];0===e||10===e?((1===t?v:_)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function s(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:c?k(c):""},n=k(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return s(t).toString().substring(2)},"%G":function(t){return s(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(t){var e=Array(D(t)+1);return j(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw _("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){w||0<z||(wt(),Z(W),_t(0),ct[1].length&&lt(1,10),ct[2].length&&lt(2,10)),w||0<z||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var s=0;s<u;s++)lt(t,T[o+s>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(113);return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var s=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var s=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var s=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,s){var c=At();try{at(t)(e,n,r,a,i,o,u,s)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,s,c,l){var f=At();try{at(t)(e,n,r,a,i,o,u,s,c,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,s,c,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,s,c,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var s=At();try{kt(t,e,n,r,a,i,o,u)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,s,c,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,s,c,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{jt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at '"+Y+"'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){_("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return _("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||q()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return _("wasm streaming compile failed: "+t),_("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},_t=e._fflush=function(){return(_t=e._fflush=e.asm.gb).apply(null,arguments)},wt=e.___funcs_on_exit=function(){return(wt=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},kt=e.dynCall_viiiiij=function(){return(kt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},jt=e.dynCall_vjji=function(){return(jt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)L();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=k,e.stringToUTF8=function(t,e,n){return j(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can't handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(\`log serverity level is not valid: \${t.logSeverityLevel}\`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(\`log verbosity level is not valid: \${t.logVerbosityLevel}\`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can't create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(\`Can't set a run config entry: \${t} - \${r}\`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const s=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(\`unsupported graph optimization level: \${t}\`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const c=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(\`unsupported execution mode: \${t}\`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(\`log serverity level is not valid: \${t.logSeverityLevel}\`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(\`log verbosity level is not valid: \${t.logVerbosityLevel}\`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(s,!!u.enableCpuMemArena,!!u.enableMemPattern,c,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can't create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(\`not supported EP: \${e}\`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(\`Can't append execution provider: \${e}\`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(\`Can't set a session config entry: \${t} - \${r}\`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(\`Can't initialize onnxruntime. error code = \${n}\`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,s=[];try{if([i,s]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can't create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),s.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<c;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can't get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can't get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const s=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(\`unsupported data type: \${t}\`)}},c=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(\`unsupported data type: \${t}\`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(\`unsupported type: \${t}\`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,_=[];const w=[],O=[];try{[v,_]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(\`tensor data at index \${e} is not a string\`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const c=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(s(e),o,u,l,r.length);if(0===n)throw new Error("Can't create a tensor");w.push(n)}finally{p.stackRestore(c)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,s=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=w[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[s++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const _=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(\`Can't access output tensor data. error code = \${f}\`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],s=p.HEAPU32[t++],h=[];for(let t=0;t<s;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=c(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}_.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),_.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return _;throw new Error(\`failed to call OrtRun(). error code = \${f}.\`)}finally{p.stackRestore(t)}}finally{w.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),_.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can't get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(17)),s=o(n(932)),c=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(h)throw new Error("previous call to 'initializeWebAssembly()' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const _=[];if(e>0&&_.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),_.push(new Promise(((t,e)=>{const r=i?c:s.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join(__dirname,"ort-wasm-threaded.js");else{const t=\`var ortWasmThreaded=(function(){var _scriptDir;return \${r.toString()}})();\`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(_),v)throw new Error(\`WebAssembly backend initializing failed due to timeout: \${e}ms\`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports='"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n'},113:t=>{"use strict";t.exports=require("crypto")},147:t=>{"use strict";t.exports=require("fs")},37:t=>{"use strict";t.exports=require("os")},17:t=>{"use strict";t.exports=require("path")},74:t=>{"use strict";t.exports=require("perf_hooks")},267:t=>{"use strict";t.exports=require("worker_threads")}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();
`,
              "Worker",
              void 0,
              void 0
            );
          }
        },
        477: (X) => {
          X.exports = function (Y, Q, G, J) {
            var U = self || window;
            try {
              try {
                var $;
                try {
                  $ = new U.Blob([Y]);
                } catch (W) {
                  (($ = new (
                    U.BlobBuilder ||
                    U.WebKitBlobBuilder ||
                    U.MozBlobBuilder ||
                    U.MSBlobBuilder
                  )()).append(Y),
                    ($ = $.getBlob()));
                }
                var B = U.URL || U.webkitURL,
                  K = B.createObjectURL($),
                  V = new U[Q](K, G);
                return (B.revokeObjectURL(K), V);
              } catch (W) {
                return new U[Q](
                  "data:application/javascript,".concat(encodeURIComponent(Y)),
                  G
                );
              }
            } catch (W) {
              if (!J) throw Error("Inline worker is not supported");
              return new U[Q](J, G);
            }
          };
        },
        4154: (X) => {
          X.exports =
            '"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n';
        },
        6231: (X) => {
          X.exports = k1("fs");
        },
        9719: (X) => {
          X.exports = k1("os");
        },
        1423: (X) => {
          X.exports = k1("path");
        },
        498: (X) => {
          X.exports = k1("perf_hooks");
        },
        6464: (X) => {
          X.exports = k1("util");
        },
        4564: (X) => {
          X.exports = k1("worker_threads");
        },
        6207: (X) => {
          X.exports = VW();
        },
        6113: (X) => {
          X.exports = k1("crypto");
        },
        5686: (X, Y, Q) => {
          (Q.r(Y), Q.d(Y, { flatbuffers: () => G }));
          var G = {};
          (G.Offset,
            G.Table,
            (G.SIZEOF_SHORT = 2),
            (G.SIZEOF_INT = 4),
            (G.FILE_IDENTIFIER_LENGTH = 4),
            (G.SIZE_PREFIX_LENGTH = 4),
            (G.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }),
            (G.int32 = new Int32Array(2)),
            (G.float32 = new Float32Array(G.int32.buffer)),
            (G.float64 = new Float64Array(G.int32.buffer)),
            (G.isLittleEndian =
              new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1),
            (G.Long = function (J, U) {
              ((this.low = 0 | J), (this.high = 0 | U));
            }),
            (G.Long.create = function (J, U) {
              return J == 0 && U == 0 ? G.Long.ZERO : new G.Long(J, U);
            }),
            (G.Long.prototype.toFloat64 = function () {
              return (this.low >>> 0) + 4294967296 * this.high;
            }),
            (G.Long.prototype.equals = function (J) {
              return this.low == J.low && this.high == J.high;
            }),
            (G.Long.ZERO = new G.Long(0, 0)),
            (G.Builder = function (J) {
              if (J) U = J;
              else var U = 1024;
              ((this.bb = G.ByteBuffer.allocate(U)),
                (this.space = U),
                (this.minalign = 1),
                (this.vtable = null),
                (this.vtable_in_use = 0),
                (this.isNested = !1),
                (this.object_start = 0),
                (this.vtables = []),
                (this.vector_num_elems = 0),
                (this.force_defaults = !1));
            }),
            (G.Builder.prototype.clear = function () {
              (this.bb.clear(),
                (this.space = this.bb.capacity()),
                (this.minalign = 1),
                (this.vtable = null),
                (this.vtable_in_use = 0),
                (this.isNested = !1),
                (this.object_start = 0),
                (this.vtables = []),
                (this.vector_num_elems = 0),
                (this.force_defaults = !1));
            }),
            (G.Builder.prototype.forceDefaults = function (J) {
              this.force_defaults = J;
            }),
            (G.Builder.prototype.dataBuffer = function () {
              return this.bb;
            }),
            (G.Builder.prototype.asUint8Array = function () {
              return this.bb
                .bytes()
                .subarray(
                  this.bb.position(),
                  this.bb.position() + this.offset()
                );
            }),
            (G.Builder.prototype.prep = function (J, U) {
              J > this.minalign && (this.minalign = J);
              for (
                var $ = (1 + ~(this.bb.capacity() - this.space + U)) & (J - 1);
                this.space < $ + J + U;
              ) {
                var B = this.bb.capacity();
                ((this.bb = G.Builder.growByteBuffer(this.bb)),
                  (this.space += this.bb.capacity() - B));
              }
              this.pad($);
            }),
            (G.Builder.prototype.pad = function (J) {
              for (var U = 0; U < J; U++) this.bb.writeInt8(--this.space, 0);
            }),
            (G.Builder.prototype.writeInt8 = function (J) {
              this.bb.writeInt8((this.space -= 1), J);
            }),
            (G.Builder.prototype.writeInt16 = function (J) {
              this.bb.writeInt16((this.space -= 2), J);
            }),
            (G.Builder.prototype.writeInt32 = function (J) {
              this.bb.writeInt32((this.space -= 4), J);
            }),
            (G.Builder.prototype.writeInt64 = function (J) {
              this.bb.writeInt64((this.space -= 8), J);
            }),
            (G.Builder.prototype.writeFloat32 = function (J) {
              this.bb.writeFloat32((this.space -= 4), J);
            }),
            (G.Builder.prototype.writeFloat64 = function (J) {
              this.bb.writeFloat64((this.space -= 8), J);
            }),
            (G.Builder.prototype.addInt8 = function (J) {
              (this.prep(1, 0), this.writeInt8(J));
            }),
            (G.Builder.prototype.addInt16 = function (J) {
              (this.prep(2, 0), this.writeInt16(J));
            }),
            (G.Builder.prototype.addInt32 = function (J) {
              (this.prep(4, 0), this.writeInt32(J));
            }),
            (G.Builder.prototype.addInt64 = function (J) {
              (this.prep(8, 0), this.writeInt64(J));
            }),
            (G.Builder.prototype.addFloat32 = function (J) {
              (this.prep(4, 0), this.writeFloat32(J));
            }),
            (G.Builder.prototype.addFloat64 = function (J) {
              (this.prep(8, 0), this.writeFloat64(J));
            }),
            (G.Builder.prototype.addFieldInt8 = function (J, U, $) {
              (this.force_defaults || U != $) &&
                (this.addInt8(U), this.slot(J));
            }),
            (G.Builder.prototype.addFieldInt16 = function (J, U, $) {
              (this.force_defaults || U != $) &&
                (this.addInt16(U), this.slot(J));
            }),
            (G.Builder.prototype.addFieldInt32 = function (J, U, $) {
              (this.force_defaults || U != $) &&
                (this.addInt32(U), this.slot(J));
            }),
            (G.Builder.prototype.addFieldInt64 = function (J, U, $) {
              (!this.force_defaults && U.equals($)) ||
                (this.addInt64(U), this.slot(J));
            }),
            (G.Builder.prototype.addFieldFloat32 = function (J, U, $) {
              (this.force_defaults || U != $) &&
                (this.addFloat32(U), this.slot(J));
            }),
            (G.Builder.prototype.addFieldFloat64 = function (J, U, $) {
              (this.force_defaults || U != $) &&
                (this.addFloat64(U), this.slot(J));
            }),
            (G.Builder.prototype.addFieldOffset = function (J, U, $) {
              (this.force_defaults || U != $) &&
                (this.addOffset(U), this.slot(J));
            }),
            (G.Builder.prototype.addFieldStruct = function (J, U, $) {
              U != $ && (this.nested(U), this.slot(J));
            }),
            (G.Builder.prototype.nested = function (J) {
              if (J != this.offset())
                throw Error("FlatBuffers: struct must be serialized inline.");
            }),
            (G.Builder.prototype.notNested = function () {
              if (this.isNested)
                throw Error(
                  "FlatBuffers: object serialization must not be nested."
                );
            }),
            (G.Builder.prototype.slot = function (J) {
              this.vtable[J] = this.offset();
            }),
            (G.Builder.prototype.offset = function () {
              return this.bb.capacity() - this.space;
            }),
            (G.Builder.growByteBuffer = function (J) {
              var U = J.capacity();
              if (3221225472 & U)
                throw Error(
                  "FlatBuffers: cannot grow buffer beyond 2 gigabytes."
                );
              var $ = U << 1,
                B = G.ByteBuffer.allocate($);
              return (B.setPosition($ - U), B.bytes().set(J.bytes(), $ - U), B);
            }),
            (G.Builder.prototype.addOffset = function (J) {
              (this.prep(G.SIZEOF_INT, 0),
                this.writeInt32(this.offset() - J + G.SIZEOF_INT));
            }),
            (G.Builder.prototype.startObject = function (J) {
              (this.notNested(),
                this.vtable == null && (this.vtable = []),
                (this.vtable_in_use = J));
              for (var U = 0; U < J; U++) this.vtable[U] = 0;
              ((this.isNested = !0), (this.object_start = this.offset()));
            }),
            (G.Builder.prototype.endObject = function () {
              if (this.vtable == null || !this.isNested)
                throw Error(
                  "FlatBuffers: endObject called without startObject"
                );
              this.addInt32(0);
              for (
                var J = this.offset(), U = this.vtable_in_use - 1;
                U >= 0 && this.vtable[U] == 0;
                U--
              );
              for (var $ = U + 1; U >= 0; U--)
                this.addInt16(this.vtable[U] != 0 ? J - this.vtable[U] : 0);
              this.addInt16(J - this.object_start);
              var B = ($ + 2) * G.SIZEOF_SHORT;
              this.addInt16(B);
              var K = 0,
                V = this.space;
              X: for (U = 0; U < this.vtables.length; U++) {
                var W = this.bb.capacity() - this.vtables[U];
                if (B == this.bb.readInt16(W)) {
                  for (var L = G.SIZEOF_SHORT; L < B; L += G.SIZEOF_SHORT)
                    if (this.bb.readInt16(V + L) != this.bb.readInt16(W + L))
                      continue X;
                  K = this.vtables[U];
                  break;
                }
              }
              return (
                K
                  ? ((this.space = this.bb.capacity() - J),
                    this.bb.writeInt32(this.space, K - J))
                  : (this.vtables.push(this.offset()),
                    this.bb.writeInt32(
                      this.bb.capacity() - J,
                      this.offset() - J
                    )),
                (this.isNested = !1),
                J
              );
            }),
            (G.Builder.prototype.finish = function (J, U, $) {
              var B = $ ? G.SIZE_PREFIX_LENGTH : 0;
              if (U) {
                var K = U;
                if (
                  (this.prep(
                    this.minalign,
                    G.SIZEOF_INT + G.FILE_IDENTIFIER_LENGTH + B
                  ),
                  K.length != G.FILE_IDENTIFIER_LENGTH)
                )
                  throw Error(
                    "FlatBuffers: file identifier must be length " +
                      G.FILE_IDENTIFIER_LENGTH
                  );
                for (var V = G.FILE_IDENTIFIER_LENGTH - 1; V >= 0; V--)
                  this.writeInt8(K.charCodeAt(V));
              }
              (this.prep(this.minalign, G.SIZEOF_INT + B),
                this.addOffset(J),
                B && this.addInt32(this.bb.capacity() - this.space),
                this.bb.setPosition(this.space));
            }),
            (G.Builder.prototype.finishSizePrefixed = function (J, U) {
              this.finish(J, U, !0);
            }),
            (G.Builder.prototype.requiredField = function (J, U) {
              var $ = this.bb.capacity() - J,
                B = $ - this.bb.readInt32($);
              if (this.bb.readInt16(B + U) == 0)
                throw Error("FlatBuffers: field " + U + " must be set");
            }),
            (G.Builder.prototype.startVector = function (J, U, $) {
              (this.notNested(),
                (this.vector_num_elems = U),
                this.prep(G.SIZEOF_INT, J * U),
                this.prep($, J * U));
            }),
            (G.Builder.prototype.endVector = function () {
              return (this.writeInt32(this.vector_num_elems), this.offset());
            }),
            (G.Builder.prototype.createString = function (J) {
              if (J instanceof Uint8Array) var U = J;
              else {
                U = [];
                for (var $ = 0; $ < J.length; ) {
                  var B,
                    K = J.charCodeAt($++);
                  (B =
                    K < 55296 || K >= 56320
                      ? K
                      : (K << 10) + J.charCodeAt($++) + -56613888) < 128
                    ? U.push(B)
                    : (B < 2048
                        ? U.push(((B >> 6) & 31) | 192)
                        : (B < 65536
                            ? U.push(((B >> 12) & 15) | 224)
                            : U.push(
                                ((B >> 18) & 7) | 240,
                                ((B >> 12) & 63) | 128
                              ),
                          U.push(((B >> 6) & 63) | 128)),
                      U.push((63 & B) | 128));
                }
              }
              (this.addInt8(0),
                this.startVector(1, U.length, 1),
                this.bb.setPosition((this.space -= U.length)),
                ($ = 0));
              for (var V = this.space, W = this.bb.bytes(); $ < U.length; $++)
                W[V++] = U[$];
              return this.endVector();
            }),
            (G.Builder.prototype.createLong = function (J, U) {
              return G.Long.create(J, U);
            }),
            (G.ByteBuffer = function (J) {
              ((this.bytes_ = J), (this.position_ = 0));
            }),
            (G.ByteBuffer.allocate = function (J) {
              return new G.ByteBuffer(new Uint8Array(J));
            }),
            (G.ByteBuffer.prototype.clear = function () {
              this.position_ = 0;
            }),
            (G.ByteBuffer.prototype.bytes = function () {
              return this.bytes_;
            }),
            (G.ByteBuffer.prototype.position = function () {
              return this.position_;
            }),
            (G.ByteBuffer.prototype.setPosition = function (J) {
              this.position_ = J;
            }),
            (G.ByteBuffer.prototype.capacity = function () {
              return this.bytes_.length;
            }),
            (G.ByteBuffer.prototype.readInt8 = function (J) {
              return (this.readUint8(J) << 24) >> 24;
            }),
            (G.ByteBuffer.prototype.readUint8 = function (J) {
              return this.bytes_[J];
            }),
            (G.ByteBuffer.prototype.readInt16 = function (J) {
              return (this.readUint16(J) << 16) >> 16;
            }),
            (G.ByteBuffer.prototype.readUint16 = function (J) {
              return this.bytes_[J] | (this.bytes_[J + 1] << 8);
            }),
            (G.ByteBuffer.prototype.readInt32 = function (J) {
              return (
                this.bytes_[J] |
                (this.bytes_[J + 1] << 8) |
                (this.bytes_[J + 2] << 16) |
                (this.bytes_[J + 3] << 24)
              );
            }),
            (G.ByteBuffer.prototype.readUint32 = function (J) {
              return this.readInt32(J) >>> 0;
            }),
            (G.ByteBuffer.prototype.readInt64 = function (J) {
              return new G.Long(this.readInt32(J), this.readInt32(J + 4));
            }),
            (G.ByteBuffer.prototype.readUint64 = function (J) {
              return new G.Long(this.readUint32(J), this.readUint32(J + 4));
            }),
            (G.ByteBuffer.prototype.readFloat32 = function (J) {
              return ((G.int32[0] = this.readInt32(J)), G.float32[0]);
            }),
            (G.ByteBuffer.prototype.readFloat64 = function (J) {
              return (
                (G.int32[G.isLittleEndian ? 0 : 1] = this.readInt32(J)),
                (G.int32[G.isLittleEndian ? 1 : 0] = this.readInt32(J + 4)),
                G.float64[0]
              );
            }),
            (G.ByteBuffer.prototype.writeInt8 = function (J, U) {
              this.bytes_[J] = U;
            }),
            (G.ByteBuffer.prototype.writeUint8 = function (J, U) {
              this.bytes_[J] = U;
            }),
            (G.ByteBuffer.prototype.writeInt16 = function (J, U) {
              ((this.bytes_[J] = U), (this.bytes_[J + 1] = U >> 8));
            }),
            (G.ByteBuffer.prototype.writeUint16 = function (J, U) {
              ((this.bytes_[J] = U), (this.bytes_[J + 1] = U >> 8));
            }),
            (G.ByteBuffer.prototype.writeInt32 = function (J, U) {
              ((this.bytes_[J] = U),
                (this.bytes_[J + 1] = U >> 8),
                (this.bytes_[J + 2] = U >> 16),
                (this.bytes_[J + 3] = U >> 24));
            }),
            (G.ByteBuffer.prototype.writeUint32 = function (J, U) {
              ((this.bytes_[J] = U),
                (this.bytes_[J + 1] = U >> 8),
                (this.bytes_[J + 2] = U >> 16),
                (this.bytes_[J + 3] = U >> 24));
            }),
            (G.ByteBuffer.prototype.writeInt64 = function (J, U) {
              (this.writeInt32(J, U.low), this.writeInt32(J + 4, U.high));
            }),
            (G.ByteBuffer.prototype.writeUint64 = function (J, U) {
              (this.writeUint32(J, U.low), this.writeUint32(J + 4, U.high));
            }),
            (G.ByteBuffer.prototype.writeFloat32 = function (J, U) {
              ((G.float32[0] = U), this.writeInt32(J, G.int32[0]));
            }),
            (G.ByteBuffer.prototype.writeFloat64 = function (J, U) {
              ((G.float64[0] = U),
                this.writeInt32(J, G.int32[G.isLittleEndian ? 0 : 1]),
                this.writeInt32(J + 4, G.int32[G.isLittleEndian ? 1 : 0]));
            }),
            (G.ByteBuffer.prototype.getBufferIdentifier = function () {
              if (
                this.bytes_.length <
                this.position_ + G.SIZEOF_INT + G.FILE_IDENTIFIER_LENGTH
              )
                throw Error(
                  "FlatBuffers: ByteBuffer is too short to contain an identifier."
                );
              for (var J = "", U = 0; U < G.FILE_IDENTIFIER_LENGTH; U++)
                J += String.fromCharCode(
                  this.readInt8(this.position_ + G.SIZEOF_INT + U)
                );
              return J;
            }),
            (G.ByteBuffer.prototype.__offset = function (J, U) {
              var $ = J - this.readInt32(J);
              return U < this.readInt16($) ? this.readInt16($ + U) : 0;
            }),
            (G.ByteBuffer.prototype.__union = function (J, U) {
              return ((J.bb_pos = U + this.readInt32(U)), (J.bb = this), J);
            }),
            (G.ByteBuffer.prototype.__string = function (J, U) {
              J += this.readInt32(J);
              var $ = this.readInt32(J),
                B = "",
                K = 0;
              if (((J += G.SIZEOF_INT), U === G.Encoding.UTF8_BYTES))
                return this.bytes_.subarray(J, J + $);
              for (; K < $; ) {
                var V,
                  W = this.readUint8(J + K++);
                if (W < 192) V = W;
                else {
                  var L = this.readUint8(J + K++);
                  if (W < 224) V = ((31 & W) << 6) | (63 & L);
                  else {
                    var H = this.readUint8(J + K++);
                    V =
                      W < 240
                        ? ((15 & W) << 12) | ((63 & L) << 6) | (63 & H)
                        : ((7 & W) << 18) |
                          ((63 & L) << 12) |
                          ((63 & H) << 6) |
                          (63 & this.readUint8(J + K++));
                  }
                }
                V < 65536
                  ? (B += String.fromCharCode(V))
                  : ((V -= 65536),
                    (B += String.fromCharCode(
                      55296 + (V >> 10),
                      56320 + (1023 & V)
                    )));
              }
              return B;
            }),
            (G.ByteBuffer.prototype.__indirect = function (J) {
              return J + this.readInt32(J);
            }),
            (G.ByteBuffer.prototype.__vector = function (J) {
              return J + this.readInt32(J) + G.SIZEOF_INT;
            }),
            (G.ByteBuffer.prototype.__vector_len = function (J) {
              return this.readInt32(J + this.readInt32(J));
            }),
            (G.ByteBuffer.prototype.__has_identifier = function (J) {
              if (J.length != G.FILE_IDENTIFIER_LENGTH)
                throw Error(
                  "FlatBuffers: file identifier must be length " +
                    G.FILE_IDENTIFIER_LENGTH
                );
              for (var U = 0; U < G.FILE_IDENTIFIER_LENGTH; U++)
                if (
                  J.charCodeAt(U) !=
                  this.readInt8(this.position_ + G.SIZEOF_INT + U)
                )
                  return !1;
              return !0;
            }),
            (G.ByteBuffer.prototype.createLong = function (J, U) {
              return G.Long.create(J, U);
            }));
        },
      },
      __webpack_module_cache__ = {};
    function __webpack_require__(X) {
      var Y = __webpack_module_cache__[X];
      if (Y !== void 0) return Y.exports;
      var Q = (__webpack_module_cache__[X] = { exports: {} });
      return (
        __webpack_modules__[X].call(
          Q.exports,
          Q,
          Q.exports,
          __webpack_require__
        ),
        Q.exports
      );
    }
    ((__webpack_require__.n = (X) => {
      var Y = X && X.__esModule ? () => X.default : () => X;
      return (__webpack_require__.d(Y, { a: Y }), Y);
    }),
      (__webpack_require__.d = (X, Y) => {
        for (var Q in Y)
          __webpack_require__.o(Y, Q) &&
            !__webpack_require__.o(X, Q) &&
            Object.defineProperty(X, Q, { enumerable: !0, get: Y[Q] });
      }),
      (__webpack_require__.o = (X, Y) =>
        Object.prototype.hasOwnProperty.call(X, Y)),
      (__webpack_require__.r = (X) => {
        (typeof Symbol < "u" &&
          Symbol.toStringTag &&
          Object.defineProperty(X, Symbol.toStringTag, { value: "Module" }),
          Object.defineProperty(X, "__esModule", { value: !0 }));
      }));
    var __webpack_exports__ = __webpack_require__(6018),
      __webpack_export_target__ = rB;
    for (var i in __webpack_exports__)
      __webpack_export_target__[i] = __webpack_exports__[i];
    __webpack_exports__.__esModule &&
      Object.defineProperty(__webpack_export_target__, "__esModule", {
        value: !0,
      });
  })();
});
var oB, sB, A4, PQ;
var FW = U8(() => {
  ((oB = AY(ZP(), 1)), (sB = AY(wP(), 1)), (PQ = ["wasm"]));
  if (typeof process < "u" && process?.release?.name === "node")
    ((A4 = oB.default ?? oB), PQ.unshift("cpu"));
  else if (
    ((A4 = sB.default ?? sB),
    typeof navigator < "u" &&
      /iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent))
  )
    A4.env.wasm.simd = !1;
});
import I10 from "fs";
import k7 from "path";
import P10 from "url";
function PP(X) {
  return Object.keys(X).length === 0;
}
var tB,
  IP = "2.17.2",
  S10,
  eB,
  T10,
  NW,
  MW,
  b10,
  CP = "/models/",
  v10,
  A5;
var AW = U8(() => {
  FW();
  (({ env: tB } = A4),
    (S10 = typeof self < "u" && "caches" in self),
    (eB = !PP(I10)),
    (T10 = !PP(k7)),
    (NW = eB && T10),
    (MW = NW
      ? k7.dirname(k7.dirname(P10.fileURLToPath(import.meta.url)))
      : "./"),
    (b10 = NW ? k7.join(MW, "/.cache/") : null),
    (v10 = NW ? k7.join(MW, CP) : CP));
  if (tB?.wasm)
    tB.wasm.wasmPaths = NW
      ? k7.join(MW, "/dist/")
      : `https://cdn.jsdelivr.net/npm/@xenova/transformers@${IP}/dist/`;
  A5 = {
    backends: { onnx: tB, tfjs: {} },
    __dirname: MW,
    version: IP,
    allowRemoteModels: !0,
    remoteHost: "https://huggingface.co/",
    remotePathTemplate: "{model}/resolve/{revision}/",
    allowLocalModels: !0,
    localModelPath: v10,
    useFS: eB,
    useBrowserCache: S10,
    useFSCache: eB,
    cacheDir: b10,
    useCustomCache: !1,
    customCache: null,
  };
});
import s9 from "fs";
import XK from "path";
class RW {
  _CONTENT_TYPE_MAP = {
    txt: "text/plain",
    html: "text/html",
    css: "text/css",
    js: "text/javascript",
    json: "application/json",
    png: "image/png",
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    gif: "image/gif",
  };
  constructor(X) {
    if (
      ((this.filePath = X),
      (this.headers = new Headers()),
      (this.exists = s9.existsSync(X)),
      this.exists)
    ) {
      ((this.status = 200), (this.statusText = "OK"));
      let Y = s9.statSync(X);
      (this.headers.set("content-length", Y.size.toString()),
        this.updateContentType());
      let Q = this;
      this.body = new ReadableStream({
        start(G) {
          Q.arrayBuffer().then((J) => {
            (G.enqueue(new Uint8Array(J)), G.close());
          });
        },
      });
    } else
      ((this.status = 404),
        (this.statusText = "Not Found"),
        (this.body = null));
  }
  updateContentType() {
    let X = this.filePath.toString().split(".").pop().toLowerCase();
    this.headers.set(
      "content-type",
      this._CONTENT_TYPE_MAP[X] ?? "application/octet-stream"
    );
  }
  clone() {
    let X = new RW(this.filePath);
    return (
      (X.exists = this.exists),
      (X.status = this.status),
      (X.statusText = this.statusText),
      (X.headers = new Headers(this.headers)),
      X
    );
  }
  async arrayBuffer() {
    return (await s9.promises.readFile(this.filePath)).buffer;
  }
  async blob() {
    let X = await s9.promises.readFile(this.filePath);
    return new Blob([X], { type: this.headers.get("content-type") });
  }
  async text() {
    return await s9.promises.readFile(this.filePath, "utf8");
  }
  async json() {
    return JSON.parse(await this.text());
  }
}
function YK(X, Y = null, Q = null) {
  let G;
  try {
    G = new URL(X);
  } catch (J) {
    return !1;
  }
  if (Y && !Y.includes(G.protocol)) return !1;
  if (Q && !Q.includes(G.hostname)) return !1;
  return !0;
}
async function y7(X) {
  if (A5.useFS && !YK(X, ["http:", "https:", "blob:"])) return new RW(X);
  else if (typeof process < "u" && process?.release?.name === "node") {
    let Y = !!process.env?.TESTING_REMOTELY,
      Q = A5.version,
      G = new Headers();
    if (
      (G.set("User-Agent", `transformers.js/${Q}; is_ci/${Y};`),
      YK(X, ["http:", "https:"], ["huggingface.co", "hf.co"]))
    ) {
      let U = process.env?.HF_TOKEN ?? process.env?.HF_ACCESS_TOKEN;
      if (U) G.set("Authorization", `Bearer ${U}`);
    }
    return fetch(X, { headers: G });
  } else return fetch(X);
}
function y10(X, Y, Q) {
  if (!Q) return null;
  let G = k10[X] ?? `Error (${X}) occurred while trying to load file`;
  throw Error(`${G}: "${Y}".`);
}
class QK {
  constructor(X) {
    this.path = X;
  }
  async match(X) {
    let Y = XK.join(this.path, X),
      Q = new RW(Y);
    if (Q.exists) return Q;
    else return;
  }
  async put(X, Y) {
    let Q = Buffer.from(await Y.arrayBuffer()),
      G = XK.join(this.path, X);
    try {
      (await s9.promises.mkdir(XK.dirname(G), { recursive: !0 }),
        await s9.promises.writeFile(G, Q));
    } catch (J) {
      console.warn("An error occurred while writing the file to cache:", J);
    }
  }
}
async function _10(X, ...Y) {
  for (let Q of Y)
    try {
      let G = await X.match(Q);
      if (G) return G;
    } catch (G) {
      continue;
    }
  return;
}
async function GK(X, Y, Q = !0, G = {}) {
  if (!A5.allowLocalModels) {
    if (G.local_files_only)
      throw Error(
        "Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`)."
      );
    else if (!A5.allowRemoteModels)
      throw Error(
        "Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`."
      );
  }
  e4(G.progress_callback, { status: "initiate", name: X, file: Y });
  let J;
  if (!J && A5.useBrowserCache) {
    if (typeof caches > "u")
      throw Error("Browser cache is not available in this environment.");
    try {
      J = await caches.open("transformers-cache");
    } catch (A) {
      console.warn("An error occurred while opening the browser cache:", A);
    }
  }
  if (!J && A5.useFSCache) J = new QK(G.cache_dir ?? A5.cacheDir);
  if (!J && A5.useCustomCache) {
    if (!A5.customCache)
      throw Error(
        "`env.useCustomCache=true`, but `env.customCache` is not defined."
      );
    if (!A5.customCache.match || !A5.customCache.put)
      throw Error(
        "`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache"
      );
    J = A5.customCache;
  }
  let U = G.revision ?? "main",
    $ = qW(X, Y),
    B = qW(A5.localModelPath, $),
    K = qW(
      A5.remoteHost,
      A5.remotePathTemplate
        .replaceAll("{model}", X)
        .replaceAll("{revision}", encodeURIComponent(U)),
      Y
    ),
    V = U === "main" ? $ : qW(X, U, Y),
    W,
    L = J instanceof QK ? V : K,
    H = !1,
    F;
  if (J) F = await _10(J, B, L);
  let N = F !== void 0;
  if (F === void 0) {
    if (A5.allowLocalModels) {
      if (!YK($, ["http:", "https:"]))
        try {
          ((F = await y7(B)), (W = B));
        } catch (D) {
          console.warn(`Unable to load from local path "${B}": "${D}"`);
        }
      else if (G.local_files_only)
        throw Error(
          `\`local_files_only=true\`, but attempted to load a remote file from: ${$}.`
        );
      else if (!A5.allowRemoteModels)
        throw Error(
          `\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${$}.`
        );
    }
    if (F === void 0 || F.status === 404) {
      if (G.local_files_only || !A5.allowRemoteModels)
        if (Q)
          throw Error(
            `\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${B}".`
          );
        else return null;
      if (((F = await y7(K)), F.status !== 200)) return y10(F.status, K, Q);
      W = L;
    }
    H = J && typeof Response < "u" && F instanceof Response && F.status === 200;
  }
  e4(G.progress_callback, { status: "download", name: X, file: Y });
  let q = { status: "progress", name: X, file: Y },
    M;
  if (!G.progress_callback) M = new Uint8Array(await F.arrayBuffer());
  else if (N && typeof navigator < "u" && /firefox/i.test(navigator.userAgent))
    ((M = new Uint8Array(await F.arrayBuffer())),
      e4(G.progress_callback, {
        ...q,
        progress: 100,
        loaded: M.length,
        total: M.length,
      }));
  else
    M = await f10(F, (A) => {
      e4(G.progress_callback, { ...q, ...A });
    });
  if (H && W && (await J.match(W)) === void 0)
    await J.put(W, new Response(M, { headers: F.headers })).catch((A) => {
      console.warn(`Unable to add response to browser cache: ${A}.`);
    });
  return (e4(G.progress_callback, { status: "done", name: X, file: Y }), M);
}
async function g6(X, Y, Q = !0, G = {}) {
  let J = await GK(X, Y, Q, G);
  if (J === null) return {};
  let $ = new TextDecoder("utf-8").decode(J);
  return JSON.parse($);
}
async function f10(X, Y) {
  let Q = X.headers.get("Content-Length");
  if (Q === null)
    console.warn(
      "Unable to determine content-length from response headers. Will expand buffer when needed."
    );
  let G = parseInt(Q ?? "0"),
    J = new Uint8Array(G),
    U = 0,
    $ = X.body.getReader();
  async function B() {
    let { done: K, value: V } = await $.read();
    if (K) return;
    let W = U + V.length;
    if (W > G) {
      G = W;
      let H = new Uint8Array(G);
      (H.set(J), (J = H));
    }
    (J.set(V, U), (U = W));
    let L = (U / G) * 100;
    return (Y({ progress: L, loaded: U, total: G }), B());
  }
  return (await B(), J);
}
function qW(...X) {
  return (
    (X = X.map((Y, Q) => {
      if (Q) Y = Y.replace(new RegExp("^/"), "");
      if (Q !== X.length - 1) Y = Y.replace(new RegExp("/$"), "");
      return Y;
    })),
    X.join("/")
  );
}
var k10;
var t9 = U8(() => {
  AW();
  k10 = {
    400: "Bad request error occurred while trying to load file",
    401: "Unauthorized access to file",
    403: "Forbidden access to file",
    404: "Could not locate file",
    408: "Request timeout error occurred while trying to load file",
    500: "Internal server error error occurred while trying to load file",
    502: "Bad gateway error occurred while trying to load file",
    503: "Service unavailable error occurred while trying to load file",
    504: "Gateway timeout error occurred while trying to load file",
  };
});
function WK(X, [Y, Q, G], [J, U], $ = "bilinear", B = !1) {
  let K = U / G,
    V = J / Q,
    W = new X.constructor(J * U * Y),
    L = Q * G,
    H = J * U;
  for (let F = 0; F < J; ++F)
    for (let N = 0; N < U; ++N) {
      let q = F * U + N,
        M = (N + 0.5) / K - 0.5,
        A = (F + 0.5) / V - 0.5,
        D = Math.floor(M),
        R = Math.floor(A),
        z = Math.min(D + 1, G - 1),
        E = Math.min(R + 1, Q - 1);
      ((D = Math.max(D, 0)), (R = Math.max(R, 0)));
      let O = M - D,
        Z = A - R,
        j = (1 - O) * (1 - Z),
        w = O * (1 - Z),
        I = (1 - O) * Z,
        T = O * Z,
        y = R * G,
        _ = E * G,
        f = y + D,
        l = y + z,
        h = _ + D,
        p = _ + z;
      for (let N0 = 0; N0 < Y; ++N0) {
        let e = N0 * L;
        W[N0 * H + q] =
          j * X[e + f] + w * X[e + l] + I * X[e + h] + T * X[e + p];
      }
    }
  return W;
}
function HK(X, Y, Q) {
  let G = Array(Q.length),
    J = Array(Q.length);
  for (let B = Q.length - 1, K = 1; B >= 0; --B)
    ((J[B] = K), (G[B] = Y[Q[B]]), (K *= G[B]));
  let U = Q.map((B, K) => J[Q.indexOf(K)]),
    $ = new X.constructor(X.length);
  for (let B = 0; B < X.length; ++B) {
    let K = 0;
    for (let V = Y.length - 1, W = B; V >= 0; --V)
      ((K += (W % Y[V]) * U[V]), (W = Math.floor(W / Y[V])));
    $[K] = X[B];
  }
  return [$, G];
}
function Z5(X) {
  let Y = x5(X)[0],
    Q = X.map((U) => Math.exp(U - Y)),
    G = Q.reduce((U, $) => U + $, 0);
  return Q.map((U) => U / G);
}
function $K(X) {
  return Z5(X).map((G) => Math.log(G));
}
function SP(X, Y) {
  let Q = 0;
  for (let G = 0; G < X.length; ++G) Q += X[G] * Y[G];
  return Q;
}
function q4(X, Y = 0) {
  if (
    ((X = Array.from(X)
      .map((Q, G) => [G, Q])
      .sort((Q, G) => G[1] - Q[1])),
    Y !== null && Y > 0)
  )
    X = X.slice(0, Y);
  return X;
}
function x10(X, Y) {
  let Q = SP(X, Y),
    G = JK(X),
    J = JK(Y);
  return Q / (G * J);
}
function JK(X) {
  return Math.sqrt(X.reduce((Y, Q) => Y + Q * Q, 0));
}
function SQ(X) {
  if (X.length === 0) throw Error("Array must not be empty");
  let Y = X[0],
    Q = 0;
  for (let G = 1; G < X.length; ++G) if (X[G] < Y) ((Y = X[G]), (Q = G));
  return [Y, Q];
}
function x5(X) {
  if (X.length === 0) throw Error("Array must not be empty");
  let Y = X[0],
    Q = 0;
  for (let G = 1; G < X.length; ++G) if (X[G] > Y) ((Y = X[G]), (Q = G));
  return [Number(Y), Q];
}
function TP(X) {
  return X > 0 && (X & (X - 1)) === 0;
}
class UK {
  constructor(X) {
    if (((this.size = X | 0), this.size <= 1 || !TP(this.size)))
      throw Error("FFT size must be a power of two larger than 1");
    ((this._csize = X << 1), (this.table = new Float64Array(this.size * 2)));
    for (let Q = 0; Q < this.table.length; Q += 2) {
      let G = (Math.PI * Q) / this.size;
      ((this.table[Q] = Math.cos(G)), (this.table[Q + 1] = -Math.sin(G)));
    }
    let Y = 0;
    for (let Q = 1; this.size > Q; Q <<= 1) ++Y;
    ((this._width = Y % 2 === 0 ? Y - 1 : Y),
      (this._bitrev = new Int32Array(1 << this._width)));
    for (let Q = 0; Q < this._bitrev.length; ++Q) {
      this._bitrev[Q] = 0;
      for (let G = 0; G < this._width; G += 2) {
        let J = this._width - G - 2;
        this._bitrev[Q] |= ((Q >>> G) & 3) << J;
      }
    }
  }
  createComplexArray() {
    return new Float64Array(this._csize);
  }
  fromComplexArray(X, Y) {
    let Q = Y || Array(X.length >>> 1);
    for (let G = 0; G < X.length; G += 2) Q[G >>> 1] = X[G];
    return Q;
  }
  toComplexArray(X, Y) {
    let Q = Y || this.createComplexArray();
    for (let G = 0; G < Q.length; G += 2) ((Q[G] = X[G >>> 1]), (Q[G + 1] = 0));
    return Q;
  }
  transform(X, Y) {
    if (X === Y) throw Error("Input and output buffers must be different");
    this._transform4(X, Y, 1);
  }
  realTransform(X, Y) {
    if (X === Y) throw Error("Input and output buffers must be different");
    this._realTransform4(X, Y, 1);
  }
  inverseTransform(X, Y) {
    if (X === Y) throw Error("Input and output buffers must be different");
    this._transform4(X, Y, -1);
    for (let Q = 0; Q < X.length; ++Q) X[Q] /= this.size;
  }
  _transform4(X, Y, Q) {
    let G = this._csize,
      U = 1 << this._width,
      $ = (G / U) << 1,
      B,
      K,
      V = this._bitrev;
    if ($ === 4)
      for (B = 0, K = 0; B < G; B += $, ++K) {
        let L = V[K];
        this._singleTransform2(Y, X, B, L, U);
      }
    else
      for (B = 0, K = 0; B < G; B += $, ++K) {
        let L = V[K];
        this._singleTransform4(Y, X, B, L, U, Q);
      }
    let W = this.table;
    for (U >>= 2; U >= 2; U >>= 2) {
      $ = (G / U) << 1;
      let L = $ >>> 2;
      for (B = 0; B < G; B += $) {
        let H = B + L - 1;
        for (let F = B, N = 0; F < H; F += 2, N += U) {
          let q = F,
            M = q + L,
            A = M + L,
            D = A + L,
            R = X[q],
            z = X[q + 1],
            E = X[M],
            O = X[M + 1],
            Z = X[A],
            j = X[A + 1],
            w = X[D],
            I = X[D + 1],
            T = W[N],
            y = Q * W[N + 1],
            _ = E * T - O * y,
            f = E * y + O * T,
            l = W[2 * N],
            h = Q * W[2 * N + 1],
            p = Z * l - j * h,
            N0 = Z * h + j * l,
            e = W[3 * N],
            P = Q * W[3 * N + 1],
            x = w * e - I * P,
            r = w * P + I * e,
            C = R + p,
            v = z + N0,
            k = R - p,
            o = z - N0,
            J0 = _ + x,
            z0 = f + r,
            A0 = Q * (_ - x),
            w0 = Q * (f - r);
          ((X[q] = C + J0),
            (X[q + 1] = v + z0),
            (X[M] = k + w0),
            (X[M + 1] = o - A0),
            (X[A] = C - J0),
            (X[A + 1] = v - z0),
            (X[D] = k - w0),
            (X[D + 1] = o + A0));
        }
      }
    }
  }
  _singleTransform2(X, Y, Q, G, J) {
    let U = X[G],
      $ = X[G + 1],
      B = X[G + J],
      K = X[G + J + 1];
    ((Y[Q] = U + B),
      (Y[Q + 1] = $ + K),
      (Y[Q + 2] = U - B),
      (Y[Q + 3] = $ - K));
  }
  _singleTransform4(X, Y, Q, G, J, U) {
    let $ = J * 2,
      B = J * 3,
      K = X[G],
      V = X[G + 1],
      W = X[G + J],
      L = X[G + J + 1],
      H = X[G + $],
      F = X[G + $ + 1],
      N = X[G + B],
      q = X[G + B + 1],
      M = K + H,
      A = V + F,
      D = K - H,
      R = V - F,
      z = W + N,
      E = L + q,
      O = U * (W - N),
      Z = U * (L - q);
    ((Y[Q] = M + z),
      (Y[Q + 1] = A + E),
      (Y[Q + 2] = D + Z),
      (Y[Q + 3] = R - O),
      (Y[Q + 4] = M - z),
      (Y[Q + 5] = A - E),
      (Y[Q + 6] = D - Z),
      (Y[Q + 7] = R + O));
  }
  _realTransform4(X, Y, Q) {
    let G = this._csize,
      U = 1 << this._width,
      $ = (G / U) << 1,
      B,
      K,
      V = this._bitrev;
    if ($ === 4)
      for (B = 0, K = 0; B < G; B += $, ++K) {
        let H = V[K];
        this._singleRealTransform2(Y, X, B, H >>> 1, U >>> 1);
      }
    else
      for (B = 0, K = 0; B < G; B += $, ++K) {
        let H = V[K];
        this._singleRealTransform4(Y, X, B, H >>> 1, U >>> 1, Q);
      }
    let W = this.table;
    for (U >>= 2; U >= 2; U >>= 2) {
      $ = (G / U) << 1;
      let H = $ >>> 1,
        F = H >>> 1,
        N = F >>> 1;
      for (B = 0; B < G; B += $)
        for (let q = 0, M = 0; q <= N; q += 2, M += U) {
          let A = B + q,
            D = A + F,
            R = D + F,
            z = R + F,
            E = X[A],
            O = X[A + 1],
            Z = X[D],
            j = X[D + 1],
            w = X[R],
            I = X[R + 1],
            T = X[z],
            y = X[z + 1],
            _ = E,
            f = O,
            l = W[M],
            h = Q * W[M + 1],
            p = Z * l - j * h,
            N0 = Z * h + j * l,
            e = W[2 * M],
            P = Q * W[2 * M + 1],
            x = w * e - I * P,
            r = w * P + I * e,
            C = W[3 * M],
            v = Q * W[3 * M + 1],
            k = T * C - y * v,
            o = T * v + y * C,
            J0 = _ + x,
            z0 = f + r,
            A0 = _ - x,
            w0 = f - r,
            Y1 = p + k,
            b = N0 + o,
            m = Q * (p - k),
            n = Q * (N0 - o);
          if (
            ((X[A] = J0 + Y1),
            (X[A + 1] = z0 + b),
            (X[D] = A0 + n),
            (X[D + 1] = w0 - m),
            q === 0)
          ) {
            ((X[R] = J0 - Y1), (X[R + 1] = z0 - b));
            continue;
          }
          if (q === N) continue;
          let M0 = B + F - q,
            D0 = B + H - q;
          ((X[M0] = A0 - Q * n),
            (X[M0 + 1] = -w0 - Q * m),
            (X[D0] = J0 - Q * Y1),
            (X[D0 + 1] = -z0 + Q * b));
        }
    }
    let L = G >>> 1;
    for (let H = 2; H < L; H += 2)
      ((X[G - H] = X[H]), (X[G - H + 1] = -X[H + 1]));
  }
  _singleRealTransform2(X, Y, Q, G, J) {
    let U = X[G],
      $ = X[G + J];
    ((Y[Q] = U + $), (Y[Q + 1] = 0), (Y[Q + 2] = U - $), (Y[Q + 3] = 0));
  }
  _singleRealTransform4(X, Y, Q, G, J, U) {
    let $ = J * 2,
      B = J * 3,
      K = X[G],
      V = X[G + J],
      W = X[G + $],
      L = X[G + B],
      H = K + W,
      F = K - W,
      N = V + L,
      q = U * (V - L);
    ((Y[Q] = H + N),
      (Y[Q + 1] = 0),
      (Y[Q + 2] = F),
      (Y[Q + 3] = -q),
      (Y[Q + 4] = H - N),
      (Y[Q + 5] = 0),
      (Y[Q + 6] = F),
      (Y[Q + 7] = q));
  }
}
class bP {
  constructor(X) {
    let Y = 2 * (X - 1),
      Q = 2 * (2 * X - 1),
      G = 2 ** Math.ceil(Math.log2(Q));
    ((this.bufferSize = G), (this._a = Y));
    let J = new Float64Array(Q),
      U = new Float64Array(G);
    ((this._chirpBuffer = new Float64Array(G)),
      (this._buffer1 = new Float64Array(G)),
      (this._buffer2 = new Float64Array(G)),
      (this._outBuffer1 = new Float64Array(G)),
      (this._outBuffer2 = new Float64Array(G)));
    let $ = (-2 * Math.PI) / X,
      B = Math.cos($),
      K = Math.sin($);
    for (let V = 0; V < Q >> 1; ++V) {
      let W = (V + 1 - X) ** 2 / 2,
        L = Math.sqrt(B ** 2 + K ** 2) ** W,
        H = W * Math.atan2(K, B),
        F = 2 * V;
      ((J[F] = L * Math.cos(H)),
        (J[F + 1] = L * Math.sin(H)),
        (U[F] = J[F]),
        (U[F + 1] = -J[F + 1]));
    }
    ((this._slicedChirpBuffer = J.subarray(Y, Q)),
      (this._f = new UK(G >> 1)),
      this._f.transform(this._chirpBuffer, U));
  }
  _transform(X, Y, Q) {
    let G = this._buffer1,
      J = this._buffer2,
      U = this._outBuffer1,
      $ = this._outBuffer2,
      B = this._chirpBuffer,
      K = this._slicedChirpBuffer,
      V = this._a;
    if (Q)
      for (let W = 0; W < K.length; W += 2) {
        let L = W + 1,
          H = W >> 1,
          F = Y[H];
        ((G[W] = F * K[W]), (G[L] = F * K[L]));
      }
    else
      for (let W = 0; W < K.length; W += 2) {
        let L = W + 1;
        ((G[W] = Y[W] * K[W] - Y[L] * K[L]),
          (G[L] = Y[W] * K[L] + Y[L] * K[W]));
      }
    this._f.transform(U, G);
    for (let W = 0; W < B.length; W += 2) {
      let L = W + 1;
      ((J[W] = U[W] * B[W] - U[L] * B[L]), (J[L] = U[W] * B[L] + U[L] * B[W]));
    }
    this._f.inverseTransform($, J);
    for (let W = 0; W < $.length; W += 2) {
      let L = $[W + V],
        H = $[W + V + 1],
        F = K[W],
        N = K[W + 1];
      ((X[W] = L * F - H * N), (X[W + 1] = L * N + H * F));
    }
  }
  transform(X, Y) {
    this._transform(X, Y, !1);
  }
  realTransform(X, Y) {
    this._transform(X, Y, !0);
  }
}
class DW {
  constructor(X) {
    if (((this.fft_length = X), (this.isPowerOfTwo = TP(X)), this.isPowerOfTwo))
      ((this.fft = new UK(X)), (this.outputBufferSize = 2 * X));
    else
      ((this.fft = new bP(X)), (this.outputBufferSize = this.fft.bufferSize));
  }
  realTransform(X, Y) {
    this.fft.realTransform(X, Y);
  }
  transform(X, Y) {
    this.fft.transform(X, Y);
  }
}
function LK(X, Y) {
  if (Y % 2 === 0 || Y <= 0)
    throw Error("Window size must be a positive odd number");
  let Q = new X.constructor(X.length),
    G = new X.constructor(Y),
    J = Math.floor(Y / 2);
  for (let U = 0; U < X.length; ++U) {
    let $ = 0;
    for (let B = -J; B <= J; ++B) {
      let K = U + B;
      if (K < 0) K = Math.abs(K);
      else if (K >= X.length) K = 2 * (X.length - 1) - K;
      G[$++] = X[K];
    }
    (G.sort(), (Q[U] = G[J]));
  }
  return Q;
}
function Q9(X, Y) {
  let Q = Math.pow(10, Y);
  return Math.round(X * Q) / Q;
}
function BK(X) {
  let Y = Math.round(X);
  return Math.abs(X) % 1 === 0.5 ? (Y % 2 === 0 ? Y : Y - 1) : Y;
}
function h10(X, Y) {
  let Q = X.length,
    G = Y.reduce((U, $) => U * $);
  if (Q !== G)
    throw Error(`cannot reshape array of size ${Q} into shape (${Y})`);
  let J = X;
  for (let U = Y.length - 1; U >= 0; U--)
    J = J.reduce(
      ($, B) => {
        let K = $[$.length - 1];
        if (K.length < Y[U]) K.push(B);
        else $.push([B]);
        return $;
      },
      [[]]
    );
  return J[0];
}
function KK(X, Y) {
  let [Q, G] = HK(X.data, X.dims, Y);
  return new I0(X.type, Q, G);
}
function J9(X, [Y, Q], G = "bilinear", J = !1) {
  let U = X.dims.at(-3) ?? 1,
    $ = X.dims.at(-2),
    B = X.dims.at(-1),
    K = WK(X.data, [U, $, B], [Y, Q], G, J);
  return new I0(X.type, K, [U, Y, Q]);
}
function VK(X, Y) {
  let Q = [X.dims[0], X.dims[2]],
    G = new X.data.constructor(Q[0] * Q[1]),
    [J, U, $] = X.dims,
    B = 0;
  for (let K = 0; K < J; ++K) {
    let V = K * $ * U;
    for (let W = 0; W < $; ++W) {
      let L = 0,
        H = 0,
        F = K * U,
        N = V + W;
      for (let M = 0; M < U; ++M) {
        let A = Number(Y.data[F + M]);
        ((H += A), (L += X.data[N + M * $] * A));
      }
      let q = L / H;
      G[B++] = q;
    }
  }
  return new I0(X.type, G, Q);
}
function g10(X, Y, { eps: Q = 0.00001 } = {}) {
  if (X.dims.length !== 2)
    throw Error("`layer_norm` currently only supports 2D input.");
  let [G, J] = X.dims;
  if (Y.length !== 1 && Y[0] !== J)
    throw Error(
      "`normalized_shape` must be a 1D array with shape `[input.dims[1]]`."
    );
  let [U, $] = zW(X, 1, 0, !0),
    B = new X.data.constructor(X.data.length);
  for (let K = 0; K < G; ++K) {
    let V = K * J;
    for (let W = 0; W < J; ++W) {
      let L = V + W;
      B[L] = (X.data[L] - $.data[K]) / (U.data[K] + Q);
    }
  }
  return new I0(X.type, B, X.dims);
}
function yP(X, Y) {
  if (((X = X.slice()), Y === null)) X = X.filter((Q) => Q !== 1);
  else if (typeof Y === "number") {
    if (X[Y] === 1) X.splice(Y, 1);
  } else if (Array.isArray(Y))
    X = X.filter((Q, G) => {
      return Q !== 1 || !Y.includes(G);
    });
  return X;
}
function _P(X, Y) {
  return ((Y = G9(Y, X.length + 1)), (X = X.slice()), X.splice(Y, 0, 1), X);
}
function G9(X, Y, Q = null) {
  if (X < -Y || X >= Y)
    throw Error(
      `IndexError: index ${X} is out of bounds for dimension${Q === null ? "" : " " + Q} with size ${Y}`
    );
  if (X < 0) X = ((X % Y) + Y) % Y;
  return X;
}
function e9(X, Y = 0) {
  Y = G9(Y, X[0].dims.length);
  let Q = X[0].dims.slice();
  Q[Y] = X.reduce(($, B) => $ + B.dims[Y], 0);
  let G = Q.reduce(($, B) => $ * B, 1),
    J = new X[0].data.constructor(G),
    U = X[0].type;
  if (Y === 0) {
    let $ = 0;
    for (let B of X) (J.set(B.data, $), ($ += B.data.length));
  } else {
    let $ = 0;
    for (let B = 0; B < X.length; ++B) {
      let K = X[B];
      for (let V = 0; V < K.data.length; ++V) {
        let W = 0;
        for (let L = K.dims.length - 1, H = V, F = 1; L >= 0; --L) {
          let N = K.dims[L],
            q = H % N;
          if (L === Y) q += $;
          ((W += q * F), (F *= Q[L]), (H = Math.floor(H / N)));
        }
        J[W] = K.data[V];
      }
      $ += K.dims[Y];
    }
  }
  return new I0(U, J, Q);
}
function XX(X, Y = 0) {
  return e9(
    X.map((Q) => Q.unsqueeze(Y)),
    Y
  );
}
function zW(X, Y = null, Q = 1, G = !1) {
  if (Y === null) {
    let V = X.data.reduce((F, N) => F + N, 0) / X.data.length,
      W = Math.sqrt(
        X.data.reduce((F, N) => F + (N - V) ** 2, 0) / (X.data.length - Q)
      ),
      L = new I0(X.type, [V], []);
    return [new I0(X.type, [W], []), L];
  }
  Y = G9(Y, X.dims.length);
  let J = EW(X, Y, G),
    U = X.dims.slice();
  U[Y] = 1;
  let $ = new X.data.constructor(X.data.length / X.dims[Y]);
  for (let K = 0; K < X.data.length; ++K) {
    let V = 0;
    for (let W = X.dims.length - 1, L = K, H = 1; W >= 0; --W) {
      let F = X.dims[W];
      if (W !== Y) {
        let N = L % F;
        ((V += N * H), (H *= U[W]));
      }
      L = Math.floor(L / F);
    }
    $[V] += (X.data[K] - J.data[V]) ** 2;
  }
  for (let K = 0; K < $.length; ++K) $[K] = Math.sqrt($[K] / (X.dims[Y] - Q));
  if (!G) U.splice(Y, 1);
  return [new I0(X.type, $, U), J];
}
function EW(X, Y = null, Q = !1) {
  if (Y === null) {
    let U = X.data.reduce(($, B) => $ + B, 0);
    return new I0(X.type, [U / X.data.length], []);
  }
  Y = G9(Y, X.dims.length);
  let G = X.dims.slice();
  G[Y] = 1;
  let J = new X.data.constructor(X.data.length / X.dims[Y]);
  for (let U = 0; U < X.data.length; ++U) {
    let $ = 0;
    for (let B = X.dims.length - 1, K = U, V = 1; B >= 0; --B) {
      let W = X.dims[B];
      if (B !== Y) {
        let L = K % W;
        (($ += L * V), (V *= G[B]));
      }
      K = Math.floor(K / W);
    }
    J[$] += X.data[U];
  }
  if (X.dims[Y] !== 1)
    for (let U = 0; U < J.length; ++U) J[U] = J[U] / X.dims[Y];
  if (!Q) G.splice(Y, 1);
  return new I0(X.type, J, G);
}
function FK(X) {
  let [Y, Q] = X.dims,
    G = [Y + 1, Q + 1],
    J = new I0("float32", new Float32Array(G[0] * G[1]).fill(1 / 0), G),
    U = new I0("float32", new Float32Array(G[0] * G[1]).fill(-1), G);
  J[0].data[0] = 0;
  for (let W = 1; W < Q + 1; ++W)
    for (let L = 1; L < Y + 1; ++L) {
      let H = J[L - 1][W - 1].item(),
        F = J[L - 1][W].item(),
        N = J[L][W - 1].item(),
        q,
        M;
      if (H < F && H < N) ((q = H), (M = 0));
      else if (F < H && F < N) ((q = F), (M = 1));
      else ((q = N), (M = 2));
      ((J[L].data[W] = X[L - 1][W - 1].item() + q), (U[L].data[W] = M));
    }
  let $ = Y,
    B = Q;
  U.data.fill(2, 0, G[1]);
  for (let W = 0; W < G[0]; ++W) U[W].data[0] = 1;
  let K = [],
    V = [];
  while ($ > 0 || B > 0)
    switch ((K.push($ - 1), V.push(B - 1), U[$][B].item())) {
      case 0:
        (--$, --B);
        break;
      case 1:
        --$;
        break;
      case 2:
        --B;
        break;
      default:
        throw Error(
          `Internal error in dynamic time warping. Unexpected trace[${$}, ${B}]. Please file a bug report.`
        );
    }
  return (K.reverse(), V.reverse(), [K, V]);
}
function u10(X) {
  let Y = Array(X.length);
  for (let Q = X.length - 1, G = 1; Q >= 0; --Q) ((Y[Q] = G), (G *= X[Q]));
  return Y;
}
function fP(X) {
  let Y = X.reduce((Q, G) => Q * G, 1);
  return new I0("int64", new BigInt64Array(Y).fill(1n), X);
}
function NK(X) {
  return fP(X.dims);
}
function MK(X, Y) {
  if (X.dims.length !== 2) throw Error("The tensor must have 2 dimensions");
  if (X.dims.at(-1) % 8 !== 0)
    throw Error("The last dimension of the tensor must be a multiple of 8");
  if (!["binary", "ubinary"].includes(Y))
    throw Error("The precision must be either 'binary' or 'ubinary'");
  let Q = Y === "binary",
    G = Q ? "int8" : "uint8",
    J = Q ? Int8Array : Uint8Array,
    U = X.data,
    $ = new J(U.length / 8);
  for (let B = 0; B < U.length; ++B) {
    let K = U[B] > 0 ? 1 : 0,
      V = Math.floor(B / 8),
      W = B % 8;
    if ((($[V] |= K << (7 - W)), Q && W === 0)) $[V] -= 128;
  }
  return new I0(G, $, [X.dims[0], X.dims[1] / 8]);
}
var vP, kP, I0;
var W9 = U8(() => {
  FW();
  ((vP = Object.freeze({
    float32: Float32Array,
    float64: Float64Array,
    string: Array,
    int8: Int8Array,
    uint8: Uint8Array,
    int16: Int16Array,
    uint16: Uint16Array,
    int32: Int32Array,
    uint32: Uint32Array,
    int64: BigInt64Array,
    uint64: BigUint64Array,
    bool: Uint8Array,
  })),
    (kP = A4.Tensor));
  I0 = class I0 {
    dims;
    type;
    data;
    size;
    constructor(...X) {
      if (X[0] instanceof kP) Object.assign(this, X[0]);
      else Object.assign(this, new kP(X[0], X[1], X[2]));
      return new Proxy(this, {
        get: (Y, Q) => {
          if (typeof Q === "string") {
            let G = Number(Q);
            if (Number.isInteger(G)) return Y._getitem(G);
          }
          return Y[Q];
        },
        set: (Y, Q, G) => {
          return (Y[Q] = G);
        },
      });
    }
    *[Symbol.iterator]() {
      let [X, ...Y] = this.dims;
      if (Y.length > 0) {
        let Q = Y.reduce((G, J) => G * J);
        for (let G = 0; G < X; ++G) yield this._subarray(G, Q, Y);
      } else yield* this.data;
    }
    _getitem(X) {
      let [Y, ...Q] = this.dims;
      if (((X = G9(X, Y)), Q.length > 0)) {
        let G = Q.reduce((J, U) => J * U);
        return this._subarray(X, G, Q);
      } else return new I0(this.type, [this.data[X]], Q);
    }
    indexOf(X) {
      for (let Y = 0; Y < this.data.length; ++Y)
        if (this.data[Y] == X) return Y;
      return -1;
    }
    _subarray(X, Y, Q) {
      let G = X * Y,
        J = (X + 1) * Y,
        U =
          "subarray" in this.data
            ? this.data.subarray(G, J)
            : this.data.slice(G, J);
      return new I0(this.type, U, Q);
    }
    item() {
      if (this.data.length !== 1)
        throw Error(
          `a Tensor with ${this.data.length} elements cannot be converted to Scalar`
        );
      return this.data[0];
    }
    tolist() {
      return h10(this.data, this.dims);
    }
    sigmoid() {
      return this.clone().sigmoid_();
    }
    sigmoid_() {
      for (let X = 0; X < this.data.length; ++X)
        this.data[X] = 1 / (1 + Math.exp(-this.data[X]));
      return this;
    }
    mul(X) {
      return this.clone().mul_(X);
    }
    mul_(X) {
      for (let Y = 0; Y < this.data.length; ++Y) this.data[Y] *= X;
      return this;
    }
    add(X) {
      return this.clone().add_(X);
    }
    add_(X) {
      for (let Y = 0; Y < this.data.length; ++Y) this.data[Y] += X;
      return this;
    }
    clone() {
      return new I0(this.type, this.data.slice(), this.dims.slice());
    }
    slice(...X) {
      let Y = [],
        Q = [];
      for (let B = 0; B < this.dims.length; ++B) {
        let K = X[B];
        if (K === null || K === void 0)
          (Q.push([0, this.dims[B]]), Y.push(this.dims[B]));
        else if (typeof K === "number")
          ((K = G9(K, this.dims[B], B)), Q.push([K, K + 1]));
        else if (Array.isArray(K) && K.length === 2) {
          if (K[0] > K[1]) throw Error(`Invalid slice: ${K}`);
          let V = [Math.max(K[0], 0), Math.min(K[1], this.dims[B])];
          (Q.push(V), Y.push(V[1] - V[0]));
        } else throw Error(`Invalid slice: ${K}`);
      }
      let G = Q.map(([B, K]) => K - B),
        J = G.reduce((B, K) => B * K),
        U = new this.data.constructor(J),
        $ = this.stride();
      for (let B = 0; B < J; ++B) {
        let K = 0;
        for (let V = G.length - 1, W = B; V >= 0; --V) {
          let L = G[V];
          ((K += ((W % L) + Q[V][0]) * $[V]), (W = Math.floor(W / L)));
        }
        U[B] = this.data[K];
      }
      return new I0(this.type, U, Y);
    }
    permute(...X) {
      return KK(this, X);
    }
    transpose(...X) {
      return this.permute(...X);
    }
    sum(X = null, Y = !1) {
      return this.norm(1, X, Y);
    }
    norm(X = "fro", Y = null, Q = !1) {
      if (X === "fro") X = 2;
      else if (typeof X === "string") throw Error(`Unsupported norm: ${X}`);
      if (Y === null) {
        let U = this.data.reduce(($, B) => $ + B ** X, 0) ** (1 / X);
        return new I0(this.type, [U], []);
      }
      Y = G9(Y, this.dims.length);
      let G = this.dims.slice();
      G[Y] = 1;
      let J = new this.data.constructor(this.data.length / this.dims[Y]);
      for (let U = 0; U < this.data.length; ++U) {
        let $ = 0;
        for (let B = this.dims.length - 1, K = U, V = 1; B >= 0; --B) {
          let W = this.dims[B];
          if (B !== Y) {
            let L = K % W;
            (($ += L * V), (V *= G[B]));
          }
          K = Math.floor(K / W);
        }
        J[$] += this.data[U] ** X;
      }
      if (X !== 1) for (let U = 0; U < J.length; ++U) J[U] = J[U] ** (1 / X);
      if (!Q) G.splice(Y, 1);
      return new I0(this.type, J, G);
    }
    normalize_(X = 2, Y = 1) {
      Y = G9(Y, this.dims.length);
      let Q = this.norm(X, Y, !0);
      for (let G = 0; G < this.data.length; ++G) {
        let J = 0;
        for (let U = this.dims.length - 1, $ = G, B = 1; U >= 0; --U) {
          let K = this.dims[U];
          if (U !== Y) {
            let V = $ % K;
            ((J += V * B), (B *= this.dims[U]));
          }
          $ = Math.floor($ / K);
        }
        this.data[G] /= Q.data[J];
      }
      return this;
    }
    normalize(X = 2, Y = 1) {
      return this.clone().normalize_(X, Y);
    }
    stride() {
      return u10(this.dims);
    }
    squeeze(X = null) {
      return new I0(this.type, this.data, yP(this.dims, X));
    }
    squeeze_(X = null) {
      return ((this.dims = yP(this.dims, X)), this);
    }
    unsqueeze(X = null) {
      return new I0(this.type, this.data, _P(this.dims, X));
    }
    unsqueeze_(X = null) {
      return ((this.dims = _P(this.dims, X)), this);
    }
    flatten_(X = 0, Y = -1) {
      Y = (Y + this.dims.length) % this.dims.length;
      let Q = this.dims.slice(0, X),
        G = this.dims.slice(X, Y + 1),
        J = this.dims.slice(Y + 1);
      return ((this.dims = [...Q, G.reduce((U, $) => U * $, 1), ...J]), this);
    }
    flatten(X = 0, Y = -1) {
      return this.clone().flatten_(X, Y);
    }
    view(...X) {
      let Y = -1;
      for (let Q = 0; Q < X.length; ++Q)
        if (X[Q] === -1) {
          if (Y !== -1) throw Error("Only one dimension can be inferred");
          Y = Q;
        }
      if (Y !== -1) {
        let Q = X.reduce((G, J, U) => {
          return U !== Y ? G * J : G;
        }, 1);
        X[Y] = this.data.length / Q;
      }
      return new I0(this.type, this.data, X);
    }
    neg_() {
      for (let X = 0; X < this.data.length; ++X) this.data[X] = -this.data[X];
      return this;
    }
    neg() {
      return this.clone().neg_();
    }
    clamp_(X, Y) {
      for (let Q = 0; Q < this.data.length; ++Q)
        this.data[Q] = Math.min(Math.max(this.data[Q], X), Y);
      return this;
    }
    clamp(X, Y) {
      return this.clone().clamp_(X, Y);
    }
    round_() {
      for (let X = 0; X < this.data.length; ++X)
        this.data[X] = Math.round(this.data[X]);
      return this;
    }
    round() {
      return this.clone().round_();
    }
    to(X) {
      if (this.type === X) return this;
      if (!vP.hasOwnProperty(X)) throw Error(`Unsupported type: ${X}`);
      return new I0(X, vP[X].from(this.data), this.dims);
    }
  };
});
class AK {
  constructor(X = (Y, Q) => Y > Q) {
    ((this._heap = []), (this._comparator = X));
  }
  get size() {
    return this._heap.length;
  }
  isEmpty() {
    return this.size === 0;
  }
  peek() {
    return this._heap[0];
  }
  push(...X) {
    return this.extend(X);
  }
  extend(X) {
    for (let Y of X) (this._heap.push(Y), this._siftUp());
    return this.size;
  }
  pop() {
    let X = this.peek(),
      Y = this.size - 1;
    if (Y > 0) this._swap(0, Y);
    return (this._heap.pop(), this._siftDown(), X);
  }
  replace(X) {
    let Y = this.peek();
    return ((this._heap[0] = X), this._siftDown(), Y);
  }
  _parent(X) {
    return ((X + 1) >>> 1) - 1;
  }
  _left(X) {
    return (X << 1) + 1;
  }
  _right(X) {
    return (X + 1) << 1;
  }
  _greater(X, Y) {
    return this._comparator(this._heap[X], this._heap[Y]);
  }
  _swap(X, Y) {
    let Q = this._heap[X];
    ((this._heap[X] = this._heap[Y]), (this._heap[Y] = Q));
  }
  _siftUp() {
    let X = this.size - 1;
    while (X > 0 && this._greater(X, this._parent(X)))
      (this._swap(X, this._parent(X)), (X = this._parent(X)));
  }
  _siftDown() {
    let X = 0;
    while (
      (this._left(X) < this.size && this._greater(this._left(X), X)) ||
      (this._right(X) < this.size && this._greater(this._right(X), X))
    ) {
      let Y =
        this._right(X) < this.size &&
        this._greater(this._right(X), this._left(X))
          ? this._right(X)
          : this._left(X);
      (this._swap(X, Y), (X = Y));
    }
  }
}
class qK {
  constructor() {
    this.root = OW.default();
  }
  extend(X) {
    for (let Y of X) this.push(Y);
  }
  push(X) {
    let Y = this.root;
    for (let Q of X) {
      let G = Y.children.get(Q);
      if (G === void 0) ((G = OW.default()), Y.children.set(Q, G));
      Y = G;
    }
    Y.isLeaf = !0;
  }
  *commonPrefixSearch(X) {
    let Y = this.root,
      Q = "";
    for (let G = 0; G < X.length && Y !== void 0; ++G) {
      let J = X[G];
      if (((Q += J), (Y = Y.children.get(J)), Y !== void 0 && Y.isLeaf))
        yield Q;
    }
  }
}
class OW {
  constructor(X, Y) {
    ((this.isLeaf = X), (this.children = Y));
  }
  static default() {
    return new OW(!1, new Map());
  }
}
class RK {
  constructor(X, Y, Q) {
    ((this.sentence = X),
      (this.len = X.length),
      (this.bosTokenId = Y),
      (this.eosTokenId = Q),
      (this.nodes = []),
      (this.beginNodes = Array.from({ length: this.len + 1 }, () => [])),
      (this.endNodes = Array.from({ length: this.len + 1 }, () => [])));
    let G = new TQ(this.bosTokenId, 0, 0, 0, 0),
      J = new TQ(this.eosTokenId, 1, this.len, 0, 0);
    (this.nodes.push(G.clone()),
      this.nodes.push(J.clone()),
      this.beginNodes[this.len].push(J),
      this.endNodes[0].push(G));
  }
  insert(X, Y, Q, G) {
    let J = this.nodes.length,
      U = new TQ(G, J, X, Y, Q);
    (this.beginNodes[X].push(U),
      this.endNodes[X + Y].push(U),
      this.nodes.push(U));
  }
  viterbi() {
    let X = this.len,
      Y = 0;
    while (Y <= X) {
      if (this.beginNodes[Y].length == 0) return [];
      for (let $ of this.beginNodes[Y]) {
        $.prev = null;
        let B = 0,
          K = null;
        for (let V of this.endNodes[Y]) {
          let W = V.backtraceScore + $.score;
          if (K === null || W > B) ((K = V.clone()), (B = W));
        }
        if (K !== null) (($.prev = K), ($.backtraceScore = B));
        else return [];
      }
      ++Y;
    }
    let Q = [],
      J = this.beginNodes[X][0].prev;
    if (J === null) return [];
    let U = J.clone();
    while (U.prev !== null) (Q.push(U.clone()), (U = U.clone().prev.clone()));
    return (Q.reverse(), Q);
  }
  piece(X) {
    return this.sentence.slice(X.pos, X.pos + X.length);
  }
  tokens() {
    return this.viterbi().map((Y) => this.piece(Y));
  }
  tokenIds() {
    return this.viterbi().map((Y) => Y.tokenId);
  }
}
class TQ {
  constructor(X, Y, Q, G, J) {
    ((this.tokenId = X),
      (this.nodeId = Y),
      (this.pos = Q),
      (this.length = G),
      (this.score = J),
      (this.prev = null),
      (this.backtraceScore = 0));
  }
  clone() {
    let X = new TQ(
      this.tokenId,
      this.nodeId,
      this.pos,
      this.length,
      this.score
    );
    return ((X.prev = this.prev), (X.backtraceScore = this.backtraceScore), X);
  }
}
function hP(X) {
  return /\w/.test(X);
}
function DK(X) {
  return /[0-9]/.test(X);
}
function c10(X, Y = {}) {
  if (
    X.endsWith(`
`)
  )
    X = X.slice(0, -1);
  if (((X = X.replace(/{#.*?#}/gs, "{##}")), Y.lstrip_blocks))
    X = X.replace(/^[ \t]*({[#%])/gm, "$1");
  if (Y.trim_blocks) X = X.replace(/([#%]})\n/g, "$1");
  return X.replace(/{##}/g, "")
    .replace(/-%}\s*/g, "%}")
    .replace(/\s*{%-/g, "{%")
    .replace(/-}}\s*/g, "}}")
    .replace(/\s*{{-/g, "{{");
}
function d10(X, Y = {}) {
  let Q = [],
    G = c10(X, Y),
    J = 0,
    U = ($) => {
      let B = "";
      while ($(G[J])) {
        if (G[J] === "\\") {
          if ((++J, J >= G.length))
            throw SyntaxError("Unexpected end of input");
          let K = G[J++],
            V = m10.get(K);
          if (V === void 0)
            throw SyntaxError(`Unexpected escaped character: ${K}`);
          B += V;
          continue;
        }
        if (((B += G[J++]), J >= G.length))
          throw SyntaxError("Unexpected end of input");
      }
      return B;
    };
  X: while (J < G.length) {
    let $ = Q.at(-1)?.type;
    if ($ === void 0 || $ === $0.CloseStatement || $ === $0.CloseExpression) {
      let K = "";
      while (
        J < G.length &&
        !(G[J] === "{" && (G[J + 1] === "%" || G[J + 1] === "{"))
      )
        K += G[J++];
      if (K.length > 0) {
        Q.push(new YX(K, $0.Text));
        continue;
      }
    }
    U((K) => /\s/.test(K));
    let B = G[J];
    if (B === "-" || B === "+") {
      let K = Q.at(-1)?.type;
      if (K === $0.Text || K === void 0)
        throw SyntaxError(`Unexpected character: ${B}`);
      switch (K) {
        case $0.Identifier:
        case $0.NumericLiteral:
        case $0.BooleanLiteral:
        case $0.StringLiteral:
        case $0.CloseParen:
        case $0.CloseSquareBracket:
          break;
        default: {
          ++J;
          let V = U(DK);
          Q.push(
            new YX(
              `${B}${V}`,
              V.length > 0 ? $0.NumericLiteral : $0.UnaryOperator
            )
          );
          continue;
        }
      }
    }
    for (let [K, V] of l10)
      if (G.slice(J, J + K.length) === K) {
        (Q.push(new YX(K, V)), (J += K.length));
        continue X;
      }
    if (B === "'" || B === '"') {
      ++J;
      let K = U((V) => V !== B);
      (Q.push(new YX(K, $0.StringLiteral)), ++J);
      continue;
    }
    if (DK(B)) {
      let K = U(DK);
      Q.push(new YX(K, $0.NumericLiteral));
      continue;
    }
    if (hP(B)) {
      let K = U(hP),
        V = Object.hasOwn(xP, K) ? xP[K] : $0.Identifier;
      if (V === $0.In && Q.at(-1)?.type === $0.Not)
        (Q.pop(), Q.push(new YX("not in", $0.NotIn)));
      else Q.push(new YX(K, V));
      continue;
    }
    throw SyntaxError(`Unexpected character: ${B}`);
  }
  return Q;
}
function J50(X) {
  let Y = new p10([]),
    Q = 0;
  function G(l, h) {
    let p = X[Q++];
    if (!p || p.type !== l)
      throw Error(`Parser Error: ${h}. ${p.type} !== ${l}.`);
    return p;
  }
  function J() {
    switch (X[Q].type) {
      case $0.Text:
        return B();
      case $0.OpenStatement:
        return K();
      case $0.OpenExpression:
        return V();
      default:
        throw SyntaxError(`Unexpected token type: ${X[Q].type}`);
    }
  }
  function U(...l) {
    return Q + l.length <= X.length && l.some((h, p) => h !== X[Q + p].type);
  }
  function $(...l) {
    return Q + l.length <= X.length && l.every((h, p) => h === X[Q + p].type);
  }
  function B() {
    return new uP(G($0.Text, "Expected text token").value);
  }
  function K() {
    G($0.OpenStatement, "Expected opening statement token");
    let l;
    switch (X[Q].type) {
      case $0.Set:
        (++Q,
          (l = W()),
          G($0.CloseStatement, "Expected closing statement token"));
        break;
      case $0.If:
        (++Q,
          (l = L()),
          G($0.OpenStatement, "Expected {% token"),
          G($0.EndIf, "Expected endif token"),
          G($0.CloseStatement, "Expected %} token"));
        break;
      case $0.For:
        (++Q,
          (l = F()),
          G($0.OpenStatement, "Expected {% token"),
          G($0.EndFor, "Expected endfor token"),
          G($0.CloseStatement, "Expected %} token"));
        break;
      default:
        throw SyntaxError(`Unknown statement type: ${X[Q].type}`);
    }
    return l;
  }
  function V() {
    G($0.OpenExpression, "Expected opening expression token");
    let l = N();
    return (G($0.CloseExpression, "Expected closing expression token"), l);
  }
  function W() {
    let l = N();
    if ($($0.Equals)) {
      ++Q;
      let h = W();
      return new n10(l, h);
    }
    return l;
  }
  function L() {
    let l = N();
    G($0.CloseStatement, "Expected closing statement token");
    let h = [],
      p = [];
    while (
      !(
        X[Q]?.type === $0.OpenStatement &&
        (X[Q + 1]?.type === $0.ElseIf ||
          X[Q + 1]?.type === $0.Else ||
          X[Q + 1]?.type === $0.EndIf)
      )
    )
      h.push(J());
    if (X[Q]?.type === $0.OpenStatement && X[Q + 1]?.type !== $0.EndIf)
      if ((++Q, $($0.ElseIf)))
        (G($0.ElseIf, "Expected elseif token"), p.push(L()));
      else {
        (G($0.Else, "Expected else token"),
          G($0.CloseStatement, "Expected closing statement token"));
        while (
          !(X[Q]?.type === $0.OpenStatement && X[Q + 1]?.type === $0.EndIf)
        )
          p.push(J());
      }
    return new gP(l, h, p);
  }
  function H(l = !1) {
    let h = l ? f : N,
      p = [h()],
      N0 = $($0.Comma);
    while (N0) if ((++Q, p.push(h()), !$($0.Comma))) break;
    return N0 ? new mP(p) : p[0];
  }
  function F() {
    let l = H(!0);
    if (!(l instanceof _7 || l instanceof mP))
      throw SyntaxError(
        `Expected identifier/tuple for the loop variable, got ${l.type} instead`
      );
    G($0.In, "Expected `in` keyword following loop variable");
    let h = N();
    G($0.CloseStatement, "Expected closing statement token");
    let p = [];
    while (U($0.OpenStatement, $0.EndFor)) p.push(J());
    return new i10(l, h, p);
  }
  function N() {
    return q();
  }
  function q() {
    let l = M();
    if ($($0.If)) {
      ++Q;
      let h = M();
      G($0.Else, "Expected else token");
      let p = M();
      return new gP(h, [l], [p]);
    }
    return l;
  }
  function M() {
    let l = A();
    while ($($0.Or)) {
      let h = X[Q];
      ++Q;
      let p = A();
      l = new bQ(h, l, p);
    }
    return l;
  }
  function A() {
    let l = D();
    while ($($0.And)) {
      let h = X[Q];
      ++Q;
      let p = D();
      l = new bQ(h, l, p);
    }
    return l;
  }
  function D() {
    let l;
    while ($($0.Not)) {
      let h = X[Q];
      ++Q;
      let p = D();
      l = new Y50(h, p);
    }
    return l ?? R();
  }
  function R() {
    let l = z();
    while ($($0.ComparisonBinaryOperator) || $($0.In) || $($0.NotIn)) {
      let h = X[Q];
      ++Q;
      let p = z();
      l = new bQ(h, l, p);
    }
    return l;
  }
  function z() {
    let l = T();
    while ($($0.AdditiveBinaryOperator)) {
      let h = X[Q];
      ++Q;
      let p = T();
      l = new bQ(h, l, p);
    }
    return l;
  }
  function E() {
    let l = I();
    if ($($0.OpenParen)) return O(l);
    return l;
  }
  function O(l) {
    let h = new r10(l, Z());
    if ($($0.OpenParen)) h = O(h);
    return h;
  }
  function Z() {
    G($0.OpenParen, "Expected opening parenthesis for arguments list");
    let l = j();
    return (
      G($0.CloseParen, "Expected closing parenthesis for arguments list"),
      l
    );
  }
  function j() {
    let l = [];
    while (!$($0.CloseParen)) {
      let h = N();
      if ($($0.Equals)) {
        if ((++Q, !(h instanceof _7)))
          throw SyntaxError("Expected identifier for keyword argument");
        let p = N();
        h = new G50(h, p);
      }
      if ((l.push(h), $($0.Comma))) ++Q;
    }
    return l;
  }
  function w() {
    let l = [],
      h = !1;
    while (!$($0.CloseSquareBracket))
      if ($($0.Colon)) (l.push(void 0), ++Q, (h = !0));
      else if ((l.push(N()), $($0.Colon))) (++Q, (h = !0));
    if (l.length === 0)
      throw SyntaxError(
        "Expected at least one argument for member/slice expression"
      );
    if (h) {
      if (l.length > 3)
        throw SyntaxError("Expected 0-3 arguments for slice expression");
      return new Q50(...l);
    }
    return l[0];
  }
  function I() {
    let l = f();
    while ($($0.Dot) || $($0.OpenSquareBracket)) {
      let h = X[Q];
      ++Q;
      let p,
        N0 = h.type !== $0.Dot;
      if (N0)
        ((p = w()),
          G($0.CloseSquareBracket, "Expected closing square bracket"));
      else if (((p = f()), p.type !== "Identifier"))
        throw SyntaxError("Expected identifier following dot operator");
      l = new a10(l, p, N0);
    }
    return l;
  }
  function T() {
    let l = y();
    while ($($0.MultiplicativeBinaryOperator)) {
      let h = X[Q];
      ++Q;
      let p = y();
      l = new bQ(h, l, p);
    }
    return l;
  }
  function y() {
    let l = _();
    while ($($0.Is)) {
      ++Q;
      let h = $($0.Not);
      if (h) ++Q;
      let p = f();
      if (p instanceof lP) p = new _7(p.value.toString());
      if (!(p instanceof _7))
        throw SyntaxError("Expected identifier for the test");
      l = new X50(l, h, p);
    }
    return l;
  }
  function _() {
    let l = E();
    while ($($0.Pipe)) {
      ++Q;
      let h = f();
      if (!(h instanceof _7))
        throw SyntaxError("Expected identifier for the filter");
      if ($($0.OpenParen)) h = O(h);
      l = new e10(l, h);
    }
    return l;
  }
  function f() {
    let l = X[Q];
    switch (l.type) {
      case $0.NumericLiteral:
        return (++Q, new o10(Number(l.value)));
      case $0.StringLiteral:
        return (++Q, new uP(l.value));
      case $0.BooleanLiteral:
        return (++Q, new lP(l.value === "true"));
      case $0.Identifier:
        return (++Q, new _7(l.value));
      case $0.OpenParen: {
        ++Q;
        let h = H();
        if (X[Q].type !== $0.CloseParen)
          throw SyntaxError(
            `Expected closing parenthesis, got ${X[Q].type} instead`
          );
        return (++Q, h);
      }
      case $0.OpenSquareBracket: {
        ++Q;
        let h = [];
        while (!$($0.CloseSquareBracket)) if ((h.push(N()), $($0.Comma))) ++Q;
        return (++Q, new s10(h));
      }
      case $0.OpenCurlyBracket: {
        ++Q;
        let h = new Map();
        while (!$($0.CloseCurlyBracket)) {
          let p = N();
          G($0.Colon, "Expected colon between key and value in object literal");
          let N0 = N();
          if ((h.set(p, N0), $($0.Comma))) ++Q;
        }
        return (++Q, new t10(h));
      }
      default:
        throw SyntaxError(`Unexpected token: ${l.type}`);
    }
  }
  while (Q < X.length) Y.body.push(J());
  return Y;
}
function W50(X, Y, Q = 1) {
  if (Y === void 0) ((Y = X), (X = 0));
  let G = [];
  for (let J = X; J < Y; J += Q) G.push(J);
  return G;
}
function cP(X, Y, Q, G = 1) {
  let J = Math.sign(G);
  if (J >= 0)
    ((Y = (Y ??= 0) < 0 ? Math.max(X.length + Y, 0) : Math.min(Y, X.length)),
      (Q =
        (Q ??= X.length) < 0
          ? Math.max(X.length + Q, 0)
          : Math.min(Q, X.length)));
  else
    ((Y =
      (Y ??= X.length - 1) < 0
        ? Math.max(X.length + Y, -1)
        : Math.min(Y, X.length - 1)),
      (Q =
        (Q ??= -1) < -1
          ? Math.max(X.length + Q, -1)
          : Math.min(Q, X.length - 1)));
  let U = [];
  for (let $ = Y; J * $ < J * Q; $ += G) U.push(X[$]);
  return U;
}
function dP(X) {
  return X.replace(/\b\w/g, (Y) => Y.toUpperCase());
}
function ZW(X) {
  switch (typeof X) {
    case "number":
      return new J5(X);
    case "string":
      return new _1(X);
    case "boolean":
      return new O5(X);
    case "object":
      if (X === null) return new vQ();
      else if (Array.isArray(X)) return new q5(X.map(ZW));
      else
        return new r8(new Map(Object.entries(X).map(([Y, Q]) => [Y, ZW(Q)])));
    case "function":
      return new R4((Y, Q) => {
        let G = X(...Y.map((J) => J.value)) ?? null;
        return ZW(G);
      });
    default:
      throw Error(`Cannot convert to runtime value: ${X}`);
  }
}
var $0,
  xP,
  YX = class {
    constructor(X, Y) {
      ((this.value = X), (this.type = Y));
    }
  },
  l10,
  m10,
  kQ = class {
    type = "Statement";
  },
  p10,
  gP,
  i10,
  n10,
  u6,
  a10,
  r10,
  _7,
  f7,
  o10,
  uP,
  lP,
  s10,
  mP,
  t10,
  bQ,
  e10,
  X50,
  Y50,
  Q50,
  G50,
  D4 = class {
    type = "RuntimeValue";
    value;
    builtins = new Map();
    constructor(X = void 0) {
      this.value = X;
    }
    __bool__() {
      return new O5(!!this.value);
    }
  },
  J5,
  _1,
  O5,
  r8,
  q5,
  H50,
  R4,
  vQ,
  a8,
  zK = class {
    constructor(X) {
      this.parent = X;
    }
    variables = new Map([
      [
        "namespace",
        new R4((X) => {
          if (X.length === 0) return new r8(new Map());
          if (X.length !== 1 || !(X[0] instanceof r8))
            throw Error(
              "`namespace` expects either zero arguments or a single object argument"
            );
          return X[0];
        }),
      ],
    ]);
    tests = new Map([
      ["boolean", (X) => X.type === "BooleanValue"],
      ["callable", (X) => X instanceof R4],
      [
        "odd",
        (X) => {
          if (X.type !== "NumericValue")
            throw Error(`Cannot apply test "odd" to type: ${X.type}`);
          return X.value % 2 !== 0;
        },
      ],
      [
        "even",
        (X) => {
          if (X.type !== "NumericValue")
            throw Error(`Cannot apply test "even" to type: ${X.type}`);
          return X.value % 2 === 0;
        },
      ],
      ["false", (X) => X.type === "BooleanValue" && !X.value],
      ["true", (X) => X.type === "BooleanValue" && X.value],
      ["number", (X) => X.type === "NumericValue"],
      [
        "integer",
        (X) => X.type === "NumericValue" && Number.isInteger(X.value),
      ],
      ["iterable", (X) => X instanceof q5 || X instanceof _1],
      [
        "lower",
        (X) => {
          let Y = X.value;
          return X.type === "StringValue" && Y === Y.toLowerCase();
        },
      ],
      [
        "upper",
        (X) => {
          let Y = X.value;
          return X.type === "StringValue" && Y === Y.toUpperCase();
        },
      ],
      ["none", (X) => X.type === "NullValue"],
      ["defined", (X) => X.type !== "UndefinedValue"],
      ["undefined", (X) => X.type === "UndefinedValue"],
      ["equalto", (X, Y) => X.value === Y.value],
    ]);
    set(X, Y) {
      return this.declareVariable(X, ZW(Y));
    }
    declareVariable(X, Y) {
      if (this.variables.has(X))
        throw SyntaxError(`Variable already declared: ${X}`);
      return (this.variables.set(X, Y), Y);
    }
    setVariable(X, Y) {
      return (this.variables.set(X, Y), Y);
    }
    resolve(X) {
      if (this.variables.has(X)) return this;
      if (this.parent) return this.parent.resolve(X);
      throw Error(`Unknown variable: ${X}`);
    }
    lookupVariable(X) {
      try {
        return this.resolve(X).variables.get(X) ?? new a8();
      } catch {
        return new a8();
      }
    }
  },
  $50 = class {
    global;
    constructor(X) {
      this.global = X ?? new zK();
    }
    run(X) {
      return this.evaluate(X, this.global);
    }
    evaluateBinaryExpression(X, Y) {
      let Q = this.evaluate(X.left, Y);
      switch (X.operator.value) {
        case "and":
          return Q.__bool__().value ? this.evaluate(X.right, Y) : Q;
        case "or":
          return Q.__bool__().value ? Q : this.evaluate(X.right, Y);
      }
      let G = this.evaluate(X.right, Y);
      switch (X.operator.value) {
        case "==":
          return new O5(Q.value == G.value);
        case "!=":
          return new O5(Q.value != G.value);
      }
      if (Q instanceof a8 || G instanceof a8)
        throw Error("Cannot perform operation on undefined values");
      else if (Q instanceof vQ || G instanceof vQ)
        throw Error("Cannot perform operation on null values");
      else if (Q instanceof J5 && G instanceof J5)
        switch (X.operator.value) {
          case "+":
            return new J5(Q.value + G.value);
          case "-":
            return new J5(Q.value - G.value);
          case "*":
            return new J5(Q.value * G.value);
          case "/":
            return new J5(Q.value / G.value);
          case "%":
            return new J5(Q.value % G.value);
          case "<":
            return new O5(Q.value < G.value);
          case ">":
            return new O5(Q.value > G.value);
          case ">=":
            return new O5(Q.value >= G.value);
          case "<=":
            return new O5(Q.value <= G.value);
        }
      else if (Q instanceof q5 && G instanceof q5)
        switch (X.operator.value) {
          case "+":
            return new q5(Q.value.concat(G.value));
        }
      else if (G instanceof q5) {
        let J = G.value.find((U) => U.value === Q.value) !== void 0;
        switch (X.operator.value) {
          case "in":
            return new O5(J);
          case "not in":
            return new O5(!J);
        }
      }
      if (Q instanceof _1 || G instanceof _1)
        switch (X.operator.value) {
          case "+":
            return new _1(Q.value.toString() + G.value.toString());
        }
      if (Q instanceof _1 && G instanceof _1)
        switch (X.operator.value) {
          case "in":
            return new O5(G.value.includes(Q.value));
          case "not in":
            return new O5(!G.value.includes(Q.value));
        }
      if (Q instanceof _1 && G instanceof r8)
        switch (X.operator.value) {
          case "in":
            return new O5(G.value.has(Q.value));
          case "not in":
            return new O5(!G.value.has(Q.value));
        }
      throw SyntaxError(
        `Unknown operator "${X.operator.value}" between ${Q.type} and ${G.type}`
      );
    }
    evaluateFilterExpression(X, Y) {
      let Q = this.evaluate(X.operand, Y);
      if (X.filter.type === "Identifier") {
        let G = X.filter;
        if (Q instanceof q5)
          switch (G.value) {
            case "list":
              return Q;
            case "first":
              return Q.value[0];
            case "last":
              return Q.value[Q.value.length - 1];
            case "length":
              return new J5(Q.value.length);
            case "reverse":
              return new q5(Q.value.reverse());
            case "sort":
              return new q5(
                Q.value.sort((J, U) => {
                  if (J.type !== U.type)
                    throw Error(
                      `Cannot compare different types: ${J.type} and ${U.type}`
                    );
                  switch (J.type) {
                    case "NumericValue":
                      return J.value - U.value;
                    case "StringValue":
                      return J.value.localeCompare(U.value);
                    default:
                      throw Error(`Cannot compare type: ${J.type}`);
                  }
                })
              );
            default:
              throw Error(`Unknown ArrayValue filter: ${G.value}`);
          }
        else if (Q instanceof _1)
          switch (G.value) {
            case "length":
              return new J5(Q.value.length);
            case "upper":
              return new _1(Q.value.toUpperCase());
            case "lower":
              return new _1(Q.value.toLowerCase());
            case "title":
              return new _1(dP(Q.value));
            case "capitalize":
              return new _1(Q.value.charAt(0).toUpperCase() + Q.value.slice(1));
            case "trim":
              return new _1(Q.value.trim());
            default:
              throw Error(`Unknown StringValue filter: ${G.value}`);
          }
        else if (Q instanceof J5)
          switch (G.value) {
            case "abs":
              return new J5(Math.abs(Q.value));
            default:
              throw Error(`Unknown NumericValue filter: ${G.value}`);
          }
        else if (Q instanceof r8)
          switch (G.value) {
            case "items":
              return new q5(
                Array.from(Q.value.entries()).map(
                  ([J, U]) => new q5([new _1(J), U])
                )
              );
            case "length":
              return new J5(Q.value.size);
            default:
              throw Error(`Unknown ObjectValue filter: ${G.value}`);
          }
        throw Error(`Cannot apply filter "${G.value}" to type: ${Q.type}`);
      } else if (X.filter.type === "CallExpression") {
        let G = X.filter;
        if (G.callee.type !== "Identifier")
          throw Error(`Unknown filter: ${G.callee.type}`);
        let J = G.callee.value;
        if (Q instanceof q5) {
          switch (J) {
            case "selectattr": {
              if (Q.value.some((W) => !(W instanceof r8)))
                throw Error(
                  "`selectattr` can only be applied to array of objects"
                );
              if (G.args.some((W) => W.type !== "StringLiteral"))
                throw Error("arguments of `selectattr` must be strings");
              let [U, $, B] = G.args.map((W) => this.evaluate(W, Y)),
                K;
              if ($) {
                let W = Y.tests.get($.value);
                if (!W) throw Error(`Unknown test: ${$.value}`);
                K = W;
              } else K = (...W) => W[0].__bool__().value;
              let V = Q.value.filter((W) => {
                let L = W.value.get(U.value);
                if (L) return K(L, B);
                return !1;
              });
              return new q5(V);
            }
          }
          throw Error(`Unknown ArrayValue filter: ${J}`);
        } else throw Error(`Cannot apply filter "${J}" to type: ${Q.type}`);
      }
      throw Error(`Unknown filter: ${X.filter.type}`);
    }
    evaluateTestExpression(X, Y) {
      let Q = this.evaluate(X.operand, Y),
        G = Y.tests.get(X.test.value);
      if (!G) throw Error(`Unknown test: ${X.test.value}`);
      let J = G(Q);
      return new O5(X.negate ? !J : J);
    }
    evaluateUnaryExpression(X, Y) {
      let Q = this.evaluate(X.argument, Y);
      switch (X.operator.value) {
        case "not":
          return new O5(!Q.value);
        default:
          throw SyntaxError(`Unknown operator: ${X.operator.value}`);
      }
    }
    evalProgram(X, Y) {
      return this.evaluateBlock(X.body, Y);
    }
    evaluateBlock(X, Y) {
      let Q = "";
      for (let G of X) {
        let J = this.evaluate(G, Y);
        if (J.type !== "NullValue" && J.type !== "UndefinedValue") Q += J.value;
      }
      return new _1(Q);
    }
    evaluateIdentifier(X, Y) {
      return Y.lookupVariable(X.value);
    }
    evaluateCallExpression(X, Y) {
      let Q = [],
        G = new Map();
      for (let U of X.args)
        if (U.type === "KeywordArgumentExpression") {
          let $ = U;
          G.set($.key.value, this.evaluate($.value, Y));
        } else Q.push(this.evaluate(U, Y));
      if (G.size > 0) Q.push(new r8(G));
      let J = this.evaluate(X.callee, Y);
      if (J.type !== "FunctionValue")
        throw Error(
          `Cannot call something that is not a function: got ${J.type}`
        );
      return J.value(Q, Y);
    }
    evaluateSliceExpression(X, Y, Q) {
      if (!(X instanceof q5 || X instanceof _1))
        throw Error("Slice object must be an array or string");
      let G = this.evaluate(Y.start, Q),
        J = this.evaluate(Y.stop, Q),
        U = this.evaluate(Y.step, Q);
      if (!(G instanceof J5 || G instanceof a8))
        throw Error("Slice start must be numeric or undefined");
      if (!(J instanceof J5 || J instanceof a8))
        throw Error("Slice stop must be numeric or undefined");
      if (!(U instanceof J5 || U instanceof a8))
        throw Error("Slice step must be numeric or undefined");
      if (X instanceof q5)
        return new q5(cP(X.value, G.value, J.value, U.value));
      else
        return new _1(
          cP(Array.from(X.value), G.value, J.value, U.value).join("")
        );
    }
    evaluateMemberExpression(X, Y) {
      let Q = this.evaluate(X.object, Y),
        G;
      if (X.computed)
        if (X.property.type === "SliceExpression")
          return this.evaluateSliceExpression(Q, X.property, Y);
        else G = this.evaluate(X.property, Y);
      else G = new _1(X.property.value);
      let J;
      if (Q instanceof r8) {
        if (!(G instanceof _1))
          throw Error(`Cannot access property with non-string: got ${G.type}`);
        J = Q.value.get(G.value) ?? Q.builtins.get(G.value);
      } else if (Q instanceof q5 || Q instanceof _1)
        if (G instanceof J5) {
          if (((J = Q.value.at(G.value)), Q instanceof _1))
            J = new _1(Q.value.at(G.value));
        } else if (G instanceof _1) J = Q.builtins.get(G.value);
        else
          throw Error(
            `Cannot access property with non-string/non-number: got ${G.type}`
          );
      else {
        if (!(G instanceof _1))
          throw Error(`Cannot access property with non-string: got ${G.type}`);
        J = Q.builtins.get(G.value);
      }
      return J instanceof D4 ? J : new a8();
    }
    evaluateSet(X, Y) {
      let Q = this.evaluate(X.value, Y);
      if (X.assignee.type === "Identifier") {
        let G = X.assignee.value;
        Y.setVariable(G, Q);
      } else if (X.assignee.type === "MemberExpression") {
        let G = X.assignee,
          J = this.evaluate(G.object, Y);
        if (!(J instanceof r8))
          throw Error("Cannot assign to member of non-object");
        if (G.property.type !== "Identifier")
          throw Error("Cannot assign to member with non-identifier property");
        J.value.set(G.property.value, Q);
      } else
        throw Error(
          `Invalid LHS inside assignment expression: ${JSON.stringify(X.assignee)}`
        );
      return new vQ();
    }
    evaluateIf(X, Y) {
      let Q = this.evaluate(X.test, Y);
      return this.evaluateBlock(Q.__bool__().value ? X.body : X.alternate, Y);
    }
    evaluateFor(X, Y) {
      let Q = new zK(Y),
        G = this.evaluate(X.iterable, Q);
      if (!(G instanceof q5))
        throw Error(`Expected iterable type in for loop: got ${G.type}`);
      let J = "";
      for (let U = 0; U < G.value.length; ++U) {
        let $ = new Map([
          ["index", new J5(U + 1)],
          ["index0", new J5(U)],
          ["revindex", new J5(G.value.length - U)],
          ["revindex0", new J5(G.value.length - U - 1)],
          ["first", new O5(U === 0)],
          ["last", new O5(U === G.value.length - 1)],
          ["length", new J5(G.value.length)],
          ["previtem", U > 0 ? G.value[U - 1] : new a8()],
          ["nextitem", U < G.value.length - 1 ? G.value[U + 1] : new a8()],
        ]);
        Q.setVariable("loop", new r8($));
        let B = G.value[U];
        if (X.loopvar.type === "Identifier") Q.setVariable(X.loopvar.value, B);
        else if (X.loopvar.type === "TupleLiteral") {
          let V = X.loopvar;
          if (B.type !== "ArrayValue")
            throw Error(`Cannot unpack non-iterable type: ${B.type}`);
          let W = B;
          if (V.value.length !== W.value.length)
            throw Error(
              `Too ${V.value.length > W.value.length ? "few" : "many"} items to unpack`
            );
          for (let L = 0; L < V.value.length; ++L) {
            if (V.value[L].type !== "Identifier")
              throw Error(
                `Cannot unpack non-identifier type: ${V.value[L].type}`
              );
            Q.setVariable(V.value[L].value, W.value[L]);
          }
        }
        let K = this.evaluateBlock(X.body, Q);
        J += K.value;
      }
      return new _1(J);
    }
    evaluate(X, Y) {
      if (X === void 0) return new a8();
      switch (X.type) {
        case "Program":
          return this.evalProgram(X, Y);
        case "Set":
          return this.evaluateSet(X, Y);
        case "If":
          return this.evaluateIf(X, Y);
        case "For":
          return this.evaluateFor(X, Y);
        case "NumericLiteral":
          return new J5(Number(X.value));
        case "StringLiteral":
          return new _1(X.value);
        case "BooleanLiteral":
          return new O5(X.value);
        case "ArrayLiteral":
          return new q5(X.value.map((Q) => this.evaluate(Q, Y)));
        case "TupleLiteral":
          return new H50(X.value.map((Q) => this.evaluate(Q, Y)));
        case "ObjectLiteral": {
          let Q = new Map();
          for (let [G, J] of X.value) {
            let U = this.evaluate(G, Y);
            if (!(U instanceof _1))
              throw Error(`Object keys must be strings: got ${U.type}`);
            Q.set(U.value, this.evaluate(J, Y));
          }
          return new r8(Q);
        }
        case "Identifier":
          return this.evaluateIdentifier(X, Y);
        case "CallExpression":
          return this.evaluateCallExpression(X, Y);
        case "MemberExpression":
          return this.evaluateMemberExpression(X, Y);
        case "UnaryExpression":
          return this.evaluateUnaryExpression(X, Y);
        case "BinaryExpression":
          return this.evaluateBinaryExpression(X, Y);
        case "FilterExpression":
          return this.evaluateFilterExpression(X, Y);
        case "TestExpression":
          return this.evaluateTestExpression(X, Y);
        default:
          throw SyntaxError(`Unknown node type: ${X.type}`);
      }
    }
  },
  pP = class {
    parsed;
    constructor(X) {
      let Y = d10(X, { lstrip_blocks: !0, trim_blocks: !0 });
      this.parsed = J50(Y);
    }
    render(X) {
      let Y = new zK();
      (Y.set("false", !1),
        Y.set("true", !0),
        Y.set("raise_exception", (J) => {
          throw Error(J);
        }),
        Y.set("range", W50));
      for (let [J, U] of Object.entries(X)) Y.set(J, U);
      return new $50(Y).run(this.parsed).value;
    }
  };
var iP = U8(() => {
  (($0 = Object.freeze({
    Text: "Text",
    NumericLiteral: "NumericLiteral",
    BooleanLiteral: "BooleanLiteral",
    StringLiteral: "StringLiteral",
    Identifier: "Identifier",
    Equals: "Equals",
    OpenParen: "OpenParen",
    CloseParen: "CloseParen",
    OpenStatement: "OpenStatement",
    CloseStatement: "CloseStatement",
    OpenExpression: "OpenExpression",
    CloseExpression: "CloseExpression",
    OpenSquareBracket: "OpenSquareBracket",
    CloseSquareBracket: "CloseSquareBracket",
    OpenCurlyBracket: "OpenCurlyBracket",
    CloseCurlyBracket: "CloseCurlyBracket",
    Comma: "Comma",
    Dot: "Dot",
    Colon: "Colon",
    Pipe: "Pipe",
    CallOperator: "CallOperator",
    AdditiveBinaryOperator: "AdditiveBinaryOperator",
    MultiplicativeBinaryOperator: "MultiplicativeBinaryOperator",
    ComparisonBinaryOperator: "ComparisonBinaryOperator",
    UnaryOperator: "UnaryOperator",
    Set: "Set",
    If: "If",
    For: "For",
    In: "In",
    Is: "Is",
    NotIn: "NotIn",
    Else: "Else",
    EndIf: "EndIf",
    ElseIf: "ElseIf",
    EndFor: "EndFor",
    And: "And",
    Or: "Or",
    Not: "UnaryOperator",
  })),
    (xP = Object.freeze({
      set: $0.Set,
      for: $0.For,
      in: $0.In,
      is: $0.Is,
      if: $0.If,
      else: $0.Else,
      endif: $0.EndIf,
      elif: $0.ElseIf,
      endfor: $0.EndFor,
      and: $0.And,
      or: $0.Or,
      not: $0.Not,
      "not in": $0.NotIn,
      true: $0.BooleanLiteral,
      false: $0.BooleanLiteral,
    })));
  ((l10 = [
    ["{%", $0.OpenStatement],
    ["%}", $0.CloseStatement],
    ["{{", $0.OpenExpression],
    ["}}", $0.CloseExpression],
    ["(", $0.OpenParen],
    [")", $0.CloseParen],
    ["{", $0.OpenCurlyBracket],
    ["}", $0.CloseCurlyBracket],
    ["[", $0.OpenSquareBracket],
    ["]", $0.CloseSquareBracket],
    [",", $0.Comma],
    [".", $0.Dot],
    [":", $0.Colon],
    ["|", $0.Pipe],
    ["<=", $0.ComparisonBinaryOperator],
    [">=", $0.ComparisonBinaryOperator],
    ["==", $0.ComparisonBinaryOperator],
    ["!=", $0.ComparisonBinaryOperator],
    ["<", $0.ComparisonBinaryOperator],
    [">", $0.ComparisonBinaryOperator],
    ["+", $0.AdditiveBinaryOperator],
    ["-", $0.AdditiveBinaryOperator],
    ["*", $0.MultiplicativeBinaryOperator],
    ["/", $0.MultiplicativeBinaryOperator],
    ["%", $0.MultiplicativeBinaryOperator],
    ["=", $0.Equals],
  ]),
    (m10 = new Map([
      [
        "n",
        `
`,
      ],
      ["t", "\t"],
      ["r", "\r"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["'", "'"],
      ['"', '"'],
      ["\\", "\\"],
    ])));
  ((p10 = class extends kQ {
    constructor(X) {
      super();
      this.body = X;
    }
    type = "Program";
  }),
    (gP = class extends kQ {
      constructor(X, Y, Q) {
        super();
        ((this.test = X), (this.body = Y), (this.alternate = Q));
      }
      type = "If";
    }),
    (i10 = class extends kQ {
      constructor(X, Y, Q) {
        super();
        ((this.loopvar = X), (this.iterable = Y), (this.body = Q));
      }
      type = "For";
    }),
    (n10 = class extends kQ {
      constructor(X, Y) {
        super();
        ((this.assignee = X), (this.value = Y));
      }
      type = "Set";
    }),
    (u6 = class extends kQ {
      type = "Expression";
    }),
    (a10 = class extends u6 {
      constructor(X, Y, Q) {
        super();
        ((this.object = X), (this.property = Y), (this.computed = Q));
      }
      type = "MemberExpression";
    }),
    (r10 = class extends u6 {
      constructor(X, Y) {
        super();
        ((this.callee = X), (this.args = Y));
      }
      type = "CallExpression";
    }),
    (_7 = class extends u6 {
      constructor(X) {
        super();
        this.value = X;
      }
      type = "Identifier";
    }),
    (f7 = class extends u6 {
      constructor(X) {
        super();
        this.value = X;
      }
      type = "Literal";
    }),
    (o10 = class extends f7 {
      type = "NumericLiteral";
    }),
    (uP = class extends f7 {
      type = "StringLiteral";
    }),
    (lP = class extends f7 {
      type = "BooleanLiteral";
    }),
    (s10 = class extends f7 {
      type = "ArrayLiteral";
    }),
    (mP = class extends f7 {
      type = "TupleLiteral";
    }),
    (t10 = class extends f7 {
      type = "ObjectLiteral";
    }),
    (bQ = class extends u6 {
      constructor(X, Y, Q) {
        super();
        ((this.operator = X), (this.left = Y), (this.right = Q));
      }
      type = "BinaryExpression";
    }),
    (e10 = class extends u6 {
      constructor(X, Y) {
        super();
        ((this.operand = X), (this.filter = Y));
      }
      type = "FilterExpression";
    }),
    (X50 = class extends u6 {
      constructor(X, Y, Q) {
        super();
        ((this.operand = X), (this.negate = Y), (this.test = Q));
      }
      type = "TestExpression";
    }),
    (Y50 = class extends u6 {
      constructor(X, Y) {
        super();
        ((this.operator = X), (this.argument = Y));
      }
      type = "UnaryExpression";
    }),
    (Q50 = class extends u6 {
      constructor(X = void 0, Y = void 0, Q = void 0) {
        super();
        ((this.start = X), (this.stop = Y), (this.step = Q));
      }
      type = "SliceExpression";
    }),
    (G50 = class extends u6 {
      constructor(X, Y) {
        super();
        ((this.key = X), (this.value = Y));
      }
      type = "KeywordArgumentExpression";
    }));
  ((J5 = class extends D4 {
    type = "NumericValue";
  }),
    (_1 = class extends D4 {
      type = "StringValue";
      builtins = new Map([
        [
          "upper",
          new R4(() => {
            return new _1(this.value.toUpperCase());
          }),
        ],
        [
          "lower",
          new R4(() => {
            return new _1(this.value.toLowerCase());
          }),
        ],
        [
          "strip",
          new R4(() => {
            return new _1(this.value.trim());
          }),
        ],
        [
          "title",
          new R4(() => {
            return new _1(dP(this.value));
          }),
        ],
        ["length", new J5(this.value.length)],
      ]);
    }),
    (O5 = class extends D4 {
      type = "BooleanValue";
    }),
    (r8 = class extends D4 {
      type = "ObjectValue";
      __bool__() {
        return new O5(this.value.size > 0);
      }
      builtins = new Map([
        [
          "get",
          new R4(([X, Y]) => {
            if (!(X instanceof _1))
              throw Error(`Object key must be a string: got ${X.type}`);
            return this.value.get(X.value) ?? Y ?? new vQ();
          }),
        ],
        [
          "items",
          new R4(() => {
            return new q5(
              Array.from(this.value.entries()).map(
                ([X, Y]) => new q5([new _1(X), Y])
              )
            );
          }),
        ],
      ]);
    }),
    (q5 = class extends D4 {
      type = "ArrayValue";
      builtins = new Map([["length", new J5(this.value.length)]]);
      __bool__() {
        return new O5(this.value.length > 0);
      }
    }),
    (H50 = class extends q5 {
      type = "TupleValue";
    }),
    (R4 = class extends D4 {
      type = "FunctionValue";
    }),
    (vQ = class extends D4 {
      type = "NullValue";
    }),
    (a8 = class extends D4 {
      type = "UndefinedValue";
    }));
});
async function nP(X, Y) {
  let Q = await Promise.all([
    g6(X, "tokenizer.json", !0, Y),
    g6(X, "tokenizer_config.json", !0, Y),
  ]);
  if (Y.legacy !== null) Q[1].legacy = Y.legacy;
  return Q;
}
function U50(X, Y) {
  let Q = [],
    G = 0;
  for (let J of X.matchAll(Y)) {
    let U = J[0];
    if (G < J.index) Q.push(X.slice(G, J.index));
    if (U.length > 0) Q.push(U);
    G = J.index + U.length;
  }
  if (G < X.length) Q.push(X.slice(G));
  return Q;
}
function CW(X, Y = !0) {
  if (X.Regex !== void 0) {
    let Q = X.Regex.replace(/\\([#&~])/g, "$1");
    for (let [G, J] of V50) Q = Q.replaceAll(G, J);
    return new RegExp(Q, "gu");
  } else if (X.String !== void 0) {
    let Q = iB(X.String);
    return new RegExp(Y ? Q : `(${Q})`, "gu");
  } else return (console.warn("Unknown pattern type:", X), null);
}
function EK(X) {
  return new Map(Object.entries(X));
}
function aP(X) {
  let Y = X.dims;
  switch (Y.length) {
    case 1:
      return X.tolist();
    case 2:
      if (Y[0] !== 1)
        throw Error(
          "Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs."
        );
      return X.tolist()[0];
    default:
      throw Error(`Expected tensor to have 1-2 dimensions, got ${Y.length}.`);
  }
}
function OK(X) {
  return X.replace(/ \./g, ".")
    .replace(/ \?/g, "?")
    .replace(/ \!/g, "!")
    .replace(/ ,/g, ",")
    .replace(/ \' /g, "'")
    .replace(/ n\'t/g, "n't")
    .replace(/ \'m/g, "'m")
    .replace(/ \'s/g, "'s")
    .replace(/ \'ve/g, "'ve")
    .replace(/ \'re/g, "'re");
}
function rP(X) {
  return X.replace(/[\u0300-\u036f]/g, "");
}
function L50(X) {
  return rP(X.toLowerCase());
}
function B50(X, Y, Q) {
  let G = [],
    J = 0;
  while (J < X.length) {
    if ((G.push(X[J]), (Q.get(X[J]) ?? Y) !== Y)) {
      ++J;
      continue;
    }
    while (J < X.length && (Q.get(X[J]) ?? Y) === Y) ++J;
  }
  return G;
}
function K50(X) {
  return X.match(/\S+/g) || [];
}
class oP {
  constructor(X) {
    ((this.content = X.content),
      (this.id = X.id),
      (this.single_word = X.single_word ?? !1),
      (this.lstrip = X.lstrip ?? !1),
      (this.rstrip = X.rstrip ?? !1),
      (this.special = X.special ?? !1),
      (this.normalized = X.normalized ?? null));
  }
}
function M50(X, Y, Q, G) {
  for (let J of Object.keys(X)) {
    let U = Y - X[J].length,
      $ = Q(J),
      B = Array(U).fill($);
    X[J] = G === "right" ? S5(X[J], B) : S5(B, X[J]);
  }
}
function A50(X, Y) {
  for (let Q of Object.keys(X)) X[Q].length = Y;
}
function XV(X, Y, Q, G) {
  if (!("language_codes" in X) || !Array.isArray(X.language_codes))
    throw Error(
      "Tokenizer must have `language_codes` attribute set and it should be an array of language ids."
    );
  if (!("languageRegex" in X) || !(X.languageRegex instanceof RegExp))
    throw Error(
      "Tokenizer must have `languageRegex` attribute set and it should be a regular expression."
    );
  if (!("lang_to_token" in X) || typeof X.lang_to_token !== "function")
    throw Error(
      "Tokenizer must have `lang_to_token` attribute set and it should be a function."
    );
  let { src_lang: J, tgt_lang: U } = G;
  if (!X.language_codes.includes(U))
    throw Error(
      `Target language code "${U}" is not valid. Must be one of: {${X.language_codes.join(", ")}}`
    );
  if (J !== void 0) {
    if (!X.language_codes.includes(J))
      throw Error(
        `Source language code "${J}" is not valid. Must be one of: {${X.language_codes.join(", ")}}`
      );
    for (let $ of X.post_processor.config.single)
      if ("SpecialToken" in $ && X.languageRegex.test($.SpecialToken.id)) {
        $.SpecialToken.id = X.lang_to_token(J);
        break;
      }
  }
  return (
    (G.forced_bos_token_id = X.model.convert_tokens_to_ids([
      X.lang_to_token(U),
    ])[0]),
    X._call(Y, Q)
  );
}
var yQ = "\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",
  V50,
  GX,
  sP,
  tP,
  eP,
  F50,
  XS,
  YS,
  M8,
  QS,
  GS,
  JS,
  WS,
  HS,
  $S,
  US,
  LS,
  BS,
  KS,
  E8,
  VS,
  FS,
  NS,
  MS,
  AS,
  QX,
  ZK,
  jK,
  qS,
  wK,
  RS,
  A8,
  DS,
  zS,
  ES,
  OS,
  ZS,
  jS,
  wS,
  CS,
  IS,
  PS,
  CK,
  SS,
  TS,
  bS,
  vS,
  kS,
  yS,
  N50,
  W1,
  IK,
  PK,
  SK,
  TK,
  bK,
  vK,
  kK,
  yK,
  _K,
  fK,
  xK,
  hK,
  gK,
  uK,
  IW,
  lK,
  PW,
  mK,
  cK,
  dK,
  jW = "\u2581",
  SW,
  pK,
  iK,
  nK,
  aK,
  rK,
  oK,
  sK,
  tK,
  eK,
  YV,
  QV,
  _S,
  wW,
  q50,
  GV,
  JV,
  WV,
  HV,
  $V,
  UV,
  TW,
  LV,
  BV,
  KV,
  VV,
  FV,
  j5;
var NV = U8(() => {
  t9();
  W9();
  iP();
  V50 = new Map([
    [
      "(?i:'s|'t|'re|'ve|'m|'ll|'d)",
      "(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))",
    ],
  ]);
  GX = class GX extends f5 {
    constructor(X) {
      super();
      ((this.config = X),
        (this.vocab = []),
        (this.tokens_to_ids = new Map()),
        (this.unk_token_id = void 0),
        (this.unk_token = void 0),
        (this.end_of_word_suffix = void 0),
        (this.fuse_unk = this.config.fuse_unk ?? !1));
    }
    static fromConfig(X, ...Y) {
      switch (X.type) {
        case "WordPiece":
          return new sP(X);
        case "Unigram":
          return new tP(X, ...Y);
        case "BPE":
          return new XS(X);
        default:
          if (X.vocab) return new YS(X, ...Y);
          throw Error(`Unknown TokenizerModel type: ${X.type}`);
      }
    }
    _call(X) {
      let Y = this.encode(X);
      if (this.fuse_unk) Y = B50(Y, this.unk_token_id, this.tokens_to_ids);
      return Y;
    }
    encode(X) {
      throw Error("encode should be implemented in subclass.");
    }
    convert_tokens_to_ids(X) {
      return X.map((Y) => this.tokens_to_ids.get(Y) ?? this.unk_token_id);
    }
    convert_ids_to_tokens(X) {
      return X.map((Y) => this.vocab[Y] ?? this.unk_token);
    }
  };
  sP = class sP extends GX {
    constructor(X) {
      super(X);
      ((this.tokens_to_ids = EK(X.vocab)),
        (this.unk_token_id = this.tokens_to_ids.get(X.unk_token)),
        (this.unk_token = X.unk_token),
        (this.max_input_chars_per_word = X.max_input_chars_per_word ?? 100),
        (this.vocab = Array(this.tokens_to_ids.size)));
      for (let [Y, Q] of this.tokens_to_ids) this.vocab[Q] = Y;
    }
    encode(X) {
      let Y = [];
      for (let Q of X) {
        let G = [...Q];
        if (G.length > this.max_input_chars_per_word) {
          Y.push(this.unk_token);
          continue;
        }
        let J = !1,
          U = 0,
          $ = [];
        while (U < G.length) {
          let B = G.length,
            K = null;
          while (U < B) {
            let V = G.slice(U, B).join("");
            if (U > 0) V = this.config.continuing_subword_prefix + V;
            if (this.tokens_to_ids.has(V)) {
              K = V;
              break;
            }
            --B;
          }
          if (K === null) {
            J = !0;
            break;
          }
          ($.push(K), (U = B));
        }
        if (J) Y.push(this.unk_token);
        else Y.push(...$);
      }
      return Y;
    }
  };
  tP = class tP extends GX {
    constructor(X, Y) {
      super(X);
      let Q = X.vocab.length;
      ((this.vocab = Array(Q)), (this.scores = Array(Q)));
      for (let G = 0; G < Q; ++G) {
        let J = X.vocab[G];
        ((this.vocab[G] = J[0]), (this.scores[G] = J[1]));
      }
      ((this.unk_token_id = X.unk_id),
        (this.unk_token = this.vocab[X.unk_id]),
        (this.tokens_to_ids = new Map(this.vocab.map((G, J) => [G, J]))),
        (this.bosToken = " "),
        (this.bosTokenId = this.tokens_to_ids.get(this.bosToken)),
        (this.eosToken = Y.eos_token),
        (this.eosTokenId = this.tokens_to_ids.get(this.eosToken)),
        (this.unkToken = this.vocab[this.unk_token_id]),
        (this.minScore = SQ(this.scores)[0]),
        (this.unkScore = this.minScore - 10),
        (this.scores[this.unk_token_id] = this.unkScore),
        (this.trie = new qK()),
        this.trie.extend(this.vocab),
        (this.fuse_unk = !0));
    }
    populateNodes(X) {
      let Y = X.sentence,
        Q = Y.length,
        G = 0;
      while (G < Q) {
        let U = !1,
          $ = [];
        for (let B of this.trie.commonPrefixSearch(Y.slice(G))) {
          $.push(B);
          let K = this.tokens_to_ids.get(B),
            V = this.scores[K],
            W = B.length;
          if ((X.insert(G, W, V, K), !U && W === 1)) U = !0;
        }
        if (!U) X.insert(G, 1, this.unkScore, this.unk_token_id);
        G += 1;
      }
    }
    tokenize(X) {
      let Y = new RK(X, this.bosTokenId, this.eosTokenId);
      return (this.populateNodes(Y), Y.tokens());
    }
    encode(X) {
      let Y = [];
      for (let Q of X) {
        let G = this.tokenize(Q);
        Y.push(...G);
      }
      return Y;
    }
  };
  ((eP = (() => {
    let X = [
        ...Array.from({ length: 94 }, (J, U) => U + 33),
        ...Array.from(
          { length: "\xAC".charCodeAt(0) - "\xA1".charCodeAt(0) + 1 },
          (J, U) => U + "\xA1".charCodeAt(0)
        ),
        ...Array.from(
          { length: "\xFF".charCodeAt(0) - "\xAE".charCodeAt(0) + 1 },
          (J, U) => U + "\xAE".charCodeAt(0)
        ),
      ],
      Y = X.slice(),
      Q = 0;
    for (let J = 0; J < 256; ++J)
      if (!X.includes(J)) (X.push(J), Y.push(256 + Q), (Q += 1));
    let G = Y.map((J) => String.fromCharCode(J));
    return Object.fromEntries(X.map((J, U) => [J, G[U]]));
  })()),
    (F50 = VP(eP)));
  XS = class XS extends GX {
    constructor(X) {
      super(X);
      ((this.BPE_SPLIT_TOKEN = " "),
        (this.tokens_to_ids = EK(X.vocab)),
        (this.unk_token_id = this.tokens_to_ids.get(X.unk_token)),
        (this.unk_token = X.unk_token),
        (this.vocab = Array(this.tokens_to_ids.size)));
      for (let [Y, Q] of this.tokens_to_ids) this.vocab[Q] = Y;
      if (
        ((this.bpe_ranks = new Map(X.merges.map((Y, Q) => [Y, Q]))),
        (this.merges = X.merges.map((Y) => Y.split(this.BPE_SPLIT_TOKEN))),
        (this.end_of_word_suffix = X.end_of_word_suffix),
        (this.continuing_subword_suffix = X.continuing_subword_suffix ?? null),
        (this.byte_fallback = this.config.byte_fallback ?? !1),
        this.byte_fallback)
      )
        this.text_encoder = new TextEncoder();
      ((this.ignore_merges = this.config.ignore_merges ?? !1),
        (this.cache = new Map()));
    }
    bpe(X) {
      if (X.length === 0) return [];
      let Y = this.cache.get(X);
      if (Y !== void 0) return Y;
      let Q = Array.from(X);
      if (this.end_of_word_suffix) Q[Q.length - 1] += this.end_of_word_suffix;
      let G = [];
      if (Q.length > 1) {
        let J = new AK((B, K) => B.score < K.score),
          U = { token: Q[0], bias: 0, prev: null, next: null },
          $ = U;
        for (let B = 1; B < Q.length; ++B) {
          let K = { bias: B / Q.length, token: Q[B], prev: $, next: null };
          (($.next = K), this._add_node(J, $), ($ = K));
        }
        while (!J.isEmpty()) {
          let B = J.pop();
          if (B.deleted || !B.next || B.next.deleted) continue;
          if (((B.deleted = !0), (B.next.deleted = !0), B.prev)) {
            let V = { ...B.prev };
            if (((B.prev.deleted = !0), (B.prev = V), V.prev)) V.prev.next = V;
            else U = V;
          }
          let K = {
            token: B.token + B.next.token,
            bias: B.bias,
            prev: B.prev,
            next: B.next.next,
          };
          if (K.prev) ((K.prev.next = K), this._add_node(J, K.prev));
          else U = K;
          if (K.next) ((K.next.prev = K), this._add_node(J, K));
        }
        for (let B = U; B !== null; B = B.next) G.push(B.token);
      } else G = Q;
      if (this.continuing_subword_suffix)
        for (let J = 0; J < G.length - 1; ++J)
          G[J] += this.continuing_subword_suffix;
      return (this.cache.set(X, G), G);
    }
    _add_node(X, Y) {
      let Q = this.bpe_ranks.get(Y.token + this.BPE_SPLIT_TOKEN + Y.next.token);
      if (Q !== void 0) ((Y.score = Q + Y.bias), X.push(Y));
    }
    encode(X) {
      let Y = [];
      for (let Q of X) {
        if (this.ignore_merges && this.tokens_to_ids.has(Q)) {
          Y.push(Q);
          continue;
        }
        let G = this.bpe(Q);
        for (let J of G)
          if (this.tokens_to_ids.has(J)) Y.push(J);
          else if (this.byte_fallback)
            Y.push(
              ...Array.from(this.text_encoder.encode(J)).map(
                (U) => `<0x${U.toString(16).toUpperCase().padStart(2, "0")}>`
              )
            );
          else Y.push(this.unk_token);
      }
      return Y;
    }
  };
  YS = class YS extends GX {
    constructor(X, Y) {
      super(X);
      ((this.tokens_to_ids = EK(
        Y.target_lang ? X.vocab[Y.target_lang] : X.vocab
      )),
        (this.bos_token = Y.bos_token),
        (this.bos_token_id = this.tokens_to_ids.get(this.bos_token)),
        (this.eos_token = Y.eos_token),
        (this.eos_token_id = this.tokens_to_ids.get(this.eos_token)),
        (this.pad_token = Y.pad_token),
        (this.pad_token_id = this.tokens_to_ids.get(this.pad_token)),
        (this.unk_token = Y.unk_token),
        (this.unk_token_id = this.tokens_to_ids.get(this.unk_token)),
        (this.vocab = Array(this.tokens_to_ids.size)));
      for (let [Q, G] of this.tokens_to_ids) this.vocab[G] = Q;
    }
    encode(X) {
      return X;
    }
  };
  M8 = class M8 extends f5 {
    constructor(X) {
      super();
      this.config = X;
    }
    static fromConfig(X) {
      if (X === null) return null;
      switch (X.type) {
        case "BertNormalizer":
          return new KS(X);
        case "Precompiled":
          return new TS(X);
        case "Sequence":
          return new BS(X);
        case "Replace":
          return new QS(X);
        case "NFC":
          return new GS(X);
        case "NFKC":
          return new JS(X);
        case "NFKD":
          return new WS(X);
        case "Strip":
          return new HS(X);
        case "StripAccents":
          return new $S(X);
        case "Lowercase":
          return new US(X);
        case "Prepend":
          return new LS(X);
        default:
          throw Error(`Unknown Normalizer type: ${X.type}`);
      }
    }
    normalize(X) {
      throw Error("normalize should be implemented in subclass.");
    }
    _call(X) {
      return this.normalize(X);
    }
  };
  QS = class QS extends M8 {
    normalize(X) {
      let Y = CW(this.config.pattern);
      return Y === null ? X : X.replaceAll(Y, this.config.content);
    }
  };
  GS = class GS extends M8 {
    normalize(X) {
      return ((X = X.normalize("NFC")), X);
    }
  };
  JS = class JS extends M8 {
    normalize(X) {
      return ((X = X.normalize("NFKC")), X);
    }
  };
  WS = class WS extends M8 {
    normalize(X) {
      return ((X = X.normalize("NFKD")), X);
    }
  };
  HS = class HS extends M8 {
    normalize(X) {
      if (this.config.strip_left && this.config.strip_right) X = X.trim();
      else {
        if (this.config.strip_left) X = X.trimStart();
        if (this.config.strip_right) X = X.trimEnd();
      }
      return X;
    }
  };
  $S = class $S extends M8 {
    normalize(X) {
      return ((X = rP(X)), X);
    }
  };
  US = class US extends M8 {
    normalize(X) {
      return ((X = X.toLowerCase()), X);
    }
  };
  LS = class LS extends M8 {
    normalize(X) {
      return ((X = this.config.prepend + X), X);
    }
  };
  BS = class BS extends M8 {
    constructor(X) {
      super(X);
      this.normalizers = X.normalizers.map((Y) => M8.fromConfig(Y));
    }
    normalize(X) {
      return this.normalizers.reduce((Y, Q) => {
        return Q.normalize(Y);
      }, X);
    }
  };
  KS = class KS extends M8 {
    _tokenize_chinese_chars(X) {
      let Y = [];
      for (let Q = 0; Q < X.length; ++Q) {
        let G = X[Q],
          J = G.charCodeAt(0);
        if (this._is_chinese_char(J)) (Y.push(" "), Y.push(G), Y.push(" "));
        else Y.push(G);
      }
      return Y.join("");
    }
    _is_chinese_char(X) {
      return (
        (X >= 19968 && X <= 40959) ||
        (X >= 13312 && X <= 19903) ||
        (X >= 131072 && X <= 173791) ||
        (X >= 173824 && X <= 177983) ||
        (X >= 177984 && X <= 178207) ||
        (X >= 178208 && X <= 183983) ||
        (X >= 63744 && X <= 64255) ||
        (X >= 194560 && X <= 195103)
      );
    }
    stripAccents(X) {
      return X.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }
    _is_control(X) {
      switch (X) {
        case "\t":
        case `
`:
        case "\r":
          return !1;
        default:
          return /^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(X);
      }
    }
    _clean_text(X) {
      let Y = [];
      for (let Q of X) {
        let G = Q.charCodeAt(0);
        if (G === 0 || G === 65533 || this._is_control(Q)) continue;
        if (/^\s$/.test(Q)) Y.push(" ");
        else Y.push(Q);
      }
      return Y.join("");
    }
    normalize(X) {
      if (this.config.clean_text) X = this._clean_text(X);
      if (this.config.handle_chinese_chars) X = this._tokenize_chinese_chars(X);
      if (this.config.lowercase) {
        if (((X = X.toLowerCase()), this.config.strip_accents !== !1))
          X = this.stripAccents(X);
      } else if (this.config.strip_accents) X = this.stripAccents(X);
      return X;
    }
  };
  E8 = class E8 extends f5 {
    static fromConfig(X) {
      if (X === null) return null;
      switch (X.type) {
        case "BertPreTokenizer":
          return new VS(X);
        case "Sequence":
          return new bS(X);
        case "Whitespace":
          return new vS(X);
        case "WhitespaceSplit":
          return new kS(X);
        case "Metaspace":
          return new CK(X);
        case "ByteLevel":
          return new FS(X);
        case "Split":
          return new NS(X);
        case "Punctuation":
          return new MS(X);
        case "Digits":
          return new AS(X);
        case "Replace":
          return new yS(X);
        default:
          throw Error(`Unknown PreTokenizer type: ${X.type}`);
      }
    }
    pre_tokenize_text(X, Y) {
      throw Error("pre_tokenize_text should be implemented in subclass.");
    }
    pre_tokenize(X, Y) {
      return (
        Array.isArray(X)
          ? X.map((Q) => this.pre_tokenize_text(Q, Y))
          : this.pre_tokenize_text(X, Y)
      ).flat();
    }
    _call(X, Y) {
      return this.pre_tokenize(X, Y);
    }
  };
  VS = class VS extends E8 {
    constructor(X) {
      super();
      this.pattern = new RegExp(`[^\\s${yQ}]+|[${yQ}]`, "gu");
    }
    pre_tokenize_text(X, Y) {
      return X.trim().match(this.pattern) || [];
    }
  };
  FS = class FS extends E8 {
    constructor(X) {
      super();
      ((this.config = X),
        (this.add_prefix_space = this.config.add_prefix_space),
        (this.trim_offsets = this.config.trim_offsets),
        (this.use_regex = this.config.use_regex ?? !0),
        (this.pattern =
          /'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu),
        (this.byte_encoder = eP),
        (this.text_encoder = new TextEncoder()));
    }
    pre_tokenize_text(X, Y) {
      if (this.add_prefix_space && !X.startsWith(" ")) X = " " + X;
      return (this.use_regex ? X.match(this.pattern) || [] : [X]).map((G) =>
        Array.from(
          this.text_encoder.encode(G),
          (J) => this.byte_encoder[J]
        ).join("")
      );
    }
  };
  NS = class NS extends E8 {
    constructor(X) {
      super();
      ((this.config = X),
        (this.pattern = CW(this.config.pattern, this.config.invert)));
    }
    pre_tokenize_text(X, Y) {
      if (this.pattern === null) return [];
      if (this.config.invert) return X.match(this.pattern) || [];
      else return U50(X, this.pattern);
    }
  };
  MS = class MS extends E8 {
    constructor(X) {
      super();
      ((this.config = X),
        (this.pattern = new RegExp(`[^${yQ}]+|[${yQ}]+`, "gu")));
    }
    pre_tokenize_text(X, Y) {
      return X.match(this.pattern) || [];
    }
  };
  AS = class AS extends E8 {
    constructor(X) {
      super();
      this.config = X;
      let Y = `[^\\d]+|\\d${this.config.individual_digits ? "" : "+"}`;
      this.pattern = new RegExp(Y, "gu");
    }
    pre_tokenize_text(X, Y) {
      return X.match(this.pattern) || [];
    }
  };
  QX = class QX extends f5 {
    constructor(X) {
      super();
      this.config = X;
    }
    static fromConfig(X) {
      if (X === null) return null;
      switch (X.type) {
        case "TemplateProcessing":
          return new qS(X);
        case "ByteLevel":
          return new wK(X);
        case "RobertaProcessing":
          return new jK(X);
        case "BertProcessing":
          return new ZK(X);
        case "Sequence":
          return new RS(X);
        default:
          throw Error(`Unknown PostProcessor type: ${X.type}`);
      }
    }
    post_process(X, ...Y) {
      throw Error("post_process should be implemented in subclass.");
    }
    _call(X, ...Y) {
      return this.post_process(X, ...Y);
    }
  };
  ZK = class ZK extends QX {
    constructor(X) {
      super(X);
      ((this.cls = X.cls[0]), (this.sep = X.sep[0]));
    }
    post_process(X, Y = null, { add_special_tokens: Q = !0 } = {}) {
      if (Q) X = S5([this.cls], X, [this.sep]);
      let G = Array(X.length).fill(0);
      if (Y !== null) {
        let J = Q && this instanceof jK ? [this.sep] : [],
          U = Q ? [this.sep] : [];
        ((X = S5(X, J, Y, U)),
          (G = S5(G, Array(Y.length + J.length + U.length).fill(1))));
      }
      return { tokens: X, token_type_ids: G };
    }
  };
  jK = class jK extends ZK {};
  qS = class qS extends QX {
    constructor(X) {
      super(X);
      ((this.single = X.single), (this.pair = X.pair));
    }
    post_process(X, Y = null, { add_special_tokens: Q = !0 } = {}) {
      let G = Y === null ? this.single : this.pair,
        J = [],
        U = [];
      for (let $ of G)
        if ("SpecialToken" in $) {
          if (Q) (J.push($.SpecialToken.id), U.push($.SpecialToken.type_id));
        } else if ("Sequence" in $) {
          if ($.Sequence.id === "A")
            ((J = S5(J, X)),
              (U = S5(U, Array(X.length).fill($.Sequence.type_id))));
          else if ($.Sequence.id === "B")
            ((J = S5(J, Y)),
              (U = S5(U, Array(Y.length).fill($.Sequence.type_id))));
        }
      return { tokens: J, token_type_ids: U };
    }
  };
  wK = class wK extends QX {
    post_process(X, Y = null) {
      if (Y) X = S5(X, Y);
      return { tokens: X };
    }
  };
  RS = class RS extends QX {
    constructor(X) {
      super(X);
      this.processors = X.processors.map((Y) => QX.fromConfig(Y));
    }
    post_process(X, Y = null, Q = {}) {
      let G;
      for (let J of this.processors)
        if (J instanceof wK) {
          if (((X = J.post_process(X).tokens), Y)) Y = J.post_process(Y).tokens;
        } else {
          let U = J.post_process(X, Y, Q);
          ((X = U.tokens), (G = U.token_type_ids));
        }
      return { tokens: X, token_type_ids: G };
    }
  };
  A8 = class A8 extends f5 {
    constructor(X) {
      super();
      ((this.config = X),
        (this.added_tokens = []),
        (this.end_of_word_suffix = null),
        (this.trim_offsets = X.trim_offsets));
    }
    static fromConfig(X) {
      if (X === null) return null;
      switch (X.type) {
        case "WordPiece":
          return new ZS(X);
        case "Metaspace":
          return new SS(X);
        case "ByteLevel":
          return new jS(X);
        case "Replace":
          return new DS(X);
        case "ByteFallback":
          return new zS(X);
        case "Fuse":
          return new ES(X);
        case "Strip":
          return new OS(X);
        case "Sequence":
          return new CS(X);
        case "CTC":
          return new wS(X);
        case "BPEDecoder":
          return new IS(X);
        default:
          throw Error(`Unknown Decoder type: ${X.type}`);
      }
    }
    _call(X) {
      return this.decode(X);
    }
    decode(X) {
      return this.decode_chain(X).join("");
    }
    decode_chain(X) {
      throw Error("`decode_chain` should be implemented in subclass.");
    }
  };
  DS = class DS extends A8 {
    decode_chain(X) {
      let Y = CW(this.config.pattern);
      return Y === null
        ? X
        : X.map((Q) => Q.replaceAll(Y, this.config.content));
    }
  };
  zS = class zS extends A8 {
    constructor(X) {
      super(X);
      this.text_decoder = new TextDecoder();
    }
    decode_chain(X) {
      let Y = [],
        Q = [];
      for (let G of X) {
        let J = null;
        if (G.length === 6 && G.startsWith("<0x") && G.endsWith(">")) {
          let U = parseInt(G.slice(3, 5), 16);
          if (!isNaN(U)) J = U;
        }
        if (J !== null) Q.push(J);
        else {
          if (Q.length > 0) {
            let U = this.text_decoder.decode(Uint8Array.from(Q));
            (Y.push(U), (Q = []));
          }
          Y.push(G);
        }
      }
      if (Q.length > 0) {
        let G = this.text_decoder.decode(Uint8Array.from(Q));
        (Y.push(G), (Q = []));
      }
      return Y;
    }
  };
  ES = class ES extends A8 {
    decode_chain(X) {
      return [X.join("")];
    }
  };
  OS = class OS extends A8 {
    constructor(X) {
      super(X);
      ((this.content = this.config.content),
        (this.start = this.config.start),
        (this.stop = this.config.stop));
    }
    decode_chain(X) {
      return X.map((Y) => {
        let Q = 0;
        for (let J = 0; J < this.start; ++J)
          if (Y[J] === this.content) {
            Q = J + 1;
            continue;
          } else break;
        let G = Y.length;
        for (let J = 0; J < this.stop; ++J) {
          let U = Y.length - J - 1;
          if (Y[U] === this.content) {
            G = U;
            continue;
          } else break;
        }
        return Y.slice(Q, G);
      });
    }
  };
  ZS = class ZS extends A8 {
    constructor(X) {
      super(X);
      this.cleanup = X.cleanup;
    }
    decode_chain(X) {
      return X.map((Y, Q) => {
        if (Q !== 0)
          if (Y.startsWith(this.config.prefix))
            Y = Y.replace(this.config.prefix, "");
          else Y = " " + Y;
        if (this.cleanup) Y = OK(Y);
        return Y;
      });
    }
  };
  jS = class jS extends A8 {
    constructor(X) {
      super(X);
      ((this.byte_decoder = F50),
        (this.text_decoder = new TextDecoder("utf-8", {
          fatal: !1,
          ignoreBOM: !0,
        })),
        (this.end_of_word_suffix = null));
    }
    convert_tokens_to_string(X) {
      let Y = X.join(""),
        Q = new Uint8Array([...Y].map((J) => this.byte_decoder[J]));
      return this.text_decoder.decode(Q);
    }
    decode_chain(X) {
      let Y = [],
        Q = [];
      for (let G of X)
        if (this.added_tokens.find((J) => J.content === G) !== void 0) {
          if (Q.length > 0)
            (Y.push(this.convert_tokens_to_string(Q)), (Q = []));
          Y.push(G);
        } else Q.push(G);
      if (Q.length > 0) Y.push(this.convert_tokens_to_string(Q));
      return Y;
    }
  };
  wS = class wS extends A8 {
    constructor(X) {
      super(X);
      ((this.pad_token = this.config.pad_token),
        (this.word_delimiter_token = this.config.word_delimiter_token),
        (this.cleanup = this.config.cleanup));
    }
    convert_tokens_to_string(X) {
      if (X.length === 0) return "";
      let Y = [X[0]];
      for (let J = 1; J < X.length; ++J) if (X[J] !== Y.at(-1)) Y.push(X[J]);
      let G = Y.filter((J) => J !== this.pad_token).join("");
      if (this.cleanup)
        G = OK(G).replaceAll(this.word_delimiter_token, " ").trim();
      return G;
    }
    decode_chain(X) {
      return [this.convert_tokens_to_string(X)];
    }
  };
  CS = class CS extends A8 {
    constructor(X) {
      super(X);
      this.decoders = X.decoders.map((Y) => A8.fromConfig(Y));
    }
    decode_chain(X) {
      return this.decoders.reduce((Y, Q) => {
        return Q.decode_chain(Y);
      }, X);
    }
  };
  IS = class IS extends A8 {
    constructor(X) {
      super(X);
      this.suffix = this.config.suffix;
    }
    decode_chain(X) {
      return X.map((Y, Q) => {
        return Y.replaceAll(this.suffix, Q === X.length - 1 ? "" : " ");
      });
    }
  };
  PS = class PS extends A8 {
    decode_chain(X) {
      let Y = "";
      for (let Q = 1; Q < X.length; Q += 2) Y += X[Q];
      return [Y];
    }
  };
  CK = class CK extends E8 {
    constructor(X) {
      super();
      ((this.addPrefixSpace = X.add_prefix_space),
        (this.replacement = X.replacement),
        (this.strRep = X.str_rep || this.replacement),
        (this.prepend_scheme = X.prepend_scheme ?? "always"));
    }
    pre_tokenize_text(X, { section_index: Y = void 0 } = {}) {
      let Q = X.replaceAll(" ", this.strRep);
      if (
        this.addPrefixSpace &&
        !Q.startsWith(this.replacement) &&
        (this.prepend_scheme === "always" ||
          (this.prepend_scheme === "first" && Y === 0))
      )
        Q = this.strRep + Q;
      return [Q];
    }
  };
  SS = class SS extends A8 {
    constructor(X) {
      super(X);
      ((this.addPrefixSpace = X.add_prefix_space),
        (this.replacement = X.replacement));
    }
    decode_chain(X) {
      let Y = [];
      for (let Q = 0; Q < X.length; ++Q) {
        let G = X[Q].replaceAll(this.replacement, " ");
        if (this.addPrefixSpace && Q == 0 && G.startsWith(" "))
          G = G.substring(1);
        Y.push(G);
      }
      return Y;
    }
  };
  TS = class TS extends M8 {
    constructor(X) {
      super(X);
      this.charsmap = X.precompiled_charsmap;
    }
    normalize(X) {
      if (
        ((X = X.replace(
          /[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,
          ""
        )),
        (X = X.replace(
          /[\u0009\u000A\u000C\u000D\u1680\u200B\u200C\u200E\u200F\u2028\u2029\u2581\uFEFF\uFFFD]/gm,
          " "
        )),
        X.includes("\uFF5E"))
      )
        X = X.split("\uFF5E")
          .map((Q) => Q.normalize("NFKC"))
          .join("\uFF5E");
      else X = X.normalize("NFKC");
      return X;
    }
  };
  bS = class bS extends E8 {
    constructor(X) {
      super();
      this.tokenizers = X.pretokenizers.map((Y) => E8.fromConfig(Y));
    }
    pre_tokenize_text(X, Y) {
      return this.tokenizers.reduce(
        (Q, G) => {
          return G.pre_tokenize(Q, Y);
        },
        [X]
      );
    }
  };
  vS = class vS extends E8 {
    constructor(X) {
      super();
    }
    pre_tokenize_text(X, Y) {
      return X.match(/\w+|[^\w\s]+/g) || [];
    }
  };
  kS = class kS extends E8 {
    constructor(X) {
      super();
    }
    pre_tokenize_text(X, Y) {
      return K50(X);
    }
  };
  yS = class yS extends E8 {
    constructor(X) {
      super();
      ((this.config = X),
        (this.pattern = CW(this.config.pattern)),
        (this.content = this.config.content));
    }
    pre_tokenize_text(X, Y) {
      if (this.pattern === null) return [X];
      return [X.replaceAll(this.pattern, this.config.content)];
    }
  };
  N50 = [
    "bos_token",
    "eos_token",
    "unk_token",
    "sep_token",
    "pad_token",
    "cls_token",
    "mask_token",
  ];
  W1 = class W1 extends f5 {
    return_token_type_ids = !1;
    _default_chat_template = `{% for message in messages %}{{'<|im_start|>' + message['role'] + '
' + message['content'] + '<|im_end|>' + '
'}}{% endfor %}{% if add_generation_prompt %}{{ '<|im_start|>assistant
' }}{% endif %}`;
    constructor(X, Y) {
      super();
      ((this._tokenizer_config = Y),
        (this.normalizer = M8.fromConfig(X.normalizer)),
        (this.pre_tokenizer = E8.fromConfig(X.pre_tokenizer)),
        (this.model = GX.fromConfig(X.model, Y)),
        (this.post_processor = QX.fromConfig(X.post_processor)),
        (this.decoder = A8.fromConfig(X.decoder)),
        (this.special_tokens = []),
        (this.all_special_ids = []),
        (this.added_tokens = []));
      for (let Q of X.added_tokens) {
        let G = new oP(Q);
        if (
          (this.added_tokens.push(G),
          this.model.tokens_to_ids.set(G.content, G.id),
          (this.model.vocab[G.id] = G.content),
          G.special)
        )
          (this.special_tokens.push(G.content),
            this.all_special_ids.push(G.id));
      }
      if (
        ((this.additional_special_tokens = Y.additional_special_tokens ?? []),
        this.special_tokens.push(...this.additional_special_tokens),
        (this.special_tokens = [...new Set(this.special_tokens)]),
        this.decoder)
      )
        ((this.decoder.added_tokens = this.added_tokens),
          (this.decoder.end_of_word_suffix = this.model.end_of_word_suffix));
      if (
        ((this.added_tokens_regex =
          this.added_tokens.length > 0
            ? new RegExp(
                this.added_tokens
                  .map(
                    (Q) =>
                      `${Q.lstrip ? "\\s*" : ""}(${iB(Q.content)})${Q.rstrip ? "\\s*" : ""}`
                  )
                  .join("|")
              )
            : null),
        (this.mask_token = this.getToken("mask_token")),
        (this.mask_token_id = this.model.tokens_to_ids.get(this.mask_token)),
        (this.pad_token = this.getToken("pad_token", "eos_token")),
        (this.pad_token_id = this.model.tokens_to_ids.get(this.pad_token)),
        (this.sep_token = this.getToken("sep_token")),
        (this.sep_token_id = this.model.tokens_to_ids.get(this.sep_token)),
        (this.unk_token = this.getToken("unk_token")),
        (this.unk_token_id = this.model.tokens_to_ids.get(this.unk_token)),
        (this.model_max_length = Y.model_max_length),
        (this.remove_space = Y.remove_space),
        (this.clean_up_tokenization_spaces =
          Y.clean_up_tokenization_spaces ?? !0),
        (this.do_lowercase_and_remove_accent =
          Y.do_lowercase_and_remove_accent ?? !1),
        (this.padding_side = "right"),
        (this.legacy = !1),
        (this.chat_template = Y.chat_template ?? null),
        Array.isArray(this.chat_template))
      ) {
        let Q = Object.create(null);
        for (let { name: G, template: J } of this.chat_template) {
          if (typeof G !== "string" || typeof J !== "string")
            throw Error(
              'Chat template must be a list of objects with "name" and "template" properties'
            );
          Q[G] = J;
        }
        this.chat_template = Q;
      }
      this._compiled_template_cache = new Map();
    }
    getToken(...X) {
      for (let Y of X) {
        let Q = this._tokenizer_config[Y];
        if (!Q) continue;
        if (typeof Q === "object")
          if (Q.__type === "AddedToken") return Q.content;
          else throw Error(`Unknown token: ${Q}`);
        else return Q;
      }
      return null;
    }
    static async from_pretrained(
      X,
      {
        progress_callback: Y = null,
        config: Q = null,
        cache_dir: G = null,
        local_files_only: J = !1,
        revision: U = "main",
        legacy: $ = null,
      } = {}
    ) {
      let B = await nP(X, {
        progress_callback: Y,
        config: Q,
        cache_dir: G,
        local_files_only: J,
        revision: U,
        legacy: $,
      });
      return new this(...B);
    }
    _call(
      X,
      {
        text_pair: Y = null,
        add_special_tokens: Q = !0,
        padding: G = !1,
        truncation: J = null,
        max_length: U = null,
        return_tensor: $ = !0,
        return_token_type_ids: B = null,
      } = {}
    ) {
      let K = Array.isArray(X),
        V;
      if (K) {
        if (X.length === 0) throw Error("text array must be non-empty");
        if (Y !== null) {
          if (!Array.isArray(Y)) throw Error("text_pair must also be an array");
          else if (X.length !== Y.length)
            throw Error("text and text_pair must have the same length");
          V = X.map((L, H) =>
            this._encode_plus(L, Y[H], {
              add_special_tokens: Q,
              return_token_type_ids: B,
            })
          );
        } else
          V = X.map((L) =>
            this._encode_plus(L, null, {
              add_special_tokens: Q,
              return_token_type_ids: B,
            })
          );
      } else {
        if (X === null || X === void 0)
          throw Error("text may not be null or undefined");
        if (Array.isArray(Y))
          throw Error(
            "When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array)."
          );
        V = [
          this._encode_plus(X, Y, {
            add_special_tokens: Q,
            return_token_type_ids: B,
          }),
        ];
      }
      if (U === null)
        if (G === "max_length") U = this.model_max_length;
        else U = x5(V.map((L) => L.input_ids.length))[0];
      else if (!J)
        console.warn(
          "Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."
        );
      if (((U = Math.min(U, this.model_max_length)), G || J)) {
        for (let L = 0; L < V.length; ++L)
          if (V[L].input_ids.length === U) continue;
          else if (V[L].input_ids.length > U) {
            if (J) A50(V[L], U);
          } else if (G)
            M50(
              V[L],
              U,
              (H) => (H === "input_ids" ? this.pad_token_id : 0),
              this.padding_side
            );
      }
      let W = {};
      if ($) {
        if (!(G && J)) {
          if (
            V.some((H) => {
              for (let F of Object.keys(H))
                if (H[F].length !== V[0][F]?.length) return !0;
              return !1;
            })
          )
            throw Error(
              "Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length."
            );
        }
        let L = [V.length, V[0].input_ids.length];
        for (let H of Object.keys(V[0]))
          W[H] = new I0(
            "int64",
            BigInt64Array.from(V.flatMap((F) => F[H]).map(BigInt)),
            L
          );
      } else {
        for (let L of Object.keys(V[0])) W[L] = V.map((H) => H[L]);
        if (!K) for (let L of Object.keys(W)) W[L] = W[L][0];
      }
      return W;
    }
    _encode_text(X) {
      if (X === null) return null;
      return (
        this.added_tokens_regex
          ? X.split(this.added_tokens_regex).filter((G) => G)
          : [X]
      )
        .map((G, J) => {
          if (this.added_tokens.find(($) => $.content === G) !== void 0)
            return G;
          else {
            if (this.remove_space === !0) G = G.trim().split(/\s+/).join(" ");
            if (this.do_lowercase_and_remove_accent) G = L50(G);
            if (this.normalizer !== null) G = this.normalizer(G);
            if (G.length === 0) return [];
            let $ =
              this.pre_tokenizer !== null
                ? this.pre_tokenizer(G, { section_index: J })
                : [G];
            return this.model($);
          }
        })
        .flat();
    }
    _encode_plus(
      X,
      Y = null,
      { add_special_tokens: Q = !0, return_token_type_ids: G = null } = {}
    ) {
      let J = this._encode_text(X),
        U = this._encode_text(Y),
        $ = this.post_processor
          ? this.post_processor(J, U, { add_special_tokens: Q })
          : { tokens: S5(J ?? [], U ?? []) },
        B = this.model.convert_tokens_to_ids($.tokens),
        K = { input_ids: B, attention_mask: Array(B.length).fill(1) };
      if ((G ?? this.return_token_type_ids) && $.token_type_ids)
        K.token_type_ids = $.token_type_ids;
      return K;
    }
    encode(
      X,
      Y = null,
      { add_special_tokens: Q = !0, return_token_type_ids: G = null } = {}
    ) {
      let { input_ids: J } = this._encode_plus(X, Y, {
        add_special_tokens: Q,
        return_token_type_ids: G,
      });
      return J;
    }
    batch_decode(X, Y = {}) {
      if (X instanceof I0) X = X.tolist();
      return X.map((Q) => this.decode(Q, Y));
    }
    decode(X, Y = {}) {
      if (X instanceof I0) X = aP(X);
      if (!Array.isArray(X) || X.length === 0 || !KW(X[0]))
        throw Error("token_ids must be a non-empty array of integers.");
      return this.decode_single(X, Y);
    }
    decode_single(
      X,
      { skip_special_tokens: Y = !1, clean_up_tokenization_spaces: Q = null }
    ) {
      let G = this.model.convert_ids_to_tokens(X);
      if (Y) G = G.filter((U) => !this.special_tokens.includes(U));
      let J = this.decoder ? this.decoder(G) : G.join(" ");
      if (this.decoder && this.decoder.end_of_word_suffix) {
        if (((J = J.replaceAll(this.decoder.end_of_word_suffix, " ")), Y))
          J = J.trim();
      }
      if (Q ?? this.clean_up_tokenization_spaces) J = OK(J);
      return J;
    }
    get default_chat_template() {
      if (!this._warned_about_chat_template)
        (console.warn(
          "No chat template is defined for this tokenizer - using a default chat template that implements the ChatML format. If the default is not appropriate for your model, please set `tokenizer.chat_template` to an appropriate template. See https://huggingface.co/docs/transformers/main/chat_templating for more information."
        ),
          (this._warned_about_chat_template = !0));
      return this._default_chat_template;
    }
    apply_chat_template(
      X,
      {
        chat_template: Y = null,
        add_generation_prompt: Q = !1,
        tokenize: G = !0,
        padding: J = !1,
        truncation: U = !1,
        max_length: $ = null,
        return_tensor: B = !0,
        tokenizer_kwargs: K = {},
        ...V
      } = {}
    ) {
      if (
        (this.chat_template && typeof this.chat_template === "object") ||
        (this.chat_template === null &&
          this.default_chat_template &&
          typeof this.default_chat_template === "object")
      ) {
        let F = this.chat_template ?? this.default_chat_template;
        if (Y !== null && Object.hasOwn(F, Y)) Y = F[Y];
        else if (Y === null && "default" in F) Y = F.default;
        else if (Y === null)
          throw Error(
            `This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(F).sort()}.`
          );
      } else Y ??= this.chat_template ?? this.default_chat_template;
      if (typeof Y !== "string")
        throw Error(`chat_template must be a string, but got ${typeof Y}`);
      let W = this._compiled_template_cache.get(Y);
      if (W === void 0)
        ((W = new pP(Y)), this._compiled_template_cache.set(Y, W));
      let L = Object.create(null);
      for (let F of N50) {
        let N = this.getToken(F);
        if (N) L[F] = N;
      }
      let H = W.render({ messages: X, add_generation_prompt: Q, ...L, ...V });
      if (G)
        return this._call(H, {
          add_special_tokens: !1,
          padding: J,
          truncation: U,
          max_length: $,
          return_tensor: B,
          ...K,
        }).input_ids;
      return H;
    }
  };
  IK = class IK extends W1 {
    return_token_type_ids = !0;
  };
  PK = class PK extends W1 {
    return_token_type_ids = !0;
  };
  SK = class SK extends W1 {
    return_token_type_ids = !0;
  };
  TK = class TK extends W1 {
    return_token_type_ids = !0;
  };
  bK = class bK extends W1 {
    return_token_type_ids = !0;
  };
  vK = class vK extends W1 {
    return_token_type_ids = !0;
  };
  kK = class kK extends W1 {
    return_token_type_ids = !0;
  };
  yK = class yK extends W1 {
    return_token_type_ids = !0;
  };
  _K = class _K extends W1 {
    return_token_type_ids = !0;
  };
  fK = class fK extends W1 {};
  xK = class xK extends W1 {};
  hK = class hK extends W1 {
    return_token_type_ids = !0;
    constructor(X, Y) {
      super(X, Y);
      console.warn(
        'WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.'
      );
    }
  };
  gK = class gK extends W1 {
    return_token_type_ids = !0;
  };
  uK = class uK extends W1 {};
  IW = class IW extends W1 {
    _default_chat_template =
      '{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}';
  };
  lK = class lK extends W1 {};
  PW = class PW extends W1 {
    constructor(X, Y) {
      super(X, Y);
      ((this.languageRegex = /^[a-z]{2}_[A-Z]{2}$/),
        (this.language_codes = this.special_tokens.filter((Q) =>
          this.languageRegex.test(Q)
        )),
        (this.lang_to_token = (Q) => Q));
    }
    _build_translation_inputs(X, Y, Q) {
      return XV(this, X, Y, Q);
    }
  };
  mK = class mK extends PW {};
  cK = class cK extends W1 {};
  dK = class dK extends IW {
    constructor(X, Y) {
      let G = X.pre_tokenizer?.pretokenizers[0]?.pattern;
      if (
        G &&
        G.Regex ===
          ` ?[^(\\s|[${".,!?\u2026\u3002\uFF0C\u3001\u0964\u06D4\u060C"}])]+`
      )
        G.Regex = ` ?[^\\s${".,!?\u2026\u3002\uFF0C\u3001\u0964\u06D4\u060C"}]+`;
      super(X, Y);
    }
  };
  SW = class SW extends W1 {
    _default_chat_template = `{% if messages[0]['role'] == 'system' %}{% set loop_messages = messages[1:] %}{% set system_message = messages[0]['content'] %}{% elif USE_DEFAULT_PROMPT == true and not '<<SYS>>' in messages[0]['content'] %}{% set loop_messages = messages %}{% set system_message = 'DEFAULT_SYSTEM_MESSAGE' %}{% else %}{% set loop_messages = messages %}{% set system_message = false %}{% endif %}{% for message in loop_messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if loop.index0 == 0 and system_message != false %}{% set content = '<<SYS>>
' + system_message + '
<</SYS>>

' + message['content'] %}{% else %}{% set content = message['content'] %}{% endif %}{% if message['role'] == 'user' %}{{ bos_token + '[INST] ' + content.strip() + ' [/INST]' }}{% elif message['role'] == 'system' %}{{ '<<SYS>>
' + content.strip() + '
<</SYS>>

' }}{% elif message['role'] == 'assistant' %}{{ ' '  + content.strip() + ' ' + eos_token }}{% endif %}{% endfor %}`;
    DEFAULT_SYSTEM_PROMPT = `You are a helpful, respectful and honest assistant. Always answer as helpfully as possible, while being safe. Your answers should not include any harmful, unethical, racist, sexist, toxic, dangerous, or illegal content. Please ensure that your responses are socially unbiased and positive in nature.

If a question does not make any sense, or is not factually coherent, explain why instead of answering something not correct. If you don't know the answer to a question, please don't share false information.`;
    constructor(X, Y) {
      super(X, Y);
      if (
        ((this.use_default_system_prompt = Y.use_default_system_prompt ?? !1),
        (this.legacy = Y.legacy ?? !0),
        !this.legacy)
      )
        ((this.normalizer = null),
          (this.pre_tokenizer = new CK({
            replacement: jW,
            add_prefix_space: !0,
            prepend_scheme: "first",
          })));
    }
    _encode_text(X) {
      if (X === null) return null;
      if (this.legacy || X.length === 0) return super._encode_text(X);
      let Y = super._encode_text(jW + X.replaceAll(jW, " "));
      if (Y.length > 1 && Y[0] === jW && this.special_tokens.includes(Y[1]))
        Y = Y.slice(1);
      return Y;
    }
    get default_chat_template() {
      return super.default_chat_template
        .replaceAll(
          "USE_DEFAULT_PROMPT",
          this.use_default_system_prompt ? "true" : "false"
        )
        .replaceAll(
          "DEFAULT_SYSTEM_MESSAGE",
          this.DEFAULT_SYSTEM_PROMPT.replaceAll(
            `
`,
            "\\n"
          ).replaceAll("'", "\\'")
        );
    }
  };
  pK = class pK extends SW {};
  iK = class iK extends W1 {};
  nK = class nK extends W1 {};
  aK = class aK extends W1 {};
  rK = class rK extends W1 {};
  oK = class oK extends W1 {};
  sK = class sK extends W1 {};
  tK = class tK extends W1 {
    _default_chat_template = `{% if messages[0]['role'] == 'system' %}{{ raise_exception('System role not supported') }}{% endif %}{% for message in messages %}{% if (message['role'] == 'user') != (loop.index0 % 2 == 0) %}{{ raise_exception('Conversation roles must alternate user/assistant/user/assistant/...') }}{% endif %}{% if (message['role'] == 'assistant') %}{% set role = 'model' %}{% else %}{% set role = message['role'] %}{% endif %}{{ '<start_of_turn>' + role + '
' + message['content'] | trim + '<end_of_turn>
' }}{% endfor %}{% if add_generation_prompt %}{{'<start_of_turn>model
'}}{% endif %}`;
  };
  eK = class eK extends W1 {};
  YV = class YV extends W1 {
    constructor(X, Y) {
      super(X, Y);
      ((this.languageRegex = /^[a-z]{3}_[A-Z][a-z]{3}$/),
        (this.language_codes = this.special_tokens.filter((Q) =>
          this.languageRegex.test(Q)
        )),
        (this.lang_to_token = (Q) => Q));
    }
    _build_translation_inputs(X, Y, Q) {
      return XV(this, X, Y, Q);
    }
  };
  QV = class QV extends W1 {
    constructor(X, Y) {
      super(X, Y);
      ((this.languageRegex = /^__[a-z]{2,3}__$/),
        (this.language_codes = this.special_tokens
          .filter((Q) => this.languageRegex.test(Q))
          .map((Q) => Q.slice(2, -2))),
        (this.lang_to_token = (Q) => `__${Q}__`));
    }
    _build_translation_inputs(X, Y, Q) {
      return XV(this, X, Y, Q);
    }
  };
  ((_S = [
    ["en", "english"],
    ["zh", "chinese"],
    ["de", "german"],
    ["es", "spanish"],
    ["ru", "russian"],
    ["ko", "korean"],
    ["fr", "french"],
    ["ja", "japanese"],
    ["pt", "portuguese"],
    ["tr", "turkish"],
    ["pl", "polish"],
    ["ca", "catalan"],
    ["nl", "dutch"],
    ["ar", "arabic"],
    ["sv", "swedish"],
    ["it", "italian"],
    ["id", "indonesian"],
    ["hi", "hindi"],
    ["fi", "finnish"],
    ["vi", "vietnamese"],
    ["he", "hebrew"],
    ["uk", "ukrainian"],
    ["el", "greek"],
    ["ms", "malay"],
    ["cs", "czech"],
    ["ro", "romanian"],
    ["da", "danish"],
    ["hu", "hungarian"],
    ["ta", "tamil"],
    ["no", "norwegian"],
    ["th", "thai"],
    ["ur", "urdu"],
    ["hr", "croatian"],
    ["bg", "bulgarian"],
    ["lt", "lithuanian"],
    ["la", "latin"],
    ["mi", "maori"],
    ["ml", "malayalam"],
    ["cy", "welsh"],
    ["sk", "slovak"],
    ["te", "telugu"],
    ["fa", "persian"],
    ["lv", "latvian"],
    ["bn", "bengali"],
    ["sr", "serbian"],
    ["az", "azerbaijani"],
    ["sl", "slovenian"],
    ["kn", "kannada"],
    ["et", "estonian"],
    ["mk", "macedonian"],
    ["br", "breton"],
    ["eu", "basque"],
    ["is", "icelandic"],
    ["hy", "armenian"],
    ["ne", "nepali"],
    ["mn", "mongolian"],
    ["bs", "bosnian"],
    ["kk", "kazakh"],
    ["sq", "albanian"],
    ["sw", "swahili"],
    ["gl", "galician"],
    ["mr", "marathi"],
    ["pa", "punjabi"],
    ["si", "sinhala"],
    ["km", "khmer"],
    ["sn", "shona"],
    ["yo", "yoruba"],
    ["so", "somali"],
    ["af", "afrikaans"],
    ["oc", "occitan"],
    ["ka", "georgian"],
    ["be", "belarusian"],
    ["tg", "tajik"],
    ["sd", "sindhi"],
    ["gu", "gujarati"],
    ["am", "amharic"],
    ["yi", "yiddish"],
    ["lo", "lao"],
    ["uz", "uzbek"],
    ["fo", "faroese"],
    ["ht", "haitian creole"],
    ["ps", "pashto"],
    ["tk", "turkmen"],
    ["nn", "nynorsk"],
    ["mt", "maltese"],
    ["sa", "sanskrit"],
    ["lb", "luxembourgish"],
    ["my", "myanmar"],
    ["bo", "tibetan"],
    ["tl", "tagalog"],
    ["mg", "malagasy"],
    ["as", "assamese"],
    ["tt", "tatar"],
    ["haw", "hawaiian"],
    ["ln", "lingala"],
    ["ha", "hausa"],
    ["ba", "bashkir"],
    ["jw", "javanese"],
    ["su", "sundanese"],
  ]),
    (wW = new Map(_S)),
    (q50 = new Map([
      ..._S.map(([X, Y]) => [Y, X]),
      ["burmese", "my"],
      ["valencian", "ca"],
      ["flemish", "nl"],
      ["haitian", "ht"],
      ["letzeburgesch", "lb"],
      ["pushto", "ps"],
      ["panjabi", "pa"],
      ["moldavian", "ro"],
      ["moldovan", "ro"],
      ["sinhalese", "si"],
      ["castilian", "es"],
    ])));
  GV = class GV extends W1 {
    _default_chat_template =
      '{% for message in messages %}" "{{ message.content }}{{ eos_token }}" "{% endfor %}';
    _decode_asr(
      X,
      {
        return_timestamps: Y = !1,
        return_language: Q = !1,
        time_precision: G = null,
        force_full_sequences: J = !0,
      } = {}
    ) {
      if (G === null) throw Error("Must specify time_precision");
      let U = null,
        $ = Y === "word";
      function B() {
        return { language: U, timestamp: [null, null], text: "" };
      }
      let K = [],
        V = B(),
        W = 0,
        L = this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0] + 1,
        H = [],
        F = [],
        N = !1,
        q = null,
        M = new Set(this.all_special_ids);
      for (let R of X) {
        let z = R.tokens,
          E = $ ? R.token_timestamps : null,
          O = null,
          Z = L;
        if ("stride" in R) {
          let [I, T, y] = R.stride;
          if (((W -= T), (q = I - y), T)) Z = T / G + L;
          if (y)
            for (let _ = z.length - 1; _ >= 0; --_) {
              let f = z[_];
              if (f >= L) {
                if (O !== null && (f - L) * G < q) break;
                O = f;
              }
            }
        }
        let j = [],
          w = [];
        for (let I = 0; I < z.length; ++I) {
          let T = z[I];
          if (M.has(T)) {
            let y = this.decode([T]),
              _ = wW.get(y.slice(2, -2));
            if (_ !== void 0) {
              if (U !== null && _ !== U && !Y) {
                H.push(j);
                let f = this.findLongestCommonSequence(H)[0],
                  l = this.decode(f);
                ((V.text = l), K.push(V), (H = []), (j = []), (V = B()));
              }
              U = V.language = _;
            }
          } else if (T >= L) {
            let y = (T - L) * G + W,
              _ = Q9(y, 2);
            if (O !== null && T >= O) N = !0;
            else if (N || (H.length > 0 && T < Z)) N = !1;
            else if (V.timestamp[0] === null) V.timestamp[0] = _;
            else if (_ === V.timestamp[0]);
            else {
              if (((V.timestamp[1] = _), H.push(j), $)) F.push(w);
              let [f, l] = this.findLongestCommonSequence(H, F),
                h = this.decode(f);
              if (((V.text = h), $))
                V.words = this.collateWordTimestamps(f, l, U);
              (K.push(V), (H = []), (j = []), (F = []), (w = []), (V = B()));
            }
          } else if ((j.push(T), $)) {
            let y = Q9(E[I] + W, 2),
              _;
            if (I + 1 < E.length) _ = Q9(E[I + 1] + W, 2);
            else _ = null;
            w.push([y, _]);
          }
        }
        if ("stride" in R) {
          let [I, T, y] = R.stride;
          W += I - y;
        }
        if (j.length > 0) {
          if ((H.push(j), $)) F.push(w);
        } else if (H.every((I) => I.length === 0))
          ((V = B()), (H = []), (j = []), (F = []), (w = []));
      }
      if (H.length > 0) {
        if (J && Y)
          throw Error(
            "Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation."
          );
        let [R, z] = this.findLongestCommonSequence(H, F),
          E = this.decode(R);
        if (((V.text = E), $)) V.words = this.collateWordTimestamps(R, z, U);
        K.push(V);
      }
      let A = Object.create(null),
        D = K.map((R) => R.text).join("");
      if (Y || Q) {
        for (let R = 0; R < K.length; ++R) {
          let z = K[R];
          if (!Y) delete z.timestamp;
          if (!Q) delete z.language;
        }
        if ($) {
          let R = [];
          for (let z of K) for (let E of z.words) R.push(E);
          A = { chunks: R };
        } else A = { chunks: K };
      }
      return [D, A];
    }
    findLongestCommonSequence(X, Y = null) {
      let Q = X[0],
        G = Q.length,
        J = [],
        U = Array.isArray(Y) && Y.length > 0,
        $ = U ? [] : null,
        B = U ? Y[0] : null;
      for (let K = 1; K < X.length; ++K) {
        let V = X[K],
          W = 0,
          L = [G, G, 0, 0],
          H = V.length;
        for (let R = 1; R < G + H; ++R) {
          let z = R / 1e4,
            E = Math.max(0, G - R),
            O = Math.min(G, G + H - R),
            Z = Q.slice(E, O),
            j = Math.max(0, R - G),
            w = Math.min(H, R),
            I = V.slice(j, w);
          if (Z.length !== I.length)
            throw Error(
              "There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference."
            );
          let T = Z.filter((_, f) => _ === I[f]).length,
            y = T / R + z;
          if (T > 1 && y > W) ((W = y), (L = [E, O, j, w]));
        }
        let [F, N, q, M] = L,
          A = Math.floor((N + F) / 2),
          D = Math.floor((M + q) / 2);
        if ((J.push(...Q.slice(0, A)), (Q = V.slice(D)), (G = Q.length), U))
          ($.push(...B.slice(0, A)), (B = Y[K].slice(D)));
      }
      if ((J.push(...Q), U)) return ($.push(...B), [J, $]);
      else return [J, []];
    }
    collateWordTimestamps(X, Y, Q) {
      let [G, J, U] = this.combineTokensIntoWords(X, Q),
        $ = [];
      for (let B = 0; B < G.length; ++B) {
        let K = U[B];
        $.push({ text: G[B], timestamp: [Y[K.at(0)][0], Y[K.at(-1)][1]] });
      }
      return $;
    }
    combineTokensIntoWords(
      X,
      Y,
      Q = `"'\u201C\xA1\xBF([{-`,
      G = `"'.\u3002,\uFF0C!\uFF01?\uFF1F:\uFF1A\u201D)]}\u3001`
    ) {
      Y = Y ?? "english";
      let J, U, $;
      if (["chinese", "japanese", "thai", "lao", "myanmar"].includes(Y))
        [J, U, $] = this.splitTokensOnUnicode(X);
      else [J, U, $] = this.splitTokensOnSpaces(X);
      return this.mergePunctuations(J, U, $, Q, G);
    }
    decode(X, Y) {
      let Q;
      if (Y && Y.decode_with_timestamps) {
        if (X instanceof I0) X = aP(X);
        Q = this.decodeWithTimestamps(X, Y);
      } else Q = super.decode(X, Y);
      return Q;
    }
    decodeWithTimestamps(X, Y) {
      let Q = Y?.time_precision ?? 0.02,
        G = Array.from(this.all_special_ids).at(-1) + 1,
        J = [[]];
      for (let U of X)
        if (U >= G) {
          let $ = Q9((U - G) * Q, 2);
          (J.push(`<|${$}|>`), J.push([]));
        } else J[J.length - 1].push(U);
      return (
        (J = J.map((U) => {
          if (typeof U === "string") return U;
          else return super.decode(U, Y);
        })),
        J.join("")
      );
    }
    splitTokensOnUnicode(X) {
      let Y = this.decode(X, { decode_with_timestamps: !0 }),
        Q = "\uFFFD",
        G = [],
        J = [],
        U = [],
        $ = [],
        B = [],
        K = 0;
      for (let V = 0; V < X.length; ++V) {
        let W = X[V];
        ($.push(W), B.push(V));
        let L = this.decode($, { decode_with_timestamps: !0 });
        if (!L.includes("\uFFFD") || Y[K + L.indexOf("\uFFFD")] === "\uFFFD")
          (G.push(L),
            J.push($),
            U.push(B),
            ($ = []),
            (B = []),
            (K += L.length));
      }
      return [G, J, U];
    }
    splitTokensOnSpaces(X) {
      let [Y, Q, G] = this.splitTokensOnUnicode(X),
        J = [],
        U = [],
        $ = [],
        B = new RegExp(`^[${yQ}]$`, "gu");
      for (let K = 0; K < Y.length; ++K) {
        let V = Y[K],
          W = Q[K],
          L = G[K],
          H = W[0] >= this.model.tokens_to_ids.get("<|endoftext|>"),
          F = V.startsWith(" "),
          N = V.trim(),
          q = B.test(N);
        if (H || F || q || J.length === 0) (J.push(V), U.push(W), $.push(L));
        else {
          let M = J.length - 1;
          ((J[M] += V), U[M].push(...W), $[M].push(...L));
        }
      }
      return [J, U, $];
    }
    mergePunctuations(X, Y, Q, G, J) {
      let U = structuredClone(X),
        $ = structuredClone(Y),
        B = structuredClone(Q),
        K = U.length - 2,
        V = U.length - 1;
      while (K >= 0) {
        if (U[K].startsWith(" ") && G.includes(U[K].trim()))
          ((U[V] = U[K] + U[V]),
            ($[V] = S5($[K], $[V])),
            (B[V] = S5(B[K], B[V])),
            (U[K] = ""),
            ($[K] = []),
            (B[K] = []));
        else V = K;
        --K;
      }
      ((K = 0), (V = 1));
      while (V < U.length) {
        if (!U[K].endsWith(" ") && J.includes(U[V]))
          ((U[K] += U[V]),
            ($[K] = S5($[K], $[V])),
            (B[K] = S5(B[K], B[V])),
            (U[V] = ""),
            ($[V] = []),
            (B[V] = []));
        else K = V;
        ++V;
      }
      return [
        U.filter((W) => W),
        $.filter((W) => W.length > 0),
        B.filter((W) => W.length > 0),
      ];
    }
    get_decoder_prompt_ids({
      language: X = null,
      task: Y = null,
      no_timestamps: Q = !0,
    } = {}) {
      let G = [];
      if (X) {
        X = X.toLowerCase();
        let J = q50.get(X);
        if (J === void 0)
          if (wW.has(X)) J = X;
          else {
            let B = X.length === 2 ? wW.keys() : wW.values();
            throw Error(
              `Language "${X}" is not supported. Must be one of: ${JSON.stringify(B)}`
            );
          }
        let U = this.model.tokens_to_ids.get(`<|${J}|>`);
        if (U === void 0)
          throw Error(
            `Unable to find language "${J}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`
          );
        G.push(U);
      } else G.push(null);
      if (Y) {
        if (((Y = Y.toLowerCase()), Y !== "transcribe" && Y !== "translate"))
          throw Error(
            `Task "${Y}" is not supported. Must be one of: ["transcribe", "translate"]`
          );
        let J = this.model.tokens_to_ids.get(`<|${Y}|>`);
        if (J === void 0)
          throw Error(
            `Unable to find task "${Y}" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.`
          );
        G.push(J);
      } else G.push(null);
      if (Q) {
        let J = this.model.tokens_to_ids.get("<|notimestamps|>");
        if (J === void 0)
          throw Error(
            'Unable to find "<|notimestamps|>" in model vocabulary. Please report this issue at https://github.com/xenova/transformers.js/issues/new/choose.'
          );
        G.push(J);
      }
      return G.map((J, U) => [U + 1, J]).filter((J) => J[1] !== null);
    }
  };
  JV = class JV extends W1 {};
  WV = class WV extends W1 {};
  HV = class HV extends W1 {};
  $V = class $V extends W1 {
    constructor(X, Y) {
      super(X, Y);
      ((this.languageRegex = /^(>>\w+<<)\s*/g),
        (this.supported_language_codes = this.model.vocab.filter((Q) =>
          this.languageRegex.test(Q)
        )),
        console.warn(
          'WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.'
        ));
    }
    _encode_text(X) {
      if (X === null) return null;
      let [Y, ...Q] = X.trim().split(this.languageRegex);
      if (Q.length === 0) return super._encode_text(Y);
      else if (Q.length === 2) {
        let [G, J] = Q;
        if (!this.supported_language_codes.includes(G))
          console.warn(
            `Unsupported language code "${G}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`
          );
        return S5([G], super._encode_text(J));
      }
    }
  };
  UV = class UV extends W1 {};
  TW = class TW extends W1 {
    _default_chat_template =
      "{% for message in messages %}{% if message['role'] == 'user' %}{{ ' ' }}{% endif %}{{ message['content'] }}{% if not loop.last %}{{ '  ' }}{% endif %}{% endfor %}{{ eos_token }}";
  };
  LV = class LV extends TW {};
  BV = class BV extends W1 {};
  KV = class KV extends W1 {};
  VV = class VV extends W1 {
    constructor(X, Y) {
      super(X, Y);
      this.decoder = new PS({});
    }
  };
  FV = class FV extends W1 {};
  j5 = class j5 {
    static TOKENIZER_CLASS_MAPPING = {
      T5Tokenizer: uK,
      DistilBertTokenizer: fK,
      CamembertTokenizer: xK,
      DebertaTokenizer: bK,
      DebertaV2Tokenizer: vK,
      BertTokenizer: IK,
      HerbertTokenizer: kK,
      ConvBertTokenizer: yK,
      RoFormerTokenizer: _K,
      XLMTokenizer: hK,
      ElectraTokenizer: gK,
      MobileBertTokenizer: SK,
      SqueezeBertTokenizer: TK,
      AlbertTokenizer: PK,
      GPT2Tokenizer: IW,
      BartTokenizer: lK,
      MBartTokenizer: PW,
      MBart50Tokenizer: mK,
      RobertaTokenizer: cK,
      WhisperTokenizer: GV,
      CodeGenTokenizer: JV,
      CLIPTokenizer: WV,
      SiglipTokenizer: HV,
      MarianTokenizer: $V,
      BloomTokenizer: dK,
      NllbTokenizer: YV,
      M2M100Tokenizer: QV,
      LlamaTokenizer: SW,
      CodeLlamaTokenizer: pK,
      XLMRobertaTokenizer: iK,
      MPNetTokenizer: nK,
      FalconTokenizer: aK,
      GPTNeoXTokenizer: rK,
      EsmTokenizer: oK,
      Wav2Vec2CTCTokenizer: UV,
      BlenderbotTokenizer: TW,
      BlenderbotSmallTokenizer: LV,
      SpeechT5Tokenizer: BV,
      NougatTokenizer: KV,
      VitsTokenizer: VV,
      Qwen2Tokenizer: sK,
      GemmaTokenizer: tK,
      Grok1Tokenizer: eK,
      CohereTokenizer: FV,
      PreTrainedTokenizer: W1,
    };
    static async from_pretrained(
      X,
      {
        quantized: Y = !0,
        progress_callback: Q = null,
        config: G = null,
        cache_dir: J = null,
        local_files_only: U = !1,
        revision: $ = "main",
        legacy: B = null,
      } = {}
    ) {
      let [K, V] = await nP(X, {
          quantized: Y,
          progress_callback: Q,
          config: G,
          cache_dir: J,
          local_files_only: U,
          revision: $,
          legacy: B,
        }),
        W = V.tokenizer_class?.replace(/Fast$/, "") ?? "PreTrainedTokenizer",
        L = this.TOKENIZER_CLASS_MAPPING[W];
      if (!L)
        (console.warn(
          `Unknown tokenizer class "${W}", attempting to construct from base class.`
        ),
          (L = W1));
      return new L(K, V);
    }
  };
});
async function R50(X, Y) {
  return await g6(X, "config.json", !0, Y);
}
class MV {
  constructor(X) {
    ((this.model_type = null),
      (this.is_encoder_decoder = !1),
      Object.assign(this, X));
  }
  static async from_pretrained(
    X,
    {
      progress_callback: Y = null,
      config: Q = null,
      cache_dir: G = null,
      local_files_only: J = !1,
      revision: U = "main",
    } = {}
  ) {
    let $ =
      Q ??
      (await R50(X, {
        progress_callback: Y,
        config: Q,
        cache_dir: G,
        local_files_only: J,
        revision: U,
      }));
    return new this($);
  }
}
class z4 {
  static async from_pretrained(...X) {
    return MV.from_pretrained(...X);
  }
}
var AV = U8(() => {
  t9();
});
var bW,
  o8,
  qV,
  RV,
  DV,
  zV,
  EV,
  OV,
  ZV,
  jV,
  wV,
  CV,
  fS = class {
    constructor(X = {}) {
      ((this.max_length = X.max_length ?? 20),
        (this.max_new_tokens = X.max_new_tokens ?? null),
        (this.min_length = X.min_length ?? 0),
        (this.min_new_tokens = X.min_new_tokens ?? null),
        (this.early_stopping = X.early_stopping ?? !1),
        (this.max_time = X.max_time ?? null),
        (this.do_sample = X.do_sample ?? !1),
        (this.num_beams = X.num_beams ?? 1),
        (this.num_beam_groups = X.num_beam_groups ?? 1),
        (this.penalty_alpha = X.penalty_alpha ?? null),
        (this.use_cache = X.use_cache ?? !0),
        (this.temperature = X.temperature ?? 1),
        (this.top_k = X.top_k ?? 50),
        (this.top_p = X.top_p ?? 1),
        (this.typical_p = X.typical_p ?? 1),
        (this.epsilon_cutoff = X.epsilon_cutoff ?? 0),
        (this.eta_cutoff = X.eta_cutoff ?? 0),
        (this.diversity_penalty = X.diversity_penalty ?? 0),
        (this.repetition_penalty = X.repetition_penalty ?? 1),
        (this.encoder_repetition_penalty = X.encoder_repetition_penalty ?? 1),
        (this.length_penalty = X.length_penalty ?? 1),
        (this.no_repeat_ngram_size = X.no_repeat_ngram_size ?? 0),
        (this.bad_words_ids = X.bad_words_ids ?? null),
        (this.force_words_ids = X.force_words_ids ?? null),
        (this.renormalize_logits = X.renormalize_logits ?? !1),
        (this.constraints = X.constraints ?? null),
        (this.forced_bos_token_id = X.forced_bos_token_id ?? null),
        (this.forced_eos_token_id = X.forced_eos_token_id ?? null),
        (this.remove_invalid_values = X.remove_invalid_values ?? !1),
        (this.exponential_decay_length_penalty =
          X.exponential_decay_length_penalty ?? null),
        (this.suppress_tokens = X.suppress_tokens ?? null),
        (this.begin_suppress_tokens = X.begin_suppress_tokens ?? null),
        (this.forced_decoder_ids = X.forced_decoder_ids ?? null),
        (this.num_return_sequences = X.num_return_sequences ?? 1),
        (this.output_attentions = X.output_attentions ?? !1),
        (this.output_hidden_states = X.output_hidden_states ?? !1),
        (this.output_scores = X.output_scores ?? !1),
        (this.return_dict_in_generate = X.return_dict_in_generate ?? !1),
        (this.pad_token_id = X.pad_token_id ?? null),
        (this.bos_token_id = X.bos_token_id ?? null),
        (this.eos_token_id = X.eos_token_id ?? null),
        (this.encoder_no_repeat_ngram_size =
          X.encoder_no_repeat_ngram_size ?? 0),
        (this.decoder_start_token_id = X.decoder_start_token_id ?? null),
        (this.generation_kwargs = X.generation_kwargs ?? {}));
    }
  },
  x7,
  xS,
  hS,
  gS;
var uS = U8(() => {
  W9();
  bW = class bW extends f5 {
    constructor() {
      super();
      this.processors = [];
    }
    push(X) {
      this.processors.push(X);
    }
    extend(X) {
      this.processors.push(...X);
    }
    _call(X, Y) {
      for (let Q of Y) this.processors.forEach((G) => G(X, Q));
    }
    [Symbol.iterator]() {
      return this.processors.values();
    }
  };
  o8 = class o8 extends f5 {
    _call(X, Y) {
      throw Error("`_call` should be implemented in a subclass");
    }
  };
  qV = class qV extends o8 {
    constructor(X) {
      super();
      this.force_token_map = Object.fromEntries(X ?? []);
    }
    _call(X, Y) {
      let Q = this.force_token_map[X.length];
      if (NP(Q)) (Y.data.fill(-1 / 0), (Y.data[Q] = 0));
      return Y;
    }
  };
  RV = class RV extends o8 {
    constructor(X) {
      super();
      this.bos_token_id = X;
    }
    _call(X, Y) {
      if (X.length === 1)
        (Y.data.fill(-1 / 0), (Y.data[this.bos_token_id] = 0));
      return Y;
    }
  };
  DV = class DV extends o8 {
    constructor(X, Y) {
      super();
      ((this.max_length = X), (this.forced_eos_token_id = Y));
    }
    _call(X, Y) {}
  };
  zV = class zV extends o8 {
    constructor(X, Y) {
      super();
      ((this.begin_suppress_tokens = X), (this.begin_index = Y));
    }
    _call(X, Y) {
      if (X.length === this.begin_index)
        for (let Q of this.begin_suppress_tokens) Y.data[Q] = -1 / 0;
      return Y;
    }
  };
  EV = class EV extends o8 {
    constructor(X) {
      super();
      if (
        ((this.eos_token_id = X.eos_token_id),
        (this.no_timestamps_token_id = X.no_timestamps_token_id),
        (this.timestamp_begin = this.no_timestamps_token_id + 1),
        (this.begin_index = (X.forced_decoder_ids || []).length + 2),
        X.forced_decoder_ids.slice(-1)[0][1] === this.no_timestamps_token_id)
      )
        this.begin_index -= 1;
      this.max_initial_timestamp_index = X.max_initial_timestamp_index;
    }
    _call(X, Y) {
      let Q = Y.data;
      if (
        ((Q[this.no_timestamps_token_id] = -1 / 0),
        X.length === this.begin_index - 1)
      )
        return (Q.fill(-1 / 0), (Q[this.timestamp_begin] = 0), Y);
      let G = X.slice(this.begin_index),
        J = G.length >= 1 && G[G.length - 1] >= this.timestamp_begin,
        U = G.length < 2 || G[G.length - 2] >= this.timestamp_begin;
      if (J)
        if (U) Q.subarray(this.timestamp_begin).fill(-1 / 0);
        else Q.subarray(0, this.eos_token_id).fill(-1 / 0);
      if (
        X.length === this.begin_index &&
        this.max_initial_timestamp_index !== null
      ) {
        let V = this.timestamp_begin + this.max_initial_timestamp_index;
        Q.subarray(V + 1).fill(-1 / 0);
      }
      let $ = $K(Q),
        B = Math.log(
          $.subarray(this.timestamp_begin)
            .map(Math.exp)
            .reduce((V, W) => V + W)
        ),
        K = x5($.subarray(0, this.timestamp_begin))[0];
      if (B > K) Q.subarray(0, this.timestamp_begin).fill(-1 / 0);
      return Y;
    }
  };
  OV = class OV extends o8 {
    constructor(X) {
      super();
      this.no_repeat_ngram_size = X;
    }
    getNgrams(X) {
      let Y = X.length,
        Q = [];
      for (let J = 0; J < Y + 1 - this.no_repeat_ngram_size; ++J) {
        let U = [];
        for (let $ = 0; $ < this.no_repeat_ngram_size; ++$) U.push(X[J + $]);
        Q.push(U);
      }
      let G = new Map();
      for (let J of Q) {
        let U = J.slice(0, J.length - 1),
          $ = JSON.stringify(U),
          B = G.get($) ?? [];
        (B.push(J[J.length - 1]), G.set($, B));
      }
      return G;
    }
    getGeneratedNgrams(X, Y) {
      let Q = Y.slice(Y.length + 1 - this.no_repeat_ngram_size, Y.length);
      return X.get(JSON.stringify(Q)) ?? [];
    }
    calcBannedNgramTokens(X) {
      let Y = [];
      if (X.length + 1 < this.no_repeat_ngram_size) return Y;
      else {
        let Q = this.getNgrams(X);
        return this.getGeneratedNgrams(Q, X);
      }
    }
    _call(X, Y) {
      let Q = this.calcBannedNgramTokens(X);
      for (let G of Q) Y.data[G] = -1 / 0;
      return Y;
    }
  };
  ZV = class ZV extends o8 {
    constructor(X) {
      super();
      this.penalty = X;
    }
    _call(X, Y) {
      for (let Q of X)
        if (Y.data[Q] < 0) Y.data[Q] *= this.penalty;
        else Y.data[Q] /= this.penalty;
      return Y;
    }
  };
  jV = class jV extends o8 {
    constructor(X, Y) {
      super();
      ((this.min_length = X), (this.eos_token_id = Array.isArray(Y) ? Y : [Y]));
    }
    _call(X, Y) {
      if (X.length < this.min_length)
        for (let Q of this.eos_token_id) Y.data[Q] = -1 / 0;
      return Y;
    }
  };
  wV = class wV extends o8 {
    constructor(X, Y, Q) {
      super();
      ((this.prompt_length_to_skip = X),
        (this.min_new_tokens = Y),
        (this.eos_token_id = Array.isArray(Q) ? Q : [Q]));
    }
    _call(X, Y) {
      if (X.length - this.prompt_length_to_skip < this.min_new_tokens)
        for (let G of this.eos_token_id) Y.data[G] = -1 / 0;
      return Y;
    }
  };
  CV = class CV extends o8 {
    constructor(X, Y) {
      super();
      ((this.bad_words_ids = X),
        (this.eos_token_id = Array.isArray(Y) ? Y : [Y]));
    }
    _call(X, Y) {
      for (let Q of this.bad_words_ids) {
        let G = !0;
        for (let J = 1; J <= Q.length - 1 && Q.length < X.length; ++J)
          if (Q.at(-J - 1) !== X.at(-J)) {
            G = !1;
            break;
          }
        if (G) Y.data[Q.at(-1)] = -1 / 0;
      }
      return Y;
    }
  };
  x7 = class x7 extends f5 {
    constructor(X) {
      super();
      this.generation_config = X;
    }
    _call(X, Y = -1) {
      return this.sample(X, Y);
    }
    sample(X, Y) {
      throw Error("sample should be implemented in subclasses.");
    }
    getLogits(X, Y) {
      let Q = X.dims.at(-1),
        G = X.data;
      if (Y === -1) G = G.slice(-Q);
      else {
        let J = Y * Q;
        G = G.slice(J, J + Q);
      }
      if (this.generation_config.temperature > 0)
        G = G.map((J) => J / this.generation_config.temperature);
      return G;
    }
    randomSelect(X) {
      let Y = X.reduce((G, J) => G + J, 0),
        Q = Math.random() * Y;
      for (let G = 0; G < X.length; ++G) if (((Q -= X[G]), Q <= 0)) return G;
      return 0;
    }
    static getSampler(X) {
      if (X.do_sample) return new hS(X);
      else if (X.num_beams > 1) return new gS(X);
      else {
        if (X.num_return_sequences > 1)
          throw Error(
            `num_return_sequences has to be 1 when doing greedy search, but is ${X.num_return_sequences}.`
          );
        return new xS(X);
      }
    }
  };
  xS = class xS extends x7 {
    sample(X, Y = -1) {
      let Q = this.getLogits(X, Y);
      return [[x5(Q)[1], 0]];
    }
  };
  hS = class hS extends x7 {
    sample(X, Y = -1) {
      let Q = X.dims.at(-1);
      if (this.generation_config.top_k > 0)
        Q = Math.min(this.generation_config.top_k, Q);
      let G = this.getLogits(X, Y),
        J = q4(G, Q),
        U = Z5(J.map(($) => $[1]));
      return Array.from({ length: this.generation_config.num_beams }, () => {
        let $ = this.randomSelect(U);
        return [J[$][0], Math.log(U[$])];
      });
    }
  };
  gS = class gS extends x7 {
    sample(X, Y = -1) {
      let Q = X.dims.at(-1);
      if (this.generation_config.top_k > 0)
        Q = Math.min(this.generation_config.top_k, Q);
      let G = this.getLogits(X, Y),
        J = q4(G, Q),
        U = Z5(J.map(($) => $[1]));
      return Array.from(
        { length: this.generation_config.num_beams },
        ($, B) => {
          return [J[B][0], Math.log(U[B])];
        }
      );
    }
  };
});
async function H9(X, Y, Q) {
  let G = `onnx/${Y}${Q.quantized ? "_quantized" : ""}.onnx`,
    J = await GK(X, G, !0, Q);
  try {
    return await IV.create(J, { executionProviders: PQ });
  } catch (U) {
    if (PQ.length === 1 && PQ[0] === "wasm") throw U;
    return (
      console.warn(U),
      console.warn(
        "Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "
      ),
      await IV.create(J, { executionProviders: ["wasm"] })
    );
  }
}
function E50(X, Y) {
  let Q = Object.create(null),
    G = [];
  for (let $ of X.inputNames) {
    let B = Y[$];
    if (!(B instanceof I0)) {
      G.push($);
      continue;
    }
    Q[$] = z50.wasm.proxy ? B.clone() : B;
  }
  if (G.length > 0)
    throw Error(
      `An error occurred during model execution: "Missing the following inputs: ${G.join(", ")}.`
    );
  let J = Object.keys(Y).length,
    U = X.inputNames.length;
  if (J > U) {
    let $ = Object.keys(Y).filter((B) => !X.inputNames.includes(B));
    console.warn(
      `WARNING: Too many inputs were provided (${J} > ${U}). The following inputs will be ignored: "${$.join(", ")}".`
    );
  }
  return Q;
}
async function h7(X, Y) {
  let Q = E50(X, Y);
  try {
    let G = await X.run(Q);
    return ((G = mS(G)), G);
  } catch (G) {
    throw (
      console.error(`An error occurred during model execution: "${G}".`),
      console.error("Inputs given to model:", Q),
      G
    );
  }
}
function mS(X) {
  for (let Y in X)
    if (X[Y] instanceof D50) X[Y] = new I0(X[Y]);
    else if (typeof X[Y] === "object") mS(X[Y]);
  return X;
}
function O50(X) {
  if (X instanceof I0) return X;
  if (X.length === 0) throw Error("items must be non-empty");
  if (Array.isArray(X[0])) {
    if (X.some((Y) => Y.length !== X[0].length))
      throw Error(
        "Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length."
      );
    return new I0("int64", BigInt64Array.from(X.flat().map((Y) => BigInt(Y))), [
      X.length,
      X[0].length,
    ]);
  } else
    return new I0("int64", BigInt64Array.from(X.map((Y) => BigInt(Y))), [
      1,
      X.length,
    ]);
}
function PV(X, Y) {
  let Q = X.config.pad_token_id ?? null,
    G = X.config.eos_token_id ?? null;
  if (KW(G)) G = [G];
  let J = Y.indexOf(Q) !== -1,
    U = G === null || !G.includes(Q);
  if (J && U) {
    let $ = BigInt64Array.from(Y.data.map((B) => B != Q));
    return new I0("int64", $, Y.dims);
  } else return NK(Y);
}
function cS(X, Y, Q) {
  if (!X.inputNames.includes("position_ids")) return;
  let G = new BigInt64Array(Y.attention_mask.data.length);
  for (let J = 0; J < Y.attention_mask.dims[0]; ++J) {
    let U = J * Y.attention_mask.dims[1],
      $ = BigInt(0);
    for (let B = 0; B < Y.attention_mask.dims[1]; ++B) {
      let K = U + B;
      if (Y.attention_mask.data[K] === 0n) G[K] = BigInt(1);
      else ((G[K] = $), ($ += Y.attention_mask.data[K]));
    }
  }
  if (((Y.position_ids = new I0("int64", G, Y.attention_mask.dims)), Q))
    Y.position_ids = Y.position_ids.slice(null, -1).unsqueeze_(-1);
}
function SV(X) {
  return new I0("bool", [X], [1]);
}
async function Z50(X, Y) {
  let { encoder_outputs: Q, past_key_values: G } = Y;
  if (!Q) Q = (await fQ(X, Y)).last_hidden_state;
  let J = { input_ids: Y.decoder_input_ids, encoder_hidden_states: Q },
    U = !!G;
  if (X.decoder_merged_session.inputNames.includes("use_cache_branch"))
    J.use_cache_branch = SV(U);
  if (X.decoder_merged_session.inputNames.includes("encoder_attention_mask"))
    J.encoder_attention_mask = Y.attention_mask;
  (cS(X.decoder_merged_session, J, U), X.addPastKeyValues(J, G));
  let $ = await h7(X.decoder_merged_session, J),
    B = $.logits;
  G = X.getPastKeyValues($, G);
  let K = X.getAttentions($);
  return new nA({ logits: B, past_key_values: G, encoder_outputs: Q, ...K });
}
function j50(X, Y, Q, G) {
  let J = [],
    U = 0,
    $ = X.requires_attention_mask ?? !0,
    B =
      Q.decoder_input_ids ??
      Q.decoder_start_token_id ??
      Q.bos_token_id ??
      Q.eos_token_id;
  if (B instanceof I0) B = B.tolist().flat();
  else if (!Array.isArray(B)) B = [B];
  for (let K of Y) {
    K.dims = [1, ...K.dims];
    let V = {
      inputs: K,
      encoder_outputs: null,
      prev_model_outputs: null,
      output_token_ids: B,
      done: !1,
      score: 0,
      id: U++,
    };
    if ($) V.attention_mask = PV(X, K);
    J.push(V);
  }
  return J;
}
async function w50(X, Y) {
  let Q = X.main_input_name,
    G = Y.output_token_ids;
  if (Y.prev_model_outputs) G = G.slice(-1);
  let J = {
    [Q]: Y.inputs,
    decoder_input_ids: O50(G),
    encoder_outputs: Y.encoder_outputs,
    past_key_values: Y.prev_model_outputs?.past_key_values,
  };
  if (Y.attention_mask) J.attention_mask = Y.attention_mask;
  let U = await X.forward(J);
  return (
    (Y.prev_model_outputs = U),
    (Y.encoder_outputs = U.encoder_outputs),
    U
  );
}
function C50(X, Y) {
  X.output_token_ids = [...X.output_token_ids, Y];
}
async function fQ(X, Y) {
  let Q = Object.create(null);
  for (let G of X.session.inputNames) Q[G] = Y[G];
  if (X.session.inputNames.includes("token_type_ids") && !Q.token_type_ids)
    Q.token_type_ids = new I0(
      "int64",
      new BigInt64Array(Q.input_ids.data.length),
      Q.input_ids.dims
    );
  return await h7(X.session, Q);
}
async function I50(X, Y) {
  let { input_ids: Q, past_key_values: G, attention_mask: J } = Y,
    U = { input_ids: Q, attention_mask: J ?? PV(X, Q) },
    $ = !!G;
  if (X.session.inputNames.includes("use_cache_branch"))
    U.use_cache_branch = SV($);
  (cS(X.session, U, $), X.addPastKeyValues(U, G));
  let B = await h7(X.session, U),
    K = B.logits;
  return ((G = X.getPastKeyValues(B, G)), { logits: K, past_key_values: G });
}
function P50(X, Y, Q, G, J) {
  let U = [],
    $ = 0;
  for (let B of Y) {
    let K = B.tolist().map(Number);
    B.dims = [1, ...B.dims];
    let V;
    if (J) ((V = J[$]), (V.dims = [1, ...V.dims]));
    else V = PV(X, B);
    let W = {
      input: B,
      model_input_ids: B,
      attention_mask: V,
      prev_model_outputs: null,
      output_token_ids: K,
      num_output_tokens: G,
      done: !1,
      score: 0,
      id: $++,
    };
    U.push(W);
  }
  return U;
}
async function S50(X, Y) {
  let Q = new BigInt64Array(Y.output_token_ids.length).fill(1n),
    G = {
      input_ids: Y.model_input_ids,
      attention_mask: new I0("int64", Q, [1, Q.length]),
      past_key_values: Y.prev_model_outputs?.past_key_values,
    },
    J = await X.forward(G);
  return ((Y.prev_model_outputs = J), J);
}
function T50(X, Y) {
  ((X.output_token_ids = [...X.output_token_ids, Y]),
    (X.model_input_ids = new I0("int64", [BigInt(Y)], [1, 1])));
}
class a5 {}
class i1 {
  static MODEL_CLASS_MAPPINGS = null;
  static BASE_IF_FAIL = !1;
  static async from_pretrained(
    X,
    {
      quantized: Y = !0,
      progress_callback: Q = null,
      config: G = null,
      cache_dir: J = null,
      local_files_only: U = !1,
      revision: $ = "main",
      model_file_name: B = null,
    } = {}
  ) {
    let K = {
      quantized: Y,
      progress_callback: Q,
      config: G,
      cache_dir: J,
      local_files_only: U,
      revision: $,
      model_file_name: B,
    };
    if (((G = await z4.from_pretrained(X, K)), !K.config)) K.config = G;
    if (!this.MODEL_CLASS_MAPPINGS)
      throw Error(
        "`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: " +
          this.name
      );
    for (let V of this.MODEL_CLASS_MAPPINGS) {
      let W = V.get(G.model_type);
      if (!W) continue;
      return await W[1].from_pretrained(X, K);
    }
    if (this.BASE_IF_FAIL)
      return (
        console.warn(
          `Unknown model class "${G.model_type}", attempting to construct from base class.`
        ),
        await j0.from_pretrained(X, K)
      );
    else throw Error(`Unsupported model type: ${G.model_type}`);
  }
}
var IV,
  D50,
  z50,
  K1,
  vW,
  lS,
  _Q,
  j0,
  dS,
  JX,
  TV,
  bV,
  vV,
  kV,
  yV,
  _V,
  fV,
  WX,
  xV,
  hV,
  gV,
  uV,
  lV,
  HX,
  mV,
  cV,
  dV,
  pV,
  iV,
  $X,
  nV,
  aV,
  rV,
  oV,
  sV,
  UX,
  tV,
  eV,
  XF,
  YF,
  QF,
  LX,
  GF,
  JF,
  WF,
  HF,
  $F,
  BX,
  UF,
  LF,
  BF,
  KF,
  VF,
  KX,
  FF,
  NF,
  MF,
  AF,
  qF,
  g7,
  RF,
  DF,
  zF,
  EF,
  u7,
  OF,
  ZF,
  jF,
  wF,
  VX,
  CF,
  IF,
  PF,
  SF,
  TF,
  l7,
  bF,
  vF,
  kF,
  yF,
  m7,
  _F,
  fF,
  xF,
  hF,
  kW,
  gF,
  uF,
  yW,
  lF,
  mF,
  _W,
  cF,
  dF,
  xQ,
  pF,
  iF,
  nF,
  c7,
  aF,
  rF,
  oF,
  sF,
  fW,
  tF,
  eF,
  xW,
  XN,
  YN,
  FX,
  QN,
  GN,
  JN,
  WN,
  HN,
  NX,
  $N,
  UN,
  LN,
  BN,
  KN,
  MX,
  VN,
  FN,
  NN,
  MN,
  AN,
  hW,
  qN,
  RN,
  gW,
  DN,
  zN,
  uW,
  d7,
  EN,
  ON,
  ZN,
  lW,
  jN,
  wN,
  CN,
  IN,
  PN,
  mW,
  SN,
  TN,
  cW,
  bN,
  vN,
  dW,
  kN,
  yN,
  pW,
  _N,
  fN,
  iW,
  xN,
  hN,
  nW,
  gN,
  uN,
  aW,
  lN,
  mN,
  rW,
  cN,
  dN,
  oW,
  pN,
  iN,
  sW,
  nN,
  aN,
  tW,
  rN,
  oN,
  eW,
  sN,
  tN,
  XH,
  eN,
  XM,
  YH,
  YM,
  QM,
  QH,
  GM,
  JM,
  WM,
  HM,
  GH,
  $M,
  UM,
  JH,
  LM,
  BM,
  WH,
  KM,
  VM,
  HH,
  FM,
  NM,
  $H,
  MM,
  AM,
  hQ,
  qM,
  RM,
  DM,
  UH,
  zM,
  LH,
  EM,
  OM,
  ZM,
  BH,
  jM,
  wM,
  KH,
  CM,
  IM,
  VH,
  PM,
  SM,
  FH,
  TM,
  bM,
  NH,
  vM,
  kM,
  yM,
  _M,
  MH,
  fM,
  xM,
  hM,
  gM,
  AH,
  uM,
  lM,
  qH,
  mM,
  cM,
  RH,
  dM,
  pM,
  DH,
  iM,
  nM,
  aM,
  rM,
  oM,
  sM,
  zH,
  tM,
  eM,
  EH,
  XA,
  YA,
  E4,
  QA,
  GA,
  JA,
  WA,
  gQ,
  HA,
  $A,
  UA,
  p7,
  LA,
  BA,
  KA,
  VA,
  uQ,
  FA,
  NA,
  MA,
  pS,
  AA,
  qA,
  RA,
  AX,
  DA,
  zA,
  EA,
  OA,
  ZA,
  lQ,
  iS,
  jA,
  wA,
  CA,
  IA,
  PA,
  OH,
  SA,
  TA,
  ZH,
  bA,
  vA,
  jH,
  kA,
  yA,
  mQ,
  _A,
  fA,
  xA,
  hA,
  wH,
  cQ,
  nS,
  gA,
  uA,
  CH,
  aS,
  lA,
  IH,
  mA,
  cA,
  rS,
  oS,
  b50,
  dA,
  sS,
  tS,
  eS,
  XT,
  pA,
  PH,
  YT,
  QT,
  iA,
  v50,
  GT,
  JT,
  WT,
  HT,
  $T,
  UT,
  LT,
  BT,
  KT,
  VT,
  FT,
  NT,
  MT,
  AT,
  qT,
  k50,
  $9,
  dQ,
  SH,
  i7,
  TH,
  bH,
  vH,
  kH,
  yH,
  _H,
  fH,
  xH,
  hH,
  gH,
  uH,
  lH,
  RT,
  mH,
  cH,
  DT,
  zT,
  dH,
  ET,
  pH,
  iH,
  nH,
  nA,
  Z1,
  aA,
  h5,
  g5,
  r5,
  U9,
  OT,
  rA,
  oA;
var sA = U8(() => {
  AV();
  t9();
  uS();
  W9();
  FW();
  tA();
  (({ InferenceSession: IV, Tensor: D50, env: z50 } = A4),
    (K1 = {
      EncoderOnly: 0,
      EncoderDecoder: 1,
      Seq2Seq: 2,
      Vision2Seq: 3,
      DecoderOnly: 4,
      MaskGeneration: 5,
    }),
    (vW = new Map()),
    (lS = new Map()),
    (_Q = new Map()));
  j0 = class j0 extends f5 {
    main_input_name = "input_ids";
    constructor(X, Y) {
      super();
      ((this.config = X), (this.session = Y));
      let Q = _Q.get(this.constructor),
        G = vW.get(Q);
      if (
        ((this.can_generate = !1),
        (this._runBeam = null),
        (this._getStartBeams = null),
        (this._updateBeam = null),
        (this._forward = null),
        G === K1.DecoderOnly)
      )
        ((this.can_generate = !0),
          (this._runBeam = S50),
          (this._getStartBeams = P50),
          (this._updateBeam = T50),
          (this._forward = I50));
      else if (G === K1.Seq2Seq || G === K1.Vision2Seq)
        ((this.can_generate = !0),
          (this._runBeam = w50),
          (this._getStartBeams = j50),
          (this._updateBeam = C50),
          (this._forward = Z50));
      else if (G === K1.EncoderDecoder) this._forward = fQ;
      else this._forward = fQ;
    }
    async dispose() {
      let X = [];
      for (let Y of Object.keys(this)) {
        let Q = this[Y];
        if (Q instanceof IV) X.push(Q.handler.dispose());
      }
      return await Promise.all(X);
    }
    static async from_pretrained(
      X,
      {
        quantized: Y = !0,
        progress_callback: Q = null,
        config: G = null,
        cache_dir: J = null,
        local_files_only: U = !1,
        revision: $ = "main",
        model_file_name: B = null,
      } = {}
    ) {
      let K = {
          quantized: Y,
          progress_callback: Q,
          config: G,
          cache_dir: J,
          local_files_only: U,
          revision: $,
          model_file_name: B,
        },
        V = _Q.get(this),
        W = vW.get(V),
        L;
      if (W === K1.DecoderOnly)
        L = await Promise.all([
          z4.from_pretrained(X, K),
          H9(X, K.model_file_name ?? "decoder_model_merged", K),
          g6(X, "generation_config.json", !1, K),
        ]);
      else if (W === K1.Seq2Seq || W === K1.Vision2Seq)
        L = await Promise.all([
          z4.from_pretrained(X, K),
          H9(X, "encoder_model", K),
          H9(X, "decoder_model_merged", K),
          g6(X, "generation_config.json", !1, K),
        ]);
      else if (W === K1.MaskGeneration)
        L = await Promise.all([
          z4.from_pretrained(X, K),
          H9(X, "vision_encoder", K),
          H9(X, "prompt_encoder_mask_decoder", K),
        ]);
      else if (W === K1.EncoderDecoder)
        L = await Promise.all([
          z4.from_pretrained(X, K),
          H9(X, "encoder_model", K),
          H9(X, "decoder_model_merged", K),
        ]);
      else {
        if (W !== K1.EncoderOnly)
          console.warn(
            `Model type for '${V ?? G?.model_type}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`
          );
        L = await Promise.all([
          z4.from_pretrained(X, K),
          H9(X, K.model_file_name ?? "model", K),
        ]);
      }
      return new this(...L);
    }
    async _call(X) {
      return await this.forward(X);
    }
    async forward(X) {
      return await this._forward(this, X);
    }
    _get_logits_processor(X, Y, Q = null) {
      let G = new bW();
      if (X.repetition_penalty !== null && X.repetition_penalty !== 1)
        G.push(new ZV(X.repetition_penalty));
      if (X.no_repeat_ngram_size !== null && X.no_repeat_ngram_size > 0)
        G.push(new OV(X.no_repeat_ngram_size));
      if (X.bad_words_ids !== null)
        G.push(new CV(X.bad_words_ids, X.eos_token_id));
      if (X.min_length !== null && X.eos_token_id !== null && X.min_length > 0)
        G.push(new jV(X.min_length, X.eos_token_id));
      if (
        X.min_new_tokens !== null &&
        X.eos_token_id !== null &&
        X.min_new_tokens > 0
      )
        G.push(new wV(Y, X.min_new_tokens, X.eos_token_id));
      if (X.forced_bos_token_id !== null) G.push(new RV(X.forced_bos_token_id));
      if (X.forced_eos_token_id !== null)
        G.push(new DV(X.max_length, X.forced_eos_token_id));
      if (X.begin_suppress_tokens !== null) {
        let J = Y > 1 || X.forced_bos_token_id === null ? Y : Y + 1;
        if (X.forced_decoder_ids !== null)
          J += X.forced_decoder_ids[X.forced_decoder_ids.length - 1][0];
        G.push(new zV(X.begin_suppress_tokens, J));
      }
      if (X.forced_decoder_ids !== null) G.push(new qV(X.forced_decoder_ids));
      if (Q !== null) G.extend(Q);
      return G;
    }
    _get_generation_config(X) {
      let Y = new fS(this.config);
      if ("generation_config" in this) Object.assign(Y, this.generation_config);
      if (X !== null) Object.assign(Y, X);
      return Y;
    }
    async generate(
      X,
      Y = null,
      Q = null,
      { inputs_attention_mask: G = null } = {}
    ) {
      if (!this.can_generate) {
        let q = `The current model class (${_Q.get(this.constructor)}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`,
          M = this.config.model_type,
          A = PH.get(M) ?? pA.get(M) ?? dA.get(M) ?? iA.get(M);
        if (A) q += ` Please use the following class instead: '${A[0]}'`;
        throw Error(q);
      }
      if (!(X instanceof I0) && !FP(X) && !Array.isArray(X))
        throw Error(
          `\`inputs\` must be a Tensor, TypedArray, or Array, but is "${X.constructor.name}".`
        );
      let J;
      if (this.config.is_encoder_decoder) J = 0;
      else if (((J = X instanceof I0 ? X.dims.at(-1) : X.length), J === 0))
        throw Error("Must supply a non-empty array of input token ids.");
      ((Y = this._get_generation_config(Y)),
        (Q = Q ?? new bW()),
        (Q = this._get_logits_processor(Y, J, Q)));
      let U = Y.eos_token_id;
      if (U !== null && !Array.isArray(U)) U = [U];
      let $ = 1,
        B = $ + (Y.max_new_tokens ?? 1 / 0),
        K =
          Number.isInteger(Y.max_length) && (Y.max_new_tokens ?? null) === null,
        V = x7.getSampler(Y),
        W = this.getStartBeams(X, Y, $, G);
      while (W.some((N) => !N.done) && $ < B) {
        let N = [];
        for (let q of W) {
          if (q.done) {
            N.push(q);
            continue;
          }
          if (K && q.output_token_ids.length >= Y.max_length) {
            ((q.done = !0), N.push(q));
            continue;
          }
          let M = await this.runBeam(q);
          if (Y.output_attentions) this.addAttentionsToBeam(q, M);
          if (Y.output_scores);
          let A = M.logits.slice(null, -1, null);
          Q(q.output_token_ids, A);
          let D = V(A);
          for (let [R, z] of D) {
            let E = { ...q };
            if ((this.updateBeam(E, R), (E.score += z), U && U.includes(R)))
              E.done = !0;
            N.push(E);
          }
        }
        if (
          (++$,
          (N = this.groupBeams(N).map((q) =>
            q.sort((M, A) => A.score - M.score).slice(0, Y.num_beams)
          )),
          (W = N.flat()),
          Y.callback_function)
        )
          Y.callback_function(W);
      }
      let L = this.groupBeams(W),
        H = (N) =>
          L.map((q) => {
            if (Y.num_return_sequences > 1)
              return q.slice(0, Y.num_return_sequences).map((M) => M[N]);
            else return [q[0][N]];
          }).flat(),
        F = H("output_token_ids");
      if (Y.return_dict_in_generate) {
        let N = H("decoder_attentions"),
          q = H("cross_attentions");
        return { sequences: F, decoder_attentions: N, cross_attentions: q };
      } else return F;
    }
    addAttentionsToBeam(X, Y) {
      if (this.config.is_encoder_decoder) {
        if (!Y.cross_attentions || Y.cross_attentions.length === 0)
          throw Error(
            "`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`."
          );
        if (!X.cross_attentions) X.cross_attentions = [];
        X.cross_attentions.push(Y.cross_attentions);
      }
      if (!Y.decoder_attentions || Y.decoder_attentions.length === 0)
        throw Error(
          "`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`."
        );
      if (!X.decoder_attentions) X.decoder_attentions = [];
      X.decoder_attentions.push(Y.decoder_attentions);
    }
    groupBeams(X) {
      let Y = Object.create(null);
      for (let Q of X)
        if (Y[Q.id] === void 0) Y[Q.id] = [Q];
        else Y[Q.id].push(Q);
      return Object.values(Y);
    }
    getPastKeyValues(X, Y) {
      let Q = Object.create(null);
      for (let G in X)
        if (G.startsWith("present")) {
          let J = G.replace("present", "past_key_values");
          if (Y && G.includes("encoder")) Q[J] = Y[J];
          else Q[J] = X[G];
        }
      return Q;
    }
    getAttentions(X) {
      let Y = Object.create(null);
      for (let Q of ["cross_attentions", "decoder_attentions"]) {
        let G = [];
        for (let J in X)
          if (J.startsWith(Q)) {
            let U = J.split(".").pop();
            G[U] = X[J];
          }
        Y[Q] = G;
      }
      return Y;
    }
    addPastKeyValues(X, Y) {
      if (Y) Object.assign(X, Y);
      else if (this.config.is_encoder_decoder && (this.add_encoder_pkv ?? !0)) {
        let G = [1, this.num_encoder_heads, 0, this.encoder_dim_kv],
          J = [1, this.num_decoder_heads, 0, this.decoder_dim_kv];
        for (let U = 0; U < this.num_decoder_layers; ++U)
          ((X[`past_key_values.${U}.encoder.key`] = new I0("float32", [], G)),
            (X[`past_key_values.${U}.encoder.value`] = new I0(
              "float32",
              [],
              G
            )),
            (X[`past_key_values.${U}.decoder.key`] = new I0("float32", [], J)),
            (X[`past_key_values.${U}.decoder.value`] = new I0(
              "float32",
              [],
              J
            )));
      } else if (this.config.model_type === "falcon") {
        let G = [1 * this.num_heads, 0, this.dim_kv];
        for (let J = 0; J < this.num_layers; ++J)
          ((X[`past_key_values.${J}.key`] = new I0("float32", [], G)),
            (X[`past_key_values.${J}.value`] = new I0("float32", [], G)));
      } else if (this.config.multi_query) {
        let G = [1 * this.num_heads, 0, 2 * this.dim_kv];
        for (let J = 0; J < this.num_layers; ++J)
          X[`past_key_values.${J}.key_value`] = new I0("float32", [], G);
      } else if (this.config.model_type === "bloom") {
        let G = [1 * this.num_heads, this.dim_kv, 0],
          J = [1 * this.num_heads, 0, this.dim_kv];
        for (let U = 0; U < this.num_layers; ++U)
          ((X[`past_key_values.${U}.key`] = new I0("float32", [], G)),
            (X[`past_key_values.${U}.value`] = new I0("float32", [], J)));
      } else {
        let G = [1, this.num_heads, 0, this.dim_kv];
        for (let J = 0; J < this.num_layers; ++J)
          ((X[`past_key_values.${J}.key`] = new I0("float32", [], G)),
            (X[`past_key_values.${J}.value`] = new I0("float32", [], G)));
      }
    }
    getStartBeams(X, Y, Q, G) {
      return this._getStartBeams(this, X, Y, Q, G);
    }
    async runBeam(X) {
      return await this._runBeam(this, X);
    }
    updateBeam(X, Y) {
      return this._updateBeam(X, Y);
    }
  };
  dS = class dS extends a5 {
    constructor({
      last_hidden_state: X,
      hidden_states: Y = null,
      attentions: Q = null,
    }) {
      super();
      ((this.last_hidden_state = X),
        (this.hidden_states = Y),
        (this.attentions = Q));
    }
  };
  JX = class JX extends j0 {};
  TV = class TV extends JX {};
  bV = class bV extends JX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  vV = class vV extends JX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  kV = class kV extends JX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  yV = class yV extends JX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  _V = class _V extends j0 {};
  fV = class fV extends _V {};
  WX = class WX extends j0 {};
  xV = class xV extends WX {};
  hV = class hV extends WX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  gV = class gV extends WX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  uV = class uV extends WX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  lV = class lV extends WX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  HX = class HX extends j0 {};
  mV = class mV extends HX {};
  cV = class cV extends HX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  dV = class dV extends HX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  pV = class pV extends HX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  iV = class iV extends HX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  $X = class $X extends j0 {};
  nV = class nV extends $X {};
  aV = class aV extends $X {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  rV = class rV extends $X {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  oV = class oV extends $X {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  sV = class sV extends $X {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  UX = class UX extends j0 {};
  tV = class tV extends UX {};
  eV = class eV extends UX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  XF = class XF extends UX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  YF = class YF extends UX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  QF = class QF extends UX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  LX = class LX extends j0 {};
  GF = class GF extends LX {};
  JF = class JF extends LX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  WF = class WF extends LX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  HF = class HF extends LX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  $F = class $F extends LX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  BX = class BX extends j0 {};
  UF = class UF extends BX {};
  LF = class LF extends BX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  BF = class BF extends BX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  KF = class KF extends BX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  VF = class VF extends BX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  KX = class KX extends j0 {};
  FF = class FF extends KX {};
  NF = class NF extends KX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  MF = class MF extends KX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  AF = class AF extends KX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  qF = class qF extends KX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  g7 = class g7 extends j0 {};
  RF = class RF extends g7 {};
  DF = class DF extends g7 {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  zF = class zF extends g7 {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  EF = class EF extends g7 {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  u7 = class u7 extends j0 {};
  OF = class OF extends u7 {};
  ZF = class ZF extends u7 {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  jF = class jF extends u7 {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  wF = class wF extends u7 {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  VX = class VX extends j0 {};
  CF = class CF extends VX {};
  IF = class IF extends VX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  PF = class PF extends VX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  SF = class SF extends VX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  TF = class TF extends VX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  l7 = class l7 extends j0 {};
  bF = class bF extends l7 {};
  vF = class vF extends l7 {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  kF = class kF extends l7 {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  yF = class yF extends l7 {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  m7 = class m7 extends j0 {};
  _F = class _F extends m7 {};
  fF = class fF extends m7 {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  xF = class xF extends m7 {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  hF = class hF extends m7 {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  kW = class kW extends j0 {};
  gF = class gF extends kW {};
  uF = class uF extends kW {
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.num_decoder_layers),
        (this.num_decoder_heads = this.config.num_heads),
        (this.decoder_dim_kv = this.config.d_kv),
        (this.num_encoder_layers = this.config.num_layers),
        (this.num_encoder_heads = this.config.num_heads),
        (this.encoder_dim_kv = this.config.d_kv));
    }
  };
  yW = class yW extends j0 {};
  lF = class lF extends yW {};
  mF = class mF extends yW {
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.num_decoder_layers),
        (this.num_decoder_heads = this.config.num_heads),
        (this.decoder_dim_kv = this.config.d_kv),
        (this.num_encoder_layers = this.config.num_layers),
        (this.num_encoder_heads = this.config.num_heads),
        (this.encoder_dim_kv = this.config.d_kv));
    }
  };
  _W = class _W extends j0 {};
  cF = class cF extends _W {};
  dF = class dF extends _W {
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.num_decoder_layers),
        (this.num_decoder_heads = this.config.num_heads),
        (this.decoder_dim_kv = this.config.d_kv),
        (this.num_encoder_layers = this.config.num_layers),
        (this.num_encoder_heads = this.config.num_heads),
        (this.encoder_dim_kv = this.config.d_kv));
    }
  };
  xQ = class xQ extends j0 {};
  pF = class pF extends xQ {};
  iF = class iF extends xQ {
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.decoder_layers),
        (this.num_decoder_heads = this.config.decoder_attention_heads),
        (this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads),
        (this.num_encoder_layers = this.config.encoder_layers),
        (this.num_encoder_heads = this.config.encoder_attention_heads),
        (this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads));
    }
  };
  nF = class nF extends xQ {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  c7 = class c7 extends j0 {};
  aF = class aF extends c7 {};
  rF = class rF extends c7 {
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.decoder_layers),
        (this.num_decoder_heads = this.config.decoder_attention_heads),
        (this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads),
        (this.num_encoder_layers = this.config.encoder_layers),
        (this.num_encoder_heads = this.config.encoder_attention_heads),
        (this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads));
    }
  };
  oF = class oF extends c7 {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  sF = class sF extends c7 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.num_decoder_layers = this.config.decoder_layers),
        (this.num_decoder_heads = this.config.decoder_attention_heads),
        (this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads),
        (this.num_encoder_layers = this.config.encoder_layers),
        (this.num_encoder_heads = this.config.encoder_attention_heads),
        (this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads));
    }
  };
  fW = class fW extends j0 {};
  tF = class tF extends fW {};
  eF = class eF extends fW {
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.decoder_layers),
        (this.num_decoder_heads = this.config.decoder_attention_heads),
        (this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads),
        (this.num_encoder_layers = this.config.encoder_layers),
        (this.num_encoder_heads = this.config.encoder_attention_heads),
        (this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads));
    }
  };
  xW = class xW extends j0 {};
  XN = class XN extends xW {};
  YN = class YN extends xW {
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.decoder_layers),
        (this.num_decoder_heads = this.config.decoder_attention_heads),
        (this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads),
        (this.num_encoder_layers = this.config.encoder_layers),
        (this.num_encoder_heads = this.config.encoder_attention_heads),
        (this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads));
    }
  };
  FX = class FX extends j0 {};
  QN = class QN extends FX {};
  GN = class GN extends FX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  JN = class JN extends FX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  WN = class WN extends FX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  HN = class HN extends FX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  NX = class NX extends j0 {};
  $N = class $N extends NX {};
  UN = class UN extends NX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  LN = class LN extends NX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  BN = class BN extends NX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  KN = class KN extends NX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  MX = class MX extends j0 {};
  VN = class VN extends MX {};
  FN = class FN extends MX {
    async _call(X) {
      return new g5(await super._call(X));
    }
  };
  NN = class NN extends MX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  MN = class MN extends MX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  AN = class AN extends MX {
    async _call(X) {
      return new r5(await super._call(X));
    }
  };
  hW = class hW extends j0 {};
  qN = class qN extends hW {};
  RN = class RN extends hW {};
  gW = class gW extends j0 {};
  DN = class DN extends gW {};
  zN = class zN extends gW {
    requires_attention_mask = !1;
    main_input_name = "input_features";
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.decoder_layers),
        (this.num_decoder_heads = this.config.decoder_attention_heads),
        (this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads),
        (this.num_encoder_layers = this.config.encoder_layers),
        (this.num_encoder_heads = this.config.encoder_attention_heads),
        (this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads));
    }
    async generate(X, Y = null, Q = null) {
      if (
        ((Y = this._get_generation_config(Y)),
        (Y.return_timestamps ??= !1),
        Y.return_timestamps)
      )
        Q = [new EV(Y)];
      if (Y.return_token_timestamps) {
        if (
          ((Y.output_attentions = !0),
          (Y.return_dict_in_generate = !0),
          Y.task === "translate")
        )
          console.warn(
            "Token-level timestamps may not be reliable for task 'translate'."
          );
        if (!Y.alignment_heads)
          throw Error(
            "Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config."
          );
      }
      let G = await super.generate(X, Y, Q);
      if (Y.return_token_timestamps && Y.alignment_heads)
        G.token_timestamps = this._extract_token_timestamps(
          G,
          Y.alignment_heads,
          Y.num_frames
        );
      return G;
    }
    _extract_token_timestamps(X, Y, Q = null, G = 0.02) {
      if (!X.cross_attentions)
        throw Error(
          "Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`."
        );
      let J = this.config.median_filter_width;
      if (J === void 0)
        (console.warn(
          "Model config has no `median_filter_width`, using default value of 7."
        ),
          (J = 7));
      let U = X.cross_attentions.map((K) => {
          let V = Array.from({ length: this.config.decoder_layers }, (q, M) =>
              e9(
                K.map((A) => A[M]),
                2
              )
            ),
            W = XX(
              Y.map(([q, M]) => {
                return Q
                  ? V[q].slice(null, M, null, [0, Q])
                  : V[q].slice(null, M);
              })
            );
          W = W.transpose(1, 0, 2, 3);
          let [L, H] = zW(W, -2, 0, !0),
            F = W.clone();
          for (let q = 0; q < F.dims[0]; ++q) {
            let M = F[q];
            for (let A = 0; A < M.dims[0]; ++A) {
              let D = M[A],
                R = L[q][A][0],
                z = H[q][A][0];
              for (let E = 0; E < D.dims[0]; ++E) {
                let O = D[E];
                for (let Z = 0; Z < O.data.length; ++Z)
                  O.data[Z] = (O.data[Z] - z.data[Z]) / R.data[Z];
                O.data.set(LK(O.data, J));
              }
            }
          }
          return EW(F, 1);
        }),
        $ = [X.sequences.length, X.sequences[0].length],
        B = new I0("float32", new Float32Array($[0] * $[1]), $);
      for (let K = 0; K < $[0]; ++K) {
        let V = U[K].neg().squeeze_(0),
          [W, L] = FK(V),
          H = Array.from({ length: W.length - 1 }, (q, M) => W[M + 1] - W[M]),
          F = S5([1], H).map((q) => !!q),
          N = [];
        for (let q = 0; q < F.length; ++q) if (F[q]) N.push(L[q] * G);
        B[K].data.set(N, 1);
      }
      return B;
    }
  };
  uW = class uW extends j0 {
    main_input_name = "pixel_values";
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q), (this.generation_config = G));
      let J = this.config.encoder,
        U = this.config.decoder,
        $ = J.model_type;
      if (!(rS.get($) ?? oS.get($)))
        console.warn(
          `Model type for encoder '${$}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`
        );
      let K = PH.get(U.model_type);
      if (!K)
        throw Error(
          `Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`
        );
      let W = new K[1](U, Q, G);
      if (
        ((this.add_encoder_pkv = "num_decoder_layers" in W),
        this.add_encoder_pkv)
      )
        ((this.num_decoder_layers = W.num_decoder_layers),
          (this.num_decoder_heads = W.num_decoder_heads),
          (this.decoder_dim_kv = W.decoder_dim_kv),
          (this.num_encoder_layers = W.num_encoder_layers),
          (this.num_encoder_heads = W.num_encoder_heads),
          (this.encoder_dim_kv = W.encoder_dim_kv));
      else
        ((this.num_layers = W.num_layers),
          (this.num_heads = W.num_heads),
          (this.dim_kv = W.dim_kv));
    }
  };
  d7 = class d7 extends j0 {};
  EN = class EN extends d7 {};
  ON = class ON extends d7 {
    static async from_pretrained(X, Y = {}) {
      return (
        (Y.model_file_name ??= "text_model"),
        super.from_pretrained(X, Y)
      );
    }
  };
  ZN = class ZN extends d7 {
    static async from_pretrained(X, Y = {}) {
      return (
        (Y.model_file_name ??= "vision_model"),
        super.from_pretrained(X, Y)
      );
    }
  };
  lW = class lW extends j0 {};
  jN = class jN extends lW {};
  wN = class wN extends lW {
    static async from_pretrained(X, Y = {}) {
      return (
        (Y.model_file_name ??= "text_model"),
        super.from_pretrained(X, Y)
      );
    }
  };
  CN = class CN extends d7 {
    static async from_pretrained(X, Y = {}) {
      return (
        (Y.model_file_name ??= "vision_model"),
        super.from_pretrained(X, Y)
      );
    }
  };
  IN = class IN extends j0 {};
  PN = class PN extends IN {};
  mW = class mW extends j0 {};
  SN = class SN extends mW {};
  TN = class TN extends mW {};
  cW = class cW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.n_head),
        (this.num_layers = this.config.n_layer),
        (this.dim_kv = this.config.n_embd / this.num_heads));
    }
  };
  bN = class bN extends cW {};
  vN = class vN extends cW {};
  dW = class dW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.num_heads),
        (this.num_layers = this.config.num_layers),
        (this.dim_kv = this.config.hidden_size / this.num_heads));
    }
  };
  kN = class kN extends dW {};
  yN = class yN extends dW {};
  pW = class pW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.num_attention_heads),
        (this.num_layers = this.config.num_hidden_layers),
        (this.dim_kv = this.config.hidden_size / this.num_heads));
    }
  };
  _N = class _N extends pW {};
  fN = class fN extends pW {};
  iW = class iW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.n_head),
        (this.num_layers = this.config.n_layer),
        (this.dim_kv = this.config.n_embd / this.num_heads));
    }
  };
  xN = class xN extends iW {};
  hN = class hN extends iW {};
  nW = class nW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.n_head),
        (this.num_layers = this.config.n_layer),
        (this.dim_kv = this.config.n_embd / this.num_heads));
    }
  };
  gN = class gN extends nW {};
  uN = class uN extends nW {};
  aW = class aW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.n_head),
        (this.num_layers = this.config.n_layer),
        (this.dim_kv = this.config.n_embd / this.num_heads));
    }
  };
  lN = class lN extends aW {};
  mN = class mN extends aW {};
  rW = class rW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads =
          this.config.num_key_value_heads ?? this.config.num_attention_heads),
        (this.num_layers = this.config.num_hidden_layers),
        (this.dim_kv =
          this.config.hidden_size / this.config.num_attention_heads));
    }
  };
  cN = class cN extends rW {};
  dN = class dN extends rW {};
  oW = class oW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads =
          this.config.num_key_value_heads ?? this.config.num_attention_heads),
        (this.num_layers = this.config.num_hidden_layers),
        (this.dim_kv =
          this.config.hidden_size / this.config.num_attention_heads));
    }
  };
  pN = class pN extends oW {};
  iN = class iN extends oW {};
  sW = class sW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.num_attention_heads),
        (this.num_layers = this.config.num_hidden_layers),
        (this.dim_kv = this.config.hidden_size / this.num_heads));
    }
  };
  nN = class nN extends sW {};
  aN = class aN extends sW {};
  tW = class tW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.n_head),
        (this.num_layers = this.config.n_layer),
        (this.dim_kv = this.config.hidden_size / this.num_heads));
    }
  };
  rN = class rN extends tW {};
  oN = class oN extends tW {};
  eW = class eW extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.n_heads),
        (this.num_layers = this.config.n_layers),
        (this.dim_kv = this.config.d_model / this.num_heads));
    }
  };
  sN = class sN extends eW {};
  tN = class tN extends eW {};
  XH = class XH extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.num_attention_heads),
        (this.num_layers = this.config.num_hidden_layers),
        (this.dim_kv = this.config.hidden_size / this.num_heads));
    }
  };
  eN = class eN extends XH {};
  XM = class XM extends XH {};
  YH = class YH extends j0 {};
  YM = class YM extends YH {};
  QM = class QM extends YH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  QH = class QH extends j0 {};
  GM = class GM extends QH {};
  JM = class JM extends QH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  WM = class WM extends j0 {};
  HM = class HM extends WM {
    async _call(X) {
      return new rA(await super._call(X));
    }
  };
  GH = class GH extends j0 {};
  $M = class $M extends GH {};
  UM = class UM extends GH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  JH = class JH extends j0 {};
  LM = class LM extends JH {};
  BM = class BM extends JH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  WH = class WH extends j0 {};
  KM = class KM extends WH {};
  VM = class VM extends WH {};
  HH = class HH extends j0 {};
  FM = class FM extends HH {};
  NM = class NM extends HH {};
  $H = class $H extends j0 {};
  MM = class MM extends $H {};
  AM = class AM extends $H {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  hQ = class hQ extends j0 {};
  qM = class qM extends hQ {};
  RM = class RM extends hQ {
    async _call(X) {
      return new UH(await super._call(X));
    }
  };
  DM = class DM extends hQ {
    async _call(X) {
      return new zM(await super._call(X));
    }
  };
  UH = class UH extends a5 {
    constructor({ logits: X, pred_boxes: Y }) {
      super();
      ((this.logits = X), (this.pred_boxes = Y));
    }
  };
  zM = class zM extends a5 {
    constructor({ logits: X, pred_boxes: Y, pred_masks: Q }) {
      super();
      ((this.logits = X), (this.pred_boxes = Y), (this.pred_masks = Q));
    }
  };
  LH = class LH extends j0 {};
  EM = class EM extends LH {};
  OM = class OM extends LH {
    async _call(X) {
      return new ZM(await super._call(X));
    }
  };
  ZM = class ZM extends UH {};
  BH = class BH extends j0 {};
  jM = class jM extends BH {};
  wM = class wM extends BH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  KH = class KH extends j0 {};
  CM = class CM extends KH {};
  IM = class IM extends KH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  VH = class VH extends j0 {};
  PM = class PM extends VH {};
  SM = class SM extends VH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  FH = class FH extends j0 {};
  TM = class TM extends FH {};
  bM = class bM extends FH {};
  NH = class NH extends j0 {};
  vM = class vM extends NH {};
  kM = class kM extends NH {};
  yM = class yM extends j0 {};
  _M = class _M extends yM {};
  MH = class MH extends j0 {};
  fM = class fM extends MH {};
  xM = class xM extends MH {};
  hM = class hM extends j0 {};
  gM = class gM extends hM {};
  AH = class AH extends j0 {};
  uM = class uM extends AH {};
  lM = class lM extends AH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  qH = class qH extends j0 {};
  mM = class mM extends qH {};
  cM = class cM extends qH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  RH = class RH extends j0 {};
  dM = class dM extends RH {};
  pM = class pM extends RH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  DH = class DH extends j0 {};
  iM = class iM extends DH {};
  nM = class nM extends DH {
    async _call(X) {
      return new aM(await super._call(X));
    }
  };
  aM = class aM extends a5 {
    constructor({ logits: X, pred_boxes: Y }) {
      super();
      ((this.logits = X), (this.pred_boxes = Y));
    }
  };
  rM = class rM extends j0 {};
  oM = class oM extends rM {
    constructor(X, Y, Q) {
      super(X, Y);
      this.prompt_encoder_mask_decoder = Q;
    }
    async get_image_embeddings({ pixel_values: X }) {
      return await fQ(this, { pixel_values: X });
    }
    async forward(X) {
      if (!X.image_embeddings || !X.image_positional_embeddings)
        X = { ...X, ...(await this.get_image_embeddings(X)) };
      if (!X.input_labels) {
        let Y = X.input_points.dims.slice(0, -1),
          Q = Y.reduce((G, J) => G * J, 1);
        X.input_labels = new I0("int64", new BigInt64Array(Q).fill(1n), Y);
      }
      return await h7(this.prompt_encoder_mask_decoder, {
        input_points: X.input_points,
        input_labels: X.input_labels,
        image_embeddings: X.image_embeddings,
        image_positional_embeddings: X.image_positional_embeddings,
      });
    }
    async _call(X) {
      return new sM(await super._call(X));
    }
  };
  sM = class sM extends a5 {
    constructor({ iou_scores: X, pred_masks: Y }) {
      super();
      ((this.iou_scores = X), (this.pred_masks = Y));
    }
  };
  zH = class zH extends j0 {};
  tM = class tM extends zH {};
  eM = class eM extends zH {
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.decoder_layers),
        (this.num_decoder_heads = this.config.decoder_attention_heads),
        (this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads),
        (this.num_encoder_layers = this.config.encoder_layers),
        (this.num_encoder_heads = this.config.encoder_attention_heads),
        (this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads));
    }
  };
  EH = class EH extends j0 {};
  XA = class XA extends EH {};
  YA = class YA extends EH {
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.decoder_layers),
        (this.num_decoder_heads = this.config.decoder_attention_heads),
        (this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads),
        (this.num_encoder_layers = this.config.encoder_layers),
        (this.num_encoder_heads = this.config.encoder_attention_heads),
        (this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads));
    }
  };
  E4 = class E4 extends j0 {};
  QA = class QA extends E4 {};
  GA = class GA extends E4 {
    async _call(X) {
      return new U9(await super._call(X));
    }
  };
  JA = class JA extends E4 {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  WA = class WA extends E4 {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  gQ = class gQ extends j0 {};
  HA = class HA extends gQ {};
  $A = class $A extends gQ {
    async _call(X) {
      return new U9(await super._call(X));
    }
  };
  UA = class UA extends gQ {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  p7 = class p7 extends j0 {};
  LA = class LA extends p7 {};
  BA = class BA extends p7 {
    async _call(X) {
      return new U9(await super._call(X));
    }
  };
  KA = class KA extends p7 {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  VA = class VA extends p7 {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  uQ = class uQ extends j0 {};
  FA = class FA extends uQ {};
  NA = class NA extends uQ {
    async _call(X) {
      return new U9(await super._call(X));
    }
  };
  MA = class MA extends uQ {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  pS = class pS extends j0 {};
  AA = class AA extends E4 {};
  qA = class qA extends E4 {
    async _call(X) {
      return new U9(await super._call(X));
    }
  };
  RA = class RA extends E4 {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  AX = class AX extends j0 {};
  DA = class DA extends AX {};
  zA = class zA extends AX {
    async _call(X) {
      return new U9(await super._call(X));
    }
  };
  EA = class EA extends AX {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  OA = class OA extends AX {
    async _call(X) {
      return new aA(await super._call(X));
    }
  };
  ZA = class ZA extends AX {
    async _call(X) {
      return new h5(await super._call(X));
    }
  };
  lQ = class lQ extends j0 {};
  iS = class iS extends lQ {};
  jA = class jA extends lQ {};
  wA = class wA extends lQ {
    constructor(X, Y, Q, G) {
      super(X, Y);
      ((this.decoder_merged_session = Q),
        (this.generation_config = G),
        (this.num_decoder_layers = this.config.decoder_layers),
        (this.num_decoder_heads = this.config.decoder_attention_heads),
        (this.decoder_dim_kv =
          this.config.hidden_size / this.num_decoder_heads),
        (this.num_encoder_layers = this.config.encoder_layers),
        (this.num_encoder_heads = this.config.encoder_attention_heads),
        (this.encoder_dim_kv =
          this.config.hidden_size / this.num_encoder_heads));
    }
    async generate_speech(
      X,
      Y,
      {
        threshold: Q = 0.5,
        minlenratio: G = 0,
        maxlenratio: J = 20,
        vocoder: U = null,
      } = {}
    ) {
      let $ = { input_ids: X },
        { encoder_outputs: B, encoder_attention_mask: K } = await fQ(this, $),
        V = B.dims[1] / this.config.reduction_factor,
        W = Math.floor(V * J),
        L = Math.floor(V * G),
        H = this.config.num_mel_bins,
        F = [],
        N = null,
        q = null,
        M = 0;
      while (!0) {
        ++M;
        let R = SV(!!q),
          z;
        if (q) z = q.output_sequence_out;
        else z = new I0("float32", new Float32Array(H), [1, 1, H]);
        let E = {
          use_cache_branch: R,
          output_sequence: z,
          encoder_attention_mask: K,
          speaker_embeddings: Y,
          encoder_hidden_states: B,
        };
        (this.addPastKeyValues(E, N),
          (q = await h7(this.decoder_merged_session, E)),
          (N = this.getPastKeyValues(q, N)));
        let { prob: O, spectrum: Z } = q;
        if (
          (F.push(Z),
          M >= L &&
            (Array.from(O.data).filter((j) => j >= Q).length > 0 || M >= W))
        )
          break;
      }
      let A = e9(F),
        { waveform: D } = await h7(U.session, { spectrogram: A });
      return { spectrogram: A, waveform: D };
    }
  };
  CA = class CA extends j0 {
    main_input_name = "spectrogram";
  };
  IA = class IA extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_encoder_layers = this.num_decoder_layers =
          this.config.decoder_layers),
        (this.num_encoder_heads = this.num_decoder_heads =
          this.config.decoder_attention_heads),
        (this.encoder_dim_kv = this.decoder_dim_kv =
          this.config.d_model / this.num_decoder_heads));
    }
  };
  PA = class PA extends IA {};
  OH = class OH extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.num_key_value_heads),
        (this.num_layers = this.config.num_hidden_layers),
        (this.dim_kv =
          this.config.hidden_size / this.config.num_attention_heads));
    }
  };
  SA = class SA extends OH {};
  TA = class TA extends OH {};
  ZH = class ZH extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.num_key_value_heads),
        (this.num_layers = this.config.num_hidden_layers),
        (this.dim_kv =
          this.config.hidden_size / this.config.num_attention_heads));
    }
  };
  bA = class bA extends ZH {};
  vA = class vA extends ZH {};
  jH = class jH extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.num_attention_heads),
        (this.num_layers = this.config.num_hidden_layers),
        (this.dim_kv =
          this.config.hidden_size / this.config.num_attention_heads));
    }
  };
  kA = class kA extends jH {};
  yA = class yA extends jH {};
  mQ = class mQ extends j0 {};
  _A = class _A extends mQ {};
  fA = class fA extends mQ {
    static async from_pretrained(X, Y = {}) {
      return (
        (Y.model_file_name ??= "text_model"),
        super.from_pretrained(X, Y)
      );
    }
  };
  xA = class xA extends mQ {
    static async from_pretrained(X, Y = {}) {
      return (
        (Y.model_file_name ??= "audio_model"),
        super.from_pretrained(X, Y)
      );
    }
  };
  hA = class hA extends j0 {};
  wH = class wH extends hA {
    async _call(X) {
      return new oA(await super._call(X));
    }
  };
  cQ = class cQ extends j0 {};
  nS = class nS extends cQ {};
  gA = class gA extends cQ {};
  uA = class uA extends cQ {};
  CH = class CH extends j0 {
    constructor(X, Y, Q) {
      super(X, Y);
      ((this.generation_config = Q),
        (this.config.pad_token_id = this.config.eos_token_id),
        (this.num_heads = this.config.num_attention_heads),
        (this.num_layers = this.config.num_hidden_layers),
        (this.dim_kv = this.config.hidden_size / this.num_heads));
    }
  };
  aS = class aS extends CH {};
  lA = class lA extends CH {};
  IH = class IH extends j0 {};
  mA = class mA extends IH {};
  cA = class cA extends IH {
    async _call(X) {
      return new Z1(await super._call(X));
    }
  };
  ((rS = new Map([
    ["bert", ["BertModel", TV]],
    ["nomic_bert", ["NomicBertModel", fV]],
    ["roformer", ["RoFormerModel", xV]],
    ["electra", ["ElectraModel", nV]],
    ["esm", ["EsmModel", RF]],
    ["convbert", ["ConvBertModel", mV]],
    ["camembert", ["CamembertModel", tV]],
    ["deberta", ["DebertaModel", GF]],
    ["deberta-v2", ["DebertaV2Model", UF]],
    ["mpnet", ["MPNetModel", CF]],
    ["albert", ["AlbertModel", _F]],
    ["distilbert", ["DistilBertModel", FF]],
    ["roberta", ["RobertaModel", QN]],
    ["xlm", ["XLMModel", $N]],
    ["xlm-roberta", ["XLMRobertaModel", VN]],
    ["clap", ["ClapModel", _A]],
    ["clip", ["CLIPModel", EN]],
    ["clipseg", ["CLIPSegModel", SN]],
    ["chinese_clip", ["ChineseCLIPModel", PN]],
    ["siglip", ["SiglipModel", jN]],
    ["mobilebert", ["MobileBertModel", OF]],
    ["squeezebert", ["SqueezeBertModel", bF]],
    ["wav2vec2", ["Wav2Vec2Model", QA]],
    ["wav2vec2-bert", ["Wav2Vec2BertModel", FA]],
    ["unispeech", ["UniSpeechModel", HA]],
    ["unispeech-sat", ["UniSpeechSatModel", LA]],
    ["hubert", ["HubertModel", AA]],
    ["wavlm", ["WavLMModel", DA]],
    ["audio-spectrogram-transformer", ["ASTModel", qN]],
    ["vits", ["VitsModel", wH]],
    ["detr", ["DetrModel", qM]],
    ["table-transformer", ["TableTransformerModel", EM]],
    ["vit", ["ViTModel", YM]],
    ["fastvit", ["FastViTModel", GM]],
    ["mobilevit", ["MobileViTModel", $M]],
    ["mobilevitv2", ["MobileViTV2Model", LM]],
    ["owlvit", ["OwlViTModel", KM]],
    ["owlv2", ["Owlv2Model", FM]],
    ["beit", ["BeitModel", MM]],
    ["deit", ["DeiTModel", jM]],
    ["convnext", ["ConvNextModel", uM]],
    ["convnextv2", ["ConvNextV2Model", mM]],
    ["dinov2", ["Dinov2Model", dM]],
    ["resnet", ["ResNetModel", CM]],
    ["swin", ["SwinModel", PM]],
    ["swin2sr", ["Swin2SRModel", TM]],
    ["donut-swin", ["DonutSwinModel", gM]],
    ["yolos", ["YolosModel", iM]],
    ["dpt", ["DPTModel", vM]],
    ["glpn", ["GLPNModel", fM]],
    ["hifigan", ["SpeechT5HifiGan", CA]],
    ["efficientnet", ["EfficientNetModel", mA]],
  ])),
    (oS = new Map([
      ["t5", ["T5Model", gF]],
      ["longt5", ["LongT5Model", lF]],
      ["mt5", ["MT5Model", cF]],
      ["bart", ["BartModel", pF]],
      ["mbart", ["MBartModel", aF]],
      ["marian", ["MarianModel", tM]],
      ["whisper", ["WhisperModel", DN]],
      ["m2m_100", ["M2M100Model", XA]],
      ["blenderbot", ["BlenderbotModel", tF]],
      ["blenderbot-small", ["BlenderbotSmallModel", XN]],
    ])),
    (b50 = new Map([
      ["bloom", ["BloomModel", rN]],
      ["gpt2", ["GPT2Model", bN]],
      ["gptj", ["GPTJModel", xN]],
      ["gpt_bigcode", ["GPTBigCodeModel", gN]],
      ["gpt_neo", ["GPTNeoModel", kN]],
      ["gpt_neox", ["GPTNeoXModel", _N]],
      ["codegen", ["CodeGenModel", lN]],
      ["llama", ["LlamaModel", cN]],
      ["qwen2", ["Qwen2Model", pN]],
      ["phi", ["PhiModel", nN]],
      ["mpt", ["MptModel", sN]],
      ["opt", ["OPTModel", eN]],
      ["mistral", ["MistralModel", SA]],
      ["starcoder2", ["Starcoder2Model", bA]],
      ["falcon", ["FalconModel", kA]],
    ])),
    (dA = new Map([
      ["speecht5", ["SpeechT5ForSpeechToText", jA]],
      ["whisper", ["WhisperForConditionalGeneration", zN]],
    ])),
    (sS = new Map([["speecht5", ["SpeechT5ForTextToSpeech", wA]]])),
    (tS = new Map([["vits", ["VitsModel", wH]]])),
    (eS = new Map([
      ["bert", ["BertForSequenceClassification", vV]],
      ["roformer", ["RoFormerForSequenceClassification", gV]],
      ["electra", ["ElectraForSequenceClassification", rV]],
      ["esm", ["EsmForSequenceClassification", zF]],
      ["convbert", ["ConvBertForSequenceClassification", dV]],
      ["camembert", ["CamembertForSequenceClassification", XF]],
      ["deberta", ["DebertaForSequenceClassification", WF]],
      ["deberta-v2", ["DebertaV2ForSequenceClassification", BF]],
      ["mpnet", ["MPNetForSequenceClassification", PF]],
      ["albert", ["AlbertForSequenceClassification", fF]],
      ["distilbert", ["DistilBertForSequenceClassification", NF]],
      ["roberta", ["RobertaForSequenceClassification", JN]],
      ["xlm", ["XLMForSequenceClassification", LN]],
      ["xlm-roberta", ["XLMRobertaForSequenceClassification", NN]],
      ["bart", ["BartForSequenceClassification", nF]],
      ["mbart", ["MBartForSequenceClassification", oF]],
      ["mobilebert", ["MobileBertForSequenceClassification", jF]],
      ["squeezebert", ["SqueezeBertForSequenceClassification", kF]],
    ])),
    (XT = new Map([
      ["bert", ["BertForTokenClassification", kV]],
      ["roformer", ["RoFormerForTokenClassification", uV]],
      ["electra", ["ElectraForTokenClassification", oV]],
      ["esm", ["EsmForTokenClassification", EF]],
      ["convbert", ["ConvBertForTokenClassification", pV]],
      ["camembert", ["CamembertForTokenClassification", YF]],
      ["deberta", ["DebertaForTokenClassification", HF]],
      ["deberta-v2", ["DebertaV2ForTokenClassification", KF]],
      ["mpnet", ["MPNetForTokenClassification", SF]],
      ["distilbert", ["DistilBertForTokenClassification", MF]],
      ["roberta", ["RobertaForTokenClassification", WN]],
      ["xlm", ["XLMForTokenClassification", BN]],
      ["xlm-roberta", ["XLMRobertaForTokenClassification", MN]],
    ])),
    (pA = new Map([
      ["t5", ["T5ForConditionalGeneration", uF]],
      ["longt5", ["LongT5ForConditionalGeneration", mF]],
      ["mt5", ["MT5ForConditionalGeneration", dF]],
      ["bart", ["BartForConditionalGeneration", iF]],
      ["mbart", ["MBartForConditionalGeneration", rF]],
      ["marian", ["MarianMTModel", eM]],
      ["m2m_100", ["M2M100ForConditionalGeneration", YA]],
      ["blenderbot", ["BlenderbotForConditionalGeneration", eF]],
      ["blenderbot-small", ["BlenderbotSmallForConditionalGeneration", YN]],
    ])),
    (PH = new Map([
      ["bloom", ["BloomForCausalLM", oN]],
      ["gpt2", ["GPT2LMHeadModel", vN]],
      ["gptj", ["GPTJForCausalLM", hN]],
      ["gpt_bigcode", ["GPTBigCodeForCausalLM", uN]],
      ["gpt_neo", ["GPTNeoForCausalLM", yN]],
      ["gpt_neox", ["GPTNeoXForCausalLM", fN]],
      ["codegen", ["CodeGenForCausalLM", mN]],
      ["llama", ["LlamaForCausalLM", dN]],
      ["qwen2", ["Qwen2ForCausalLM", iN]],
      ["phi", ["PhiForCausalLM", aN]],
      ["mpt", ["MptForCausalLM", tN]],
      ["opt", ["OPTForCausalLM", XM]],
      ["mbart", ["MBartForCausalLM", sF]],
      ["mistral", ["MistralForCausalLM", TA]],
      ["starcoder2", ["Starcoder2ForCausalLM", vA]],
      ["falcon", ["FalconForCausalLM", yA]],
      ["trocr", ["TrOCRForCausalLM", PA]],
      ["stablelm", ["StableLmForCausalLM", lA]],
    ])),
    (YT = new Map([
      ["bert", ["BertForMaskedLM", bV]],
      ["roformer", ["RoFormerForMaskedLM", hV]],
      ["electra", ["ElectraForMaskedLM", aV]],
      ["esm", ["EsmForMaskedLM", DF]],
      ["convbert", ["ConvBertForMaskedLM", cV]],
      ["camembert", ["CamembertForMaskedLM", eV]],
      ["deberta", ["DebertaForMaskedLM", JF]],
      ["deberta-v2", ["DebertaV2ForMaskedLM", LF]],
      ["mpnet", ["MPNetForMaskedLM", IF]],
      ["albert", ["AlbertForMaskedLM", hF]],
      ["distilbert", ["DistilBertForMaskedLM", qF]],
      ["roberta", ["RobertaForMaskedLM", GN]],
      ["xlm", ["XLMWithLMHeadModel", UN]],
      ["xlm-roberta", ["XLMRobertaForMaskedLM", FN]],
      ["mobilebert", ["MobileBertForMaskedLM", ZF]],
      ["squeezebert", ["SqueezeBertForMaskedLM", vF]],
    ])),
    (QT = new Map([
      ["bert", ["BertForQuestionAnswering", yV]],
      ["roformer", ["RoFormerForQuestionAnswering", lV]],
      ["electra", ["ElectraForQuestionAnswering", sV]],
      ["convbert", ["ConvBertForQuestionAnswering", iV]],
      ["camembert", ["CamembertForQuestionAnswering", QF]],
      ["deberta", ["DebertaForQuestionAnswering", $F]],
      ["deberta-v2", ["DebertaV2ForQuestionAnswering", VF]],
      ["mpnet", ["MPNetForQuestionAnswering", TF]],
      ["albert", ["AlbertForQuestionAnswering", xF]],
      ["distilbert", ["DistilBertForQuestionAnswering", AF]],
      ["roberta", ["RobertaForQuestionAnswering", HN]],
      ["xlm", ["XLMForQuestionAnswering", KN]],
      ["xlm-roberta", ["XLMRobertaForQuestionAnswering", AN]],
      ["mobilebert", ["MobileBertForQuestionAnswering", wF]],
      ["squeezebert", ["SqueezeBertForQuestionAnswering", yF]],
    ])),
    (iA = new Map([
      ["vision-encoder-decoder", ["VisionEncoderDecoderModel", uW]],
    ])),
    (v50 = new Map([
      ["vision-encoder-decoder", ["VisionEncoderDecoderModel", uW]],
    ])),
    (GT = new Map([
      ["vit", ["ViTForImageClassification", QM]],
      ["fastvit", ["FastViTForImageClassification", JM]],
      ["mobilevit", ["MobileViTForImageClassification", UM]],
      ["mobilevitv2", ["MobileViTV2ForImageClassification", BM]],
      ["beit", ["BeitForImageClassification", AM]],
      ["deit", ["DeiTForImageClassification", wM]],
      ["convnext", ["ConvNextForImageClassification", lM]],
      ["convnextv2", ["ConvNextV2ForImageClassification", cM]],
      ["dinov2", ["Dinov2ForImageClassification", pM]],
      ["resnet", ["ResNetForImageClassification", IM]],
      ["swin", ["SwinForImageClassification", SM]],
      ["segformer", ["SegformerForImageClassification", gA]],
      ["efficientnet", ["EfficientNetForImageClassification", cA]],
    ])),
    (JT = new Map([
      ["detr", ["DetrForObjectDetection", RM]],
      ["table-transformer", ["TableTransformerForObjectDetection", OM]],
      ["yolos", ["YolosForObjectDetection", nM]],
    ])),
    (WT = new Map([
      ["owlvit", ["OwlViTForObjectDetection", VM]],
      ["owlv2", ["Owlv2ForObjectDetection", NM]],
    ])),
    (HT = new Map([
      ["detr", ["DetrForSegmentation", DM]],
      ["clipseg", ["CLIPSegForImageSegmentation", TN]],
    ])),
    ($T = new Map([["segformer", ["SegformerForSemanticSegmentation", uA]]])),
    (UT = new Map([["sam", ["SamModel", oM]]])),
    (LT = new Map([
      ["wav2vec2", ["Wav2Vec2ForCTC", GA]],
      ["wav2vec2-bert", ["Wav2Vec2BertForCTC", NA]],
      ["unispeech", ["UniSpeechForCTC", $A]],
      ["unispeech-sat", ["UniSpeechSatForCTC", BA]],
      ["wavlm", ["WavLMForCTC", zA]],
      ["hubert", ["HubertForCTC", qA]],
    ])),
    (BT = new Map([
      ["wav2vec2", ["Wav2Vec2ForSequenceClassification", JA]],
      ["wav2vec2-bert", ["Wav2Vec2BertForSequenceClassification", MA]],
      ["unispeech", ["UniSpeechForSequenceClassification", UA]],
      ["unispeech-sat", ["UniSpeechSatForSequenceClassification", KA]],
      ["wavlm", ["WavLMForSequenceClassification", EA]],
      ["hubert", ["HubertForSequenceClassification", RA]],
      ["audio-spectrogram-transformer", ["ASTForAudioClassification", RN]],
    ])),
    (KT = new Map([["wavlm", ["WavLMForXVector", OA]]])),
    (VT = new Map([
      ["unispeech-sat", ["UniSpeechSatForAudioFrameClassification", VA]],
      ["wavlm", ["WavLMForAudioFrameClassification", ZA]],
      ["wav2vec2", ["Wav2Vec2ForAudioFrameClassification", WA]],
    ])),
    (FT = new Map([["vitmatte", ["VitMatteForImageMatting", HM]]])),
    (NT = new Map([["swin2sr", ["Swin2SRForImageSuperResolution", bM]]])),
    (MT = new Map([
      ["dpt", ["DPTForDepthEstimation", kM]],
      ["depth_anything", ["DepthAnythingForDepthEstimation", _M]],
      ["glpn", ["GLPNForDepthEstimation", xM]],
    ])),
    (AT = new Map([
      ["clip", ["CLIPVisionModelWithProjection", ZN]],
      ["siglip", ["SiglipVisionModel", CN]],
    ])),
    (qT = [
      [rS, K1.EncoderOnly],
      [oS, K1.EncoderDecoder],
      [b50, K1.DecoderOnly],
      [eS, K1.EncoderOnly],
      [XT, K1.EncoderOnly],
      [pA, K1.Seq2Seq],
      [dA, K1.Seq2Seq],
      [PH, K1.DecoderOnly],
      [YT, K1.EncoderOnly],
      [QT, K1.EncoderOnly],
      [iA, K1.Vision2Seq],
      [GT, K1.EncoderOnly],
      [HT, K1.EncoderOnly],
      [$T, K1.EncoderOnly],
      [FT, K1.EncoderOnly],
      [NT, K1.EncoderOnly],
      [MT, K1.EncoderOnly],
      [JT, K1.EncoderOnly],
      [WT, K1.EncoderOnly],
      [UT, K1.MaskGeneration],
      [LT, K1.EncoderOnly],
      [BT, K1.EncoderOnly],
      [sS, K1.Seq2Seq],
      [tS, K1.EncoderOnly],
      [KT, K1.EncoderOnly],
      [VT, K1.EncoderOnly],
      [AT, K1.EncoderOnly],
    ]));
  for (let [X, Y] of qT)
    for (let [Q, G] of X.values()) (vW.set(Q, Y), _Q.set(G, Q), lS.set(Q, G));
  k50 = [
    ["CLIPTextModelWithProjection", ON, K1.EncoderOnly],
    ["SiglipTextModel", wN, K1.EncoderOnly],
    ["ClapTextModelWithProjection", fA, K1.EncoderOnly],
    ["ClapAudioModelWithProjection", xA, K1.EncoderOnly],
  ];
  for (let [X, Y, Q] of k50) (vW.set(X, Q), _Q.set(Y, X), lS.set(X, Y));
  $9 = class $9 extends i1 {
    static MODEL_CLASS_MAPPINGS = qT.map((X) => X[0]);
    static BASE_IF_FAIL = !0;
  };
  dQ = class dQ extends i1 {
    static MODEL_CLASS_MAPPINGS = [eS];
  };
  SH = class SH extends i1 {
    static MODEL_CLASS_MAPPINGS = [XT];
  };
  i7 = class i7 extends i1 {
    static MODEL_CLASS_MAPPINGS = [pA];
  };
  TH = class TH extends i1 {
    static MODEL_CLASS_MAPPINGS = [dA];
  };
  bH = class bH extends i1 {
    static MODEL_CLASS_MAPPINGS = [sS];
  };
  vH = class vH extends i1 {
    static MODEL_CLASS_MAPPINGS = [tS];
  };
  kH = class kH extends i1 {
    static MODEL_CLASS_MAPPINGS = [PH];
  };
  yH = class yH extends i1 {
    static MODEL_CLASS_MAPPINGS = [YT];
  };
  _H = class _H extends i1 {
    static MODEL_CLASS_MAPPINGS = [QT];
  };
  fH = class fH extends i1 {
    static MODEL_CLASS_MAPPINGS = [iA];
  };
  xH = class xH extends i1 {
    static MODEL_CLASS_MAPPINGS = [GT];
  };
  hH = class hH extends i1 {
    static MODEL_CLASS_MAPPINGS = [HT];
  };
  gH = class gH extends i1 {
    static MODEL_CLASS_MAPPINGS = [$T];
  };
  uH = class uH extends i1 {
    static MODEL_CLASS_MAPPINGS = [JT];
  };
  lH = class lH extends i1 {
    static MODEL_CLASS_MAPPINGS = [WT];
  };
  RT = class RT extends i1 {
    static MODEL_CLASS_MAPPINGS = [UT];
  };
  mH = class mH extends i1 {
    static MODEL_CLASS_MAPPINGS = [LT];
  };
  cH = class cH extends i1 {
    static MODEL_CLASS_MAPPINGS = [BT];
  };
  DT = class DT extends i1 {
    static MODEL_CLASS_MAPPINGS = [KT];
  };
  zT = class zT extends i1 {
    static MODEL_CLASS_MAPPINGS = [VT];
  };
  dH = class dH extends i1 {
    static MODEL_CLASS_MAPPINGS = [v50];
  };
  ET = class ET extends i1 {
    static MODEL_CLASS_MAPPINGS = [FT];
  };
  pH = class pH extends i1 {
    static MODEL_CLASS_MAPPINGS = [NT];
  };
  iH = class iH extends i1 {
    static MODEL_CLASS_MAPPINGS = [MT];
  };
  nH = class nH extends i1 {
    static MODEL_CLASS_MAPPINGS = [AT];
  };
  nA = class nA extends a5 {
    constructor({
      logits: X,
      past_key_values: Y,
      encoder_outputs: Q,
      decoder_attentions: G = null,
      cross_attentions: J = null,
    }) {
      super();
      ((this.logits = X),
        (this.past_key_values = Y),
        (this.encoder_outputs = Q),
        (this.decoder_attentions = G),
        (this.cross_attentions = J));
    }
  };
  Z1 = class Z1 extends a5 {
    constructor({ logits: X }) {
      super();
      this.logits = X;
    }
  };
  aA = class aA extends a5 {
    constructor({ logits: X, embeddings: Y }) {
      super();
      ((this.logits = X), (this.embeddings = Y));
    }
  };
  h5 = class h5 extends a5 {
    constructor({ logits: X }) {
      super();
      this.logits = X;
    }
  };
  g5 = class g5 extends a5 {
    constructor({ logits: X }) {
      super();
      this.logits = X;
    }
  };
  r5 = class r5 extends a5 {
    constructor({ start_logits: X, end_logits: Y }) {
      super();
      ((this.start_logits = X), (this.end_logits = Y));
    }
  };
  U9 = class U9 extends a5 {
    constructor({ logits: X }) {
      super();
      this.logits = X;
    }
  };
  OT = class OT extends a5 {
    constructor({ logits: X, past_key_values: Y }) {
      super();
      ((this.logits = X), (this.past_key_values = Y));
    }
  };
  rA = class rA extends a5 {
    constructor({ alphas: X }) {
      super();
      this.alphas = X;
    }
  };
  oA = class oA extends a5 {
    constructor({ waveform: X, spectrogram: Y }) {
      super();
      ((this.waveform = X), (this.spectrogram = Y));
    }
  };
});
var l6 = s((JV0, jT) => {
  var ZT = function (X) {
      return typeof X < "u" && X !== null;
    },
    y50 = function (X) {
      return typeof X === "object";
    },
    _50 = function (X) {
      return Object.prototype.toString.call(X) === "[object Object]";
    },
    f50 = function (X) {
      return typeof X === "function";
    },
    x50 = function (X) {
      return typeof X === "boolean";
    },
    h50 = function (X) {
      return X instanceof Buffer;
    },
    g50 = function (X) {
      if (ZT(X))
        switch (X.constructor) {
          case Uint8Array:
          case Uint8ClampedArray:
          case Int8Array:
          case Uint16Array:
          case Int16Array:
          case Uint32Array:
          case Int32Array:
          case Float32Array:
          case Float64Array:
            return !0;
        }
      return !1;
    },
    u50 = function (X) {
      return X instanceof ArrayBuffer;
    },
    l50 = function (X) {
      return typeof X === "string" && X.length > 0;
    },
    m50 = function (X) {
      return typeof X === "number" && !Number.isNaN(X);
    },
    c50 = function (X) {
      return Number.isInteger(X);
    },
    d50 = function (X, Y, Q) {
      return X >= Y && X <= Q;
    },
    p50 = function (X, Y) {
      return Y.includes(X);
    },
    i50 = function (X, Y, Q) {
      return Error(
        `Expected ${Y} for ${X} but received ${Q} of type ${typeof Q}`
      );
    };
  jT.exports = {
    defined: ZT,
    object: y50,
    plainObject: _50,
    fn: f50,
    bool: x50,
    buffer: h50,
    typedArray: g50,
    arrayBuffer: u50,
    string: l50,
    number: m50,
    integer: c50,
    inRange: d50,
    inArray: p50,
    invalidParameterError: i50,
  };
});
var eA = s((WV0, wT) => {
  var n50 =
    typeof process === "object" &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ? (...X) => console.error("SEMVER", ...X)
      : () => {};
  wT.exports = n50;
});
var Xq = s((HV0, CT) => {
  var a50 = Number.MAX_SAFE_INTEGER || 9007199254740991,
    r50 = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease",
    ];
  CT.exports = {
    MAX_LENGTH: 256,
    MAX_SAFE_COMPONENT_LENGTH: 16,
    MAX_SAFE_BUILD_LENGTH: 250,
    MAX_SAFE_INTEGER: a50,
    RELEASE_TYPES: r50,
    SEMVER_SPEC_VERSION: "2.0.0",
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2,
  };
});
var Gq = s((m6, IT) => {
  var {
      MAX_SAFE_COMPONENT_LENGTH: Yq,
      MAX_SAFE_BUILD_LENGTH: o50,
      MAX_LENGTH: s50,
    } = Xq(),
    t50 = eA();
  m6 = IT.exports = {};
  var e50 = (m6.re = []),
    X80 = (m6.safeRe = []),
    _0 = (m6.src = []),
    Y80 = (m6.safeSrc = []),
    f0 = (m6.t = {}),
    Q80 = 0,
    Qq = "[a-zA-Z0-9-]",
    G80 = [
      ["\\s", 1],
      ["\\d", s50],
      [Qq, o50],
    ],
    J80 = (X) => {
      for (let [Y, Q] of G80)
        X = X.split(`${Y}*`)
          .join(`${Y}{0,${Q}}`)
          .split(`${Y}+`)
          .join(`${Y}{1,${Q}}`);
      return X;
    },
    $1 = (X, Y, Q) => {
      let G = J80(Y),
        J = Q80++;
      (t50(X, J, Y),
        (f0[X] = J),
        (_0[J] = Y),
        (Y80[J] = G),
        (e50[J] = new RegExp(Y, Q ? "g" : void 0)),
        (X80[J] = new RegExp(G, Q ? "g" : void 0)));
    };
  $1("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  $1("NUMERICIDENTIFIERLOOSE", "\\d+");
  $1("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${Qq}*`);
  $1(
    "MAINVERSION",
    `(${_0[f0.NUMERICIDENTIFIER]})\\.(${_0[f0.NUMERICIDENTIFIER]})\\.(${_0[f0.NUMERICIDENTIFIER]})`
  );
  $1(
    "MAINVERSIONLOOSE",
    `(${_0[f0.NUMERICIDENTIFIERLOOSE]})\\.(${_0[f0.NUMERICIDENTIFIERLOOSE]})\\.(${_0[f0.NUMERICIDENTIFIERLOOSE]})`
  );
  $1(
    "PRERELEASEIDENTIFIER",
    `(?:${_0[f0.NONNUMERICIDENTIFIER]}|${_0[f0.NUMERICIDENTIFIER]})`
  );
  $1(
    "PRERELEASEIDENTIFIERLOOSE",
    `(?:${_0[f0.NONNUMERICIDENTIFIER]}|${_0[f0.NUMERICIDENTIFIERLOOSE]})`
  );
  $1(
    "PRERELEASE",
    `(?:-(${_0[f0.PRERELEASEIDENTIFIER]}(?:\\.${_0[f0.PRERELEASEIDENTIFIER]})*))`
  );
  $1(
    "PRERELEASELOOSE",
    `(?:-?(${_0[f0.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${_0[f0.PRERELEASEIDENTIFIERLOOSE]})*))`
  );
  $1("BUILDIDENTIFIER", `${Qq}+`);
  $1(
    "BUILD",
    `(?:\\+(${_0[f0.BUILDIDENTIFIER]}(?:\\.${_0[f0.BUILDIDENTIFIER]})*))`
  );
  $1(
    "FULLPLAIN",
    `v?${_0[f0.MAINVERSION]}${_0[f0.PRERELEASE]}?${_0[f0.BUILD]}?`
  );
  $1("FULL", `^${_0[f0.FULLPLAIN]}$`);
  $1(
    "LOOSEPLAIN",
    `[v=\\s]*${_0[f0.MAINVERSIONLOOSE]}${_0[f0.PRERELEASELOOSE]}?${_0[f0.BUILD]}?`
  );
  $1("LOOSE", `^${_0[f0.LOOSEPLAIN]}$`);
  $1("GTLT", "((?:<|>)?=?)");
  $1("XRANGEIDENTIFIERLOOSE", `${_0[f0.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  $1("XRANGEIDENTIFIER", `${_0[f0.NUMERICIDENTIFIER]}|x|X|\\*`);
  $1(
    "XRANGEPLAIN",
    `[v=\\s]*(${_0[f0.XRANGEIDENTIFIER]})(?:\\.(${_0[f0.XRANGEIDENTIFIER]})(?:\\.(${_0[f0.XRANGEIDENTIFIER]})(?:${_0[f0.PRERELEASE]})?${_0[f0.BUILD]}?)?)?`
  );
  $1(
    "XRANGEPLAINLOOSE",
    `[v=\\s]*(${_0[f0.XRANGEIDENTIFIERLOOSE]})(?:\\.(${_0[f0.XRANGEIDENTIFIERLOOSE]})(?:\\.(${_0[f0.XRANGEIDENTIFIERLOOSE]})(?:${_0[f0.PRERELEASELOOSE]})?${_0[f0.BUILD]}?)?)?`
  );
  $1("XRANGE", `^${_0[f0.GTLT]}\\s*${_0[f0.XRANGEPLAIN]}$`);
  $1("XRANGELOOSE", `^${_0[f0.GTLT]}\\s*${_0[f0.XRANGEPLAINLOOSE]}$`);
  $1(
    "COERCEPLAIN",
    `(^|[^\\d])(\\d{1,${Yq}})(?:\\.(\\d{1,${Yq}}))?(?:\\.(\\d{1,${Yq}}))?`
  );
  $1("COERCE", `${_0[f0.COERCEPLAIN]}(?:$|[^\\d])`);
  $1(
    "COERCEFULL",
    _0[f0.COERCEPLAIN] +
      `(?:${_0[f0.PRERELEASE]})?(?:${_0[f0.BUILD]})?(?:$|[^\\d])`
  );
  $1("COERCERTL", _0[f0.COERCE], !0);
  $1("COERCERTLFULL", _0[f0.COERCEFULL], !0);
  $1("LONETILDE", "(?:~>?)");
  $1("TILDETRIM", `(\\s*)${_0[f0.LONETILDE]}\\s+`, !0);
  m6.tildeTrimReplace = "$1~";
  $1("TILDE", `^${_0[f0.LONETILDE]}${_0[f0.XRANGEPLAIN]}$`);
  $1("TILDELOOSE", `^${_0[f0.LONETILDE]}${_0[f0.XRANGEPLAINLOOSE]}$`);
  $1("LONECARET", "(?:\\^)");
  $1("CARETTRIM", `(\\s*)${_0[f0.LONECARET]}\\s+`, !0);
  m6.caretTrimReplace = "$1^";
  $1("CARET", `^${_0[f0.LONECARET]}${_0[f0.XRANGEPLAIN]}$`);
  $1("CARETLOOSE", `^${_0[f0.LONECARET]}${_0[f0.XRANGEPLAINLOOSE]}$`);
  $1("COMPARATORLOOSE", `^${_0[f0.GTLT]}\\s*(${_0[f0.LOOSEPLAIN]})$|^$`);
  $1("COMPARATOR", `^${_0[f0.GTLT]}\\s*(${_0[f0.FULLPLAIN]})$|^$`);
  $1(
    "COMPARATORTRIM",
    `(\\s*)${_0[f0.GTLT]}\\s*(${_0[f0.LOOSEPLAIN]}|${_0[f0.XRANGEPLAIN]})`,
    !0
  );
  m6.comparatorTrimReplace = "$1$2$3";
  $1(
    "HYPHENRANGE",
    `^\\s*(${_0[f0.XRANGEPLAIN]})\\s+-\\s+(${_0[f0.XRANGEPLAIN]})\\s*$`
  );
  $1(
    "HYPHENRANGELOOSE",
    `^\\s*(${_0[f0.XRANGEPLAINLOOSE]})\\s+-\\s+(${_0[f0.XRANGEPLAINLOOSE]})\\s*$`
  );
  $1("STAR", "(<|>)?=?\\s*\\*");
  $1("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  $1("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});
var ST = s(($V0, PT) => {
  var W80 = Object.freeze({ loose: !0 }),
    H80 = Object.freeze({}),
    $80 = (X) => {
      if (!X) return H80;
      if (typeof X !== "object") return W80;
      return X;
    };
  PT.exports = $80;
});
var kT = s((UV0, vT) => {
  var TT = /^[0-9]+$/,
    bT = (X, Y) => {
      if (typeof X === "number" && typeof Y === "number")
        return X === Y ? 0 : X < Y ? -1 : 1;
      let Q = TT.test(X),
        G = TT.test(Y);
      if (Q && G) ((X = +X), (Y = +Y));
      return X === Y ? 0 : Q && !G ? -1 : G && !Q ? 1 : X < Y ? -1 : 1;
    },
    U80 = (X, Y) => bT(Y, X);
  vT.exports = { compareIdentifiers: bT, rcompareIdentifiers: U80 };
});
var tH = s((LV0, _T) => {
  var aH = eA(),
    { MAX_LENGTH: yT, MAX_SAFE_INTEGER: rH } = Xq(),
    { safeRe: oH, t: sH } = Gq(),
    L80 = ST(),
    { compareIdentifiers: Jq } = kT();
  class s8 {
    constructor(X, Y) {
      if (((Y = L80(Y)), X instanceof s8))
        if (
          X.loose === !!Y.loose &&
          X.includePrerelease === !!Y.includePrerelease
        )
          return X;
        else X = X.version;
      else if (typeof X !== "string")
        throw TypeError(
          `Invalid version. Must be a string. Got type "${typeof X}".`
        );
      if (X.length > yT)
        throw TypeError(`version is longer than ${yT} characters`);
      (aH("SemVer", X, Y),
        (this.options = Y),
        (this.loose = !!Y.loose),
        (this.includePrerelease = !!Y.includePrerelease));
      let Q = X.trim().match(Y.loose ? oH[sH.LOOSE] : oH[sH.FULL]);
      if (!Q) throw TypeError(`Invalid Version: ${X}`);
      if (
        ((this.raw = X),
        (this.major = +Q[1]),
        (this.minor = +Q[2]),
        (this.patch = +Q[3]),
        this.major > rH || this.major < 0)
      )
        throw TypeError("Invalid major version");
      if (this.minor > rH || this.minor < 0)
        throw TypeError("Invalid minor version");
      if (this.patch > rH || this.patch < 0)
        throw TypeError("Invalid patch version");
      if (!Q[4]) this.prerelease = [];
      else
        this.prerelease = Q[4].split(".").map((G) => {
          if (/^[0-9]+$/.test(G)) {
            let J = +G;
            if (J >= 0 && J < rH) return J;
          }
          return G;
        });
      ((this.build = Q[5] ? Q[5].split(".") : []), this.format());
    }
    format() {
      if (
        ((this.version = `${this.major}.${this.minor}.${this.patch}`),
        this.prerelease.length)
      )
        this.version += `-${this.prerelease.join(".")}`;
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(X) {
      if (
        (aH("SemVer.compare", this.version, this.options, X),
        !(X instanceof s8))
      ) {
        if (typeof X === "string" && X === this.version) return 0;
        X = new s8(X, this.options);
      }
      if (X.version === this.version) return 0;
      return this.compareMain(X) || this.comparePre(X);
    }
    compareMain(X) {
      if (!(X instanceof s8)) X = new s8(X, this.options);
      if (this.major < X.major) return -1;
      if (this.major > X.major) return 1;
      if (this.minor < X.minor) return -1;
      if (this.minor > X.minor) return 1;
      if (this.patch < X.patch) return -1;
      if (this.patch > X.patch) return 1;
      return 0;
    }
    comparePre(X) {
      if (!(X instanceof s8)) X = new s8(X, this.options);
      if (this.prerelease.length && !X.prerelease.length) return -1;
      else if (!this.prerelease.length && X.prerelease.length) return 1;
      else if (!this.prerelease.length && !X.prerelease.length) return 0;
      let Y = 0;
      do {
        let Q = this.prerelease[Y],
          G = X.prerelease[Y];
        if ((aH("prerelease compare", Y, Q, G), Q === void 0 && G === void 0))
          return 0;
        else if (G === void 0) return 1;
        else if (Q === void 0) return -1;
        else if (Q === G) continue;
        else return Jq(Q, G);
      } while (++Y);
    }
    compareBuild(X) {
      if (!(X instanceof s8)) X = new s8(X, this.options);
      let Y = 0;
      do {
        let Q = this.build[Y],
          G = X.build[Y];
        if ((aH("build compare", Y, Q, G), Q === void 0 && G === void 0))
          return 0;
        else if (G === void 0) return 1;
        else if (Q === void 0) return -1;
        else if (Q === G) continue;
        else return Jq(Q, G);
      } while (++Y);
    }
    inc(X, Y, Q) {
      if (X.startsWith("pre")) {
        if (!Y && Q === !1)
          throw Error("invalid increment argument: identifier is empty");
        if (Y) {
          let G = `-${Y}`.match(
            this.options.loose ? oH[sH.PRERELEASELOOSE] : oH[sH.PRERELEASE]
          );
          if (!G || G[1] !== Y) throw Error(`invalid identifier: ${Y}`);
        }
      }
      switch (X) {
        case "premajor":
          ((this.prerelease.length = 0),
            (this.patch = 0),
            (this.minor = 0),
            this.major++,
            this.inc("pre", Y, Q));
          break;
        case "preminor":
          ((this.prerelease.length = 0),
            (this.patch = 0),
            this.minor++,
            this.inc("pre", Y, Q));
          break;
        case "prepatch":
          ((this.prerelease.length = 0),
            this.inc("patch", Y, Q),
            this.inc("pre", Y, Q));
          break;
        case "prerelease":
          if (this.prerelease.length === 0) this.inc("patch", Y, Q);
          this.inc("pre", Y, Q);
          break;
        case "release":
          if (this.prerelease.length === 0)
            throw Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          if (
            this.minor !== 0 ||
            this.patch !== 0 ||
            this.prerelease.length === 0
          )
            this.major++;
          ((this.minor = 0), (this.patch = 0), (this.prerelease = []));
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
          ((this.patch = 0), (this.prerelease = []));
          break;
        case "patch":
          if (this.prerelease.length === 0) this.patch++;
          this.prerelease = [];
          break;
        case "pre": {
          let G = Number(Q) ? 1 : 0;
          if (this.prerelease.length === 0) this.prerelease = [G];
          else {
            let J = this.prerelease.length;
            while (--J >= 0)
              if (typeof this.prerelease[J] === "number")
                (this.prerelease[J]++, (J = -2));
            if (J === -1) {
              if (Y === this.prerelease.join(".") && Q === !1)
                throw Error(
                  "invalid increment argument: identifier already exists"
                );
              this.prerelease.push(G);
            }
          }
          if (Y) {
            let J = [Y, G];
            if (Q === !1) J = [Y];
            if (Jq(this.prerelease[0], Y) === 0) {
              if (isNaN(this.prerelease[1])) this.prerelease = J;
            } else this.prerelease = J;
          }
          break;
        }
        default:
          throw Error(`invalid increment argument: ${X}`);
      }
      if (((this.raw = this.format()), this.build.length))
        this.raw += `+${this.build.join(".")}`;
      return this;
    }
  }
  _T.exports = s8;
});
var hT = s((BV0, xT) => {
  var fT = tH(),
    B80 = (X, Y, Q = !1) => {
      if (X instanceof fT) return X;
      try {
        return new fT(X, Y);
      } catch (G) {
        if (!Q) return null;
        throw G;
      }
    };
  xT.exports = B80;
});
var uT = s((KV0, gT) => {
  var K80 = tH(),
    V80 = hT(),
    { safeRe: eH, t: X$ } = Gq(),
    F80 = (X, Y) => {
      if (X instanceof K80) return X;
      if (typeof X === "number") X = String(X);
      if (typeof X !== "string") return null;
      Y = Y || {};
      let Q = null;
      if (!Y.rtl)
        Q = X.match(Y.includePrerelease ? eH[X$.COERCEFULL] : eH[X$.COERCE]);
      else {
        let K = Y.includePrerelease ? eH[X$.COERCERTLFULL] : eH[X$.COERCERTL],
          V;
        while ((V = K.exec(X)) && (!Q || Q.index + Q[0].length !== X.length)) {
          if (!Q || V.index + V[0].length !== Q.index + Q[0].length) Q = V;
          K.lastIndex = V.index + V[1].length + V[2].length;
        }
        K.lastIndex = -1;
      }
      if (Q === null) return null;
      let G = Q[2],
        J = Q[3] || "0",
        U = Q[4] || "0",
        $ = Y.includePrerelease && Q[5] ? `-${Q[5]}` : "",
        B = Y.includePrerelease && Q[6] ? `+${Q[6]}` : "";
      return V80(`${G}.${J}.${U}${$}${B}`, Y);
    };
  gT.exports = F80;
});
var cT = s((VV0, mT) => {
  var lT = tH(),
    N80 = (X, Y, Q) => new lT(X, Q).compare(new lT(Y, Q));
  mT.exports = N80;
});
var pT = s((FV0, dT) => {
  var M80 = cT(),
    A80 = (X, Y, Q) => M80(X, Y, Q) >= 0;
  dT.exports = A80;
});
var aT = s((NV0, nT) => {
  var iT = () => process.platform === "linux",
    Y$ = null,
    q80 = () => {
      if (!Y$)
        if (iT() && process.report) {
          let X = process.report.excludeNetwork;
          ((process.report.excludeNetwork = !0),
            (Y$ = process.report.getReport()),
            (process.report.excludeNetwork = X));
        } else Y$ = {};
      return Y$;
    };
  nT.exports = { isLinux: iT, getReport: q80 };
});
var oT = s((MV0, rT) => {
  var n7 = k1("fs"),
    R80 = (X) => {
      let Y = n7.openSync(X, "r"),
        Q = Buffer.alloc(2048),
        G = n7.readSync(Y, Q, 0, 2048, 0);
      return (n7.close(Y, () => {}), Q.subarray(0, G));
    },
    D80 = (X) =>
      new Promise((Y, Q) => {
        n7.open(X, "r", (G, J) => {
          if (G) Q(G);
          else {
            let U = Buffer.alloc(2048);
            n7.read(J, U, 0, 2048, 0, ($, B) => {
              (Y(U.subarray(0, B)), n7.close(J, () => {}));
            });
          }
        });
      });
  rT.exports = {
    LDD_PATH: "/usr/bin/ldd",
    SELF_PATH: "/proc/self/exe",
    readFileSync: R80,
    readFile: D80,
  };
});
var tT = s((AV0, sT) => {
  var z80 = (X) => {
    if (X.length < 64) return null;
    if (X.readUInt32BE(0) !== 2135247942) return null;
    if (X.readUInt8(4) !== 2) return null;
    if (X.readUInt8(5) !== 1) return null;
    let Y = X.readUInt32LE(32),
      Q = X.readUInt16LE(54),
      G = X.readUInt16LE(56);
    for (let J = 0; J < G; J++) {
      let U = Y + J * Q;
      if (X.readUInt32LE(U) === 3) {
        let B = X.readUInt32LE(U + 8),
          K = X.readUInt32LE(U + 32);
        return X.subarray(B, B + K)
          .toString()
          .replace(/\0.*$/g, "");
      }
    }
    return null;
  };
  sT.exports = { interpreterPath: z80 };
});
var $q = s((qV0, Mb) => {
  var Xb = k1("child_process"),
    { isLinux: a7, getReport: Yb } = aT(),
    { LDD_PATH: Q$, SELF_PATH: Qb, readFile: Wq, readFileSync: Hq } = oT(),
    { interpreterPath: Gb } = tT(),
    c6,
    d6,
    p6,
    L9 = "",
    Jb = () => {
      if (!L9)
        return new Promise((X) => {
          Xb.exec(
            "getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",
            (Y, Q) => {
              ((L9 = Y ? " " : Q), X(L9));
            }
          );
        });
      return L9;
    },
    Wb = () => {
      if (!L9)
        try {
          L9 = Xb.execSync(
            "getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",
            { encoding: "utf8" }
          );
        } catch (X) {
          L9 = " ";
        }
      return L9;
    },
    O4 = "glibc",
    Hb = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i,
    qX = "musl",
    E80 = (X) => X.includes("libc.musl-") || X.includes("ld-musl-"),
    $b = () => {
      let X = Yb();
      if (X.header && X.header.glibcVersionRuntime) return O4;
      if (Array.isArray(X.sharedObjects)) {
        if (X.sharedObjects.some(E80)) return qX;
      }
      return null;
    },
    Ub = (X) => {
      let [Y, Q] = X.split(/[\r\n]+/);
      if (Y && Y.includes(O4)) return O4;
      if (Q && Q.includes(qX)) return qX;
      return null;
    },
    Lb = (X) => {
      if (X) {
        if (X.includes("/ld-musl-")) return qX;
        else if (X.includes("/ld-linux-")) return O4;
      }
      return null;
    },
    Bb = (X) => {
      if (((X = X.toString()), X.includes("musl"))) return qX;
      if (X.includes("GNU C Library")) return O4;
      return null;
    },
    O80 = async () => {
      if (d6 !== void 0) return d6;
      d6 = null;
      try {
        let X = await Wq(Q$);
        d6 = Bb(X);
      } catch (X) {}
      return d6;
    },
    Z80 = () => {
      if (d6 !== void 0) return d6;
      d6 = null;
      try {
        let X = Hq(Q$);
        d6 = Bb(X);
      } catch (X) {}
      return d6;
    },
    j80 = async () => {
      if (c6 !== void 0) return c6;
      c6 = null;
      try {
        let X = await Wq(Qb),
          Y = Gb(X);
        c6 = Lb(Y);
      } catch (X) {}
      return c6;
    },
    w80 = () => {
      if (c6 !== void 0) return c6;
      c6 = null;
      try {
        let X = Hq(Qb),
          Y = Gb(X);
        c6 = Lb(Y);
      } catch (X) {}
      return c6;
    },
    Kb = async () => {
      let X = null;
      if (a7()) {
        if (((X = await j80()), !X)) {
          if (((X = await O80()), !X)) X = $b();
          if (!X) {
            let Y = await Jb();
            X = Ub(Y);
          }
        }
      }
      return X;
    },
    Vb = () => {
      let X = null;
      if (a7()) {
        if (((X = w80()), !X)) {
          if (((X = Z80()), !X)) X = $b();
          if (!X) {
            let Y = Wb();
            X = Ub(Y);
          }
        }
      }
      return X;
    },
    C80 = async () => a7() && (await Kb()) !== O4,
    I80 = () => a7() && Vb() !== O4,
    P80 = async () => {
      if (p6 !== void 0) return p6;
      p6 = null;
      try {
        let Y = (await Wq(Q$)).match(Hb);
        if (Y) p6 = Y[1];
      } catch (X) {}
      return p6;
    },
    S80 = () => {
      if (p6 !== void 0) return p6;
      p6 = null;
      try {
        let Y = Hq(Q$).match(Hb);
        if (Y) p6 = Y[1];
      } catch (X) {}
      return p6;
    },
    Fb = () => {
      let X = Yb();
      if (X.header && X.header.glibcVersionRuntime)
        return X.header.glibcVersionRuntime;
      return null;
    },
    eT = (X) => X.trim().split(/\s+/)[1],
    Nb = (X) => {
      let [Y, Q, G] = X.split(/[\r\n]+/);
      if (Y && Y.includes(O4)) return eT(Y);
      if (Q && G && Q.includes(qX)) return eT(G);
      return null;
    },
    T80 = async () => {
      let X = null;
      if (a7()) {
        if (((X = await P80()), !X)) X = Fb();
        if (!X) {
          let Y = await Jb();
          X = Nb(Y);
        }
      }
      return X;
    },
    b80 = () => {
      let X = null;
      if (a7()) {
        if (((X = S80()), !X)) X = Fb();
        if (!X) {
          let Y = Wb();
          X = Nb(Y);
        }
      }
      return X;
    };
  Mb.exports = {
    GLIBC: O4,
    MUSL: qX,
    family: Kb,
    familySync: Vb,
    isNonGlibcLinux: C80,
    isNonGlibcLinuxSync: I80,
    version: T80,
    versionSync: b80,
  };
});
var J$ = s((RV0, Ab) => {
  var Uq = $q(),
    G$ = process.env;
  Ab.exports = function () {
    let X = G$.npm_config_arch || process.arch,
      Y = G$.npm_config_platform || process.platform,
      Q =
        process.env.npm_config_libc ||
        (Uq.isNonGlibcLinuxSync() ? Uq.familySync() : ""),
      G = Y !== "linux" || Q === Uq.GLIBC ? "" : Q,
      J = [`${Y}${G}`];
    if (X === "arm") {
      let U = process.versions.electron ? "7" : "6";
      J.push(
        `armv${G$.npm_config_arm_version || process.config.variables.arm_version || U}`
      );
    } else if (X === "arm64")
      J.push(`arm64v${G$.npm_config_arm_version || "8"}`);
    else J.push(X);
    return J.join("-");
  };
});
var Lq = s((DV0, v80) => {
  v80.exports = {
    name: "sharp",
    description:
      "High performance Node.js image processing, the fastest module to resize JPEG, PNG, WebP, GIF, AVIF and TIFF images",
    version: "0.32.6",
    author: "Lovell Fuller <npm@lovell.info>",
    homepage: "https://github.com/lovell/sharp",
    contributors: [
      "Pierre Inglebert <pierre.inglebert@gmail.com>",
      "Jonathan Ong <jonathanrichardong@gmail.com>",
      "Chanon Sajjamanochai <chanon.s@gmail.com>",
      "Juliano Julio <julianojulio@gmail.com>",
      "Daniel Gasienica <daniel@gasienica.ch>",
      "Julian Walker <julian@fiftythree.com>",
      "Amit Pitaru <pitaru.amit@gmail.com>",
      "Brandon Aaron <hello.brandon@aaron.sh>",
      "Andreas Lind <andreas@one.com>",
      "Maurus Cuelenaere <mcuelenaere@gmail.com>",
      "Linus Unneb\xE4ck <linus@folkdatorn.se>",
      "Victor Mateevitsi <mvictoras@gmail.com>",
      "Alaric Holloway <alaric.holloway@gmail.com>",
      "Bernhard K. Weisshuhn <bkw@codingforce.com>",
      "Chris Riley <criley@primedia.com>",
      "David Carley <dacarley@gmail.com>",
      "John Tobin <john@limelightmobileinc.com>",
      "Kenton Gray <kentongray@gmail.com>",
      "Felix B\xFCnemann <Felix.Buenemann@gmail.com>",
      "Samy Al Zahrani <samyalzahrany@gmail.com>",
      "Chintan Thakkar <lemnisk8@gmail.com>",
      "F. Orlando Galashan <frulo@gmx.de>",
      "Kleis Auke Wolthuizen <info@kleisauke.nl>",
      "Matt Hirsch <mhirsch@media.mit.edu>",
      "Matthias Thoemmes <thoemmes@gmail.com>",
      "Patrick Paskaris <patrick@paskaris.gr>",
      "J\xE9r\xE9my Lal <kapouer@melix.org>",
      "Rahul Nanwani <r.nanwani@gmail.com>",
      "Alice Monday <alice0meta@gmail.com>",
      "Kristo Jorgenson <kristo.jorgenson@gmail.com>",
      "YvesBos <yves_bos@outlook.com>",
      "Guy Maliar <guy@tailorbrands.com>",
      "Nicolas Coden <nicolas@ncoden.fr>",
      "Matt Parrish <matt.r.parrish@gmail.com>",
      "Marcel Bretschneider <marcel.bretschneider@gmail.com>",
      "Matthew McEachen <matthew+github@mceachen.org>",
      "Jarda Kot\u011B\u0161ovec <jarda.kotesovec@gmail.com>",
      "Kenric D'Souza <kenric.dsouza@gmail.com>",
      "Oleh Aleinyk <oleg.aleynik@gmail.com>",
      "Marcel Bretschneider <marcel.bretschneider@gmail.com>",
      "Andrea Bianco <andrea.bianco@unibas.ch>",
      "Rik Heywood <rik@rik.org>",
      "Thomas Parisot <hi@oncletom.io>",
      "Nathan Graves <nathanrgraves+github@gmail.com>",
      "Tom Lokhorst <tom@lokhorst.eu>",
      "Espen Hovlandsdal <espen@hovlandsdal.com>",
      "Sylvain Dumont <sylvain.dumont35@gmail.com>",
      "Alun Davies <alun.owain.davies@googlemail.com>",
      "Aidan Hoolachan <ajhoolachan21@gmail.com>",
      "Axel Eirola <axel.eirola@iki.fi>",
      "Freezy <freezy@xbmc.org>",
      "Daiz <taneli.vatanen@gmail.com>",
      "Julian Aubourg <j@ubourg.net>",
      "Keith Belovay <keith@picthrive.com>",
      "Michael B. Klein <mbklein@gmail.com>",
      "Jordan Prudhomme <jordan@raboland.fr>",
      "Ilya Ovdin <iovdin@gmail.com>",
      "Andargor <andargor@yahoo.com>",
      "Paul Neave <paul.neave@gmail.com>",
      "Brendan Kennedy <brenwken@gmail.com>",
      "Brychan Bennett-Odlum <git@brychan.io>",
      "Edward Silverton <e.silverton@gmail.com>",
      "Roman Malieiev <aromaleev@gmail.com>",
      "Tomas Szabo <tomas.szabo@deftomat.com>",
      "Robert O'Rourke <robert@o-rourke.org>",
      "Guillermo Alfonso Varela Chouci\xF1o <guillevch@gmail.com>",
      "Christian Flintrup <chr@gigahost.dk>",
      "Manan Jadhav <manan@motionden.com>",
      "Leon Radley <leon@radley.se>",
      "alza54 <alza54@thiocod.in>",
      "Jacob Smith <jacob@frende.me>",
      "Michael Nutt <michael@nutt.im>",
      "Brad Parham <baparham@gmail.com>",
      "Taneli Vatanen <taneli.vatanen@gmail.com>",
      "Joris Dugu\xE9 <zaruike10@gmail.com>",
      "Chris Banks <christopher.bradley.banks@gmail.com>",
      "Ompal Singh <ompal.hitm09@gmail.com>",
      "Brodan <christopher.hranj@gmail.com",
      "Ankur Parihar <ankur.github@gmail.com>",
      "Brahim Ait elhaj <brahima@gmail.com>",
      "Mart Jansink <m.jansink@gmail.com>",
      "Lachlan Newman <lachnewman007@gmail.com>",
    ],
    scripts: {
      install:
        "(node install/libvips && node install/dll-copy && prebuild-install) || (node install/can-compile && node-gyp rebuild && node install/dll-copy)",
      clean:
        "rm -rf node_modules/ build/ vendor/ .nyc_output/ coverage/ test/fixtures/output.*",
      test: "npm run test-lint && npm run test-unit && npm run test-licensing && npm run test-types",
      "test-lint": "semistandard && cpplint",
      "test-unit":
        "nyc --reporter=lcov --reporter=text --check-coverage --branches=100 mocha",
      "test-licensing":
        'license-checker --production --summary --onlyAllow="Apache-2.0;BSD;ISC;MIT"',
      "test-leak": "./test/leak/leak.sh",
      "test-types": "tsd",
      "docs-build": "node docs/build && node docs/search-index/build",
      "docs-serve": "cd docs && npx serve",
      "docs-publish":
        "cd docs && npx firebase-tools deploy --project pixelplumbing --only hosting:pixelplumbing-sharp",
    },
    main: "lib/index.js",
    types: "lib/index.d.ts",
    files: ["binding.gyp", "install/**", "lib/**", "src/**"],
    repository: { type: "git", url: "git://github.com/lovell/sharp" },
    keywords: [
      "jpeg",
      "png",
      "webp",
      "avif",
      "tiff",
      "gif",
      "svg",
      "jp2",
      "dzi",
      "image",
      "resize",
      "thumbnail",
      "crop",
      "embed",
      "libvips",
      "vips",
    ],
    dependencies: {
      color: "^4.2.3",
      "detect-libc": "^2.0.2",
      "node-addon-api": "^6.1.0",
      "prebuild-install": "^7.1.1",
      semver: "^7.5.4",
      "simple-get": "^4.0.1",
      "tar-fs": "^3.0.4",
      "tunnel-agent": "^0.6.0",
    },
    devDependencies: {
      "@types/node": "*",
      async: "^3.2.4",
      cc: "^3.0.1",
      "exif-reader": "^1.2.0",
      "extract-zip": "^2.0.1",
      icc: "^3.0.0",
      "jsdoc-to-markdown": "^8.0.0",
      "license-checker": "^25.0.1",
      mocha: "^10.2.0",
      "mock-fs": "^5.2.0",
      nyc: "^15.1.0",
      prebuild: "^12.0.0",
      semistandard: "^16.0.1",
      tsd: "^0.29.0",
    },
    license: "Apache-2.0",
    config: {
      libvips: "8.14.5",
      integrity: {
        "darwin-arm64v8":
          "sha512-1QZzICfCJd4wAO0P6qmYI5e5VFMt9iCE4QgefI8VMMbdSzjIXA9L/ARN6pkMQPZ3h20Y9RtJ2W1skgCsvCIccw==",
        "darwin-x64":
          "sha512-sMIKMYXsdU9FlIfztj6Kt/SfHlhlDpP0Ups7ftVFqwjaszmYmpI9y/d/q3mLb4jrzuSiSUEislSWCwBnW7MPTw==",
        "linux-arm64v8":
          "sha512-CD8owELzkDumaom+O3jJ8fKamILAQdj+//KK/VNcHK3sngUcFpdjx36C8okwbux9sml/T7GTB/gzpvReDrAejQ==",
        "linux-armv6":
          "sha512-wk6IPHatDFVWKJy7lI1TJezHGHPQut1wF2bwx256KlZwXUQU3fcVcMpV1zxXjgLFewHq2+uhyMkoSGBPahWzlA==",
        "linux-armv7":
          "sha512-HEZC9KYtkmBK5rUR2MqBhrVarnQVZ/TwLUeLkKq0XuoM2pc/eXI6N0Fh5NGEFwdXI2XE8g1ySf+OYS6DDi+xCQ==",
        "linux-x64":
          "sha512-SlFWrITSW5XVUkaFPQOySAaSGXnhkGJCj8X2wGYYta9hk5piZldQyMp4zwy0z6UeRu1qKTKtZvmq28W3Gnh9xA==",
        "linuxmusl-arm64v8":
          "sha512-ga9iX7WUva3sG/VsKkOD318InLlCfPIztvzCZKZ2/+izQXRbQi8VoXWMHgEN4KHACv45FTl7mJ/8CRqUzhS8wQ==",
        "linuxmusl-x64":
          "sha512-yeaHnpfee1hrZLok2l4eFceHzlfq8gN3QOu0R4Mh8iMK5O5vAUu97bdtxeZZeJJvHw8tfh2/msGi0qysxKN8bw==",
        "win32-arm64v8":
          "sha512-kR91hy9w1+GEXK56hLh51+hBCBo7T+ijM4Slkmvb/2PsYZySq5H7s61n99iDYl6kTJP2y9sW5Xcvm3uuXDaDgg==",
        "win32-ia32":
          "sha512-HrnofEbzHNpHJ0vVnjsTj5yfgVdcqdWshXuwFO2zc8xlEjA83BvXZ0lVj9MxPxkxJ2ta+/UlLr+CFzc5bOceMw==",
        "win32-x64":
          "sha512-BwKckinJZ0Fu/EcunqiLPwOLEBWp4xf8GV7nvmVuKKz5f6B+GxoA2k9aa2wueqv4r4RJVgV/aWXZWFKOIjre/Q==",
      },
      runtime: "napi",
      target: 7,
    },
    engines: { node: ">=14.15.0" },
    funding: { url: "https://opencollective.com/libvips" },
    binary: { napi_versions: [7] },
    semistandard: { env: ["mocha"] },
    cc: { linelength: "120", filter: ["build/include"] },
    tsd: { directory: "test/types/" },
  };
});
var jb = s((zV0, Zb) => {
  var __dirname =
      "/Users/kazuto/Desktop/claude-cnthub/node_modules/.bun/sharp@0.32.6/node_modules/sharp/lib",
    Kq = k1("fs"),
    k80 = k1("os"),
    W$ = k1("path"),
    Vq = k1("child_process").spawnSync,
    y80 = uT(),
    _80 = pT(),
    f80 = J$(),
    { config: qb } = Lq(),
    B9 = process.env,
    Rb = B9.npm_package_config_libvips || qb.libvips,
    Fq = y80(Rb).version,
    Nq = { encoding: "utf8", shell: !0 },
    Db = W$.join(__dirname, "..", "vendor", Fq, f80()),
    Bq = function (X) {
      try {
        Kq.mkdirSync(X, { recursive: !0 });
      } catch (Y) {
        if (Y.code !== "EEXIST") throw Y;
      }
    },
    x80 = function () {
      let X =
        B9.npm_config_cache ||
        (B9.APPDATA
          ? W$.join(B9.APPDATA, "npm-cache")
          : W$.join(k80.homedir(), ".npm"));
      Bq(X);
      let Y = W$.join(X, "_libvips");
      return (Bq(Y), Y);
    },
    h80 = function (X) {
      return (
        B9[`npm_package_config_integrity_${X.replace("-", "_")}`] ||
        qb.integrity[X]
      );
    },
    zb = function (X) {
      if (X instanceof Error)
        console.error(`sharp: Installation error: ${X.message}`);
      else console.log(`sharp: ${X}`);
    },
    g80 = function () {
      if (process.platform === "darwin" && process.arch === "x64")
        return (
          (Vq("sysctl sysctl.proc_translated", Nq).stdout || "").trim() ===
          "sysctl.proc_translated: 1"
        );
      return !1;
    },
    Eb = function () {
      if (process.platform !== "win32")
        return (
          Vq("pkg-config --modversion vips-cpp", {
            ...Nq,
            env: { ...B9, PKG_CONFIG_PATH: Ob() },
          }).stdout || ""
        ).trim();
      else return "";
    },
    u80 = function () {
      return Kq.existsSync(Db);
    },
    l80 = function () {
      Kq.rmSync(Db, { recursive: !0, maxRetries: 3, force: !0 });
    },
    Ob = function () {
      if (process.platform !== "win32")
        return [
          (
            Vq(
              'which brew >/dev/null 2>&1 && brew environment --plain | grep PKG_CONFIG_LIBDIR | cut -d" " -f2',
              Nq
            ).stdout || ""
          ).trim(),
          B9.PKG_CONFIG_PATH,
          "/usr/local/lib/pkgconfig",
          "/usr/lib/pkgconfig",
          "/usr/local/libdata/pkgconfig",
          "/usr/libdata/pkgconfig",
        ]
          .filter(Boolean)
          .join(":");
      else return "";
    },
    m80 = function () {
      if (Boolean(B9.SHARP_IGNORE_GLOBAL_LIBVIPS) === !0) return !1;
      if (g80())
        return (
          zb(
            "Detected Rosetta, skipping search for globally-installed libvips"
          ),
          !1
        );
      let X = Eb();
      return !!X && _80(X, Fq);
    };
  Zb.exports = {
    minimumLibvipsVersion: Fq,
    minimumLibvipsVersionLabelled: Rb,
    cachePath: x80,
    integrity: h80,
    log: zb,
    globalLibvipsVersion: Eb,
    hasVendoredLibvips: u80,
    removeVendoredLibvips: l80,
    pkgConfigPath: Ob,
    useGlobalLibvips: m80,
    mkdirSync: Bq,
  };
});
var pQ = s((EV0, wb) => {
  var Mq = J$()();
  try {
    wb.exports = k1(`../build/Release/sharp-${Mq}.node`);
  } catch (X) {
    let Y = [
      "",
      'Something went wrong installing the "sharp" module',
      "",
      X.message,
      "",
      "Possible solutions:",
    ];
    if (
      /dylib/.test(X.message) &&
      /Incompatible library version/.test(X.message)
    )
      Y.push('- Update Homebrew: "brew update && brew upgrade vips"');
    else {
      let [Q, G] = Mq.split("-");
      if (Q === "linux" && /Module did not self-register/.test(X.message))
        Y.push(
          "- Using worker threads? See https://sharp.pixelplumbing.com/install#worker-threads"
        );
      Y.push(
        '- Install with verbose logging and look for errors: "npm install --ignore-scripts=false --foreground-scripts --verbose sharp"',
        `- Install for the current ${Mq} runtime: "npm install --platform=${Q} --arch=${G} sharp"`
      );
    }
    if (
      (Y.push(
        "- Consult the installation documentation: https://sharp.pixelplumbing.com/install"
      ),
      process.platform === "win32" || /symbol/.test(X.message))
    ) {
      let Q = Object.keys(k1.cache).find((G) =>
        /[\\/]build[\\/]Release[\\/]sharp(.*)\.node$/.test(G)
      );
      if (Q) {
        let [, G] = Q.match(/node_modules[\\/]([^\\/]+)[\\/]/);
        Y.push(
          `- Ensure the version of sharp aligns with the ${G} package: "npm ls sharp"`
        );
      }
    }
    throw Error(
      Y.join(`
`)
    );
  }
});
var Ib = s((ZV0, Cb) => {
  var c80 = k1("util"),
    Aq = k1("stream"),
    d80 = l6();
  jb().hasVendoredLibvips();
  pQ();
  var p80 = c80.debuglog("sharp"),
    RX = function (X, Y) {
      if (arguments.length === 1 && !d80.defined(X))
        throw Error("Invalid input");
      if (!(this instanceof RX)) return new RX(X, Y);
      return (
        Aq.Duplex.call(this),
        (this.options = {
          topOffsetPre: -1,
          leftOffsetPre: -1,
          widthPre: -1,
          heightPre: -1,
          topOffsetPost: -1,
          leftOffsetPost: -1,
          widthPost: -1,
          heightPost: -1,
          width: -1,
          height: -1,
          canvas: "crop",
          position: 0,
          resizeBackground: [0, 0, 0, 255],
          useExifOrientation: !1,
          angle: 0,
          rotationAngle: 0,
          rotationBackground: [0, 0, 0, 255],
          rotateBeforePreExtract: !1,
          flip: !1,
          flop: !1,
          extendTop: 0,
          extendBottom: 0,
          extendLeft: 0,
          extendRight: 0,
          extendBackground: [0, 0, 0, 255],
          extendWith: "background",
          withoutEnlargement: !1,
          withoutReduction: !1,
          affineMatrix: [],
          affineBackground: [0, 0, 0, 255],
          affineIdx: 0,
          affineIdy: 0,
          affineOdx: 0,
          affineOdy: 0,
          affineInterpolator: this.constructor.interpolators.bilinear,
          kernel: "lanczos3",
          fastShrinkOnLoad: !0,
          tintA: 128,
          tintB: 128,
          flatten: !1,
          flattenBackground: [0, 0, 0],
          unflatten: !1,
          negate: !1,
          negateAlpha: !0,
          medianSize: 0,
          blurSigma: 0,
          sharpenSigma: 0,
          sharpenM1: 1,
          sharpenM2: 2,
          sharpenX1: 2,
          sharpenY2: 10,
          sharpenY3: 20,
          threshold: 0,
          thresholdGrayscale: !0,
          trimBackground: [],
          trimThreshold: 0,
          gamma: 0,
          gammaOut: 0,
          greyscale: !1,
          normalise: !1,
          normaliseLower: 1,
          normaliseUpper: 99,
          claheWidth: 0,
          claheHeight: 0,
          claheMaxSlope: 3,
          brightness: 1,
          saturation: 1,
          hue: 0,
          lightness: 0,
          booleanBufferIn: null,
          booleanFileIn: "",
          joinChannelIn: [],
          extractChannel: -1,
          removeAlpha: !1,
          ensureAlpha: -1,
          colourspace: "srgb",
          colourspaceInput: "last",
          composite: [],
          fileOut: "",
          formatOut: "input",
          streamOut: !1,
          withMetadata: !1,
          withMetadataOrientation: -1,
          withMetadataDensity: 0,
          withMetadataIcc: "",
          withMetadataStrs: {},
          resolveWithObject: !1,
          jpegQuality: 80,
          jpegProgressive: !1,
          jpegChromaSubsampling: "4:2:0",
          jpegTrellisQuantisation: !1,
          jpegOvershootDeringing: !1,
          jpegOptimiseScans: !1,
          jpegOptimiseCoding: !0,
          jpegQuantisationTable: 0,
          pngProgressive: !1,
          pngCompressionLevel: 6,
          pngAdaptiveFiltering: !1,
          pngPalette: !1,
          pngQuality: 100,
          pngEffort: 7,
          pngBitdepth: 8,
          pngDither: 1,
          jp2Quality: 80,
          jp2TileHeight: 512,
          jp2TileWidth: 512,
          jp2Lossless: !1,
          jp2ChromaSubsampling: "4:4:4",
          webpQuality: 80,
          webpAlphaQuality: 100,
          webpLossless: !1,
          webpNearLossless: !1,
          webpSmartSubsample: !1,
          webpPreset: "default",
          webpEffort: 4,
          webpMinSize: !1,
          webpMixed: !1,
          gifBitdepth: 8,
          gifEffort: 7,
          gifDither: 1,
          gifInterFrameMaxError: 0,
          gifInterPaletteMaxError: 3,
          gifReuse: !0,
          gifProgressive: !1,
          tiffQuality: 80,
          tiffCompression: "jpeg",
          tiffPredictor: "horizontal",
          tiffPyramid: !1,
          tiffBitdepth: 8,
          tiffTile: !1,
          tiffTileHeight: 256,
          tiffTileWidth: 256,
          tiffXres: 1,
          tiffYres: 1,
          tiffResolutionUnit: "inch",
          heifQuality: 50,
          heifLossless: !1,
          heifCompression: "av1",
          heifEffort: 4,
          heifChromaSubsampling: "4:4:4",
          jxlDistance: 1,
          jxlDecodingTier: 0,
          jxlEffort: 7,
          jxlLossless: !1,
          rawDepth: "uchar",
          tileSize: 256,
          tileOverlap: 0,
          tileContainer: "fs",
          tileLayout: "dz",
          tileFormat: "last",
          tileDepth: "last",
          tileAngle: 0,
          tileSkipBlanks: -1,
          tileBackground: [255, 255, 255, 255],
          tileCentre: !1,
          tileId: "https://example.com/iiif",
          tileBasename: "",
          timeoutSeconds: 0,
          linearA: [],
          linearB: [],
          debuglog: (Q) => {
            (this.emit("warning", Q), p80(Q));
          },
          queueListener: function (Q) {
            RX.queue.emit("change", Q);
          },
        }),
        (this.options.input = this._createInputDescriptor(X, Y, {
          allowStream: !0,
        })),
        this
      );
    };
  Object.setPrototypeOf(RX.prototype, Aq.Duplex.prototype);
  Object.setPrototypeOf(RX, Aq.Duplex);
  function i80() {
    let X = this.constructor.call();
    if (((X.options = Object.assign({}, this.options)), this._isStreamInput()))
      this.on("finish", () => {
        (this._flattenBufferIn(),
          (X.options.bufferIn = this.options.bufferIn),
          X.emit("finish"));
      });
    return X;
  }
  Object.assign(RX.prototype, { clone: i80 });
  Cb.exports = RX;
});
var qq = s((jV0, Pb) => {
  Pb.exports = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  };
});
var Tb = s((wV0, Sb) => {
  Sb.exports = function (Y) {
    if (!Y || typeof Y === "string") return !1;
    return (
      Y instanceof Array ||
      Array.isArray(Y) ||
      (Y.length >= 0 &&
        (Y.splice instanceof Function ||
          (Object.getOwnPropertyDescriptor(Y, Y.length - 1) &&
            Y.constructor.name !== "String")))
    );
  };
});
var kb = s((CV0, vb) => {
  var n80 = Tb(),
    a80 = Array.prototype.concat,
    r80 = Array.prototype.slice,
    bb = (vb.exports = function (Y) {
      var Q = [];
      for (var G = 0, J = Y.length; G < J; G++) {
        var U = Y[G];
        if (n80(U)) Q = a80.call(Q, r80.call(U));
        else Q.push(U);
      }
      return Q;
    });
  bb.wrap = function (X) {
    return function () {
      return X(bb(arguments));
    };
  };
});
var xb = s((IV0, fb) => {
  var nQ = qq(),
    aQ = kb(),
    yb = Object.hasOwnProperty,
    _b = Object.create(null);
  for (iQ in nQ) if (yb.call(nQ, iQ)) _b[nQ[iQ]] = iQ;
  var iQ,
    O8 = (fb.exports = { to: {}, get: {} });
  O8.get = function (X) {
    var Y = X.substring(0, 3).toLowerCase(),
      Q,
      G;
    switch (Y) {
      case "hsl":
        ((Q = O8.get.hsl(X)), (G = "hsl"));
        break;
      case "hwb":
        ((Q = O8.get.hwb(X)), (G = "hwb"));
        break;
      default:
        ((Q = O8.get.rgb(X)), (G = "rgb"));
        break;
    }
    if (!Q) return null;
    return { model: G, value: Q };
  };
  O8.get.rgb = function (X) {
    if (!X) return null;
    var Y = /^#([a-f0-9]{3,4})$/i,
      Q = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i,
      G =
        /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,
      J =
        /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/,
      U = /^(\w+)$/,
      $ = [0, 0, 0, 1],
      B,
      K,
      V;
    if ((B = X.match(Q))) {
      ((V = B[2]), (B = B[1]));
      for (K = 0; K < 3; K++) {
        var W = K * 2;
        $[K] = parseInt(B.slice(W, W + 2), 16);
      }
      if (V) $[3] = parseInt(V, 16) / 255;
    } else if ((B = X.match(Y))) {
      ((B = B[1]), (V = B[3]));
      for (K = 0; K < 3; K++) $[K] = parseInt(B[K] + B[K], 16);
      if (V) $[3] = parseInt(V + V, 16) / 255;
    } else if ((B = X.match(G))) {
      for (K = 0; K < 3; K++) $[K] = parseInt(B[K + 1], 0);
      if (B[4])
        if (B[5]) $[3] = parseFloat(B[4]) * 0.01;
        else $[3] = parseFloat(B[4]);
    } else if ((B = X.match(J))) {
      for (K = 0; K < 3; K++) $[K] = Math.round(parseFloat(B[K + 1]) * 2.55);
      if (B[4])
        if (B[5]) $[3] = parseFloat(B[4]) * 0.01;
        else $[3] = parseFloat(B[4]);
    } else if ((B = X.match(U))) {
      if (B[1] === "transparent") return [0, 0, 0, 0];
      if (!yb.call(nQ, B[1])) return null;
      return (($ = nQ[B[1]]), ($[3] = 1), $);
    } else return null;
    for (K = 0; K < 3; K++) $[K] = K9($[K], 0, 255);
    return (($[3] = K9($[3], 0, 1)), $);
  };
  O8.get.hsl = function (X) {
    if (!X) return null;
    var Y =
        /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,
      Q = X.match(Y);
    if (Q) {
      var G = parseFloat(Q[4]),
        J = ((parseFloat(Q[1]) % 360) + 360) % 360,
        U = K9(parseFloat(Q[2]), 0, 100),
        $ = K9(parseFloat(Q[3]), 0, 100),
        B = K9(isNaN(G) ? 1 : G, 0, 1);
      return [J, U, $, B];
    }
    return null;
  };
  O8.get.hwb = function (X) {
    if (!X) return null;
    var Y =
        /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/,
      Q = X.match(Y);
    if (Q) {
      var G = parseFloat(Q[4]),
        J = ((parseFloat(Q[1]) % 360) + 360) % 360,
        U = K9(parseFloat(Q[2]), 0, 100),
        $ = K9(parseFloat(Q[3]), 0, 100),
        B = K9(isNaN(G) ? 1 : G, 0, 1);
      return [J, U, $, B];
    }
    return null;
  };
  O8.to.hex = function () {
    var X = aQ(arguments);
    return (
      "#" +
      H$(X[0]) +
      H$(X[1]) +
      H$(X[2]) +
      (X[3] < 1 ? H$(Math.round(X[3] * 255)) : "")
    );
  };
  O8.to.rgb = function () {
    var X = aQ(arguments);
    return X.length < 4 || X[3] === 1
      ? "rgb(" +
          Math.round(X[0]) +
          ", " +
          Math.round(X[1]) +
          ", " +
          Math.round(X[2]) +
          ")"
      : "rgba(" +
          Math.round(X[0]) +
          ", " +
          Math.round(X[1]) +
          ", " +
          Math.round(X[2]) +
          ", " +
          X[3] +
          ")";
  };
  O8.to.rgb.percent = function () {
    var X = aQ(arguments),
      Y = Math.round((X[0] / 255) * 100),
      Q = Math.round((X[1] / 255) * 100),
      G = Math.round((X[2] / 255) * 100);
    return X.length < 4 || X[3] === 1
      ? "rgb(" + Y + "%, " + Q + "%, " + G + "%)"
      : "rgba(" + Y + "%, " + Q + "%, " + G + "%, " + X[3] + ")";
  };
  O8.to.hsl = function () {
    var X = aQ(arguments);
    return X.length < 4 || X[3] === 1
      ? "hsl(" + X[0] + ", " + X[1] + "%, " + X[2] + "%)"
      : "hsla(" + X[0] + ", " + X[1] + "%, " + X[2] + "%, " + X[3] + ")";
  };
  O8.to.hwb = function () {
    var X = aQ(arguments),
      Y = "";
    if (X.length >= 4 && X[3] !== 1) Y = ", " + X[3];
    return "hwb(" + X[0] + ", " + X[1] + "%, " + X[2] + "%" + Y + ")";
  };
  O8.to.keyword = function (X) {
    return _b[X.slice(0, 3)];
  };
  function K9(X, Y, Q) {
    return Math.min(Math.max(Y, X), Q);
  }
  function H$(X) {
    var Y = Math.round(X).toString(16).toUpperCase();
    return Y.length < 2 ? "0" + Y : Y;
  }
});
var Rq = s((PV0, gb) => {
  var rQ = qq(),
    hb = {};
  for (let X of Object.keys(rQ)) hb[rQ[X]] = X;
  var g0 = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] },
  };
  gb.exports = g0;
  for (let X of Object.keys(g0)) {
    if (!("channels" in g0[X])) throw Error("missing channels property: " + X);
    if (!("labels" in g0[X]))
      throw Error("missing channel labels property: " + X);
    if (g0[X].labels.length !== g0[X].channels)
      throw Error("channel and label counts mismatch: " + X);
    let { channels: Y, labels: Q } = g0[X];
    (delete g0[X].channels,
      delete g0[X].labels,
      Object.defineProperty(g0[X], "channels", { value: Y }),
      Object.defineProperty(g0[X], "labels", { value: Q }));
  }
  g0.rgb.hsl = function (X) {
    let Y = X[0] / 255,
      Q = X[1] / 255,
      G = X[2] / 255,
      J = Math.min(Y, Q, G),
      U = Math.max(Y, Q, G),
      $ = U - J,
      B,
      K;
    if (U === J) B = 0;
    else if (Y === U) B = (Q - G) / $;
    else if (Q === U) B = 2 + (G - Y) / $;
    else if (G === U) B = 4 + (Y - Q) / $;
    if (((B = Math.min(B * 60, 360)), B < 0)) B += 360;
    let V = (J + U) / 2;
    if (U === J) K = 0;
    else if (V <= 0.5) K = $ / (U + J);
    else K = $ / (2 - U - J);
    return [B, K * 100, V * 100];
  };
  g0.rgb.hsv = function (X) {
    let Y,
      Q,
      G,
      J,
      U,
      $ = X[0] / 255,
      B = X[1] / 255,
      K = X[2] / 255,
      V = Math.max($, B, K),
      W = V - Math.min($, B, K),
      L = function (H) {
        return (V - H) / 6 / W + 0.5;
      };
    if (W === 0) ((J = 0), (U = 0));
    else {
      if (((U = W / V), (Y = L($)), (Q = L(B)), (G = L(K)), $ === V)) J = G - Q;
      else if (B === V) J = 0.3333333333333333 + Y - G;
      else if (K === V) J = 0.6666666666666666 + Q - Y;
      if (J < 0) J += 1;
      else if (J > 1) J -= 1;
    }
    return [J * 360, U * 100, V * 100];
  };
  g0.rgb.hwb = function (X) {
    let Y = X[0],
      Q = X[1],
      G = X[2],
      J = g0.rgb.hsl(X)[0],
      U = 0.00392156862745098 * Math.min(Y, Math.min(Q, G));
    return (
      (G = 1 - 0.00392156862745098 * Math.max(Y, Math.max(Q, G))),
      [J, U * 100, G * 100]
    );
  };
  g0.rgb.cmyk = function (X) {
    let Y = X[0] / 255,
      Q = X[1] / 255,
      G = X[2] / 255,
      J = Math.min(1 - Y, 1 - Q, 1 - G),
      U = (1 - Y - J) / (1 - J) || 0,
      $ = (1 - Q - J) / (1 - J) || 0,
      B = (1 - G - J) / (1 - J) || 0;
    return [U * 100, $ * 100, B * 100, J * 100];
  };
  function o80(X, Y) {
    return (X[0] - Y[0]) ** 2 + (X[1] - Y[1]) ** 2 + (X[2] - Y[2]) ** 2;
  }
  g0.rgb.keyword = function (X) {
    let Y = hb[X];
    if (Y) return Y;
    let Q = 1 / 0,
      G;
    for (let J of Object.keys(rQ)) {
      let U = rQ[J],
        $ = o80(X, U);
      if ($ < Q) ((Q = $), (G = J));
    }
    return G;
  };
  g0.keyword.rgb = function (X) {
    return rQ[X];
  };
  g0.rgb.xyz = function (X) {
    let Y = X[0] / 255,
      Q = X[1] / 255,
      G = X[2] / 255;
    ((Y = Y > 0.04045 ? ((Y + 0.055) / 1.055) ** 2.4 : Y / 12.92),
      (Q = Q > 0.04045 ? ((Q + 0.055) / 1.055) ** 2.4 : Q / 12.92),
      (G = G > 0.04045 ? ((G + 0.055) / 1.055) ** 2.4 : G / 12.92));
    let J = Y * 0.4124 + Q * 0.3576 + G * 0.1805,
      U = Y * 0.2126 + Q * 0.7152 + G * 0.0722,
      $ = Y * 0.0193 + Q * 0.1192 + G * 0.9505;
    return [J * 100, U * 100, $ * 100];
  };
  g0.rgb.lab = function (X) {
    let Y = g0.rgb.xyz(X),
      Q = Y[0],
      G = Y[1],
      J = Y[2];
    ((Q /= 95.047),
      (G /= 100),
      (J /= 108.883),
      (Q =
        Q > 0.008856
          ? Q ** 0.3333333333333333
          : 7.787 * Q + 0.13793103448275862),
      (G =
        G > 0.008856
          ? G ** 0.3333333333333333
          : 7.787 * G + 0.13793103448275862),
      (J =
        J > 0.008856
          ? J ** 0.3333333333333333
          : 7.787 * J + 0.13793103448275862));
    let U = 116 * G - 16,
      $ = 500 * (Q - G),
      B = 200 * (G - J);
    return [U, $, B];
  };
  g0.hsl.rgb = function (X) {
    let Y = X[0] / 360,
      Q = X[1] / 100,
      G = X[2] / 100,
      J,
      U,
      $;
    if (Q === 0) return (($ = G * 255), [$, $, $]);
    if (G < 0.5) J = G * (1 + Q);
    else J = G + Q - G * Q;
    let B = 2 * G - J,
      K = [0, 0, 0];
    for (let V = 0; V < 3; V++) {
      if (((U = Y + 0.3333333333333333 * -(V - 1)), U < 0)) U++;
      if (U > 1) U--;
      if (6 * U < 1) $ = B + (J - B) * 6 * U;
      else if (2 * U < 1) $ = J;
      else if (3 * U < 2) $ = B + (J - B) * (0.6666666666666666 - U) * 6;
      else $ = B;
      K[V] = $ * 255;
    }
    return K;
  };
  g0.hsl.hsv = function (X) {
    let Y = X[0],
      Q = X[1] / 100,
      G = X[2] / 100,
      J = Q,
      U = Math.max(G, 0.01);
    ((G *= 2), (Q *= G <= 1 ? G : 2 - G), (J *= U <= 1 ? U : 2 - U));
    let $ = (G + Q) / 2,
      B = G === 0 ? (2 * J) / (U + J) : (2 * Q) / (G + Q);
    return [Y, B * 100, $ * 100];
  };
  g0.hsv.rgb = function (X) {
    let Y = X[0] / 60,
      Q = X[1] / 100,
      G = X[2] / 100,
      J = Math.floor(Y) % 6,
      U = Y - Math.floor(Y),
      $ = 255 * G * (1 - Q),
      B = 255 * G * (1 - Q * U),
      K = 255 * G * (1 - Q * (1 - U));
    switch (((G *= 255), J)) {
      case 0:
        return [G, K, $];
      case 1:
        return [B, G, $];
      case 2:
        return [$, G, K];
      case 3:
        return [$, B, G];
      case 4:
        return [K, $, G];
      case 5:
        return [G, $, B];
    }
  };
  g0.hsv.hsl = function (X) {
    let Y = X[0],
      Q = X[1] / 100,
      G = X[2] / 100,
      J = Math.max(G, 0.01),
      U,
      $;
    $ = (2 - Q) * G;
    let B = (2 - Q) * J;
    return (
      (U = Q * J),
      (U /= B <= 1 ? B : 2 - B),
      (U = U || 0),
      ($ /= 2),
      [Y, U * 100, $ * 100]
    );
  };
  g0.hwb.rgb = function (X) {
    let Y = X[0] / 360,
      Q = X[1] / 100,
      G = X[2] / 100,
      J = Q + G,
      U;
    if (J > 1) ((Q /= J), (G /= J));
    let $ = Math.floor(6 * Y),
      B = 1 - G;
    if (((U = 6 * Y - $), ($ & 1) !== 0)) U = 1 - U;
    let K = Q + U * (B - Q),
      V,
      W,
      L;
    switch ($) {
      default:
      case 6:
      case 0:
        ((V = B), (W = K), (L = Q));
        break;
      case 1:
        ((V = K), (W = B), (L = Q));
        break;
      case 2:
        ((V = Q), (W = B), (L = K));
        break;
      case 3:
        ((V = Q), (W = K), (L = B));
        break;
      case 4:
        ((V = K), (W = Q), (L = B));
        break;
      case 5:
        ((V = B), (W = Q), (L = K));
        break;
    }
    return [V * 255, W * 255, L * 255];
  };
  g0.cmyk.rgb = function (X) {
    let Y = X[0] / 100,
      Q = X[1] / 100,
      G = X[2] / 100,
      J = X[3] / 100,
      U = 1 - Math.min(1, Y * (1 - J) + J),
      $ = 1 - Math.min(1, Q * (1 - J) + J),
      B = 1 - Math.min(1, G * (1 - J) + J);
    return [U * 255, $ * 255, B * 255];
  };
  g0.xyz.rgb = function (X) {
    let Y = X[0] / 100,
      Q = X[1] / 100,
      G = X[2] / 100,
      J,
      U,
      $;
    return (
      (J = Y * 3.2406 + Q * -1.5372 + G * -0.4986),
      (U = Y * -0.9689 + Q * 1.8758 + G * 0.0415),
      ($ = Y * 0.0557 + Q * -0.204 + G * 1.057),
      (J = J > 0.0031308 ? 1.055 * J ** 0.4166666666666667 - 0.055 : J * 12.92),
      (U = U > 0.0031308 ? 1.055 * U ** 0.4166666666666667 - 0.055 : U * 12.92),
      ($ = $ > 0.0031308 ? 1.055 * $ ** 0.4166666666666667 - 0.055 : $ * 12.92),
      (J = Math.min(Math.max(0, J), 1)),
      (U = Math.min(Math.max(0, U), 1)),
      ($ = Math.min(Math.max(0, $), 1)),
      [J * 255, U * 255, $ * 255]
    );
  };
  g0.xyz.lab = function (X) {
    let Y = X[0],
      Q = X[1],
      G = X[2];
    ((Y /= 95.047),
      (Q /= 100),
      (G /= 108.883),
      (Y =
        Y > 0.008856
          ? Y ** 0.3333333333333333
          : 7.787 * Y + 0.13793103448275862),
      (Q =
        Q > 0.008856
          ? Q ** 0.3333333333333333
          : 7.787 * Q + 0.13793103448275862),
      (G =
        G > 0.008856
          ? G ** 0.3333333333333333
          : 7.787 * G + 0.13793103448275862));
    let J = 116 * Q - 16,
      U = 500 * (Y - Q),
      $ = 200 * (Q - G);
    return [J, U, $];
  };
  g0.lab.xyz = function (X) {
    let Y = X[0],
      Q = X[1],
      G = X[2],
      J,
      U,
      $;
    ((U = (Y + 16) / 116), (J = Q / 500 + U), ($ = U - G / 200));
    let B = U ** 3,
      K = J ** 3,
      V = $ ** 3;
    return (
      (U = B > 0.008856 ? B : (U - 0.13793103448275862) / 7.787),
      (J = K > 0.008856 ? K : (J - 0.13793103448275862) / 7.787),
      ($ = V > 0.008856 ? V : ($ - 0.13793103448275862) / 7.787),
      (J *= 95.047),
      (U *= 100),
      ($ *= 108.883),
      [J, U, $]
    );
  };
  g0.lab.lch = function (X) {
    let Y = X[0],
      Q = X[1],
      G = X[2],
      J;
    if (((J = (Math.atan2(G, Q) * 360) / 2 / Math.PI), J < 0)) J += 360;
    let $ = Math.sqrt(Q * Q + G * G);
    return [Y, $, J];
  };
  g0.lch.lab = function (X) {
    let Y = X[0],
      Q = X[1],
      J = (X[2] / 360) * 2 * Math.PI,
      U = Q * Math.cos(J),
      $ = Q * Math.sin(J);
    return [Y, U, $];
  };
  g0.rgb.ansi16 = function (X, Y = null) {
    let [Q, G, J] = X,
      U = Y === null ? g0.rgb.hsv(X)[2] : Y;
    if (((U = Math.round(U / 50)), U === 0)) return 30;
    let $ =
      30 +
      ((Math.round(J / 255) << 2) |
        (Math.round(G / 255) << 1) |
        Math.round(Q / 255));
    if (U === 2) $ += 60;
    return $;
  };
  g0.hsv.ansi16 = function (X) {
    return g0.rgb.ansi16(g0.hsv.rgb(X), X[2]);
  };
  g0.rgb.ansi256 = function (X) {
    let Y = X[0],
      Q = X[1],
      G = X[2];
    if (Y === Q && Q === G) {
      if (Y < 8) return 16;
      if (Y > 248) return 231;
      return Math.round(((Y - 8) / 247) * 24) + 232;
    }
    return (
      16 +
      36 * Math.round((Y / 255) * 5) +
      6 * Math.round((Q / 255) * 5) +
      Math.round((G / 255) * 5)
    );
  };
  g0.ansi16.rgb = function (X) {
    let Y = X % 10;
    if (Y === 0 || Y === 7) {
      if (X > 50) Y += 3.5;
      return ((Y = (Y / 10.5) * 255), [Y, Y, Y]);
    }
    let Q = (~~(X > 50) + 1) * 0.5,
      G = (Y & 1) * Q * 255,
      J = ((Y >> 1) & 1) * Q * 255,
      U = ((Y >> 2) & 1) * Q * 255;
    return [G, J, U];
  };
  g0.ansi256.rgb = function (X) {
    if (X >= 232) {
      let U = (X - 232) * 10 + 8;
      return [U, U, U];
    }
    X -= 16;
    let Y,
      Q = (Math.floor(X / 36) / 5) * 255,
      G = (Math.floor((Y = X % 36) / 6) / 5) * 255,
      J = ((Y % 6) / 5) * 255;
    return [Q, G, J];
  };
  g0.rgb.hex = function (X) {
    let Q = (
      ((Math.round(X[0]) & 255) << 16) +
      ((Math.round(X[1]) & 255) << 8) +
      (Math.round(X[2]) & 255)
    )
      .toString(16)
      .toUpperCase();
    return "000000".substring(Q.length) + Q;
  };
  g0.hex.rgb = function (X) {
    let Y = X.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!Y) return [0, 0, 0];
    let Q = Y[0];
    if (Y[0].length === 3)
      Q = Q.split("")
        .map((B) => {
          return B + B;
        })
        .join("");
    let G = parseInt(Q, 16),
      J = (G >> 16) & 255,
      U = (G >> 8) & 255,
      $ = G & 255;
    return [J, U, $];
  };
  g0.rgb.hcg = function (X) {
    let Y = X[0] / 255,
      Q = X[1] / 255,
      G = X[2] / 255,
      J = Math.max(Math.max(Y, Q), G),
      U = Math.min(Math.min(Y, Q), G),
      $ = J - U,
      B,
      K;
    if ($ < 1) B = U / (1 - $);
    else B = 0;
    if ($ <= 0) K = 0;
    else if (J === Y) K = ((Q - G) / $) % 6;
    else if (J === Q) K = 2 + (G - Y) / $;
    else K = 4 + (Y - Q) / $;
    return ((K /= 6), (K %= 1), [K * 360, $ * 100, B * 100]);
  };
  g0.hsl.hcg = function (X) {
    let Y = X[1] / 100,
      Q = X[2] / 100,
      G = Q < 0.5 ? 2 * Y * Q : 2 * Y * (1 - Q),
      J = 0;
    if (G < 1) J = (Q - 0.5 * G) / (1 - G);
    return [X[0], G * 100, J * 100];
  };
  g0.hsv.hcg = function (X) {
    let Y = X[1] / 100,
      Q = X[2] / 100,
      G = Y * Q,
      J = 0;
    if (G < 1) J = (Q - G) / (1 - G);
    return [X[0], G * 100, J * 100];
  };
  g0.hcg.rgb = function (X) {
    let Y = X[0] / 360,
      Q = X[1] / 100,
      G = X[2] / 100;
    if (Q === 0) return [G * 255, G * 255, G * 255];
    let J = [0, 0, 0],
      U = (Y % 1) * 6,
      $ = U % 1,
      B = 1 - $,
      K = 0;
    switch (Math.floor(U)) {
      case 0:
        ((J[0] = 1), (J[1] = $), (J[2] = 0));
        break;
      case 1:
        ((J[0] = B), (J[1] = 1), (J[2] = 0));
        break;
      case 2:
        ((J[0] = 0), (J[1] = 1), (J[2] = $));
        break;
      case 3:
        ((J[0] = 0), (J[1] = B), (J[2] = 1));
        break;
      case 4:
        ((J[0] = $), (J[1] = 0), (J[2] = 1));
        break;
      default:
        ((J[0] = 1), (J[1] = 0), (J[2] = B));
    }
    return (
      (K = (1 - Q) * G),
      [(Q * J[0] + K) * 255, (Q * J[1] + K) * 255, (Q * J[2] + K) * 255]
    );
  };
  g0.hcg.hsv = function (X) {
    let Y = X[1] / 100,
      Q = X[2] / 100,
      G = Y + Q * (1 - Y),
      J = 0;
    if (G > 0) J = Y / G;
    return [X[0], J * 100, G * 100];
  };
  g0.hcg.hsl = function (X) {
    let Y = X[1] / 100,
      G = (X[2] / 100) * (1 - Y) + 0.5 * Y,
      J = 0;
    if (G > 0 && G < 0.5) J = Y / (2 * G);
    else if (G >= 0.5 && G < 1) J = Y / (2 * (1 - G));
    return [X[0], J * 100, G * 100];
  };
  g0.hcg.hwb = function (X) {
    let Y = X[1] / 100,
      Q = X[2] / 100,
      G = Y + Q * (1 - Y);
    return [X[0], (G - Y) * 100, (1 - G) * 100];
  };
  g0.hwb.hcg = function (X) {
    let Y = X[1] / 100,
      G = 1 - X[2] / 100,
      J = G - Y,
      U = 0;
    if (J < 1) U = (G - J) / (1 - J);
    return [X[0], J * 100, U * 100];
  };
  g0.apple.rgb = function (X) {
    return [(X[0] / 65535) * 255, (X[1] / 65535) * 255, (X[2] / 65535) * 255];
  };
  g0.rgb.apple = function (X) {
    return [(X[0] / 255) * 65535, (X[1] / 255) * 65535, (X[2] / 255) * 65535];
  };
  g0.gray.rgb = function (X) {
    return [(X[0] / 100) * 255, (X[0] / 100) * 255, (X[0] / 100) * 255];
  };
  g0.gray.hsl = function (X) {
    return [0, 0, X[0]];
  };
  g0.gray.hsv = g0.gray.hsl;
  g0.gray.hwb = function (X) {
    return [0, 100, X[0]];
  };
  g0.gray.cmyk = function (X) {
    return [0, 0, 0, X[0]];
  };
  g0.gray.lab = function (X) {
    return [X[0], 0, 0];
  };
  g0.gray.hex = function (X) {
    let Y = Math.round((X[0] / 100) * 255) & 255,
      G = ((Y << 16) + (Y << 8) + Y).toString(16).toUpperCase();
    return "000000".substring(G.length) + G;
  };
  g0.rgb.gray = function (X) {
    return [((X[0] + X[1] + X[2]) / 3 / 255) * 100];
  };
});
var lb = s((SV0, ub) => {
  var $$ = Rq();
  function s80() {
    let X = {},
      Y = Object.keys($$);
    for (let Q = Y.length, G = 0; G < Q; G++)
      X[Y[G]] = { distance: -1, parent: null };
    return X;
  }
  function t80(X) {
    let Y = s80(),
      Q = [X];
    Y[X].distance = 0;
    while (Q.length) {
      let G = Q.pop(),
        J = Object.keys($$[G]);
      for (let U = J.length, $ = 0; $ < U; $++) {
        let B = J[$],
          K = Y[B];
        if (K.distance === -1)
          ((K.distance = Y[G].distance + 1), (K.parent = G), Q.unshift(B));
      }
    }
    return Y;
  }
  function e80(X, Y) {
    return function (Q) {
      return Y(X(Q));
    };
  }
  function X60(X, Y) {
    let Q = [Y[X].parent, X],
      G = $$[Y[X].parent][X],
      J = Y[X].parent;
    while (Y[J].parent)
      (Q.unshift(Y[J].parent),
        (G = e80($$[Y[J].parent][J], G)),
        (J = Y[J].parent));
    return ((G.conversion = Q), G);
  }
  ub.exports = function (X) {
    let Y = t80(X),
      Q = {},
      G = Object.keys(Y);
    for (let J = G.length, U = 0; U < J; U++) {
      let $ = G[U];
      if (Y[$].parent === null) continue;
      Q[$] = X60($, Y);
    }
    return Q;
  };
});
var cb = s((TV0, mb) => {
  var Dq = Rq(),
    Y60 = lb(),
    r7 = {},
    Q60 = Object.keys(Dq);
  function G60(X) {
    let Y = function (...Q) {
      let G = Q[0];
      if (G === void 0 || G === null) return G;
      if (G.length > 1) Q = G;
      return X(Q);
    };
    if ("conversion" in X) Y.conversion = X.conversion;
    return Y;
  }
  function J60(X) {
    let Y = function (...Q) {
      let G = Q[0];
      if (G === void 0 || G === null) return G;
      if (G.length > 1) Q = G;
      let J = X(Q);
      if (typeof J === "object")
        for (let U = J.length, $ = 0; $ < U; $++) J[$] = Math.round(J[$]);
      return J;
    };
    if ("conversion" in X) Y.conversion = X.conversion;
    return Y;
  }
  Q60.forEach((X) => {
    ((r7[X] = {}),
      Object.defineProperty(r7[X], "channels", { value: Dq[X].channels }),
      Object.defineProperty(r7[X], "labels", { value: Dq[X].labels }));
    let Y = Y60(X);
    Object.keys(Y).forEach((G) => {
      let J = Y[G];
      ((r7[X][G] = J60(J)), (r7[X][G].raw = G60(J)));
    });
  });
  mb.exports = r7;
});
var L$ = s((bV0, pb) => {
  var o7 = xb(),
    Z8 = cb(),
    db = ["keyword", "gray", "hex"],
    zq = {};
  for (let X of Object.keys(Z8)) zq[[...Z8[X].labels].sort().join("")] = X;
  var U$ = {};
  function u5(X, Y) {
    if (!(this instanceof u5)) return new u5(X, Y);
    if (Y && Y in db) Y = null;
    if (Y && !(Y in Z8)) throw Error("Unknown model: " + Y);
    let Q, G;
    if (X == null)
      ((this.model = "rgb"), (this.color = [0, 0, 0]), (this.valpha = 1));
    else if (X instanceof u5)
      ((this.model = X.model),
        (this.color = [...X.color]),
        (this.valpha = X.valpha));
    else if (typeof X === "string") {
      let J = o7.get(X);
      if (J === null) throw Error("Unable to parse color from string: " + X);
      ((this.model = J.model),
        (G = Z8[this.model].channels),
        (this.color = J.value.slice(0, G)),
        (this.valpha = typeof J.value[G] === "number" ? J.value[G] : 1));
    } else if (X.length > 0) {
      ((this.model = Y || "rgb"), (G = Z8[this.model].channels));
      let J = Array.prototype.slice.call(X, 0, G);
      ((this.color = Eq(J, G)),
        (this.valpha = typeof X[G] === "number" ? X[G] : 1));
    } else if (typeof X === "number")
      ((this.model = "rgb"),
        (this.color = [(X >> 16) & 255, (X >> 8) & 255, X & 255]),
        (this.valpha = 1));
    else {
      this.valpha = 1;
      let J = Object.keys(X);
      if ("alpha" in X)
        (J.splice(J.indexOf("alpha"), 1),
          (this.valpha = typeof X.alpha === "number" ? X.alpha : 0));
      let U = J.sort().join("");
      if (!(U in zq))
        throw Error("Unable to parse color from object: " + JSON.stringify(X));
      this.model = zq[U];
      let { labels: $ } = Z8[this.model],
        B = [];
      for (Q = 0; Q < $.length; Q++) B.push(X[$[Q]]);
      this.color = Eq(B);
    }
    if (U$[this.model]) {
      G = Z8[this.model].channels;
      for (Q = 0; Q < G; Q++) {
        let J = U$[this.model][Q];
        if (J) this.color[Q] = J(this.color[Q]);
      }
    }
    if (((this.valpha = Math.max(0, Math.min(1, this.valpha))), Object.freeze))
      Object.freeze(this);
  }
  u5.prototype = {
    toString() {
      return this.string();
    },
    toJSON() {
      return this[this.model]();
    },
    string(X) {
      let Y = this.model in o7.to ? this : this.rgb();
      Y = Y.round(typeof X === "number" ? X : 1);
      let Q = Y.valpha === 1 ? Y.color : [...Y.color, this.valpha];
      return o7.to[Y.model](Q);
    },
    percentString(X) {
      let Y = this.rgb().round(typeof X === "number" ? X : 1),
        Q = Y.valpha === 1 ? Y.color : [...Y.color, this.valpha];
      return o7.to.rgb.percent(Q);
    },
    array() {
      return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
    },
    object() {
      let X = {},
        { channels: Y } = Z8[this.model],
        { labels: Q } = Z8[this.model];
      for (let G = 0; G < Y; G++) X[Q[G]] = this.color[G];
      if (this.valpha !== 1) X.alpha = this.valpha;
      return X;
    },
    unitArray() {
      let X = this.rgb().color;
      if (((X[0] /= 255), (X[1] /= 255), (X[2] /= 255), this.valpha !== 1))
        X.push(this.valpha);
      return X;
    },
    unitObject() {
      let X = this.rgb().object();
      if (((X.r /= 255), (X.g /= 255), (X.b /= 255), this.valpha !== 1))
        X.alpha = this.valpha;
      return X;
    },
    round(X) {
      return (
        (X = Math.max(X || 0, 0)),
        new u5([...this.color.map(H60(X)), this.valpha], this.model)
      );
    },
    alpha(X) {
      if (X !== void 0)
        return new u5([...this.color, Math.max(0, Math.min(1, X))], this.model);
      return this.valpha;
    },
    red: R5("rgb", 0, T5(255)),
    green: R5("rgb", 1, T5(255)),
    blue: R5("rgb", 2, T5(255)),
    hue: R5(
      ["hsl", "hsv", "hsl", "hwb", "hcg"],
      0,
      (X) => ((X % 360) + 360) % 360
    ),
    saturationl: R5("hsl", 1, T5(100)),
    lightness: R5("hsl", 2, T5(100)),
    saturationv: R5("hsv", 1, T5(100)),
    value: R5("hsv", 2, T5(100)),
    chroma: R5("hcg", 1, T5(100)),
    gray: R5("hcg", 2, T5(100)),
    white: R5("hwb", 1, T5(100)),
    wblack: R5("hwb", 2, T5(100)),
    cyan: R5("cmyk", 0, T5(100)),
    magenta: R5("cmyk", 1, T5(100)),
    yellow: R5("cmyk", 2, T5(100)),
    black: R5("cmyk", 3, T5(100)),
    x: R5("xyz", 0, T5(95.047)),
    y: R5("xyz", 1, T5(100)),
    z: R5("xyz", 2, T5(108.833)),
    l: R5("lab", 0, T5(100)),
    a: R5("lab", 1),
    b: R5("lab", 2),
    keyword(X) {
      if (X !== void 0) return new u5(X);
      return Z8[this.model].keyword(this.color);
    },
    hex(X) {
      if (X !== void 0) return new u5(X);
      return o7.to.hex(this.rgb().round().color);
    },
    hexa(X) {
      if (X !== void 0) return new u5(X);
      let Y = this.rgb().round().color,
        Q = Math.round(this.valpha * 255)
          .toString(16)
          .toUpperCase();
      if (Q.length === 1) Q = "0" + Q;
      return o7.to.hex(Y) + Q;
    },
    rgbNumber() {
      let X = this.rgb().color;
      return ((X[0] & 255) << 16) | ((X[1] & 255) << 8) | (X[2] & 255);
    },
    luminosity() {
      let X = this.rgb().color,
        Y = [];
      for (let [Q, G] of X.entries()) {
        let J = G / 255;
        Y[Q] = J <= 0.04045 ? J / 12.92 : ((J + 0.055) / 1.055) ** 2.4;
      }
      return 0.2126 * Y[0] + 0.7152 * Y[1] + 0.0722 * Y[2];
    },
    contrast(X) {
      let Y = this.luminosity(),
        Q = X.luminosity();
      if (Y > Q) return (Y + 0.05) / (Q + 0.05);
      return (Q + 0.05) / (Y + 0.05);
    },
    level(X) {
      let Y = this.contrast(X);
      if (Y >= 7) return "AAA";
      return Y >= 4.5 ? "AA" : "";
    },
    isDark() {
      let X = this.rgb().color;
      return (X[0] * 2126 + X[1] * 7152 + X[2] * 722) / 1e4 < 128;
    },
    isLight() {
      return !this.isDark();
    },
    negate() {
      let X = this.rgb();
      for (let Y = 0; Y < 3; Y++) X.color[Y] = 255 - X.color[Y];
      return X;
    },
    lighten(X) {
      let Y = this.hsl();
      return ((Y.color[2] += Y.color[2] * X), Y);
    },
    darken(X) {
      let Y = this.hsl();
      return ((Y.color[2] -= Y.color[2] * X), Y);
    },
    saturate(X) {
      let Y = this.hsl();
      return ((Y.color[1] += Y.color[1] * X), Y);
    },
    desaturate(X) {
      let Y = this.hsl();
      return ((Y.color[1] -= Y.color[1] * X), Y);
    },
    whiten(X) {
      let Y = this.hwb();
      return ((Y.color[1] += Y.color[1] * X), Y);
    },
    blacken(X) {
      let Y = this.hwb();
      return ((Y.color[2] += Y.color[2] * X), Y);
    },
    grayscale() {
      let X = this.rgb().color,
        Y = X[0] * 0.3 + X[1] * 0.59 + X[2] * 0.11;
      return u5.rgb(Y, Y, Y);
    },
    fade(X) {
      return this.alpha(this.valpha - this.valpha * X);
    },
    opaquer(X) {
      return this.alpha(this.valpha + this.valpha * X);
    },
    rotate(X) {
      let Y = this.hsl(),
        Q = Y.color[0];
      return (
        (Q = (Q + X) % 360),
        (Q = Q < 0 ? 360 + Q : Q),
        (Y.color[0] = Q),
        Y
      );
    },
    mix(X, Y) {
      if (!X || !X.rgb)
        throw Error(
          'Argument to "mix" was not a Color instance, but rather an instance of ' +
            typeof X
        );
      let Q = X.rgb(),
        G = this.rgb(),
        J = Y === void 0 ? 0.5 : Y,
        U = 2 * J - 1,
        $ = Q.alpha() - G.alpha(),
        B = ((U * $ === -1 ? U : (U + $) / (1 + U * $)) + 1) / 2,
        K = 1 - B;
      return u5.rgb(
        B * Q.red() + K * G.red(),
        B * Q.green() + K * G.green(),
        B * Q.blue() + K * G.blue(),
        Q.alpha() * J + G.alpha() * (1 - J)
      );
    },
  };
  for (let X of Object.keys(Z8)) {
    if (db.includes(X)) continue;
    let { channels: Y } = Z8[X];
    ((u5.prototype[X] = function (...Q) {
      if (this.model === X) return new u5(this);
      if (Q.length > 0) return new u5(Q, X);
      return new u5(
        [...$60(Z8[this.model][X].raw(this.color)), this.valpha],
        X
      );
    }),
      (u5[X] = function (...Q) {
        let G = Q[0];
        if (typeof G === "number") G = Eq(Q, Y);
        return new u5(G, X);
      }));
  }
  function W60(X, Y) {
    return Number(X.toFixed(Y));
  }
  function H60(X) {
    return function (Y) {
      return W60(Y, X);
    };
  }
  function R5(X, Y, Q) {
    X = Array.isArray(X) ? X : [X];
    for (let G of X) (U$[G] || (U$[G] = []))[Y] = Q;
    return (
      (X = X[0]),
      function (G) {
        let J;
        if (G !== void 0) {
          if (Q) G = Q(G);
          return ((J = this[X]()), (J.color[Y] = G), J);
        }
        if (((J = this[X]().color[Y]), Q)) J = Q(J);
        return J;
      }
    );
  }
  function T5(X) {
    return function (Y) {
      return Math.max(0, Math.min(X, Y));
    };
  }
  function $60(X) {
    return Array.isArray(X) ? X : [X];
  }
  function Eq(X, Y) {
    for (let Q = 0; Q < Y; Q++) if (typeof X[Q] !== "number") X[Q] = 0;
    return X;
  }
  pb.exports = u5;
});
var ab = s((vV0, nb) => {
  var U60 = L$(),
    q0 = l6(),
    V9 = pQ(),
    L60 = { left: "low", center: "centre", centre: "centre", right: "high" };
  function ib(X) {
    let {
      raw: Y,
      density: Q,
      limitInputPixels: G,
      ignoreIcc: J,
      unlimited: U,
      sequentialRead: $,
      failOn: B,
      failOnError: K,
      animated: V,
      page: W,
      pages: L,
      subifd: H,
    } = X;
    return [Y, Q, G, J, U, $, B, K, V, W, L, H].some(q0.defined)
      ? {
          raw: Y,
          density: Q,
          limitInputPixels: G,
          ignoreIcc: J,
          unlimited: U,
          sequentialRead: $,
          failOn: B,
          failOnError: K,
          animated: V,
          page: W,
          pages: L,
          subifd: H,
        }
      : void 0;
  }
  function B60(X, Y, Q) {
    let G = {
      failOn: "warning",
      limitInputPixels: Math.pow(16383, 2),
      ignoreIcc: !1,
      unlimited: !1,
      sequentialRead: !0,
    };
    if (q0.string(X)) G.file = X;
    else if (q0.buffer(X)) {
      if (X.length === 0) throw Error("Input Buffer is empty");
      G.buffer = X;
    } else if (q0.arrayBuffer(X)) {
      if (X.byteLength === 0) throw Error("Input bit Array is empty");
      G.buffer = Buffer.from(X, 0, X.byteLength);
    } else if (q0.typedArray(X)) {
      if (X.length === 0) throw Error("Input Bit Array is empty");
      G.buffer = Buffer.from(X.buffer, X.byteOffset, X.byteLength);
    } else if (q0.plainObject(X) && !q0.defined(Y)) {
      if (((Y = X), ib(Y))) G.buffer = [];
    } else if (
      !q0.defined(X) &&
      !q0.defined(Y) &&
      q0.object(Q) &&
      Q.allowStream
    )
      G.buffer = [];
    else
      throw Error(
        `Unsupported input '${X}' of type ${typeof X}${q0.defined(Y) ? ` when also providing options of type ${typeof Y}` : ""}`
      );
    if (q0.object(Y)) {
      if (q0.defined(Y.failOnError))
        if (q0.bool(Y.failOnError))
          G.failOn = Y.failOnError ? "warning" : "none";
        else
          throw q0.invalidParameterError(
            "failOnError",
            "boolean",
            Y.failOnError
          );
      if (q0.defined(Y.failOn))
        if (
          q0.string(Y.failOn) &&
          q0.inArray(Y.failOn, ["none", "truncated", "error", "warning"])
        )
          G.failOn = Y.failOn;
        else
          throw q0.invalidParameterError(
            "failOn",
            "one of: none, truncated, error, warning",
            Y.failOn
          );
      if (q0.defined(Y.density))
        if (q0.inRange(Y.density, 1, 1e5)) G.density = Y.density;
        else
          throw q0.invalidParameterError(
            "density",
            "number between 1 and 100000",
            Y.density
          );
      if (q0.defined(Y.ignoreIcc))
        if (q0.bool(Y.ignoreIcc)) G.ignoreIcc = Y.ignoreIcc;
        else
          throw q0.invalidParameterError("ignoreIcc", "boolean", Y.ignoreIcc);
      if (q0.defined(Y.limitInputPixels))
        if (q0.bool(Y.limitInputPixels))
          G.limitInputPixels = Y.limitInputPixels ? Math.pow(16383, 2) : 0;
        else if (
          q0.integer(Y.limitInputPixels) &&
          q0.inRange(Y.limitInputPixels, 0, Number.MAX_SAFE_INTEGER)
        )
          G.limitInputPixels = Y.limitInputPixels;
        else
          throw q0.invalidParameterError(
            "limitInputPixels",
            "positive integer",
            Y.limitInputPixels
          );
      if (q0.defined(Y.unlimited))
        if (q0.bool(Y.unlimited)) G.unlimited = Y.unlimited;
        else
          throw q0.invalidParameterError("unlimited", "boolean", Y.unlimited);
      if (q0.defined(Y.sequentialRead))
        if (q0.bool(Y.sequentialRead)) G.sequentialRead = Y.sequentialRead;
        else
          throw q0.invalidParameterError(
            "sequentialRead",
            "boolean",
            Y.sequentialRead
          );
      if (q0.defined(Y.raw))
        if (
          q0.object(Y.raw) &&
          q0.integer(Y.raw.width) &&
          Y.raw.width > 0 &&
          q0.integer(Y.raw.height) &&
          Y.raw.height > 0 &&
          q0.integer(Y.raw.channels) &&
          q0.inRange(Y.raw.channels, 1, 4)
        )
          switch (
            ((G.rawWidth = Y.raw.width),
            (G.rawHeight = Y.raw.height),
            (G.rawChannels = Y.raw.channels),
            (G.rawPremultiplied = !!Y.raw.premultiplied),
            X.constructor)
          ) {
            case Uint8Array:
            case Uint8ClampedArray:
              G.rawDepth = "uchar";
              break;
            case Int8Array:
              G.rawDepth = "char";
              break;
            case Uint16Array:
              G.rawDepth = "ushort";
              break;
            case Int16Array:
              G.rawDepth = "short";
              break;
            case Uint32Array:
              G.rawDepth = "uint";
              break;
            case Int32Array:
              G.rawDepth = "int";
              break;
            case Float32Array:
              G.rawDepth = "float";
              break;
            case Float64Array:
              G.rawDepth = "double";
              break;
            default:
              G.rawDepth = "uchar";
              break;
          }
        else
          throw Error(
            "Expected width, height and channels for raw pixel input"
          );
      if (q0.defined(Y.animated))
        if (q0.bool(Y.animated)) G.pages = Y.animated ? -1 : 1;
        else throw q0.invalidParameterError("animated", "boolean", Y.animated);
      if (q0.defined(Y.pages))
        if (q0.integer(Y.pages) && q0.inRange(Y.pages, -1, 1e5))
          G.pages = Y.pages;
        else
          throw q0.invalidParameterError(
            "pages",
            "integer between -1 and 100000",
            Y.pages
          );
      if (q0.defined(Y.page))
        if (q0.integer(Y.page) && q0.inRange(Y.page, 0, 1e5)) G.page = Y.page;
        else
          throw q0.invalidParameterError(
            "page",
            "integer between 0 and 100000",
            Y.page
          );
      if (q0.defined(Y.level))
        if (q0.integer(Y.level) && q0.inRange(Y.level, 0, 256))
          G.level = Y.level;
        else
          throw q0.invalidParameterError(
            "level",
            "integer between 0 and 256",
            Y.level
          );
      if (q0.defined(Y.subifd))
        if (q0.integer(Y.subifd) && q0.inRange(Y.subifd, -1, 1e5))
          G.subifd = Y.subifd;
        else
          throw q0.invalidParameterError(
            "subifd",
            "integer between -1 and 100000",
            Y.subifd
          );
      if (q0.defined(Y.create))
        if (
          q0.object(Y.create) &&
          q0.integer(Y.create.width) &&
          Y.create.width > 0 &&
          q0.integer(Y.create.height) &&
          Y.create.height > 0 &&
          q0.integer(Y.create.channels)
        ) {
          if (
            ((G.createWidth = Y.create.width),
            (G.createHeight = Y.create.height),
            (G.createChannels = Y.create.channels),
            q0.defined(Y.create.noise))
          ) {
            if (!q0.object(Y.create.noise))
              throw Error("Expected noise to be an object");
            if (!q0.inArray(Y.create.noise.type, ["gaussian"]))
              throw Error("Only gaussian noise is supported at the moment");
            if (!q0.inRange(Y.create.channels, 1, 4))
              throw q0.invalidParameterError(
                "create.channels",
                "number between 1 and 4",
                Y.create.channels
              );
            if (
              ((G.createNoiseType = Y.create.noise.type),
              q0.number(Y.create.noise.mean) &&
                q0.inRange(Y.create.noise.mean, 0, 1e4))
            )
              G.createNoiseMean = Y.create.noise.mean;
            else
              throw q0.invalidParameterError(
                "create.noise.mean",
                "number between 0 and 10000",
                Y.create.noise.mean
              );
            if (
              q0.number(Y.create.noise.sigma) &&
              q0.inRange(Y.create.noise.sigma, 0, 1e4)
            )
              G.createNoiseSigma = Y.create.noise.sigma;
            else
              throw q0.invalidParameterError(
                "create.noise.sigma",
                "number between 0 and 10000",
                Y.create.noise.sigma
              );
          } else if (q0.defined(Y.create.background)) {
            if (!q0.inRange(Y.create.channels, 3, 4))
              throw q0.invalidParameterError(
                "create.channels",
                "number between 3 and 4",
                Y.create.channels
              );
            let J = U60(Y.create.background);
            G.createBackground = [
              J.red(),
              J.green(),
              J.blue(),
              Math.round(J.alpha() * 255),
            ];
          } else
            throw Error(
              "Expected valid noise or background to create a new input image"
            );
          delete G.buffer;
        } else
          throw Error(
            "Expected valid width, height and channels to create a new input image"
          );
      if (q0.defined(Y.text))
        if (q0.object(Y.text) && q0.string(Y.text.text)) {
          if (
            ((G.textValue = Y.text.text),
            q0.defined(Y.text.height) && q0.defined(Y.text.dpi))
          )
            throw Error("Expected only one of dpi or height");
          if (q0.defined(Y.text.font))
            if (q0.string(Y.text.font)) G.textFont = Y.text.font;
            else
              throw q0.invalidParameterError(
                "text.font",
                "string",
                Y.text.font
              );
          if (q0.defined(Y.text.fontfile))
            if (q0.string(Y.text.fontfile)) G.textFontfile = Y.text.fontfile;
            else
              throw q0.invalidParameterError(
                "text.fontfile",
                "string",
                Y.text.fontfile
              );
          if (q0.defined(Y.text.width))
            if (q0.number(Y.text.width)) G.textWidth = Y.text.width;
            else
              throw q0.invalidParameterError(
                "text.textWidth",
                "number",
                Y.text.width
              );
          if (q0.defined(Y.text.height))
            if (q0.number(Y.text.height)) G.textHeight = Y.text.height;
            else
              throw q0.invalidParameterError(
                "text.height",
                "number",
                Y.text.height
              );
          if (q0.defined(Y.text.align))
            if (
              q0.string(Y.text.align) &&
              q0.string(this.constructor.align[Y.text.align])
            )
              G.textAlign = this.constructor.align[Y.text.align];
            else
              throw q0.invalidParameterError(
                "text.align",
                "valid alignment",
                Y.text.align
              );
          if (q0.defined(Y.text.justify))
            if (q0.bool(Y.text.justify)) G.textJustify = Y.text.justify;
            else
              throw q0.invalidParameterError(
                "text.justify",
                "boolean",
                Y.text.justify
              );
          if (q0.defined(Y.text.dpi))
            if (q0.number(Y.text.dpi) && q0.inRange(Y.text.dpi, 1, 1e5))
              G.textDpi = Y.text.dpi;
            else
              throw q0.invalidParameterError(
                "text.dpi",
                "number between 1 and 100000",
                Y.text.dpi
              );
          if (q0.defined(Y.text.rgba))
            if (q0.bool(Y.text.rgba)) G.textRgba = Y.text.rgba;
            else
              throw q0.invalidParameterError("text.rgba", "bool", Y.text.rgba);
          if (q0.defined(Y.text.spacing))
            if (q0.number(Y.text.spacing)) G.textSpacing = Y.text.spacing;
            else
              throw q0.invalidParameterError(
                "text.spacing",
                "number",
                Y.text.spacing
              );
          if (q0.defined(Y.text.wrap))
            if (
              q0.string(Y.text.wrap) &&
              q0.inArray(Y.text.wrap, ["word", "char", "wordChar", "none"])
            )
              G.textWrap = Y.text.wrap;
            else
              throw q0.invalidParameterError(
                "text.wrap",
                "one of: word, char, wordChar, none",
                Y.text.wrap
              );
          delete G.buffer;
        } else
          throw Error("Expected a valid string to create an image with text.");
    } else if (q0.defined(Y)) throw Error("Invalid input options " + Y);
    return G;
  }
  function K60(X, Y, Q) {
    if (Array.isArray(this.options.input.buffer))
      if (q0.buffer(X)) {
        if (this.options.input.buffer.length === 0)
          this.on("finish", () => {
            this.streamInFinished = !0;
          });
        (this.options.input.buffer.push(X), Q());
      } else Q(Error("Non-Buffer data on Writable Stream"));
    else Q(Error("Unexpected data on Writable Stream"));
  }
  function V60() {
    if (this._isStreamInput())
      this.options.input.buffer = Buffer.concat(this.options.input.buffer);
  }
  function F60() {
    return Array.isArray(this.options.input.buffer);
  }
  function N60(X) {
    if (q0.fn(X)) {
      if (this._isStreamInput())
        this.on("finish", () => {
          (this._flattenBufferIn(), V9.metadata(this.options, X));
        });
      else V9.metadata(this.options, X);
      return this;
    } else if (this._isStreamInput())
      return new Promise((Y, Q) => {
        let G = () => {
          (this._flattenBufferIn(),
            V9.metadata(this.options, (J, U) => {
              if (J) Q(J);
              else Y(U);
            }));
        };
        if (this.writableFinished) G();
        else this.once("finish", G);
      });
    else
      return new Promise((Y, Q) => {
        V9.metadata(this.options, (G, J) => {
          if (G) Q(G);
          else Y(J);
        });
      });
  }
  function M60(X) {
    if (q0.fn(X)) {
      if (this._isStreamInput())
        this.on("finish", () => {
          (this._flattenBufferIn(), V9.stats(this.options, X));
        });
      else V9.stats(this.options, X);
      return this;
    } else if (this._isStreamInput())
      return new Promise((Y, Q) => {
        this.on("finish", function () {
          (this._flattenBufferIn(),
            V9.stats(this.options, (G, J) => {
              if (G) Q(G);
              else Y(J);
            }));
        });
      });
    else
      return new Promise((Y, Q) => {
        V9.stats(this.options, (G, J) => {
          if (G) Q(G);
          else Y(J);
        });
      });
  }
  nb.exports = function (X) {
    (Object.assign(X.prototype, {
      _inputOptionsFromObject: ib,
      _createInputDescriptor: B60,
      _write: K60,
      _flattenBufferIn: V60,
      _isStreamInput: F60,
      metadata: N60,
      stats: M60,
    }),
      (X.align = L60));
  };
});
var Xv = s((kV0, eb) => {
  var l0 = l6(),
    ob = {
      center: 0,
      centre: 0,
      north: 1,
      east: 2,
      south: 3,
      west: 4,
      northeast: 5,
      southeast: 6,
      southwest: 7,
      northwest: 8,
    },
    sb = {
      top: 1,
      right: 2,
      bottom: 3,
      left: 4,
      "right top": 5,
      "right bottom": 6,
      "left bottom": 7,
      "left top": 8,
    },
    rb = {
      background: "background",
      copy: "copy",
      repeat: "repeat",
      mirror: "mirror",
    },
    tb = { entropy: 16, attention: 17 },
    Oq = {
      nearest: "nearest",
      cubic: "cubic",
      mitchell: "mitchell",
      lanczos2: "lanczos2",
      lanczos3: "lanczos3",
    },
    A60 = {
      contain: "contain",
      cover: "cover",
      fill: "fill",
      inside: "inside",
      outside: "outside",
    },
    q60 = {
      contain: "embed",
      cover: "crop",
      fill: "ignore_aspect",
      inside: "max",
      outside: "min",
    };
  function Zq(X) {
    return (
      X.angle % 360 !== 0 ||
      X.useExifOrientation === !0 ||
      X.rotationAngle !== 0
    );
  }
  function B$(X) {
    return X.width !== -1 || X.height !== -1;
  }
  function R60(X, Y, Q) {
    if (B$(this.options))
      this.options.debuglog("ignoring previous resize options");
    if (l0.defined(X))
      if (l0.object(X) && !l0.defined(Q)) Q = X;
      else if (l0.integer(X) && X > 0) this.options.width = X;
      else throw l0.invalidParameterError("width", "positive integer", X);
    else this.options.width = -1;
    if (l0.defined(Y))
      if (l0.integer(Y) && Y > 0) this.options.height = Y;
      else throw l0.invalidParameterError("height", "positive integer", Y);
    else this.options.height = -1;
    if (l0.object(Q)) {
      if (l0.defined(Q.width))
        if (l0.integer(Q.width) && Q.width > 0) this.options.width = Q.width;
        else
          throw l0.invalidParameterError("width", "positive integer", Q.width);
      if (l0.defined(Q.height))
        if (l0.integer(Q.height) && Q.height > 0)
          this.options.height = Q.height;
        else
          throw l0.invalidParameterError(
            "height",
            "positive integer",
            Q.height
          );
      if (l0.defined(Q.fit)) {
        let G = q60[Q.fit];
        if (l0.string(G)) this.options.canvas = G;
        else throw l0.invalidParameterError("fit", "valid fit", Q.fit);
      }
      if (l0.defined(Q.position)) {
        let G = l0.integer(Q.position)
          ? Q.position
          : tb[Q.position] || sb[Q.position] || ob[Q.position];
        if (l0.integer(G) && (l0.inRange(G, 0, 8) || l0.inRange(G, 16, 17)))
          this.options.position = G;
        else
          throw l0.invalidParameterError(
            "position",
            "valid position/gravity/strategy",
            Q.position
          );
      }
      if (
        (this._setBackgroundColourOption("resizeBackground", Q.background),
        l0.defined(Q.kernel))
      )
        if (l0.string(Oq[Q.kernel])) this.options.kernel = Oq[Q.kernel];
        else
          throw l0.invalidParameterError(
            "kernel",
            "valid kernel name",
            Q.kernel
          );
      if (l0.defined(Q.withoutEnlargement))
        this._setBooleanOption("withoutEnlargement", Q.withoutEnlargement);
      if (l0.defined(Q.withoutReduction))
        this._setBooleanOption("withoutReduction", Q.withoutReduction);
      if (l0.defined(Q.fastShrinkOnLoad))
        this._setBooleanOption("fastShrinkOnLoad", Q.fastShrinkOnLoad);
    }
    if (Zq(this.options) && B$(this.options))
      this.options.rotateBeforePreExtract = !0;
    return this;
  }
  function D60(X) {
    if (l0.integer(X) && X > 0)
      ((this.options.extendTop = X),
        (this.options.extendBottom = X),
        (this.options.extendLeft = X),
        (this.options.extendRight = X));
    else if (l0.object(X)) {
      if (l0.defined(X.top))
        if (l0.integer(X.top) && X.top >= 0) this.options.extendTop = X.top;
        else throw l0.invalidParameterError("top", "positive integer", X.top);
      if (l0.defined(X.bottom))
        if (l0.integer(X.bottom) && X.bottom >= 0)
          this.options.extendBottom = X.bottom;
        else
          throw l0.invalidParameterError(
            "bottom",
            "positive integer",
            X.bottom
          );
      if (l0.defined(X.left))
        if (l0.integer(X.left) && X.left >= 0) this.options.extendLeft = X.left;
        else throw l0.invalidParameterError("left", "positive integer", X.left);
      if (l0.defined(X.right))
        if (l0.integer(X.right) && X.right >= 0)
          this.options.extendRight = X.right;
        else
          throw l0.invalidParameterError("right", "positive integer", X.right);
      if (
        (this._setBackgroundColourOption("extendBackground", X.background),
        l0.defined(X.extendWith))
      )
        if (l0.string(rb[X.extendWith]))
          this.options.extendWith = rb[X.extendWith];
        else
          throw l0.invalidParameterError(
            "extendWith",
            "one of: background, copy, repeat, mirror",
            X.extendWith
          );
    } else throw l0.invalidParameterError("extend", "integer or object", X);
    return this;
  }
  function z60(X) {
    let Y = B$(this.options) || this.options.widthPre !== -1 ? "Post" : "Pre";
    if (this.options[`width${Y}`] !== -1)
      this.options.debuglog("ignoring previous extract options");
    if (
      (["left", "top", "width", "height"].forEach(function (Q) {
        let G = X[Q];
        if (l0.integer(G) && G >= 0)
          this.options[Q + (Q === "left" || Q === "top" ? "Offset" : "") + Y] =
            G;
        else throw l0.invalidParameterError(Q, "integer", G);
      }, this),
      Zq(this.options) && !B$(this.options))
    ) {
      if (this.options.widthPre === -1 || this.options.widthPost === -1)
        this.options.rotateBeforePreExtract = !0;
    }
    return this;
  }
  function E60(X) {
    if (!l0.defined(X)) this.options.trimThreshold = 10;
    else if (l0.string(X))
      (this._setBackgroundColourOption("trimBackground", X),
        (this.options.trimThreshold = 10));
    else if (l0.number(X))
      if (X >= 0) this.options.trimThreshold = X;
      else throw l0.invalidParameterError("threshold", "positive number", X);
    else if (l0.object(X))
      if (
        (this._setBackgroundColourOption("trimBackground", X.background),
        !l0.defined(X.threshold))
      )
        this.options.trimThreshold = 10;
      else if (l0.number(X.threshold) && X.threshold >= 0)
        this.options.trimThreshold = X.threshold;
      else throw l0.invalidParameterError("threshold", "positive number", X);
    else throw l0.invalidParameterError("trim", "string, number or object", X);
    if (Zq(this.options)) this.options.rotateBeforePreExtract = !0;
    return this;
  }
  eb.exports = function (X) {
    (Object.assign(X.prototype, {
      resize: R60,
      extend: D60,
      extract: z60,
      trim: E60,
    }),
      (X.gravity = ob),
      (X.strategy = tb),
      (X.kernel = Oq),
      (X.fit = A60),
      (X.position = sb));
  };
});
var Qv = s((yV0, Yv) => {
  var n1 = l6(),
    jq = {
      clear: "clear",
      source: "source",
      over: "over",
      in: "in",
      out: "out",
      atop: "atop",
      dest: "dest",
      "dest-over": "dest-over",
      "dest-in": "dest-in",
      "dest-out": "dest-out",
      "dest-atop": "dest-atop",
      xor: "xor",
      add: "add",
      saturate: "saturate",
      multiply: "multiply",
      screen: "screen",
      overlay: "overlay",
      darken: "darken",
      lighten: "lighten",
      "colour-dodge": "colour-dodge",
      "color-dodge": "colour-dodge",
      "colour-burn": "colour-burn",
      "color-burn": "colour-burn",
      "hard-light": "hard-light",
      "soft-light": "soft-light",
      difference: "difference",
      exclusion: "exclusion",
    };
  function O60(X) {
    if (!Array.isArray(X))
      throw n1.invalidParameterError("images to composite", "array", X);
    return (
      (this.options.composite = X.map((Y) => {
        if (!n1.object(Y))
          throw n1.invalidParameterError("image to composite", "object", Y);
        let Q = this._inputOptionsFromObject(Y),
          G = {
            input: this._createInputDescriptor(Y.input, Q, { allowStream: !1 }),
            blend: "over",
            tile: !1,
            left: 0,
            top: 0,
            hasOffset: !1,
            gravity: 0,
            premultiplied: !1,
          };
        if (n1.defined(Y.blend))
          if (n1.string(jq[Y.blend])) G.blend = jq[Y.blend];
          else
            throw n1.invalidParameterError(
              "blend",
              "valid blend name",
              Y.blend
            );
        if (n1.defined(Y.tile))
          if (n1.bool(Y.tile)) G.tile = Y.tile;
          else throw n1.invalidParameterError("tile", "boolean", Y.tile);
        if (n1.defined(Y.left))
          if (n1.integer(Y.left)) G.left = Y.left;
          else throw n1.invalidParameterError("left", "integer", Y.left);
        if (n1.defined(Y.top))
          if (n1.integer(Y.top)) G.top = Y.top;
          else throw n1.invalidParameterError("top", "integer", Y.top);
        if (n1.defined(Y.top) !== n1.defined(Y.left))
          throw Error("Expected both left and top to be set");
        else G.hasOffset = n1.integer(Y.top) && n1.integer(Y.left);
        if (n1.defined(Y.gravity))
          if (n1.integer(Y.gravity) && n1.inRange(Y.gravity, 0, 8))
            G.gravity = Y.gravity;
          else if (
            n1.string(Y.gravity) &&
            n1.integer(this.constructor.gravity[Y.gravity])
          )
            G.gravity = this.constructor.gravity[Y.gravity];
          else
            throw n1.invalidParameterError(
              "gravity",
              "valid gravity",
              Y.gravity
            );
        if (n1.defined(Y.premultiplied))
          if (n1.bool(Y.premultiplied)) G.premultiplied = Y.premultiplied;
          else
            throw n1.invalidParameterError(
              "premultiplied",
              "boolean",
              Y.premultiplied
            );
        return G;
      })),
      this
    );
  }
  Yv.exports = function (X) {
    ((X.prototype.composite = O60), (X.blend = jq));
  };
});
var Jv = s((_V0, Gv) => {
  var Z60 = L$(),
    H0 = l6();
  function j60(X, Y) {
    if (
      this.options.useExifOrientation ||
      this.options.angle ||
      this.options.rotationAngle
    )
      this.options.debuglog("ignoring previous rotate options");
    if (!H0.defined(X)) this.options.useExifOrientation = !0;
    else if (H0.integer(X) && !(X % 90)) this.options.angle = X;
    else if (H0.number(X)) {
      if (((this.options.rotationAngle = X), H0.object(Y) && Y.background)) {
        let Q = Z60(Y.background);
        this.options.rotationBackground = [
          Q.red(),
          Q.green(),
          Q.blue(),
          Math.round(Q.alpha() * 255),
        ];
      }
    } else throw H0.invalidParameterError("angle", "numeric", X);
    return this;
  }
  function w60(X) {
    return ((this.options.flip = H0.bool(X) ? X : !0), this);
  }
  function C60(X) {
    return ((this.options.flop = H0.bool(X) ? X : !0), this);
  }
  function I60(X, Y) {
    let Q = [].concat(...X);
    if (Q.length === 4 && Q.every(H0.number)) this.options.affineMatrix = Q;
    else throw H0.invalidParameterError("matrix", "1x4 or 2x2 array", X);
    if (H0.defined(Y))
      if (H0.object(Y)) {
        if (
          (this._setBackgroundColourOption("affineBackground", Y.background),
          H0.defined(Y.idx))
        )
          if (H0.number(Y.idx)) this.options.affineIdx = Y.idx;
          else throw H0.invalidParameterError("options.idx", "number", Y.idx);
        if (H0.defined(Y.idy))
          if (H0.number(Y.idy)) this.options.affineIdy = Y.idy;
          else throw H0.invalidParameterError("options.idy", "number", Y.idy);
        if (H0.defined(Y.odx))
          if (H0.number(Y.odx)) this.options.affineOdx = Y.odx;
          else throw H0.invalidParameterError("options.odx", "number", Y.odx);
        if (H0.defined(Y.ody))
          if (H0.number(Y.ody)) this.options.affineOdy = Y.ody;
          else throw H0.invalidParameterError("options.ody", "number", Y.ody);
        if (H0.defined(Y.interpolator))
          if (
            H0.inArray(
              Y.interpolator,
              Object.values(this.constructor.interpolators)
            )
          )
            this.options.affineInterpolator = Y.interpolator;
          else
            throw H0.invalidParameterError(
              "options.interpolator",
              "valid interpolator name",
              Y.interpolator
            );
      } else throw H0.invalidParameterError("options", "object", Y);
    return this;
  }
  function P60(X, Y, Q) {
    if (!H0.defined(X)) this.options.sharpenSigma = -1;
    else if (H0.bool(X)) this.options.sharpenSigma = X ? -1 : 0;
    else if (H0.number(X) && H0.inRange(X, 0.01, 1e4)) {
      if (((this.options.sharpenSigma = X), H0.defined(Y)))
        if (H0.number(Y) && H0.inRange(Y, 0, 1e4)) this.options.sharpenM1 = Y;
        else
          throw H0.invalidParameterError(
            "flat",
            "number between 0 and 10000",
            Y
          );
      if (H0.defined(Q))
        if (H0.number(Q) && H0.inRange(Q, 0, 1e4)) this.options.sharpenM2 = Q;
        else
          throw H0.invalidParameterError(
            "jagged",
            "number between 0 and 10000",
            Q
          );
    } else if (H0.plainObject(X)) {
      if (H0.number(X.sigma) && H0.inRange(X.sigma, 0.000001, 10))
        this.options.sharpenSigma = X.sigma;
      else
        throw H0.invalidParameterError(
          "options.sigma",
          "number between 0.000001 and 10",
          X.sigma
        );
      if (H0.defined(X.m1))
        if (H0.number(X.m1) && H0.inRange(X.m1, 0, 1e6))
          this.options.sharpenM1 = X.m1;
        else
          throw H0.invalidParameterError(
            "options.m1",
            "number between 0 and 1000000",
            X.m1
          );
      if (H0.defined(X.m2))
        if (H0.number(X.m2) && H0.inRange(X.m2, 0, 1e6))
          this.options.sharpenM2 = X.m2;
        else
          throw H0.invalidParameterError(
            "options.m2",
            "number between 0 and 1000000",
            X.m2
          );
      if (H0.defined(X.x1))
        if (H0.number(X.x1) && H0.inRange(X.x1, 0, 1e6))
          this.options.sharpenX1 = X.x1;
        else
          throw H0.invalidParameterError(
            "options.x1",
            "number between 0 and 1000000",
            X.x1
          );
      if (H0.defined(X.y2))
        if (H0.number(X.y2) && H0.inRange(X.y2, 0, 1e6))
          this.options.sharpenY2 = X.y2;
        else
          throw H0.invalidParameterError(
            "options.y2",
            "number between 0 and 1000000",
            X.y2
          );
      if (H0.defined(X.y3))
        if (H0.number(X.y3) && H0.inRange(X.y3, 0, 1e6))
          this.options.sharpenY3 = X.y3;
        else
          throw H0.invalidParameterError(
            "options.y3",
            "number between 0 and 1000000",
            X.y3
          );
    } else
      throw H0.invalidParameterError(
        "sigma",
        "number between 0.01 and 10000",
        X
      );
    return this;
  }
  function S60(X) {
    if (!H0.defined(X)) this.options.medianSize = 3;
    else if (H0.integer(X) && H0.inRange(X, 1, 1000))
      this.options.medianSize = X;
    else
      throw H0.invalidParameterError("size", "integer between 1 and 1000", X);
    return this;
  }
  function T60(X) {
    if (!H0.defined(X)) this.options.blurSigma = -1;
    else if (H0.bool(X)) this.options.blurSigma = X ? -1 : 0;
    else if (H0.number(X) && H0.inRange(X, 0.3, 1000))
      this.options.blurSigma = X;
    else
      throw H0.invalidParameterError("sigma", "number between 0.3 and 1000", X);
    return this;
  }
  function b60(X) {
    if (((this.options.flatten = H0.bool(X) ? X : !0), H0.object(X)))
      this._setBackgroundColourOption("flattenBackground", X.background);
    return this;
  }
  function v60() {
    return ((this.options.unflatten = !0), this);
  }
  function k60(X, Y) {
    if (!H0.defined(X)) this.options.gamma = 2.2;
    else if (H0.number(X) && H0.inRange(X, 1, 3)) this.options.gamma = X;
    else
      throw H0.invalidParameterError("gamma", "number between 1.0 and 3.0", X);
    if (!H0.defined(Y)) this.options.gammaOut = this.options.gamma;
    else if (H0.number(Y) && H0.inRange(Y, 1, 3)) this.options.gammaOut = Y;
    else
      throw H0.invalidParameterError(
        "gammaOut",
        "number between 1.0 and 3.0",
        Y
      );
    return this;
  }
  function y60(X) {
    if (
      ((this.options.negate = H0.bool(X) ? X : !0),
      H0.plainObject(X) && "alpha" in X)
    )
      if (!H0.bool(X.alpha))
        throw H0.invalidParameterError(
          "alpha",
          "should be boolean value",
          X.alpha
        );
      else this.options.negateAlpha = X.alpha;
    return this;
  }
  function _60(X) {
    if (H0.plainObject(X)) {
      if (H0.defined(X.lower))
        if (H0.number(X.lower) && H0.inRange(X.lower, 0, 99))
          this.options.normaliseLower = X.lower;
        else
          throw H0.invalidParameterError(
            "lower",
            "number between 0 and 99",
            X.lower
          );
      if (H0.defined(X.upper))
        if (H0.number(X.upper) && H0.inRange(X.upper, 1, 100))
          this.options.normaliseUpper = X.upper;
        else
          throw H0.invalidParameterError(
            "upper",
            "number between 1 and 100",
            X.upper
          );
    }
    if (this.options.normaliseLower >= this.options.normaliseUpper)
      throw H0.invalidParameterError(
        "range",
        "lower to be less than upper",
        `${this.options.normaliseLower} >= ${this.options.normaliseUpper}`
      );
    return ((this.options.normalise = !0), this);
  }
  function f60(X) {
    return this.normalise(X);
  }
  function x60(X) {
    if (H0.plainObject(X)) {
      if (H0.integer(X.width) && X.width > 0) this.options.claheWidth = X.width;
      else
        throw H0.invalidParameterError(
          "width",
          "integer greater than zero",
          X.width
        );
      if (H0.integer(X.height) && X.height > 0)
        this.options.claheHeight = X.height;
      else
        throw H0.invalidParameterError(
          "height",
          "integer greater than zero",
          X.height
        );
      if (H0.defined(X.maxSlope))
        if (H0.integer(X.maxSlope) && H0.inRange(X.maxSlope, 0, 100))
          this.options.claheMaxSlope = X.maxSlope;
        else
          throw H0.invalidParameterError(
            "maxSlope",
            "integer between 0 and 100",
            X.maxSlope
          );
    } else throw H0.invalidParameterError("options", "plain object", X);
    return this;
  }
  function h60(X) {
    if (
      !H0.object(X) ||
      !Array.isArray(X.kernel) ||
      !H0.integer(X.width) ||
      !H0.integer(X.height) ||
      !H0.inRange(X.width, 3, 1001) ||
      !H0.inRange(X.height, 3, 1001) ||
      X.height * X.width !== X.kernel.length
    )
      throw Error("Invalid convolution kernel");
    if (!H0.integer(X.scale))
      X.scale = X.kernel.reduce(function (Y, Q) {
        return Y + Q;
      }, 0);
    if (X.scale < 1) X.scale = 1;
    if (!H0.integer(X.offset)) X.offset = 0;
    return ((this.options.convKernel = X), this);
  }
  function g60(X, Y) {
    if (!H0.defined(X)) this.options.threshold = 128;
    else if (H0.bool(X)) this.options.threshold = X ? 128 : 0;
    else if (H0.integer(X) && H0.inRange(X, 0, 255)) this.options.threshold = X;
    else
      throw H0.invalidParameterError(
        "threshold",
        "integer between 0 and 255",
        X
      );
    if (!H0.object(Y) || Y.greyscale === !0 || Y.grayscale === !0)
      this.options.thresholdGrayscale = !0;
    else this.options.thresholdGrayscale = !1;
    return this;
  }
  function u60(X, Y, Q) {
    if (
      ((this.options.boolean = this._createInputDescriptor(X, Q)),
      H0.string(Y) && H0.inArray(Y, ["and", "or", "eor"]))
    )
      this.options.booleanOp = Y;
    else throw H0.invalidParameterError("operator", "one of: and, or, eor", Y);
    return this;
  }
  function l60(X, Y) {
    if (!H0.defined(X) && H0.number(Y)) X = 1;
    else if (H0.number(X) && !H0.defined(Y)) Y = 0;
    if (!H0.defined(X)) this.options.linearA = [];
    else if (H0.number(X)) this.options.linearA = [X];
    else if (Array.isArray(X) && X.length && X.every(H0.number))
      this.options.linearA = X;
    else throw H0.invalidParameterError("a", "number or array of numbers", X);
    if (!H0.defined(Y)) this.options.linearB = [];
    else if (H0.number(Y)) this.options.linearB = [Y];
    else if (Array.isArray(Y) && Y.length && Y.every(H0.number))
      this.options.linearB = Y;
    else throw H0.invalidParameterError("b", "number or array of numbers", Y);
    if (this.options.linearA.length !== this.options.linearB.length)
      throw Error("Expected a and b to be arrays of the same length");
    return this;
  }
  function m60(X) {
    if (
      !Array.isArray(X) ||
      X.length !== 3 ||
      X[0].length !== 3 ||
      X[1].length !== 3 ||
      X[2].length !== 3
    )
      throw Error("Invalid recombination matrix");
    return (
      (this.options.recombMatrix = [
        X[0][0],
        X[0][1],
        X[0][2],
        X[1][0],
        X[1][1],
        X[1][2],
        X[2][0],
        X[2][1],
        X[2][2],
      ].map(Number)),
      this
    );
  }
  function c60(X) {
    if (!H0.plainObject(X))
      throw H0.invalidParameterError("options", "plain object", X);
    if ("brightness" in X)
      if (H0.number(X.brightness) && X.brightness >= 0)
        this.options.brightness = X.brightness;
      else
        throw H0.invalidParameterError(
          "brightness",
          "number above zero",
          X.brightness
        );
    if ("saturation" in X)
      if (H0.number(X.saturation) && X.saturation >= 0)
        this.options.saturation = X.saturation;
      else
        throw H0.invalidParameterError(
          "saturation",
          "number above zero",
          X.saturation
        );
    if ("hue" in X)
      if (H0.integer(X.hue)) this.options.hue = X.hue % 360;
      else throw H0.invalidParameterError("hue", "number", X.hue);
    if ("lightness" in X)
      if (H0.number(X.lightness)) this.options.lightness = X.lightness;
      else throw H0.invalidParameterError("lightness", "number", X.lightness);
    return this;
  }
  Gv.exports = function (X) {
    Object.assign(X.prototype, {
      rotate: j60,
      flip: w60,
      flop: C60,
      affine: I60,
      sharpen: P60,
      median: S60,
      blur: T60,
      flatten: b60,
      unflatten: v60,
      gamma: k60,
      negate: y60,
      normalise: _60,
      normalize: f60,
      clahe: x60,
      convolve: h60,
      threshold: g60,
      boolean: u60,
      linear: l60,
      recomb: m60,
      modulate: c60,
    });
  };
});
var Uv = s((fV0, $v) => {
  var Hv = L$(),
    Z4 = l6(),
    Wv = {
      multiband: "multiband",
      "b-w": "b-w",
      bw: "b-w",
      cmyk: "cmyk",
      srgb: "srgb",
    };
  function d60(X) {
    let Y = Hv(X);
    return ((this.options.tintA = Y.a()), (this.options.tintB = Y.b()), this);
  }
  function p60(X) {
    return ((this.options.greyscale = Z4.bool(X) ? X : !0), this);
  }
  function i60(X) {
    return this.greyscale(X);
  }
  function n60(X) {
    if (!Z4.string(X))
      throw Z4.invalidParameterError("colourspace", "string", X);
    return ((this.options.colourspaceInput = X), this);
  }
  function a60(X) {
    return this.pipelineColourspace(X);
  }
  function r60(X) {
    if (!Z4.string(X))
      throw Z4.invalidParameterError("colourspace", "string", X);
    return ((this.options.colourspace = X), this);
  }
  function o60(X) {
    return this.toColourspace(X);
  }
  function s60(X, Y) {
    if (Z4.defined(Y))
      if (Z4.object(Y) || Z4.string(Y)) {
        let Q = Hv(Y);
        this.options[X] = [
          Q.red(),
          Q.green(),
          Q.blue(),
          Math.round(Q.alpha() * 255),
        ];
      } else
        throw Z4.invalidParameterError("background", "object or string", Y);
  }
  $v.exports = function (X) {
    (Object.assign(X.prototype, {
      tint: d60,
      greyscale: p60,
      grayscale: i60,
      pipelineColourspace: n60,
      pipelineColorspace: a60,
      toColourspace: r60,
      toColorspace: o60,
      _setBackgroundColourOption: s60,
    }),
      (X.colourspace = Wv),
      (X.colorspace = Wv));
  };
});
var Bv = s((xV0, Lv) => {
  var i6 = l6(),
    t60 = { and: "and", or: "or", eor: "eor" };
  function e60() {
    return ((this.options.removeAlpha = !0), this);
  }
  function X40(X) {
    if (i6.defined(X))
      if (i6.number(X) && i6.inRange(X, 0, 1)) this.options.ensureAlpha = X;
      else throw i6.invalidParameterError("alpha", "number between 0 and 1", X);
    else this.options.ensureAlpha = 1;
    return this;
  }
  function Y40(X) {
    let Y = { red: 0, green: 1, blue: 2, alpha: 3 };
    if (Object.keys(Y).includes(X)) X = Y[X];
    if (i6.integer(X) && i6.inRange(X, 0, 4)) this.options.extractChannel = X;
    else
      throw i6.invalidParameterError(
        "channel",
        "integer or one of: red, green, blue, alpha",
        X
      );
    return this;
  }
  function Q40(X, Y) {
    if (Array.isArray(X))
      X.forEach(function (Q) {
        this.options.joinChannelIn.push(this._createInputDescriptor(Q, Y));
      }, this);
    else this.options.joinChannelIn.push(this._createInputDescriptor(X, Y));
    return this;
  }
  function G40(X) {
    if (i6.string(X) && i6.inArray(X, ["and", "or", "eor"]))
      this.options.bandBoolOp = X;
    else throw i6.invalidParameterError("boolOp", "one of: and, or, eor", X);
    return this;
  }
  Lv.exports = function (X) {
    (Object.assign(X.prototype, {
      removeAlpha: e60,
      ensureAlpha: X40,
      extractChannel: Y40,
      joinChannel: Q40,
      bandbool: G40,
    }),
      (X.bool = t60));
  };
});
var Av = s((hV0, Mv) => {
  var wq = k1("path"),
    c = l6(),
    s7 = pQ(),
    Kv = new Map([
      ["heic", "heif"],
      ["heif", "heif"],
      ["avif", "avif"],
      ["jpeg", "jpeg"],
      ["jpg", "jpeg"],
      ["jpe", "jpeg"],
      ["tile", "tile"],
      ["dz", "tile"],
      ["png", "png"],
      ["raw", "raw"],
      ["tiff", "tiff"],
      ["tif", "tiff"],
      ["webp", "webp"],
      ["gif", "gif"],
      ["jp2", "jp2"],
      ["jpx", "jp2"],
      ["j2k", "jp2"],
      ["j2c", "jp2"],
      ["jxl", "jxl"],
    ]),
    J40 = /\.(jp[2x]|j2[kc])$/i,
    Vv = () => Error("JP2 output requires libvips with support for OpenJPEG"),
    Fv = (X) => 1 << (31 - Math.clz32(Math.ceil(Math.log2(X))));
  function W40(X, Y) {
    let Q;
    if (!c.string(X)) Q = Error("Missing output file path");
    else if (
      c.string(this.options.input.file) &&
      wq.resolve(this.options.input.file) === wq.resolve(X)
    )
      Q = Error("Cannot use same file for input and output");
    else if (
      J40.test(wq.extname(X)) &&
      !this.constructor.format.jp2k.output.file
    )
      Q = Vv();
    if (Q)
      if (c.fn(Y)) Y(Q);
      else return Promise.reject(Q);
    else return ((this.options.fileOut = X), this._pipeline(Y));
    return this;
  }
  function H40(X, Y) {
    if (c.object(X))
      this._setBooleanOption("resolveWithObject", X.resolveWithObject);
    else if (this.options.resolveWithObject)
      this.options.resolveWithObject = !1;
    return ((this.options.fileOut = ""), this._pipeline(c.fn(X) ? X : Y));
  }
  function $40(X) {
    if (((this.options.withMetadata = c.bool(X) ? X : !0), c.object(X))) {
      if (c.defined(X.orientation))
        if (c.integer(X.orientation) && c.inRange(X.orientation, 1, 8))
          this.options.withMetadataOrientation = X.orientation;
        else
          throw c.invalidParameterError(
            "orientation",
            "integer between 1 and 8",
            X.orientation
          );
      if (c.defined(X.density))
        if (c.number(X.density) && X.density > 0)
          this.options.withMetadataDensity = X.density;
        else
          throw c.invalidParameterError(
            "density",
            "positive number",
            X.density
          );
      if (c.defined(X.icc))
        if (c.string(X.icc)) this.options.withMetadataIcc = X.icc;
        else
          throw c.invalidParameterError(
            "icc",
            "string filesystem path to ICC profile",
            X.icc
          );
      if (c.defined(X.exif))
        if (c.object(X.exif))
          for (let [Y, Q] of Object.entries(X.exif))
            if (c.object(Q))
              for (let [G, J] of Object.entries(Q))
                if (c.string(J))
                  this.options.withMetadataStrs[
                    `exif-${Y.toLowerCase()}-${G}`
                  ] = J;
                else
                  throw c.invalidParameterError(`exif.${Y}.${G}`, "string", J);
            else throw c.invalidParameterError(`exif.${Y}`, "object", Q);
        else throw c.invalidParameterError("exif", "object", X.exif);
    }
    return this;
  }
  function U40(X, Y) {
    let Q = Kv.get((c.object(X) && c.string(X.id) ? X.id : X).toLowerCase());
    if (!Q)
      throw c.invalidParameterError(
        "format",
        `one of: ${[...Kv.keys()].join(", ")}`,
        X
      );
    return this[Q](Y);
  }
  function L40(X) {
    if (c.object(X)) {
      if (c.defined(X.quality))
        if (c.integer(X.quality) && c.inRange(X.quality, 1, 100))
          this.options.jpegQuality = X.quality;
        else
          throw c.invalidParameterError(
            "quality",
            "integer between 1 and 100",
            X.quality
          );
      if (c.defined(X.progressive))
        this._setBooleanOption("jpegProgressive", X.progressive);
      if (c.defined(X.chromaSubsampling))
        if (
          c.string(X.chromaSubsampling) &&
          c.inArray(X.chromaSubsampling, ["4:2:0", "4:4:4"])
        )
          this.options.jpegChromaSubsampling = X.chromaSubsampling;
        else
          throw c.invalidParameterError(
            "chromaSubsampling",
            "one of: 4:2:0, 4:4:4",
            X.chromaSubsampling
          );
      let Y = c.bool(X.optimizeCoding) ? X.optimizeCoding : X.optimiseCoding;
      if (c.defined(Y)) this._setBooleanOption("jpegOptimiseCoding", Y);
      if (c.defined(X.mozjpeg))
        if (c.bool(X.mozjpeg)) {
          if (X.mozjpeg)
            ((this.options.jpegTrellisQuantisation = !0),
              (this.options.jpegOvershootDeringing = !0),
              (this.options.jpegOptimiseScans = !0),
              (this.options.jpegProgressive = !0),
              (this.options.jpegQuantisationTable = 3));
        } else throw c.invalidParameterError("mozjpeg", "boolean", X.mozjpeg);
      let Q = c.bool(X.trellisQuantization)
        ? X.trellisQuantization
        : X.trellisQuantisation;
      if (c.defined(Q)) this._setBooleanOption("jpegTrellisQuantisation", Q);
      if (c.defined(X.overshootDeringing))
        this._setBooleanOption("jpegOvershootDeringing", X.overshootDeringing);
      let G = c.bool(X.optimizeScans) ? X.optimizeScans : X.optimiseScans;
      if (c.defined(G)) {
        if ((this._setBooleanOption("jpegOptimiseScans", G), G))
          this.options.jpegProgressive = !0;
      }
      let J = c.number(X.quantizationTable)
        ? X.quantizationTable
        : X.quantisationTable;
      if (c.defined(J))
        if (c.integer(J) && c.inRange(J, 0, 8))
          this.options.jpegQuantisationTable = J;
        else
          throw c.invalidParameterError(
            "quantisationTable",
            "integer between 0 and 8",
            J
          );
    }
    return this._updateFormatOut("jpeg", X);
  }
  function B40(X) {
    if (c.object(X)) {
      if (c.defined(X.progressive))
        this._setBooleanOption("pngProgressive", X.progressive);
      if (c.defined(X.compressionLevel))
        if (
          c.integer(X.compressionLevel) &&
          c.inRange(X.compressionLevel, 0, 9)
        )
          this.options.pngCompressionLevel = X.compressionLevel;
        else
          throw c.invalidParameterError(
            "compressionLevel",
            "integer between 0 and 9",
            X.compressionLevel
          );
      if (c.defined(X.adaptiveFiltering))
        this._setBooleanOption("pngAdaptiveFiltering", X.adaptiveFiltering);
      let Y = X.colours || X.colors;
      if (c.defined(Y))
        if (c.integer(Y) && c.inRange(Y, 2, 256))
          this.options.pngBitdepth = Fv(Y);
        else
          throw c.invalidParameterError(
            "colours",
            "integer between 2 and 256",
            Y
          );
      if (c.defined(X.palette)) this._setBooleanOption("pngPalette", X.palette);
      else if (
        [X.quality, X.effort, X.colours, X.colors, X.dither].some(c.defined)
      )
        this._setBooleanOption("pngPalette", !0);
      if (this.options.pngPalette) {
        if (c.defined(X.quality))
          if (c.integer(X.quality) && c.inRange(X.quality, 0, 100))
            this.options.pngQuality = X.quality;
          else
            throw c.invalidParameterError(
              "quality",
              "integer between 0 and 100",
              X.quality
            );
        if (c.defined(X.effort))
          if (c.integer(X.effort) && c.inRange(X.effort, 1, 10))
            this.options.pngEffort = X.effort;
          else
            throw c.invalidParameterError(
              "effort",
              "integer between 1 and 10",
              X.effort
            );
        if (c.defined(X.dither))
          if (c.number(X.dither) && c.inRange(X.dither, 0, 1))
            this.options.pngDither = X.dither;
          else
            throw c.invalidParameterError(
              "dither",
              "number between 0.0 and 1.0",
              X.dither
            );
      }
    }
    return this._updateFormatOut("png", X);
  }
  function K40(X) {
    if (c.object(X)) {
      if (c.defined(X.quality))
        if (c.integer(X.quality) && c.inRange(X.quality, 1, 100))
          this.options.webpQuality = X.quality;
        else
          throw c.invalidParameterError(
            "quality",
            "integer between 1 and 100",
            X.quality
          );
      if (c.defined(X.alphaQuality))
        if (c.integer(X.alphaQuality) && c.inRange(X.alphaQuality, 0, 100))
          this.options.webpAlphaQuality = X.alphaQuality;
        else
          throw c.invalidParameterError(
            "alphaQuality",
            "integer between 0 and 100",
            X.alphaQuality
          );
      if (c.defined(X.lossless))
        this._setBooleanOption("webpLossless", X.lossless);
      if (c.defined(X.nearLossless))
        this._setBooleanOption("webpNearLossless", X.nearLossless);
      if (c.defined(X.smartSubsample))
        this._setBooleanOption("webpSmartSubsample", X.smartSubsample);
      if (c.defined(X.preset))
        if (
          c.string(X.preset) &&
          c.inArray(X.preset, [
            "default",
            "photo",
            "picture",
            "drawing",
            "icon",
            "text",
          ])
        )
          this.options.webpPreset = X.preset;
        else
          throw c.invalidParameterError(
            "preset",
            "one of: default, photo, picture, drawing, icon, text",
            X.preset
          );
      if (c.defined(X.effort))
        if (c.integer(X.effort) && c.inRange(X.effort, 0, 6))
          this.options.webpEffort = X.effort;
        else
          throw c.invalidParameterError(
            "effort",
            "integer between 0 and 6",
            X.effort
          );
      if (c.defined(X.minSize))
        this._setBooleanOption("webpMinSize", X.minSize);
      if (c.defined(X.mixed)) this._setBooleanOption("webpMixed", X.mixed);
    }
    return (Nv(X, this.options), this._updateFormatOut("webp", X));
  }
  function V40(X) {
    if (c.object(X)) {
      if (c.defined(X.reuse)) this._setBooleanOption("gifReuse", X.reuse);
      if (c.defined(X.progressive))
        this._setBooleanOption("gifProgressive", X.progressive);
      let Y = X.colours || X.colors;
      if (c.defined(Y))
        if (c.integer(Y) && c.inRange(Y, 2, 256))
          this.options.gifBitdepth = Fv(Y);
        else
          throw c.invalidParameterError(
            "colours",
            "integer between 2 and 256",
            Y
          );
      if (c.defined(X.effort))
        if (c.number(X.effort) && c.inRange(X.effort, 1, 10))
          this.options.gifEffort = X.effort;
        else
          throw c.invalidParameterError(
            "effort",
            "integer between 1 and 10",
            X.effort
          );
      if (c.defined(X.dither))
        if (c.number(X.dither) && c.inRange(X.dither, 0, 1))
          this.options.gifDither = X.dither;
        else
          throw c.invalidParameterError(
            "dither",
            "number between 0.0 and 1.0",
            X.dither
          );
      if (c.defined(X.interFrameMaxError))
        if (
          c.number(X.interFrameMaxError) &&
          c.inRange(X.interFrameMaxError, 0, 32)
        )
          this.options.gifInterFrameMaxError = X.interFrameMaxError;
        else
          throw c.invalidParameterError(
            "interFrameMaxError",
            "number between 0.0 and 32.0",
            X.interFrameMaxError
          );
      if (c.defined(X.interPaletteMaxError))
        if (
          c.number(X.interPaletteMaxError) &&
          c.inRange(X.interPaletteMaxError, 0, 256)
        )
          this.options.gifInterPaletteMaxError = X.interPaletteMaxError;
        else
          throw c.invalidParameterError(
            "interPaletteMaxError",
            "number between 0.0 and 256.0",
            X.interPaletteMaxError
          );
    }
    return (Nv(X, this.options), this._updateFormatOut("gif", X));
  }
  function F40(X) {
    if (!this.constructor.format.jp2k.output.buffer) throw Vv();
    if (c.object(X)) {
      if (c.defined(X.quality))
        if (c.integer(X.quality) && c.inRange(X.quality, 1, 100))
          this.options.jp2Quality = X.quality;
        else
          throw c.invalidParameterError(
            "quality",
            "integer between 1 and 100",
            X.quality
          );
      if (c.defined(X.lossless))
        if (c.bool(X.lossless)) this.options.jp2Lossless = X.lossless;
        else throw c.invalidParameterError("lossless", "boolean", X.lossless);
      if (c.defined(X.tileWidth))
        if (c.integer(X.tileWidth) && c.inRange(X.tileWidth, 1, 32768))
          this.options.jp2TileWidth = X.tileWidth;
        else
          throw c.invalidParameterError(
            "tileWidth",
            "integer between 1 and 32768",
            X.tileWidth
          );
      if (c.defined(X.tileHeight))
        if (c.integer(X.tileHeight) && c.inRange(X.tileHeight, 1, 32768))
          this.options.jp2TileHeight = X.tileHeight;
        else
          throw c.invalidParameterError(
            "tileHeight",
            "integer between 1 and 32768",
            X.tileHeight
          );
      if (c.defined(X.chromaSubsampling))
        if (
          c.string(X.chromaSubsampling) &&
          c.inArray(X.chromaSubsampling, ["4:2:0", "4:4:4"])
        )
          this.options.jp2ChromaSubsampling = X.chromaSubsampling;
        else
          throw c.invalidParameterError(
            "chromaSubsampling",
            "one of: 4:2:0, 4:4:4",
            X.chromaSubsampling
          );
    }
    return this._updateFormatOut("jp2", X);
  }
  function Nv(X, Y) {
    if (c.object(X) && c.defined(X.loop))
      if (c.integer(X.loop) && c.inRange(X.loop, 0, 65535)) Y.loop = X.loop;
      else
        throw c.invalidParameterError(
          "loop",
          "integer between 0 and 65535",
          X.loop
        );
    if (c.object(X) && c.defined(X.delay))
      if (c.integer(X.delay) && c.inRange(X.delay, 0, 65535))
        Y.delay = [X.delay];
      else if (
        Array.isArray(X.delay) &&
        X.delay.every(c.integer) &&
        X.delay.every((Q) => c.inRange(Q, 0, 65535))
      )
        Y.delay = X.delay;
      else
        throw c.invalidParameterError(
          "delay",
          "integer or an array of integers between 0 and 65535",
          X.delay
        );
  }
  function N40(X) {
    if (c.object(X)) {
      if (c.defined(X.quality))
        if (c.integer(X.quality) && c.inRange(X.quality, 1, 100))
          this.options.tiffQuality = X.quality;
        else
          throw c.invalidParameterError(
            "quality",
            "integer between 1 and 100",
            X.quality
          );
      if (c.defined(X.bitdepth))
        if (c.integer(X.bitdepth) && c.inArray(X.bitdepth, [1, 2, 4, 8]))
          this.options.tiffBitdepth = X.bitdepth;
        else
          throw c.invalidParameterError("bitdepth", "1, 2, 4 or 8", X.bitdepth);
      if (c.defined(X.tile)) this._setBooleanOption("tiffTile", X.tile);
      if (c.defined(X.tileWidth))
        if (c.integer(X.tileWidth) && X.tileWidth > 0)
          this.options.tiffTileWidth = X.tileWidth;
        else
          throw c.invalidParameterError(
            "tileWidth",
            "integer greater than zero",
            X.tileWidth
          );
      if (c.defined(X.tileHeight))
        if (c.integer(X.tileHeight) && X.tileHeight > 0)
          this.options.tiffTileHeight = X.tileHeight;
        else
          throw c.invalidParameterError(
            "tileHeight",
            "integer greater than zero",
            X.tileHeight
          );
      if (c.defined(X.pyramid))
        this._setBooleanOption("tiffPyramid", X.pyramid);
      if (c.defined(X.xres))
        if (c.number(X.xres) && X.xres > 0) this.options.tiffXres = X.xres;
        else
          throw c.invalidParameterError(
            "xres",
            "number greater than zero",
            X.xres
          );
      if (c.defined(X.yres))
        if (c.number(X.yres) && X.yres > 0) this.options.tiffYres = X.yres;
        else
          throw c.invalidParameterError(
            "yres",
            "number greater than zero",
            X.yres
          );
      if (c.defined(X.compression))
        if (
          c.string(X.compression) &&
          c.inArray(X.compression, [
            "none",
            "jpeg",
            "deflate",
            "packbits",
            "ccittfax4",
            "lzw",
            "webp",
            "zstd",
            "jp2k",
          ])
        )
          this.options.tiffCompression = X.compression;
        else
          throw c.invalidParameterError(
            "compression",
            "one of: none, jpeg, deflate, packbits, ccittfax4, lzw, webp, zstd, jp2k",
            X.compression
          );
      if (c.defined(X.predictor))
        if (
          c.string(X.predictor) &&
          c.inArray(X.predictor, ["none", "horizontal", "float"])
        )
          this.options.tiffPredictor = X.predictor;
        else
          throw c.invalidParameterError(
            "predictor",
            "one of: none, horizontal, float",
            X.predictor
          );
      if (c.defined(X.resolutionUnit))
        if (
          c.string(X.resolutionUnit) &&
          c.inArray(X.resolutionUnit, ["inch", "cm"])
        )
          this.options.tiffResolutionUnit = X.resolutionUnit;
        else
          throw c.invalidParameterError(
            "resolutionUnit",
            "one of: inch, cm",
            X.resolutionUnit
          );
    }
    return this._updateFormatOut("tiff", X);
  }
  function M40(X) {
    return this.heif({ ...X, compression: "av1" });
  }
  function A40(X) {
    if (c.object(X)) {
      if (c.defined(X.quality))
        if (c.integer(X.quality) && c.inRange(X.quality, 1, 100))
          this.options.heifQuality = X.quality;
        else
          throw c.invalidParameterError(
            "quality",
            "integer between 1 and 100",
            X.quality
          );
      if (c.defined(X.lossless))
        if (c.bool(X.lossless)) this.options.heifLossless = X.lossless;
        else throw c.invalidParameterError("lossless", "boolean", X.lossless);
      if (c.defined(X.compression))
        if (
          c.string(X.compression) &&
          c.inArray(X.compression, ["av1", "hevc"])
        )
          this.options.heifCompression = X.compression;
        else
          throw c.invalidParameterError(
            "compression",
            "one of: av1, hevc",
            X.compression
          );
      if (c.defined(X.effort))
        if (c.integer(X.effort) && c.inRange(X.effort, 0, 9))
          this.options.heifEffort = X.effort;
        else
          throw c.invalidParameterError(
            "effort",
            "integer between 0 and 9",
            X.effort
          );
      if (c.defined(X.chromaSubsampling))
        if (
          c.string(X.chromaSubsampling) &&
          c.inArray(X.chromaSubsampling, ["4:2:0", "4:4:4"])
        )
          this.options.heifChromaSubsampling = X.chromaSubsampling;
        else
          throw c.invalidParameterError(
            "chromaSubsampling",
            "one of: 4:2:0, 4:4:4",
            X.chromaSubsampling
          );
    }
    return this._updateFormatOut("heif", X);
  }
  function q40(X) {
    if (c.object(X)) {
      if (c.defined(X.quality))
        if (c.integer(X.quality) && c.inRange(X.quality, 1, 100))
          this.options.jxlDistance =
            X.quality >= 30
              ? 0.1 + (100 - X.quality) * 0.09
              : 0.017666666666666667 * X.quality * X.quality -
                1.15 * X.quality +
                25;
        else
          throw c.invalidParameterError(
            "quality",
            "integer between 1 and 100",
            X.quality
          );
      else if (c.defined(X.distance))
        if (c.number(X.distance) && c.inRange(X.distance, 0, 15))
          this.options.jxlDistance = X.distance;
        else
          throw c.invalidParameterError(
            "distance",
            "number between 0.0 and 15.0",
            X.distance
          );
      if (c.defined(X.decodingTier))
        if (c.integer(X.decodingTier) && c.inRange(X.decodingTier, 0, 4))
          this.options.jxlDecodingTier = X.decodingTier;
        else
          throw c.invalidParameterError(
            "decodingTier",
            "integer between 0 and 4",
            X.decodingTier
          );
      if (c.defined(X.lossless))
        if (c.bool(X.lossless)) this.options.jxlLossless = X.lossless;
        else throw c.invalidParameterError("lossless", "boolean", X.lossless);
      if (c.defined(X.effort))
        if (c.integer(X.effort) && c.inRange(X.effort, 3, 9))
          this.options.jxlEffort = X.effort;
        else
          throw c.invalidParameterError(
            "effort",
            "integer between 3 and 9",
            X.effort
          );
    }
    return this._updateFormatOut("jxl", X);
  }
  function R40(X) {
    if (c.object(X)) {
      if (c.defined(X.depth))
        if (
          c.string(X.depth) &&
          c.inArray(X.depth, [
            "char",
            "uchar",
            "short",
            "ushort",
            "int",
            "uint",
            "float",
            "complex",
            "double",
            "dpcomplex",
          ])
        )
          this.options.rawDepth = X.depth;
        else
          throw c.invalidParameterError(
            "depth",
            "one of: char, uchar, short, ushort, int, uint, float, complex, double, dpcomplex",
            X.depth
          );
    }
    return this._updateFormatOut("raw");
  }
  function D40(X) {
    if (c.object(X)) {
      if (c.defined(X.size))
        if (c.integer(X.size) && c.inRange(X.size, 1, 8192))
          this.options.tileSize = X.size;
        else
          throw c.invalidParameterError(
            "size",
            "integer between 1 and 8192",
            X.size
          );
      if (c.defined(X.overlap))
        if (c.integer(X.overlap) && c.inRange(X.overlap, 0, 8192)) {
          if (X.overlap > this.options.tileSize)
            throw c.invalidParameterError(
              "overlap",
              `<= size (${this.options.tileSize})`,
              X.overlap
            );
          this.options.tileOverlap = X.overlap;
        } else
          throw c.invalidParameterError(
            "overlap",
            "integer between 0 and 8192",
            X.overlap
          );
      if (c.defined(X.container))
        if (c.string(X.container) && c.inArray(X.container, ["fs", "zip"]))
          this.options.tileContainer = X.container;
        else
          throw c.invalidParameterError(
            "container",
            "one of: fs, zip",
            X.container
          );
      if (c.defined(X.layout))
        if (
          c.string(X.layout) &&
          c.inArray(X.layout, ["dz", "google", "iiif", "iiif3", "zoomify"])
        )
          this.options.tileLayout = X.layout;
        else
          throw c.invalidParameterError(
            "layout",
            "one of: dz, google, iiif, iiif3, zoomify",
            X.layout
          );
      if (c.defined(X.angle))
        if (c.integer(X.angle) && !(X.angle % 90))
          this.options.tileAngle = X.angle;
        else
          throw c.invalidParameterError(
            "angle",
            "positive/negative multiple of 90",
            X.angle
          );
      if (
        (this._setBackgroundColourOption("tileBackground", X.background),
        c.defined(X.depth))
      )
        if (
          c.string(X.depth) &&
          c.inArray(X.depth, ["onepixel", "onetile", "one"])
        )
          this.options.tileDepth = X.depth;
        else
          throw c.invalidParameterError(
            "depth",
            "one of: onepixel, onetile, one",
            X.depth
          );
      if (c.defined(X.skipBlanks))
        if (c.integer(X.skipBlanks) && c.inRange(X.skipBlanks, -1, 65535))
          this.options.tileSkipBlanks = X.skipBlanks;
        else
          throw c.invalidParameterError(
            "skipBlanks",
            "integer between -1 and 255/65535",
            X.skipBlanks
          );
      else if (c.defined(X.layout) && X.layout === "google")
        this.options.tileSkipBlanks = 5;
      let Y = c.bool(X.center) ? X.center : X.centre;
      if (c.defined(Y)) this._setBooleanOption("tileCentre", Y);
      if (c.defined(X.id))
        if (c.string(X.id)) this.options.tileId = X.id;
        else throw c.invalidParameterError("id", "string", X.id);
      if (c.defined(X.basename))
        if (c.string(X.basename)) this.options.tileBasename = X.basename;
        else throw c.invalidParameterError("basename", "string", X.basename);
    }
    if (c.inArray(this.options.formatOut, ["jpeg", "png", "webp"]))
      this.options.tileFormat = this.options.formatOut;
    else if (this.options.formatOut !== "input")
      throw c.invalidParameterError(
        "format",
        "one of: jpeg, png, webp",
        this.options.formatOut
      );
    return this._updateFormatOut("dz");
  }
  function z40(X) {
    if (!c.plainObject(X))
      throw c.invalidParameterError("options", "object", X);
    if (c.integer(X.seconds) && c.inRange(X.seconds, 0, 3600))
      this.options.timeoutSeconds = X.seconds;
    else
      throw c.invalidParameterError(
        "seconds",
        "integer between 0 and 3600",
        X.seconds
      );
    return this;
  }
  function E40(X, Y) {
    if (!(c.object(Y) && Y.force === !1)) this.options.formatOut = X;
    return this;
  }
  function O40(X, Y) {
    if (c.bool(Y)) this.options[X] = Y;
    else throw c.invalidParameterError(X, "boolean", Y);
  }
  function Z40() {
    if (!this.options.streamOut)
      ((this.options.streamOut = !0), this._pipeline());
  }
  function j40(X) {
    if (typeof X === "function") {
      if (this._isStreamInput())
        this.on("finish", () => {
          (this._flattenBufferIn(), s7.pipeline(this.options, X));
        });
      else s7.pipeline(this.options, X);
      return this;
    } else if (this.options.streamOut) {
      if (this._isStreamInput()) {
        if (
          (this.once("finish", () => {
            (this._flattenBufferIn(),
              s7.pipeline(this.options, (Y, Q, G) => {
                if (Y) this.emit("error", Y);
                else (this.emit("info", G), this.push(Q));
                (this.push(null), this.on("end", () => this.emit("close")));
              }));
          }),
          this.streamInFinished)
        )
          this.emit("finish");
      } else
        s7.pipeline(this.options, (Y, Q, G) => {
          if (Y) this.emit("error", Y);
          else (this.emit("info", G), this.push(Q));
          (this.push(null), this.on("end", () => this.emit("close")));
        });
      return this;
    } else if (this._isStreamInput())
      return new Promise((Y, Q) => {
        this.once("finish", () => {
          (this._flattenBufferIn(),
            s7.pipeline(this.options, (G, J, U) => {
              if (G) Q(G);
              else if (this.options.resolveWithObject) Y({ data: J, info: U });
              else Y(J);
            }));
        });
      });
    else
      return new Promise((Y, Q) => {
        s7.pipeline(this.options, (G, J, U) => {
          if (G) Q(G);
          else if (this.options.resolveWithObject) Y({ data: J, info: U });
          else Y(J);
        });
      });
  }
  Mv.exports = function (X) {
    Object.assign(X.prototype, {
      toFile: W40,
      toBuffer: H40,
      withMetadata: $40,
      toFormat: U40,
      jpeg: L40,
      jp2: F40,
      png: B40,
      webp: K40,
      tiff: N40,
      avif: M40,
      heif: A40,
      jxl: q40,
      gif: V40,
      raw: R40,
      tile: D40,
      timeout: z40,
      _updateFormatOut: E40,
      _setBooleanOption: O40,
      _read: Z40,
      _pipeline: j40,
    });
  };
});
var Zv = s((gV0, Ov) => {
  var __dirname =
      "/Users/kazuto/Desktop/claude-cnthub/node_modules/.bun/sharp@0.32.6/node_modules/sharp/lib",
    w40 = k1("fs"),
    C40 = k1("path"),
    I40 = k1("events"),
    qv = $q(),
    k8 = l6(),
    Rv = J$()(),
    j8 = pQ(),
    sQ = j8.format();
  sQ.heif.output.alias = ["avif", "heic"];
  sQ.jpeg.output.alias = ["jpe", "jpg"];
  sQ.tiff.output.alias = ["tif"];
  sQ.jp2k.output.alias = ["j2c", "j2k", "jp2", "jpx"];
  var P40 = {
      nearest: "nearest",
      bilinear: "bilinear",
      bicubic: "bicubic",
      locallyBoundedBicubic: "lbb",
      nohalo: "nohalo",
      vertexSplitQuadraticBasisSpline: "vsqbs",
    },
    oQ = { vips: j8.libvipsVersion() };
  try {
    oQ = k1(`../vendor/${oQ.vips}/${Rv}/versions.json`);
  } catch (X) {}
  oQ.sharp = Lq().version;
  var Dv = { current: Rv, installed: [] };
  try {
    Dv.installed = w40.readdirSync(C40.join(__dirname, `../vendor/${oQ.vips}`));
  } catch (X) {}
  function zv(X) {
    if (k8.bool(X))
      if (X) return j8.cache(50, 20, 100);
      else return j8.cache(0, 0, 0);
    else if (k8.object(X)) return j8.cache(X.memory, X.files, X.items);
    else return j8.cache();
  }
  zv(!0);
  function S40(X) {
    return j8.concurrency(k8.integer(X) ? X : null);
  }
  if (qv.familySync() === qv.GLIBC && !j8._isUsingJemalloc()) j8.concurrency(1);
  var T40 = new I40.EventEmitter();
  function b40() {
    return j8.counters();
  }
  function Ev(X) {
    return j8.simd(k8.bool(X) ? X : null);
  }
  Ev(!0);
  function v40(X) {
    if (k8.object(X))
      if (Array.isArray(X.operation) && X.operation.every(k8.string))
        j8.block(X.operation, !0);
      else
        throw k8.invalidParameterError(
          "operation",
          "Array<string>",
          X.operation
        );
    else throw k8.invalidParameterError("options", "object", X);
  }
  function k40(X) {
    if (k8.object(X))
      if (Array.isArray(X.operation) && X.operation.every(k8.string))
        j8.block(X.operation, !1);
      else
        throw k8.invalidParameterError(
          "operation",
          "Array<string>",
          X.operation
        );
    else throw k8.invalidParameterError("options", "object", X);
  }
  Ov.exports = function (X) {
    ((X.cache = zv),
      (X.concurrency = S40),
      (X.counters = b40),
      (X.simd = Ev),
      (X.format = sQ),
      (X.interpolators = P40),
      (X.versions = oQ),
      (X.vendor = Dv),
      (X.queue = T40),
      (X.block = v40),
      (X.unblock = k40));
  };
});
var wv = s((lV0, jv) => {
  var j4 = Ib();
  ab()(j4);
  Xv()(j4);
  Qv()(j4);
  Jv()(j4);
  Uv()(j4);
  Bv()(j4);
  Av()(j4);
  Zv()(j4);
  jv.exports = j4;
});
class o5 {
  constructor(X, Y, Q, G) {
    ((this.data = X), (this.width = Y), (this.height = Q), (this.channels = G));
  }
  get size() {
    return [this.width, this.height];
  }
  static async read(X) {
    if (X instanceof o5) return X;
    else if (typeof X === "string" || X instanceof URL)
      return await this.fromURL(X);
    else throw Error(`Unsupported input type: ${typeof X}`);
  }
  static async fromURL(X) {
    let Y = await y7(X);
    if (Y.status !== 200)
      throw Error(
        `Unable to read image from "${X}" (${Y.status} ${Y.statusText})`
      );
    let Q = await Y.blob();
    return this.fromBlob(Q);
  }
  static async fromBlob(X) {
    if (t8) {
      let Y = await F9(X),
        Q = DX(Y.width, Y.height).getContext("2d");
      return (
        Q.drawImage(Y, 0, 0),
        new this(
          Q.getImageData(0, 0, Y.width, Y.height).data,
          Y.width,
          Y.height,
          4
        )
      );
    } else {
      let Y = K$.default(await X.arrayBuffer());
      return await F9(Y);
    }
  }
  static fromTensor(X, Y = "CHW") {
    if (X.dims.length !== 3)
      throw Error(
        `Tensor should have 3 dimensions, but has ${X.dims.length} dimensions.`
      );
    if (Y === "CHW") X = X.transpose(1, 2, 0);
    else if (Y === "HWC");
    else throw Error(`Unsupported channel format: ${Y}`);
    if (!(X.data instanceof Uint8ClampedArray || X.data instanceof Uint8Array))
      throw Error(`Unsupported tensor type: ${X.type}`);
    switch (X.dims[2]) {
      case 1:
      case 2:
      case 3:
      case 4:
        return new o5(X.data, X.dims[1], X.dims[0], X.dims[2]);
      default:
        throw Error(`Unsupported number of channels: ${X.dims[2]}`);
    }
  }
  grayscale() {
    if (this.channels === 1) return this;
    let X = new Uint8ClampedArray(this.width * this.height * 1);
    switch (this.channels) {
      case 3:
      case 4:
        for (let Y = 0, Q = 0; Y < this.data.length; Y += this.channels) {
          let G = this.data[Y],
            J = this.data[Y + 1],
            U = this.data[Y + 2];
          X[Q++] = Math.round(0.2989 * G + 0.587 * J + 0.114 * U);
        }
        break;
      default:
        throw Error(
          `Conversion failed due to unsupported number of channels: ${this.channels}`
        );
    }
    return this._update(X, this.width, this.height, 1);
  }
  rgb() {
    if (this.channels === 3) return this;
    let X = new Uint8ClampedArray(this.width * this.height * 3);
    switch (this.channels) {
      case 1:
        for (let Y = 0, Q = 0; Y < this.data.length; ++Y)
          ((X[Q++] = this.data[Y]),
            (X[Q++] = this.data[Y]),
            (X[Q++] = this.data[Y]));
        break;
      case 4:
        for (let Y = 0, Q = 0; Y < this.data.length; Y += 4)
          ((X[Q++] = this.data[Y]),
            (X[Q++] = this.data[Y + 1]),
            (X[Q++] = this.data[Y + 2]));
        break;
      default:
        throw Error(
          `Conversion failed due to unsupported number of channels: ${this.channels}`
        );
    }
    return this._update(X, this.width, this.height, 3);
  }
  rgba() {
    if (this.channels === 4) return this;
    let X = new Uint8ClampedArray(this.width * this.height * 4);
    switch (this.channels) {
      case 1:
        for (let Y = 0, Q = 0; Y < this.data.length; ++Y)
          ((X[Q++] = this.data[Y]),
            (X[Q++] = this.data[Y]),
            (X[Q++] = this.data[Y]),
            (X[Q++] = 255));
        break;
      case 3:
        for (let Y = 0, Q = 0; Y < this.data.length; Y += 3)
          ((X[Q++] = this.data[Y]),
            (X[Q++] = this.data[Y + 1]),
            (X[Q++] = this.data[Y + 2]),
            (X[Q++] = 255));
        break;
      default:
        throw Error(
          `Conversion failed due to unsupported number of channels: ${this.channels}`
        );
    }
    return this._update(X, this.width, this.height, 4);
  }
  async resize(X, Y, { resample: Q = 2 } = {}) {
    let G = _40[Q] ?? Q;
    if (t8) {
      let J = this.channels,
        U = this.toCanvas(),
        $ = DX(X, Y).getContext("2d");
      return (
        $.drawImage(U, 0, 0, X, Y),
        new o5($.getImageData(0, 0, X, Y).data, X, Y, 4).convert(J)
      );
    } else {
      let J = this.toSharp();
      switch (G) {
        case "box":
        case "hamming":
          if (G === "box" || G === "hamming")
            (console.warn(
              `Resampling method ${G} is not yet supported. Using bilinear instead.`
            ),
              (G = "bilinear"));
        case "nearest":
        case "bilinear":
        case "bicubic":
          J = J.affine([X / this.width, 0, 0, Y / this.height], {
            interpolator: G,
          });
          break;
        case "lanczos":
          J = J.resize({
            width: X,
            height: Y,
            fit: "fill",
            kernel: "lanczos3",
          });
          break;
        default:
          throw Error(`Resampling method ${G} is not supported.`);
      }
      return await F9(J);
    }
  }
  async pad([X, Y, Q, G]) {
    if (
      ((X = Math.max(X, 0)),
      (Y = Math.max(Y, 0)),
      (Q = Math.max(Q, 0)),
      (G = Math.max(G, 0)),
      X === 0 && Y === 0 && Q === 0 && G === 0)
    )
      return this;
    if (t8) {
      let J = this.channels,
        U = this.toCanvas(),
        $ = this.width + X + Y,
        B = this.height + Q + G,
        K = DX($, B).getContext("2d");
      return (
        K.drawImage(U, 0, 0, this.width, this.height, X, Q, $, B),
        new o5(K.getImageData(0, 0, $, B).data, $, B, 4).convert(J)
      );
    } else {
      let J = this.toSharp().extend({ left: X, right: Y, top: Q, bottom: G });
      return await F9(J);
    }
  }
  async crop([X, Y, Q, G]) {
    if (
      ((X = Math.max(X, 0)),
      (Y = Math.max(Y, 0)),
      (Q = Math.min(Q, this.width - 1)),
      (G = Math.min(G, this.height - 1)),
      X === 0 && Y === 0 && Q === this.width - 1 && G === this.height - 1)
    )
      return this;
    let J = Q - X + 1,
      U = G - Y + 1;
    if (t8) {
      let $ = this.channels,
        B = this.toCanvas(),
        K = DX(J, U).getContext("2d");
      return (
        K.drawImage(B, X, Y, J, U, 0, 0, J, U),
        new o5(K.getImageData(0, 0, J, U).data, J, U, 4).convert($)
      );
    } else {
      let $ = this.toSharp().extract({ left: X, top: Y, width: J, height: U });
      return await F9($);
    }
  }
  async center_crop(X, Y) {
    if (this.width === X && this.height === Y) return this;
    let Q = (this.width - X) / 2,
      G = (this.height - Y) / 2;
    if (t8) {
      let J = this.channels,
        U = this.toCanvas(),
        $ = DX(X, Y).getContext("2d"),
        B = 0,
        K = 0,
        V = 0,
        W = 0;
      if (Q >= 0) B = Q;
      else V = -Q;
      if (G >= 0) K = G;
      else W = -G;
      return (
        $.drawImage(U, B, K, X, Y, V, W, X, Y),
        new o5($.getImageData(0, 0, X, Y).data, X, Y, 4).convert(J)
      );
    } else {
      let J = this.toSharp();
      if (Q >= 0 && G >= 0)
        J = J.extract({
          left: Math.floor(Q),
          top: Math.floor(G),
          width: X,
          height: Y,
        });
      else if (Q <= 0 && G <= 0) {
        let U = Math.floor(-G),
          $ = Math.floor(-Q);
        J = J.extend({
          top: U,
          left: $,
          right: X - this.width - $,
          bottom: Y - this.height - U,
        });
      } else {
        let U = [0, 0],
          $ = 0;
        if (G < 0) ((U[0] = Math.floor(-G)), (U[1] = Y - this.height - U[0]));
        else $ = Math.floor(G);
        let B = [0, 0],
          K = 0;
        if (Q < 0) ((B[0] = Math.floor(-Q)), (B[1] = X - this.width - B[0]));
        else K = Math.floor(Q);
        J = J.extend({
          top: U[0],
          bottom: U[1],
          left: B[0],
          right: B[1],
        }).extract({ left: K, top: $, width: X, height: Y });
      }
      return await F9(J);
    }
  }
  async toBlob(X = "image/png", Y = 1) {
    if (!t8) throw Error("toBlob() is only supported in browser environments.");
    return await this.toCanvas().convertToBlob({ type: X, quality: Y });
  }
  toTensor(X = "CHW") {
    let Y = new I0("uint8", new Uint8Array(this.data), [
      this.height,
      this.width,
      this.channels,
    ]);
    if (X === "HWC");
    else if (X === "CHW") Y = Y.permute(2, 0, 1);
    else throw Error(`Unsupported channel format: ${X}`);
    return Y;
  }
  toCanvas() {
    if (!t8)
      throw Error("toCanvas() is only supported in browser environments.");
    let X = this.clone().rgba(),
      Y = DX(X.width, X.height),
      Q = new Cv(X.data, X.width, X.height);
    return (Y.getContext("2d").putImageData(Q, 0, 0), Y);
  }
  _update(X, Y, Q, G = null) {
    if (((this.data = X), (this.width = Y), (this.height = Q), G !== null))
      this.channels = G;
    return this;
  }
  clone() {
    return new o5(this.data.slice(), this.width, this.height, this.channels);
  }
  convert(X) {
    if (this.channels === X) return this;
    switch (X) {
      case 1:
        this.grayscale();
        break;
      case 3:
        this.rgb();
        break;
      case 4:
        this.rgba();
        break;
      default:
        throw Error(
          `Conversion failed due to unsupported number of channels: ${this.channels}`
        );
    }
    return this;
  }
  async save(X) {
    if (t8) {
      if (y40) throw Error("Unable to save an image from a Web Worker.");
      let Y = X.split(".").pop().toLowerCase(),
        Q = f40.get(Y) ?? "image/png",
        G = await this.toBlob(Q),
        J = URL.createObjectURL(G),
        U = document.createElement("a");
      ((U.href = J), (U.download = X), U.click(), U.remove());
    } else if (!A5.useFS)
      throw Error(
        "Unable to save the image because filesystem is disabled in this environment."
      );
    else return await this.toSharp().toFile(X);
  }
  toSharp() {
    if (t8)
      throw Error("toSharp() is only supported in server-side environments.");
    return K$.default(this.data, {
      raw: { width: this.width, height: this.height, channels: this.channels },
    });
  }
}
var K$, t8, y40, DX, Cv, F9, _40, f40;
var V$ = U8(() => {
  t9();
  AW();
  W9();
  ((K$ = AY(wv(), 1)),
    (t8 = typeof self < "u"),
    (y40 = t8 && self.constructor.name === "DedicatedWorkerGlobalScope"));
  if (t8)
    ((DX = (X, Y) => {
      if (!self.OffscreenCanvas)
        throw Error("OffscreenCanvas not supported by this browser.");
      return new self.OffscreenCanvas(X, Y);
    }),
      (F9 = self.createImageBitmap),
      (Cv = self.ImageData));
  else if (K$.default)
    F9 = async (X) => {
      let Q = (await X.metadata()).channels,
        { data: G, info: J } = await X.rotate()
          .raw()
          .toBuffer({ resolveWithObject: !0 }),
        U = new o5(new Uint8ClampedArray(G), J.width, J.height, J.channels);
      if (Q !== void 0 && Q !== J.channels) U.convert(Q);
      return U;
    };
  else throw Error("Unable to load image processing library.");
  ((_40 = {
    0: "nearest",
    1: "lanczos",
    2: "bilinear",
    3: "bicubic",
    4: "box",
    5: "hamming",
  }),
    (f40 = new Map([
      ["png", "image/png"],
      ["jpg", "image/jpeg"],
      ["jpeg", "image/jpeg"],
      ["gif", "image/gif"],
    ])));
});
async function Pq(X, Y) {
  if (typeof AudioContext > "u")
    throw Error(
      "Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing."
    );
  let Q = await (await y7(X)).arrayBuffer(),
    G = new AudioContext({ sampleRate: Y });
  if (typeof Y > "u")
    console.warn(
      `No sampling rate provided, using default of ${G.sampleRate}Hz.`
    );
  let J = await G.decodeAudioData(Q),
    U;
  if (J.numberOfChannels === 2) {
    let $ = Math.sqrt(2),
      B = J.getChannelData(0),
      K = J.getChannelData(1);
    U = new Float32Array(B.length);
    for (let V = 0; V < J.length; ++V) U[V] = ($ * (B[V] + K[V])) / 2;
  } else U = J.getChannelData(0);
  return U;
}
function Iq(X) {
  if (X < 1) return new Float64Array();
  if (X === 1) return new Float64Array([1]);
  let Y = X - 1,
    Q = Math.PI / Y,
    G = new Float64Array(X);
  for (let J = 0; J < X; ++J) {
    let U = 2 * J - Y;
    G[J] = 0.5 + 0.5 * Math.cos(Q * U);
  }
  return G;
}
function Cq(X, Y = "htk") {
  let Q = x40[Y];
  if (!Q) throw Error('mel_scale should be one of "htk", "slaney" or "kaldi".');
  return typeof X === "number" ? Q(X) : X.map((G) => Q(G));
}
function g40(X, Y = "htk") {
  let Q = h40[Y];
  if (!Q) throw Error('mel_scale should be one of "htk", "slaney" or "kaldi".');
  return typeof X === "number" ? Q(X) : X.map((G) => Q(G));
}
function u40(X, Y) {
  let Q = Float64Array.from(
      { length: Y.length - 1 },
      ($, B) => Y[B + 1] - Y[B]
    ),
    G = Array.from({ length: X.length }, () => Array(Y.length));
  for (let $ = 0; $ < X.length; ++$) {
    let B = G[$];
    for (let K = 0; K < Y.length; ++K) B[K] = Y[K] - X[$];
  }
  let J = Y.length - 2,
    U = Array.from({ length: J }, () => Array(X.length));
  for (let $ = 0; $ < X.length; ++$) {
    let B = G[$];
    for (let K = 0; K < J; ++K) {
      let V = -B[K] / Q[K],
        W = B[K + 2] / Q[K + 1];
      U[K][$] = Math.max(0, Math.min(V, W));
    }
  }
  return U;
}
function Iv(X, Y, Q) {
  let G = (Y - X) / (Q - 1);
  return Float64Array.from({ length: Q }, (J, U) => X + G * U);
}
function zX(X, Y, Q, G, J, U = null, $ = "htk", B = !1) {
  if (U !== null && U !== "slaney")
    throw Error('norm must be one of null or "slaney"');
  let K = Cq(Q, $),
    V = Cq(G, $),
    W = Iv(K, V, Y + 2),
    L = g40(W, $),
    H;
  if (B) {
    let N = J / (X * 2);
    ((H = Cq(
      Float64Array.from({ length: X }, (q, M) => M * N),
      $
    )),
      (L = W));
  } else H = Iv(0, Math.floor(J / 2), X);
  let F = u40(H, L);
  if (U !== null && U === "slaney")
    for (let N = 0; N < Y; ++N) {
      let q = F[N],
        M = 2 / (L[N + 2] - L[N]);
      for (let A = 0; A < X; ++A) q[A] *= M;
    }
  return F;
}
function l40(X, Y, Q) {
  let G = new X.constructor(X.length + Y + Q),
    J = X.length - 1;
  for (let U = 0; U < X.length; ++U) G[Y + U] = X[U];
  for (let U = 1; U <= Y; ++U) G[Y - U] = X[v7(U, J)];
  for (let U = 1; U <= Q; ++U) G[J + Y + U] = X[v7(J - U, J)];
  return G;
}
function Pv(X, Y, Q, G, J) {
  if (Q <= 0) throw Error("reference must be greater than zero");
  if (G <= 0) throw Error("min_value must be greater than zero");
  Q = Math.max(G, Q);
  let U = Math.log10(Q);
  for (let $ = 0; $ < X.length; ++$)
    X[$] = Y * Math.log10(Math.max(G, X[$]) - U);
  if (J !== null) {
    if (J <= 0) throw Error("db_range must be greater than zero");
    let $ = x5(X)[0] - J;
    for (let B = 0; B < X.length; ++B) X[B] = Math.max(X[B], $);
  }
  return X;
}
function m40(X, Y = 1, Q = 0.00001, G = null) {
  return Pv(X, 20, Y, Q, G);
}
function c40(X, Y = 1, Q = 0.0000000001, G = null) {
  return Pv(X, 10, Y, Q, G);
}
function t7(
  X,
  Y,
  Q,
  G,
  {
    fft_length: J = null,
    power: U = 1,
    center: $ = !0,
    pad_mode: B = "reflect",
    onesided: K = !0,
    preemphasis: V = null,
    mel_filters: W = null,
    mel_floor: L = 0.0000000001,
    log_mel: H = null,
    reference: F = 1,
    min_value: N = 0.0000000001,
    db_range: q = null,
    remove_dc_offset: M = null,
    max_num_frames: A = null,
    do_pad: D = !0,
    transpose: R = !1,
  } = {}
) {
  let z = Y.length;
  if (J === null) J = Q;
  if (Q > J)
    throw Error(`frame_length (${Q}) may not be larger than fft_length (${J})`);
  if (z !== Q)
    throw Error(`Length of the window (${z}) must equal frame_length (${Q})`);
  if (G <= 0) throw Error("hop_length must be greater than zero");
  if (U === null && W !== null)
    throw Error(
      "You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue."
    );
  if ($) {
    if (B !== "reflect") throw Error(`pad_mode="${B}" not implemented yet.`);
    let h = Math.floor((J - 1) / 2) + 1;
    X = l40(X, h, h);
  }
  let E = Math.floor(1 + Math.floor((X.length - Q) / G)),
    O = K ? Math.floor(J / 2) + 1 : J,
    Z = E,
    j = E;
  if (A !== null)
    if (A > E) {
      if (D) j = A;
    } else j = Z = A;
  let w = new DW(J),
    I = new Float64Array(J),
    T = new Float64Array(w.outputBufferSize),
    y = Array(Z);
  for (let h = 0; h < Z; ++h) {
    let p = h * G;
    for (let e = 0; e < Q; ++e) I[e] = X[p + e];
    if (M) {
      let e = 0;
      for (let x = 0; x < Q; ++x) e += I[x];
      let P = e / Q;
      for (let x = 0; x < Q; ++x) I[x] -= P;
    }
    if (V !== null) {
      for (let e = Q - 1; e >= 1; --e) I[e] -= V * I[e - 1];
      I[0] *= 1 - V;
    }
    for (let e = 0; e < Y.length; ++e) I[e] *= Y[e];
    w.realTransform(T, I);
    let N0 = Array(O);
    for (let e = 0; e < N0.length; ++e) {
      let P = e << 1;
      N0[e] = T[P] ** 2 + T[P + 1] ** 2;
    }
    y[h] = N0;
  }
  if (U !== null && U !== 2) {
    let h = 2 / U;
    for (let p = 0; p < y.length; ++p) {
      let N0 = y[p];
      for (let e = 0; e < N0.length; ++e) N0[e] **= h;
    }
  }
  let _ = W.length,
    f = new Float32Array(_ * j),
    l = R ? [j, _] : [_, j];
  for (let h = 0; h < _; ++h) {
    let p = W[h];
    for (let N0 = 0; N0 < Z; ++N0) {
      let e = y[N0],
        P = 0;
      for (let x = 0; x < O; ++x) P += p[x] * e[x];
      f[R ? N0 * _ + h : h * Z + N0] = Math.max(L, P);
    }
  }
  if (U !== null && H !== null) {
    let h = Math.min(f.length, Z * _);
    switch (H) {
      case "log":
        for (let p = 0; p < h; ++p) f[p] = Math.log(f[p]);
        break;
      case "log10":
        for (let p = 0; p < h; ++p) f[p] = Math.log10(f[p]);
        break;
      case "dB":
        if (U === 1) m40(f, F, N, q);
        else if (U === 2) c40(f, F, N, q);
        else throw Error(`Cannot use log_mel option '${H}' with power ${U}`);
        break;
      default:
        throw Error(
          `log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${H}'`
        );
    }
  }
  return { data: f, dims: l };
}
function e7(
  X,
  Y,
  { periodic: Q = !0, frame_length: G = null, center: J = !0 } = {}
) {
  let U = Q ? X + 1 : X,
    $;
  switch (Y) {
    case "boxcar":
      $ = new Float64Array(U).fill(1);
      break;
    case "hann":
    case "hann_window":
      $ = Iq(U);
      break;
    case "povey":
      $ = Iq(U).map((B) => Math.pow(B, 0.85));
      break;
    default:
      throw Error(`Unknown window type ${Y}.`);
  }
  if (Q) $ = $.subarray(0, X);
  if (G === null) return $;
  if (X > G)
    throw Error(
      `Length of the window (${X}) may not be larger than frame_length (${G})`
    );
  return $;
}
var x40, h40;
var F$ = U8(() => {
  t9();
  x40 = {
    htk: (X) => 2595 * Math.log10(1 + X / 700),
    kaldi: (X) => 1127 * Math.log(1 + X / 700),
    slaney: (X, Y = 1000, Q = 15, G = 27 / Math.log(6.4)) =>
      X >= Y ? Q + Math.log(X / Y) * G : (3 * X) / 200,
  };
  h40 = {
    htk: (X) => 700 * (10 ** (X / 2595) - 1),
    kaldi: (X) => 700 * (Math.exp(X / 1127) - 1),
    slaney: (X, Y = 1000, Q = 15, G = Math.log(6.4) / 27) =>
      X >= Q ? Y * Math.exp(G * (X - Q)) : (200 * X) / 3,
  };
});
function d40([X, Y, Q, G]) {
  return [X - Q / 2, Y - G / 2, X + Q / 2, Y + G / 2];
}
function Tq(X, Y = 0.5, Q = null, G = !1) {
  let { logits: J, pred_boxes: U } = X,
    [$, B, K] = J.dims;
  if (Q !== null && Q.length !== $)
    throw Error(
      "Make sure that you pass in as many target sizes as the batch dimension of the logits"
    );
  let V = [];
  for (let W = 0; W < $; ++W) {
    let L = Q !== null ? Q[W] : null,
      H = { boxes: [], classes: [], scores: [] },
      F = J[W],
      N = U[W];
    for (let q = 0; q < B; ++q) {
      let M = F[q],
        A = [],
        D;
      if (G) {
        D = M.sigmoid().data;
        for (let R = 0; R < D.length; ++R) if (D[R] > Y) A.push(R);
      } else {
        let R = x5(M.data)[1];
        if (R === K - 1) continue;
        (A.push(R), (D = Z5(M.data)));
      }
      for (let R of A) {
        let z = N[q].data;
        if (((z = d40(z)), L !== null)) z = z.map((E, O) => E * L[(O + 1) % 2]);
        (H.boxes.push(z), H.classes.push(R), H.scores.push(D[R]));
      }
    }
    V.push(H);
  }
  return V;
}
function tQ(X, Y) {
  if (!(X instanceof Float32Array || X instanceof Float64Array))
    throw Error(
      `${Y} expects input to be a Float32Array or a Float64Array, but got ${X?.constructor?.name ?? typeof X} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`
    );
}
function Sv(X, Y, Q = 0, G = null) {
  let J = X / Y,
    U = BK(J) * Y;
  if (G !== null && U > G) U = Math.floor(J) * Y;
  if (U < Q) U = Math.ceil(J) * Y;
  return U;
}
function Sq([X, Y], Q) {
  return [
    Math.max(Math.floor(X / Q), 1) * Q,
    Math.max(Math.floor(Y / Q), 1) * Q,
  ];
}
var w4,
  W5,
  bq,
  N$,
  vq,
  kq,
  yq,
  _q,
  fq,
  xq,
  M$,
  hq,
  gq,
  uq,
  lq,
  A$,
  mq,
  q$,
  cq,
  dq,
  pq,
  R$,
  iq,
  nq,
  aq,
  rq,
  oq,
  sq,
  tq,
  eq,
  XR,
  YR,
  QR,
  GR,
  C4,
  JR,
  WR,
  HR,
  $R,
  UR,
  s5;
var LR = U8(() => {
  t9();
  W9();
  V$();
  F$();
  w4 = class w4 extends f5 {
    constructor(X) {
      super();
      this.config = X;
    }
  };
  W5 = class W5 extends w4 {
    constructor(X) {
      super(X);
      if (
        ((this.image_mean = this.config.image_mean ?? this.config.mean),
        (this.image_std = this.config.image_std ?? this.config.std),
        (this.resample = this.config.resample ?? 2),
        (this.do_rescale = this.config.do_rescale ?? !0),
        (this.rescale_factor =
          this.config.rescale_factor ?? 0.00392156862745098),
        (this.do_normalize = this.config.do_normalize),
        (this.do_resize = this.config.do_resize),
        (this.do_thumbnail = this.config.do_thumbnail),
        (this.size = this.config.size),
        (this.size_divisibility =
          this.config.size_divisibility ?? this.config.size_divisor),
        (this.do_center_crop = this.config.do_center_crop),
        (this.crop_size = this.config.crop_size),
        (this.do_convert_rgb = this.config.do_convert_rgb ?? !0),
        (this.do_crop_margin = this.config.do_crop_margin),
        (this.pad_size = this.config.pad_size),
        (this.do_pad = this.config.do_pad),
        this.do_pad &&
          !this.pad_size &&
          this.size &&
          this.size.width !== void 0 &&
          this.size.height !== void 0)
      )
        this.pad_size = this.size;
      this.do_flip_channel_order = this.config.do_flip_channel_order ?? !1;
    }
    async thumbnail(X, Y, Q = 2) {
      let { height: G, width: J } = X,
        U = Y.height,
        $ = Y.width,
        B = Math.min(G, U),
        K = Math.min(J, $);
      if (B === G && K === J) return X;
      if (G > J) K = Math.floor((J * B) / G);
      else if (J > G) B = Math.floor((G * K) / J);
      return await X.resize(K, B, { resample: Q });
    }
    async crop_margin(X, Y = 200) {
      let Q = X.clone().grayscale(),
        G = SQ(Q.data)[0],
        U = x5(Q.data)[0] - G;
      if (U === 0) return X;
      let $ = Y / 255,
        B = Q.width,
        K = Q.height,
        V = 0,
        W = 0;
      for (let L = 0; L < Q.height; ++L) {
        let H = L * Q.width;
        for (let F = 0; F < Q.width; ++F)
          if ((Q.data[H + F] - G) / U < $)
            ((B = Math.min(B, F)),
              (K = Math.min(K, L)),
              (V = Math.max(V, F)),
              (W = Math.max(W, L)));
      }
      return ((X = await X.crop([B, K, V, W])), X);
    }
    pad_image(
      X,
      Y,
      Q,
      { mode: G = "constant", center: J = !1, constant_values: U = 0 } = {}
    ) {
      let [$, B, K] = Y,
        V,
        W;
      if (typeof Q === "number") ((V = Q), (W = Q));
      else ((V = Q.width), (W = Q.height));
      if (V !== B || W !== $) {
        let L = new Float32Array(V * W * K);
        if (Array.isArray(U))
          for (let N = 0; N < L.length; ++N) L[N] = U[N % K];
        else if (U !== 0) L.fill(U);
        let [H, F] = J
          ? [Math.floor((V - B) / 2), Math.floor((W - $) / 2)]
          : [0, 0];
        for (let N = 0; N < $; ++N) {
          let q = (N + F) * V,
            M = N * B;
          for (let A = 0; A < B; ++A) {
            let D = (q + A + H) * K,
              R = (M + A) * K;
            for (let z = 0; z < K; ++z) L[D + z] = X[R + z];
          }
        }
        if (G === "symmetric") {
          if (J)
            throw Error(
              "`center` padding is not supported when `mode` is set to `symmetric`."
            );
          let N = $ - 1,
            q = B - 1;
          for (let M = 0; M < W; ++M) {
            let A = M * V,
              D = v7(M, N) * B;
            for (let R = 0; R < V; ++R) {
              if (M < $ && R < B) continue;
              let z = (A + R) * K,
                E = (D + v7(R, q)) * K;
              for (let O = 0; O < K; ++O) L[z + O] = X[E + O];
            }
          }
        }
        ((X = L), (Y = [W, V, K]));
      }
      return [X, Y];
    }
    rescale(X) {
      for (let Y = 0; Y < X.length; ++Y) X[Y] = this.rescale_factor * X[Y];
    }
    get_resize_output_image_size(X, Y) {
      let [Q, G] = X.size,
        J,
        U;
      if (this.do_thumbnail) {
        let { height: $, width: B } = Y;
        J = Math.min($, B);
      } else if (Number.isInteger(Y))
        ((J = Y), (U = this.config.max_size ?? J));
      else if (Y !== void 0) ((J = Y.shortest_edge), (U = Y.longest_edge));
      if (J !== void 0 || U !== void 0) {
        let $ = J === void 0 ? 1 : Math.max(J / Q, J / G),
          B = Q * $,
          K = G * $,
          V = U === void 0 ? 1 : Math.min(U / B, U / K),
          W = Math.floor(Number((B * V).toFixed(2))),
          L = Math.floor(Number((K * V).toFixed(2)));
        if (this.size_divisibility !== void 0)
          [W, L] = Sq([W, L], this.size_divisibility);
        return [W, L];
      } else if (Y !== void 0 && Y.width !== void 0 && Y.height !== void 0) {
        let { width: $, height: B } = Y;
        if (this.config.keep_aspect_ratio && this.config.ensure_multiple_of) {
          let K = B / G,
            V = $ / Q;
          if (Math.abs(1 - V) < Math.abs(1 - K)) K = V;
          else V = K;
          ((B = Sv(K * G, this.config.ensure_multiple_of)),
            ($ = Sv(V * Q, this.config.ensure_multiple_of)));
        }
        return [$, B];
      } else if (this.size_divisibility !== void 0)
        return Sq([Q, G], this.size_divisibility);
      else
        throw Error(
          `Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(Y)}`
        );
    }
    async resize(X) {
      let [Y, Q] = this.get_resize_output_image_size(X, this.size);
      return await X.resize(Y, Q, { resample: this.resample });
    }
    async preprocess(
      X,
      {
        do_normalize: Y = null,
        do_pad: Q = null,
        do_convert_rgb: G = null,
        do_convert_grayscale: J = null,
        do_flip_channel_order: U = null,
      } = {}
    ) {
      if (this.do_crop_margin) X = await this.crop_margin(X);
      let [$, B] = X.size;
      if (G ?? this.do_convert_rgb) X = X.rgb();
      else if (J) X = X.grayscale();
      if (this.do_resize) X = await this.resize(X);
      if (this.do_thumbnail)
        X = await this.thumbnail(X, this.size, this.resample);
      if (this.do_center_crop) {
        let H, F;
        if (Number.isInteger(this.crop_size))
          ((H = this.crop_size), (F = this.crop_size));
        else ((H = this.crop_size.width), (F = this.crop_size.height));
        X = await X.center_crop(H, F);
      }
      let K = [X.height, X.width],
        V = Float32Array.from(X.data),
        W = [X.height, X.width, X.channels];
      if (this.do_rescale) this.rescale(V);
      if (Y ?? this.do_normalize) {
        let H = this.image_mean;
        if (!Array.isArray(this.image_mean)) H = Array(X.channels).fill(H);
        let F = this.image_std;
        if (!Array.isArray(this.image_std)) F = Array(X.channels).fill(H);
        if (H.length !== X.channels || F.length !== X.channels)
          throw Error(
            `When set to arrays, the length of \`image_mean\` (${H.length}) and \`image_std\` (${F.length}) must match the number of channels in the image (${X.channels}).`
          );
        for (let N = 0; N < V.length; N += X.channels)
          for (let q = 0; q < X.channels; ++q)
            V[N + q] = (V[N + q] - H[q]) / F[q];
      }
      if (Q ?? this.do_pad) {
        if (this.pad_size)
          [V, W] = this.pad_image(
            V,
            [X.height, X.width, X.channels],
            this.pad_size
          );
        else if (this.size_divisibility) {
          let [H, F] = Sq([W[1], W[0]], this.size_divisibility);
          [V, W] = this.pad_image(V, W, { width: H, height: F });
        }
      }
      if (U ?? this.do_flip_channel_order) {
        if (W[2] !== 3)
          throw Error(
            "Flipping channel order is only supported for RGB images."
          );
        for (let H = 0; H < V.length; H += 3) {
          let F = V[H];
          ((V[H] = V[H + 2]), (V[H + 2] = F));
        }
      }
      let L = new I0("float32", V, W).permute(2, 0, 1);
      return { original_size: [B, $], reshaped_input_size: K, pixel_values: L };
    }
    async _call(X, ...Y) {
      if (!Array.isArray(X)) X = [X];
      let Q = await Promise.all(X.map((J) => this.preprocess(J)));
      return {
        pixel_values: XX(
          Q.map((J) => J.pixel_values),
          0
        ),
        original_sizes: Q.map((J) => J.original_size),
        reshaped_input_sizes: Q.map((J) => J.reshaped_input_size),
      };
    }
  };
  bq = class bq extends W5 {
    post_process_semantic_segmentation(X, Y = null) {
      let Q = X.logits,
        G = Q.dims[0];
      if (Y !== null && Y.length !== G)
        throw Error(
          "Make sure that you pass in as many target sizes as the batch dimension of the logits"
        );
      let J = [];
      for (let U = 0; U < G; ++U) {
        let $ = Y !== null ? Y[U] : null,
          B = Q[U];
        if ($ !== null) B = J9(B, $, "bilinear", !1);
        let [K, V] = $ ?? B.dims.slice(-2),
          W = new I0("int32", new Int32Array(K * V), [K, V]),
          L = B[0].data;
        for (let q = 1; q < B.dims[0]; ++q) {
          let M = B[q].data;
          for (let A = 0; A < M.length; ++A)
            if (M[A] > L[A]) ((L[A] = M[A]), (W.data[A] = q));
        }
        let H = Array(B.dims[0]),
          F = W.data;
        for (let q = 0; q < F.length; ++q) {
          let M = F[q];
          H[M] = M;
        }
        let N = H.filter((q) => q !== void 0);
        J.push({ segmentation: W, labels: N });
      }
      return J;
    }
  };
  N$ = class N$ extends W5 {};
  vq = class vq extends N$ {};
  kq = class kq extends W5 {};
  yq = class yq extends W5 {};
  _q = class _q extends W5 {};
  fq = class fq extends W5 {};
  xq = class xq extends W5 {};
  M$ = class M$ extends W5 {
    constructor(X) {
      super(X);
      this.crop_pct = this.config.crop_pct ?? 0.875;
    }
    async resize(X) {
      let Y = this.size?.shortest_edge;
      if (Y === void 0)
        throw Error("Size dictionary must contain 'shortest_edge' key.");
      if (Y < 384) {
        let Q = Math.floor(Y / this.crop_pct),
          [G, J] = this.get_resize_output_image_size(X, { shortest_edge: Q });
        ((X = await X.resize(G, J, { resample: this.resample })),
          (X = await X.center_crop(Y, Y)));
      } else X = await X.resize(Y, Y, { resample: this.resample });
      return X;
    }
  };
  hq = class hq extends M$ {};
  gq = class gq extends W5 {};
  uq = class uq extends W5 {};
  lq = class lq extends W5 {
    constructor(X) {
      super(X);
      if (
        ((this.include_top = this.config.include_top ?? !0), this.include_top)
      )
        this.image_std = this.image_std.map((Y) => Y * Y);
    }
  };
  A$ = class A$ extends W5 {};
  mq = class mq extends A$ {};
  q$ = class q$ extends W5 {
    post_process_object_detection(...X) {
      return Tq(...X);
    }
  };
  cq = class cq extends q$ {};
  dq = class dq extends W5 {};
  pq = class pq extends W5 {};
  R$ = class R$ extends W5 {
    pad_image(X, Y, Q, G = {}) {
      let [J, U, $] = Y,
        B = this.image_mean;
      if (!Array.isArray(this.image_mean)) B = Array($).fill(B);
      let K = this.image_std;
      if (!Array.isArray(K)) K = Array($).fill(B);
      let V = B.map((W, L) => -W / K[L]);
      return super.pad_image(X, Y, Q, { center: !0, constant_values: V, ...G });
    }
  };
  iq = class iq extends R$ {};
  nq = class nq extends W5 {
    async _call(X) {
      let Y = await super._call(X),
        Q = [Y.pixel_values.dims[0], 64, 64],
        G = new I0(
          "int64",
          new BigInt64Array(Q.reduce((J, U) => J * U)).fill(1n),
          Q
        );
      return { ...Y, pixel_mask: G };
    }
    post_process_object_detection(...X) {
      return Tq(...X);
    }
    remove_low_and_no_objects(X, Y, Q, G) {
      let J = [],
        U = [],
        $ = [];
      for (let B = 0; B < X.dims[0]; ++B) {
        let K = X[B],
          V = Y[B],
          W = x5(K.data)[1];
        if (W === G) continue;
        let H = Z5(K.data)[W];
        if (H > Q) (J.push(V), U.push(H), $.push(W));
      }
      return [J, U, $];
    }
    check_segment_validity(X, Y, Q, G = 0.5, J = 0.8) {
      let U = [],
        $ = 0,
        B = 0;
      for (let V = 0; V < X.length; ++V) {
        if (X[V] === Q) (U.push(V), ++$);
        if (Y[Q].data[V] >= G) ++B;
      }
      let K = $ > 0 && B > 0;
      if (K) K = $ / B > J;
      return [K, U];
    }
    compute_segments(X, Y, Q, G, J, U = null, $ = null) {
      let [B, K] = $ ?? X[0].dims,
        V = new I0("int32", new Int32Array(B * K), [B, K]),
        W = [];
      if ($ !== null)
        for (let N = 0; N < X.length; ++N) X[N] = J9(X[N], $, "bilinear", !1);
      let L = new Int32Array(X[0].data.length),
        H = new Float32Array(X[0].data.length);
      for (let N = 0; N < X.length; ++N) {
        let q = Y[N];
        for (let M = 0; M < X[N].data.length; ++M)
          if (((X[N].data[M] *= q), X[N].data[M] > H[M]))
            ((L[M] = N), (H[M] = X[N].data[M]));
      }
      let F = 0;
      for (let N = 0; N < Q.length; ++N) {
        let q = Q[N],
          [M, A] = this.check_segment_validity(L, X, N, G, J);
        if (!M) continue;
        ++F;
        for (let D of A) V.data[D] = F;
        W.push({ id: F, label_id: q, score: Y[N] });
      }
      return [V, W];
    }
    post_process_panoptic_segmentation(
      X,
      Y = 0.5,
      Q = 0.5,
      G = 0.8,
      J = null,
      U = null
    ) {
      if (J === null)
        (console.warn("`label_ids_to_fuse` unset. No instance will be fused."),
          (J = new Set()));
      let $ = X.logits,
        K = X.pred_masks.sigmoid(),
        [V, W, L] = $.dims;
      if (((L -= 1), U !== null && U.length !== V))
        throw Error(
          "Make sure that you pass in as many target sizes as the batch dimension of the logits"
        );
      let H = [];
      for (let F = 0; F < V; ++F) {
        let N = U !== null ? U[F] : null,
          q = $[F],
          M = K[F],
          [A, D, R] = this.remove_low_and_no_objects(q, M, Y, L);
        if (R.length === 0) {
          let [O, Z] = N ?? M.dims.slice(-2),
            j = new I0("int32", new Int32Array(O * Z).fill(-1), [O, Z]);
          H.push({ segmentation: j, segments_info: [] });
          continue;
        }
        let [z, E] = this.compute_segments(A, D, R, Q, G, J, N);
        H.push({ segmentation: z, segments_info: E });
      }
      return H;
    }
    post_process_instance_segmentation() {
      throw Error("Not implemented yet");
    }
  };
  aq = class aq extends W5 {
    post_process_object_detection(...X) {
      return Tq(...X);
    }
  };
  rq = class rq extends W5 {
    reshape_input_points(X, Y, Q) {
      X = structuredClone(X);
      let G = nB(X);
      if (G.length === 3) ((G = [1, ...G]), (X = [X]));
      else if (G.length !== 4)
        throw Error(
          "The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`."
        );
      for (let J = 0; J < X.length; ++J) {
        let U = Y[J],
          $ = Q[J],
          B = [$[0] / U[0], $[1] / U[1]];
        for (let K = 0; K < X[J].length; ++K)
          for (let V = 0; V < X[J][K].length; ++V)
            for (let W = 0; W < X[J][K][V].length; ++W) X[J][K][V][W] *= B[W];
      }
      return new I0("float32", Float32Array.from(X.flat(1 / 0)), G);
    }
    add_input_labels(X, Y) {
      let Q = nB(X);
      if (Q.length === 2) ((Q = [1, ...Q]), (X = [X]));
      else if (Q.length !== 3)
        throw Error(
          "The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`."
        );
      if (Q.some((G, J) => G !== Y.dims[J]))
        throw Error(
          `The first ${Q.length} dimensions of 'input_points' and 'input_labels' must be the same.`
        );
      return new I0("int64", X.flat(1 / 0).map(BigInt), Q);
    }
    async _call(X, Y = null, Q = null) {
      let G = await super._call(X);
      if (Y)
        G.input_points = this.reshape_input_points(
          Y,
          G.original_sizes,
          G.reshaped_input_sizes
        );
      if (Q) {
        if (!G.input_points)
          throw Error(
            "`input_points` must be provided if `input_labels` are provided."
          );
        G.input_labels = this.add_input_labels(Q, G.input_points);
      }
      return G;
    }
    post_process_masks(
      X,
      Y,
      Q,
      { mask_threshold: G = 0, binarize: J = !0, pad_size: U = null } = {}
    ) {
      let $ = [];
      U = U ?? this.pad_size;
      let B = [U.height, U.width];
      for (let K = 0; K < Y.length; ++K) {
        let V = Y[K],
          W = Q[K],
          L = X[K],
          H = [];
        for (let F = 0; F < L.dims[0]; ++F) {
          let N = L[F],
            q = J9(N, B, "bilinear", !1);
          if (
            ((q = q.slice(null, [0, W[0]], [0, W[1]])),
            (q = J9(q, V, "bilinear", !1)),
            J)
          ) {
            let M = new Uint8Array(q.data.length);
            for (let A = 0; A < q.data.length; ++A) if (q.data[A] > G) M[A] = 1;
            q = new I0("bool", M, q.dims);
          }
          H.push(q);
        }
        $.push(XX(H));
      }
      return $;
    }
  };
  oq = class oq extends W5 {
    pad_image(X, Y, Q, G = {}) {
      let [J, U, $] = Y;
      return super.pad_image(
        X,
        Y,
        { width: U + ((Q - (U % Q)) % Q), height: J + ((Q - (J % Q)) % Q) },
        { mode: "symmetric", center: !1, constant_values: -1, ...G }
      );
    }
  };
  sq = class sq extends W5 {
    async _call(X, Y) {
      if (!Array.isArray(X)) X = [X];
      if (!Array.isArray(Y)) Y = [Y];
      let Q = await Promise.all(X.map((U) => this.preprocess(U))),
        G = await Promise.all(
          Y.map((U) =>
            this.preprocess(U, {
              do_normalize: !1,
              do_convert_rgb: !1,
              do_convert_grayscale: !0,
            })
          )
        );
      return {
        pixel_values: XX(
          Q.map((U, $) => e9([U.pixel_values, G[$].pixel_values], 0)),
          0
        ),
        original_sizes: Q.map((U) => U.original_size),
        reshaped_input_sizes: Q.map((U) => U.reshaped_input_size),
      };
    }
  };
  tq = class tq extends w4 {
    constructor(X) {
      super(X);
      ((this.config.mel_filters ??= zX(
        Math.floor(1 + this.config.n_fft / 2),
        this.config.feature_size,
        0,
        8000,
        this.config.sampling_rate,
        "slaney",
        "slaney"
      )),
        (this.window = e7(this.config.n_fft, "hann")));
    }
    _extract_fbank_features(X) {
      let { data: Y, dims: Q } = t7(
          X,
          this.window,
          this.config.n_fft,
          this.config.hop_length,
          {
            power: 2,
            mel_filters: this.config.mel_filters,
            log_mel: "log10",
            max_num_frames: this.config.nb_max_frames,
          }
        ),
        G = x5(Y)[0];
      for (let J = 0; J < Y.length; ++J) Y[J] = (Math.max(Y[J], G - 8) + 4) / 4;
      return { data: Y, dims: Q };
    }
    async _call(X) {
      tQ(X, "WhisperFeatureExtractor");
      let Y;
      if (X.length > this.config.n_samples)
        (console.warn(
          "Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."
        ),
          (Y = X.slice(0, this.config.n_samples)));
      else ((Y = new Float32Array(this.config.n_samples)), Y.set(X));
      let { data: Q, dims: G } = this._extract_fbank_features(Y);
      return { input_features: new I0("float32", Q, [1, ...G]) };
    }
  };
  eq = class eq extends w4 {
    _zero_mean_unit_var_norm(X) {
      let Q = X.reduce((J, U) => J + U, 0) / X.length,
        G = X.reduce((J, U) => J + (U - Q) ** 2, 0) / X.length;
      return X.map((J) => (J - Q) / Math.sqrt(G + 0.0000001));
    }
    async _call(X) {
      if ((tQ(X, "Wav2Vec2FeatureExtractor"), X instanceof Float64Array))
        X = new Float32Array(X);
      let Y = X;
      if (this.config.do_normalize) Y = this._zero_mean_unit_var_norm(Y);
      let Q = [1, Y.length];
      return {
        input_values: new I0("float32", Y, Q),
        attention_mask: new I0(
          "int64",
          new BigInt64Array(Y.length).fill(1n),
          Q
        ),
      };
    }
  };
  XR = class XR extends w4 {
    constructor(X) {
      super(X);
      let Y = this.config.sampling_rate,
        Q = zX(
          256,
          this.config.num_mel_bins,
          20,
          Math.floor(Y / 2),
          Y,
          null,
          "kaldi",
          !0
        );
      for (let G = 0; G < Q.length; ++G) Q[G].push(0);
      ((this.mel_filters = Q),
        (this.window = e7(400, "povey", { periodic: !1 })));
    }
    _extract_fbank_features(X, Y) {
      return (
        (X = X.map((Q) => Q * 32768)),
        t7(X, this.window, 400, 160, {
          fft_length: 512,
          power: 2,
          center: !1,
          preemphasis: 0.97,
          mel_filters: this.mel_filters,
          log_mel: "log",
          mel_floor: 0.0000001192092955078125,
          remove_dc_offset: !0,
          max_num_frames: Y,
          transpose: !0,
        })
      );
    }
    async _call(
      X,
      {
        padding: Y = !0,
        pad_to_multiple_of: Q = 2,
        do_normalize_per_mel_bins: G = !0,
        return_attention_mask: J = !0,
      } = {}
    ) {
      tQ(X, "SeamlessM4TFeatureExtractor");
      let U = this._extract_fbank_features(X, this.config.max_length);
      if (G) {
        let [F, N] = U.dims;
        for (let q = 0; q < N; ++q) {
          let M = 0;
          for (let z = 0; z < F; ++z) M += U.data[z * N + q];
          let A = M / F,
            D = 0;
          for (let z = 0; z < F; ++z) D += (U.data[z * N + q] - A) ** 2;
          D /= F - 1;
          let R = Math.sqrt(D + 0.0000001);
          for (let z = 0; z < F; ++z) {
            let E = z * N + q;
            U.data[E] = (U.data[E] - A) / R;
          }
        }
      }
      let $;
      if (Y) {
        let [F, N] = U.dims,
          q = F % Q;
        if (q > 0) {
          let M = new Float32Array(N * (F + q));
          (M.set(U.data), M.fill(this.config.padding_value, U.data.length));
          let A = F + q;
          if (((U = { data: M, dims: [A, N] }), J))
            (($ = new I0("int64", new BigInt64Array(A), [1, A])),
              $.data.fill(1n, 0, F));
        }
      }
      let [B, K] = U.dims,
        V = this.config.stride;
      if (B % V !== 0)
        throw Error(
          `The number of frames (${B}) must be a multiple of the stride (${V}).`
        );
      let L = new I0("float32", U.data, U.dims).view(
          1,
          Math.floor(B / V),
          K * V
        ),
        H = { input_features: L };
      if (J) {
        let F = L.dims[1],
          N = new I0("int64", new BigInt64Array(F), [1, F]);
        if ($) for (let q = 1, M = 0; q < B; q += V, ++M) N.data[M] = $.data[q];
        else N.data.fill(1n);
        H.attention_mask = N;
      }
      return H;
    }
  };
  YR = class YR extends w4 {
    constructor(X) {
      super(X);
      let Y = this.config.sampling_rate,
        Q = zX(
          256,
          this.config.num_mel_bins,
          20,
          Math.floor(Y / 2),
          Y,
          null,
          "kaldi",
          !0
        );
      for (let G = 0; G < Q.length; ++G) Q[G].push(0);
      ((this.mel_filters = Q),
        (this.window = e7(400, "hann", { periodic: !1 })),
        (this.mean = this.config.mean),
        (this.std = this.config.std));
    }
    _extract_fbank_features(X, Y) {
      return t7(X, this.window, 400, 160, {
        fft_length: 512,
        power: 2,
        center: !1,
        preemphasis: 0.97,
        mel_filters: this.mel_filters,
        log_mel: "log",
        mel_floor: 0.0000001192092955078125,
        remove_dc_offset: !0,
        max_num_frames: Y,
        transpose: !0,
      });
    }
    async _call(X) {
      tQ(X, "ASTFeatureExtractor");
      let Y = this._extract_fbank_features(X, this.config.max_length);
      if (this.config.do_normalize) {
        let Q = this.std * 2;
        for (let G = 0; G < Y.data.length; ++G)
          Y.data[G] = (Y.data[G] - this.mean) / Q;
      }
      return { input_values: new I0("float32", Y.data, [1, ...Y.dims]) };
    }
  };
  QR = class QR extends w4 {
    constructor(X) {
      super(X);
      ((this.mel_filters = zX(
        this.config.nb_frequency_bins,
        this.config.feature_size,
        this.config.frequency_min,
        this.config.frequency_max,
        this.config.sampling_rate,
        null,
        "htk"
      )),
        (this.mel_filters_slaney = zX(
          this.config.nb_frequency_bins,
          this.config.feature_size,
          this.config.frequency_min,
          this.config.frequency_max,
          this.config.sampling_rate,
          "slaney",
          "slaney"
        )),
        (this.window = e7(this.config.fft_window_size, "hann")));
    }
    _get_input_mel(X, Y, Q, G) {
      let J,
        U = !1,
        $ = X.length - Y;
      if ($ > 0)
        if (Q === "rand_trunc") {
          U = !0;
          let B = Math.floor(Math.random() * ($ + 1));
          ((X = X.subarray(B, B + Y)),
            (J = this._extract_fbank_features(
              X,
              this.mel_filters_slaney,
              this.config.nb_max_samples
            )),
            (J.dims = [1, ...J.dims]));
        } else throw Error(`Truncation strategy "${Q}" not implemented`);
      else {
        if ($ < 0) {
          let B = new Float64Array(Y);
          if ((B.set(X), G === "repeat"))
            for (let K = X.length; K < Y; K += X.length)
              B.set(X.subarray(0, Math.min(X.length, Y - K)), K);
          else if (G === "repeatpad")
            for (let K = X.length; K < -$; K += X.length) B.set(X, K);
          X = B;
        }
        if (Q === "fusion")
          throw Error(`Truncation strategy "${Q}" not implemented`);
        ((J = this._extract_fbank_features(
          X,
          this.mel_filters_slaney,
          this.config.nb_max_samples
        )),
          (J.dims = [1, ...J.dims]));
      }
      return { ...J, longer: U };
    }
    _extract_fbank_features(X, Y, Q = null) {
      return t7(
        X,
        this.window,
        this.config.fft_window_size,
        this.config.hop_length,
        {
          power: 2,
          mel_filters: Y,
          log_mel: "dB",
          max_num_frames: Q,
          do_pad: !1,
          transpose: !0,
        }
      );
    }
    async _call(X, { max_length: Y = null } = {}) {
      tQ(X, "ClapFeatureExtractor");
      let Q = this._get_input_mel(
        X,
        Y ?? this.config.nb_max_samples,
        this.config.truncation,
        this.config.padding
      );
      return { input_features: new I0("float32", Q.data, [1, ...Q.dims]) };
    }
  };
  GR = class GR extends w4 {};
  C4 = class C4 extends f5 {
    constructor(X) {
      super();
      this.feature_extractor = X;
    }
    async _call(X, ...Y) {
      return await this.feature_extractor(X, ...Y);
    }
  };
  JR = class JR extends C4 {
    async _call(...X) {
      return await this.feature_extractor(...X);
    }
    post_process_masks(...X) {
      return this.feature_extractor.post_process_masks(...X);
    }
    reshape_input_points(...X) {
      return this.feature_extractor.reshape_input_points(...X);
    }
  };
  WR = class WR extends C4 {
    async _call(X) {
      return await this.feature_extractor(X);
    }
  };
  HR = class HR extends C4 {
    async _call(X) {
      return await this.feature_extractor(X);
    }
  };
  $R = class $R extends C4 {
    async _call(X) {
      return await this.feature_extractor(X);
    }
  };
  UR = class UR extends C4 {};
  s5 = class s5 {
    static FEATURE_EXTRACTOR_CLASS_MAPPING = {
      ImageFeatureExtractor: W5,
      WhisperFeatureExtractor: tq,
      ViTFeatureExtractor: gq,
      MobileViTFeatureExtractor: A$,
      MobileViTImageProcessor: mq,
      OwlViTFeatureExtractor: q$,
      Owlv2ImageProcessor: cq,
      CLIPFeatureExtractor: _q,
      ChineseCLIPFeatureExtractor: fq,
      SiglipImageProcessor: xq,
      ConvNextFeatureExtractor: M$,
      ConvNextImageProcessor: hq,
      SegformerFeatureExtractor: bq,
      BitImageProcessor: kq,
      DPTImageProcessor: vq,
      DPTFeatureExtractor: N$,
      GLPNFeatureExtractor: yq,
      BeitFeatureExtractor: pq,
      DeiTFeatureExtractor: dq,
      DetrFeatureExtractor: nq,
      YolosFeatureExtractor: aq,
      DonutFeatureExtractor: R$,
      NougatImageProcessor: iq,
      EfficientNetImageProcessor: lq,
      ViTImageProcessor: uq,
      VitMatteImageProcessor: sq,
      SamImageProcessor: rq,
      Swin2SRImageProcessor: oq,
      Wav2Vec2FeatureExtractor: eq,
      SeamlessM4TFeatureExtractor: XR,
      SpeechT5FeatureExtractor: GR,
      ASTFeatureExtractor: YR,
      ClapFeatureExtractor: QR,
    };
    static PROCESSOR_CLASS_MAPPING = {
      WhisperProcessor: WR,
      Wav2Vec2ProcessorWithLM: HR,
      SamProcessor: JR,
      SpeechT5Processor: $R,
      OwlViTProcessor: UR,
    };
    static async from_pretrained(
      X,
      {
        progress_callback: Y = null,
        config: Q = null,
        cache_dir: G = null,
        local_files_only: J = !1,
        revision: U = "main",
      } = {}
    ) {
      let $ =
          Q ??
          (await g6(X, "preprocessor_config.json", !0, {
            progress_callback: Y,
            config: Q,
            cache_dir: G,
            local_files_only: J,
            revision: U,
          })),
        B = $.feature_extractor_type ?? $.image_processor_type,
        K = this.FEATURE_EXTRACTOR_CLASS_MAPPING[B];
      if (!K)
        if ($.size !== void 0)
          (console.warn(
            `Feature extractor type "${B}" not found, assuming ImageFeatureExtractor due to size parameter in config.`
          ),
            (K = W5));
        else throw Error(`Unknown Feature Extractor type: ${B}`);
      let V = this.PROCESSOR_CLASS_MAPPING[$.processor_class] ?? C4,
        W = new K($);
      return new V(W);
    }
  };
});
async function n6(X) {
  if (!Array.isArray(X)) X = [X];
  return await Promise.all(X.map((Y) => o5.read(Y)));
}
async function D$(X, Y) {
  if (!Array.isArray(X)) X = [X];
  return await Promise.all(
    X.map((Q) => {
      if (typeof Q === "string" || Q instanceof URL) return Pq(Q, Y);
      else if (Q instanceof Float64Array) return new Float32Array(Q);
      return Q;
    })
  );
}
function vv(X, Y) {
  if (Y) X = X.map(($) => $ | 0);
  let [Q, G, J, U] = X;
  return { xmin: Q, ymin: G, xmax: J, ymax: U };
}
function Tv(X) {
  return Array.isArray(X) && X.every((Y) => "role" in Y && "content" in Y);
}
async function i40(
  X,
  Y = null,
  {
    quantized: Q = !0,
    progress_callback: G = null,
    config: J = null,
    cache_dir: U = null,
    local_files_only: $ = !1,
    revision: B = "main",
    model_file_name: K = null,
  } = {}
) {
  X = p40[X] ?? X;
  let V = bv[X.split("_", 1)[0]];
  if (!V)
    throw Error(
      `Unsupported pipeline: ${X}. Must be one of [${Object.keys(bv)}]`
    );
  if (!Y)
    ((Y = V.default.model),
      console.log(`No model specified. Using default model: "${Y}".`));
  let W = {
      quantized: Q,
      progress_callback: G,
      config: J,
      cache_dir: U,
      local_files_only: $,
      revision: B,
      model_file_name: K,
    },
    L = new Map([
      ["tokenizer", V.tokenizer],
      ["model", V.model],
      ["processor", V.processor],
    ]),
    H = await n40(L, Y, W);
  return (
    (H.task = X),
    e4(G, { status: "ready", task: X, model: Y }),
    new V.pipeline(H)
  );
}
async function n40(X, Y, Q) {
  let G = Object.create(null),
    J = [];
  for (let [U, $] of X.entries()) {
    if (!$) continue;
    let B;
    if (Array.isArray($))
      B = new Promise(async (K, V) => {
        let W;
        for (let L of $) {
          if (L === null) {
            K(null);
            return;
          }
          try {
            K(await L.from_pretrained(Y, Q));
            return;
          } catch (H) {
            W = H;
          }
        }
        V(W);
      });
    else B = $.from_pretrained(Y, Q);
    ((G[U] = B), J.push(B));
  }
  await Promise.all(J);
  for (let [U, $] of Object.entries(G)) G[U] = await $;
  return G;
}
var U5,
  BR,
  KR,
  VR,
  FR,
  eQ,
  NR,
  z$,
  MR,
  AR,
  qR,
  RR,
  DR,
  zR,
  ER,
  OR,
  ZR,
  jR,
  wR,
  CR,
  IR,
  PR,
  SR,
  TR,
  bR,
  bv,
  p40;
var kv = U8(() => {
  NV();
  sA();
  LR();
  F$();
  W9();
  V$();
  U5 = class U5 extends f5 {
    constructor({
      task: X,
      model: Y,
      tokenizer: Q = null,
      processor: G = null,
    }) {
      super();
      ((this.task = X),
        (this.model = Y),
        (this.tokenizer = Q),
        (this.processor = G));
    }
    async dispose() {
      await this.model.dispose();
    }
  };
  BR = class BR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, { topk: Y = 1 } = {}) {
      let Q = this.tokenizer(X, { padding: !0, truncation: !0 }),
        G = await this.model(Q),
        J =
          this.model.config.problem_type === "multi_label_classification"
            ? (B) => B.sigmoid().data
            : (B) => Z5(B.data),
        U = this.model.config.id2label,
        $ = [];
      for (let B of G.logits) {
        let K = J(B),
          W = q4(K, Y).map((L) => ({ label: U[L[0]], score: L[1] }));
        if (Y === 1) $.push(...W);
        else $.push(W);
      }
      return Array.isArray(X) || Y === 1 ? $ : $[0];
    }
  };
  KR = class KR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, { ignore_labels: Y = ["O"] } = {}) {
      let Q = Array.isArray(X),
        G = this.tokenizer(Q ? X : [X], { padding: !0, truncation: !0 }),
        U = (await this.model(G)).logits,
        $ = this.model.config.id2label,
        B = [];
      for (let K = 0; K < U.dims[0]; ++K) {
        let V = G.input_ids[K],
          W = U[K],
          L = [];
        for (let H = 0; H < W.dims[0]; ++H) {
          let F = W[H],
            N = x5(F.data)[1],
            q = $ ? $[N] : `LABEL_${N}`;
          if (Y.includes(q)) continue;
          let M = this.tokenizer.decode([V[H].item()], {
            skip_special_tokens: !0,
          });
          if (M === "") continue;
          let A = Z5(F.data);
          L.push({
            entity: q,
            score: A[N],
            index: H,
            word: M,
            start: null,
            end: null,
          });
        }
        B.push(L);
      }
      return Q ? B : B[0];
    }
  };
  VR = class VR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, Y, { topk: Q = 1 } = {}) {
      let G = this.tokenizer(X, { text_pair: Y, padding: !0, truncation: !0 }),
        J = await this.model(G),
        U = [];
      for (let $ = 0; $ < J.start_logits.dims[0]; ++$) {
        let B = G.input_ids[$],
          K = B.indexOf(this.tokenizer.sep_token_id),
          V = Array.from(Z5(J.start_logits[$].data))
            .map((H, F) => [H, F])
            .filter((H) => H[1] > K),
          W = Array.from(Z5(J.end_logits[$].data))
            .map((H, F) => [H, F])
            .filter((H) => H[1] > K),
          L = MP(V, W)
            .filter((H) => H[0][1] <= H[1][1])
            .map((H) => [H[0][1], H[1][1], H[0][0] * H[1][0]])
            .sort((H, F) => F[2] - H[2]);
        for (let H = 0; H < Math.min(L.length, Q); ++H) {
          let [F, N, q] = L[H],
            M = [...B].slice(F, N + 1),
            A = this.tokenizer.decode(M, { skip_special_tokens: !0 });
          U.push({ answer: A, score: q });
        }
      }
      return Q === 1 ? U[0] : U;
    }
  };
  FR = class FR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, { topk: Y = 5 } = {}) {
      let Q = this.tokenizer(X, { padding: !0, truncation: !0 }),
        G = await this.model(Q),
        J = [];
      for (let U = 0; U < Q.input_ids.dims[0]; ++U) {
        let $ = Q.input_ids[U],
          B = $.indexOf(this.tokenizer.mask_token_id);
        if (B === -1)
          throw Error(
            `Mask token (${this.tokenizer.mask_token}) not found in text.`
          );
        let V = G.logits[U][B],
          W = q4(Z5(V.data), Y);
        J.push(
          W.map((L) => {
            let H = [...$];
            return (
              (H[B] = L[0]),
              {
                score: L[1],
                token: L[0],
                token_str: this.tokenizer.model.vocab[L[0]],
                sequence: this.tokenizer.decode(H, { skip_special_tokens: !0 }),
              }
            );
          })
        );
      }
      return Array.isArray(X) ? J : J[0];
    }
  };
  eQ = class eQ extends U5 {
    _key = "generated_text";
    constructor(X) {
      super(X);
    }
    async _call(X, Y = {}) {
      if (!Array.isArray(X)) X = [X];
      if (this.model.config.prefix)
        X = X.map((B) => this.model.config.prefix + B);
      let Q = this.model.config.task_specific_params;
      if (Q && Q[this.task]) {
        if (Q[this.task].prefix) X = X.map((B) => Q[this.task].prefix + B);
      }
      let G = this.tokenizer,
        J = { padding: !0, truncation: !0 },
        U;
      if (this instanceof z$ && "_build_translation_inputs" in G)
        U = G._build_translation_inputs(X, J, Y).input_ids;
      else U = G(X, J).input_ids;
      let $ = await this.model.generate(U, Y);
      return G.batch_decode($, { skip_special_tokens: !0 }).map((B) => ({
        [this._key]: B,
      }));
    }
  };
  NR = class NR extends eQ {
    _key = "summary_text";
    constructor(X) {
      super(X);
    }
  };
  z$ = class z$ extends eQ {
    _key = "translation_text";
    constructor(X) {
      super(X);
    }
  };
  MR = class MR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, Y = {}) {
      let Q = !1,
        G = !1,
        J;
      if (typeof X === "string") J = X = [X];
      else if (Array.isArray(X) && X.every((F) => typeof F === "string"))
        ((Q = !0), (J = X));
      else {
        if (Tv(X)) X = [X];
        else if (Array.isArray(X) && X.every(Tv)) Q = !0;
        else
          throw Error(
            "Input must be a string, an array of strings, a Chat, or an array of Chats"
          );
        ((G = !0),
          (J = X.map((F) =>
            this.tokenizer.apply_chat_template(F, {
              tokenize: !1,
              add_generation_prompt: !0,
            })
          )));
      }
      let U = Y.add_special_tokens ?? !1,
        $ = G ? !1 : (Y.return_full_text ?? !0);
      this.tokenizer.padding_side = "left";
      let { input_ids: B, attention_mask: K } = this.tokenizer(J, {
          add_special_tokens: U,
          padding: !0,
          truncation: !0,
        }),
        V = await this.model.generate(B, Y, null, { inputs_attention_mask: K }),
        W = this.tokenizer.batch_decode(V, { skip_special_tokens: !0 }),
        L;
      if (!$ && B.dims.at(-1) > 0)
        L = this.tokenizer
          .batch_decode(B, { skip_special_tokens: !0 })
          .map((F) => F.length);
      let H = Array.from({ length: X.length }, (F) => []);
      for (let F = 0; F < W.length; ++F) {
        let N = Math.floor((F / V.length) * X.length);
        if (L) W[F] = W[F].slice(L[N]);
        H[N].push({
          generated_text: G
            ? [...X[N], { role: "assistant", content: W[F] }]
            : W[F],
        });
      }
      return !Q && H.length === 1 ? H[0] : H;
    }
  };
  AR = class AR extends U5 {
    constructor(X) {
      super(X);
      if (
        ((this.label2id = Object.fromEntries(
          Object.entries(this.model.config.label2id).map(([Y, Q]) => [
            Y.toLowerCase(),
            Q,
          ])
        )),
        (this.entailment_id = this.label2id.entailment),
        this.entailment_id === void 0)
      )
        (console.warn(
          "Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."
        ),
          (this.entailment_id = 2));
      if (
        ((this.contradiction_id =
          this.label2id.contradiction ?? this.label2id.not_entailment),
        this.contradiction_id === void 0)
      )
        (console.warn(
          "Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."
        ),
          (this.contradiction_id = 0));
    }
    async _call(
      X,
      Y,
      {
        hypothesis_template: Q = "This example is {}.",
        multi_label: G = !1,
      } = {}
    ) {
      let J = Array.isArray(X);
      if (!J) X = [X];
      if (!Array.isArray(Y)) Y = [Y];
      let U = Y.map((K) => Q.replace("{}", K)),
        $ = G || Y.length === 1,
        B = [];
      for (let K of X) {
        let V = [];
        for (let H of U) {
          let F = this.tokenizer(K, {
              text_pair: H,
              padding: !0,
              truncation: !0,
            }),
            N = await this.model(F);
          if ($)
            V.push([
              N.logits.data[this.contradiction_id],
              N.logits.data[this.entailment_id],
            ]);
          else V.push(N.logits.data[this.entailment_id]);
        }
        let L = ($ ? V.map((H) => Z5(H)[1]) : Z5(V))
          .map((H, F) => [H, F])
          .sort((H, F) => F[0] - H[0]);
        B.push({
          sequence: K,
          labels: L.map((H) => Y[H[1]]),
          scores: L.map((H) => H[0]),
        });
      }
      return J ? B : B[0];
    }
  };
  qR = class qR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(
      X,
      {
        pooling: Y = "none",
        normalize: Q = !1,
        quantize: G = !1,
        precision: J = "binary",
      } = {}
    ) {
      let U = this.tokenizer(X, { padding: !0, truncation: !0 }),
        $ = await this.model(U),
        B = $.last_hidden_state ?? $.logits ?? $.token_embeddings;
      if (Y === "none");
      else if (Y === "mean") B = VK(B, U.attention_mask);
      else if (Y === "cls") B = B.slice(null, 0);
      else throw Error(`Pooling method '${Y}' not supported.`);
      if (Q) B = B.normalize(2, -1);
      if (G) B = MK(B, J);
      return B;
    }
  };
  RR = class RR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, { pool: Y = null } = {}) {
      let Q = await n6(X),
        { pixel_values: G } = await this.processor(Q),
        J = await this.model({ pixel_values: G }),
        U;
      if (Y) {
        if (!("pooler_output" in J))
          throw Error(
            "No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option."
          );
        U = J.pooler_output;
      } else U = J.last_hidden_state ?? J.logits ?? J.image_embeds;
      return U;
    }
  };
  DR = class DR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, { topk: Y = null } = {}) {
      let Q = !Array.isArray(X),
        G = this.processor.feature_extractor.config.sampling_rate,
        J = await D$(X, G),
        U = this.model.config.id2label,
        $ = [];
      for (let B of J) {
        let K = await this.processor(B),
          W = (await this.model(K)).logits[0],
          H = q4(Z5(W.data), Y).map((F) => ({ label: U[F[0]], score: F[1] }));
        if (Y === 1) $.push(...H);
        else $.push(H);
      }
      return !Q || Y === 1 ? $ : $[0];
    }
  };
  zR = class zR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(
      X,
      Y,
      { hypothesis_template: Q = "This is a sound of {}." } = {}
    ) {
      let G = !Array.isArray(X);
      if (G) X = [X];
      let J = Y.map((V) => Q.replace("{}", V)),
        U = this.tokenizer(J, { padding: !0, truncation: !0 }),
        $ = this.processor.feature_extractor.config.sampling_rate,
        B = await D$(X, $),
        K = [];
      for (let V of B) {
        let W = await this.processor(V),
          L = await this.model({ ...U, ...W }),
          H = Z5(L.logits_per_audio.data);
        K.push([...H].map((F, N) => ({ score: F, label: Y[N] })));
      }
      return G ? K[0] : K;
    }
  };
  ER = class ER extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, Y = {}) {
      switch (this.model.config.model_type) {
        case "whisper":
          return this._call_whisper(X, Y);
        case "wav2vec2":
        case "wav2vec2-bert":
        case "unispeech":
        case "unispeech-sat":
        case "hubert":
          return this._call_wav2vec2(X, Y);
        default:
          throw Error(
            `AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`
          );
      }
    }
    async _call_wav2vec2(X, Y = {}) {
      if (Y.language)
        console.warn(
          '`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'
        );
      if (Y.task)
        console.warn(
          '`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".'
        );
      let Q = !Array.isArray(X);
      if (Q) X = [X];
      let G = this.processor.feature_extractor.config.sampling_rate,
        J = await D$(X, G),
        U = [];
      for (let $ of J) {
        let B = await this.processor($),
          V = (await this.model(B)).logits[0],
          W = [];
        for (let H of V) W.push(x5(H.data)[1]);
        let L = this.tokenizer.decode(W);
        U.push({ text: L });
      }
      return Q ? U[0] : U;
    }
    async _call_whisper(X, Y = {}) {
      let Q = Y.return_timestamps ?? !1,
        G = Y.chunk_length_s ?? 0,
        J = Y.chunk_callback ?? null,
        U = Y.force_full_sequences ?? !1,
        $ = Y.stride_length_s ?? null;
      if (Q === "word") Y.return_token_timestamps = !0;
      let B = aB(Y, "language", null),
        K = aB(Y, "task", null);
      if (B || K || Q) {
        if (Y.forced_decoder_ids)
          throw Error(
            "Cannot specify `language`/`task`/`return_timestamps` and `forced_decoder_ids` at the same time."
          );
        let q = this.tokenizer.get_decoder_prompt_ids({
          language: B,
          task: K,
          no_timestamps: !Q,
        });
        if (q.length > 0) Y.forced_decoder_ids = q;
      }
      let V = !Array.isArray(X);
      if (V) X = [X];
      let W =
          this.processor.feature_extractor.config.chunk_length /
          this.model.config.max_source_positions,
        L = this.processor.feature_extractor.config.hop_length,
        H = this.processor.feature_extractor.config.sampling_rate,
        F = await D$(X, H),
        N = [];
      for (let q of F) {
        let M = [];
        if (G > 0) {
          if ($ === null) $ = G / 6;
          else if (G <= $)
            throw Error(
              "`chunk_length_s` must be larger than `stride_length_s`."
            );
          let R = H * G,
            z = H * $,
            E = R - 2 * z,
            O = 0;
          while (O < q.length) {
            let Z = q.subarray(O, O + R),
              j = await this.processor(Z),
              w = O === 0,
              I = O + E >= q.length;
            (M.push({
              stride: [Z.length, w ? 0 : z, I ? 0 : z],
              input_features: j.input_features,
              is_last: I,
            }),
              (O += E));
          }
        } else
          M = [
            {
              stride: [q.length, 0, 0],
              input_features: (await this.processor(q)).input_features,
              is_last: !0,
            },
          ];
        for (let R of M) {
          Y.num_frames = Math.floor(R.stride[0] / L);
          let z = await this.model.generate(R.input_features, Y);
          if (Q === "word")
            ((R.tokens = z.sequences[0]),
              (R.token_timestamps = z.token_timestamps
                .tolist()[0]
                .map((E) => Q9(E, 2))));
          else R.tokens = z[0];
          if (((R.stride = R.stride.map((E) => E / H)), J !== null)) J(R);
        }
        let [A, D] = this.tokenizer._decode_asr(M, {
          time_precision: W,
          return_timestamps: Q,
          force_full_sequences: U,
        });
        N.push({ text: A, ...D });
      }
      return V ? N[0] : N;
    }
  };
  OR = class OR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, Y = {}) {
      let Q = Array.isArray(X),
        G = await n6(X),
        { pixel_values: J } = await this.processor(G),
        U = [];
      for (let $ of J) {
        $.dims = [1, ...$.dims];
        let B = await this.model.generate($, Y),
          K = this.tokenizer
            .batch_decode(B, { skip_special_tokens: !0 })
            .map((V) => ({ generated_text: V.trim() }));
        U.push(K);
      }
      return Q ? U : U[0];
    }
  };
  ZR = class ZR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, { topk: Y = 1 } = {}) {
      let Q = Array.isArray(X),
        G = await n6(X),
        { pixel_values: J } = await this.processor(G),
        U = await this.model({ pixel_values: J }),
        $ = this.model.config.id2label,
        B = [];
      for (let K of U.logits) {
        let W = q4(Z5(K.data), Y).map((L) => ({ label: $[L[0]], score: L[1] }));
        if (Y === 1) B.push(...W);
        else B.push(W);
      }
      return Q || Y === 1 ? B : B[0];
    }
  };
  jR = class jR extends U5 {
    constructor(X) {
      super(X);
      this.subtasks_mapping = {
        panoptic: "post_process_panoptic_segmentation",
        instance: "post_process_instance_segmentation",
        semantic: "post_process_semantic_segmentation",
      };
    }
    async _call(
      X,
      {
        threshold: Y = 0.5,
        mask_threshold: Q = 0.5,
        overlap_mask_area_threshold: G = 0.8,
        label_ids_to_fuse: J = null,
        target_sizes: U = null,
        subtask: $ = null,
      } = {}
    ) {
      if (Array.isArray(X) && X.length !== 1)
        throw Error(
          "Image segmentation pipeline currently only supports a batch size of 1."
        );
      let K = await n6(X),
        V = K.map((M) => [M.height, M.width]),
        { pixel_values: W, pixel_mask: L } = await this.processor(K),
        H = await this.model({ pixel_values: W, pixel_mask: L }),
        F = null;
      if ($ !== null) F = this.subtasks_mapping[$];
      else
        for (let [M, A] of Object.entries(this.subtasks_mapping))
          if (A in this.processor.feature_extractor) {
            ((F = this.processor.feature_extractor[A].bind(
              this.processor.feature_extractor
            )),
              ($ = M));
            break;
          }
      let N = this.model.config.id2label,
        q = [];
      if ($ === "panoptic" || $ === "instance") {
        let M = F(H, Y, Q, G, J, U ?? V)[0],
          A = M.segmentation;
        for (let D of M.segments_info) {
          let R = new Uint8ClampedArray(A.data.length);
          for (let E = 0; E < A.data.length; ++E)
            if (A.data[E] === D.id) R[E] = 255;
          let z = new o5(R, A.dims[1], A.dims[0], 1);
          q.push({ score: D.score, label: N[D.label_id], mask: z });
        }
      } else if ($ === "semantic") {
        let { segmentation: M, labels: A } = F(H, U ?? V)[0];
        for (let D of A) {
          let R = new Uint8ClampedArray(M.data.length);
          for (let E = 0; E < M.data.length; ++E)
            if (M.data[E] === D) R[E] = 255;
          let z = new o5(R, M.dims[1], M.dims[0], 1);
          q.push({ score: null, label: N[D], mask: z });
        }
      } else throw Error(`Subtask ${$} not supported.`);
      return q;
    }
  };
  wR = class wR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(
      X,
      Y,
      { hypothesis_template: Q = "This is a photo of {}" } = {}
    ) {
      let G = Array.isArray(X),
        J = await n6(X),
        U = Y.map((L) => Q.replace("{}", L)),
        $ = this.tokenizer(U, {
          padding:
            this.model.config.model_type === "siglip" ? "max_length" : !0,
          truncation: !0,
        }),
        { pixel_values: B } = await this.processor(J),
        K = await this.model({ ...$, pixel_values: B }),
        V =
          this.model.config.model_type === "siglip"
            ? (L) => L.sigmoid().data
            : (L) => Z5(L.data),
        W = [];
      for (let L of K.logits_per_image) {
        let F = [...V(L)].map((N, q) => ({ score: N, label: Y[q] }));
        (F.sort((N, q) => q.score - N.score), W.push(F));
      }
      return G ? W : W[0];
    }
  };
  CR = class CR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, { threshold: Y = 0.9, percentage: Q = !1 } = {}) {
      let G = Array.isArray(X);
      if (G && X.length !== 1)
        throw Error(
          "Object detection pipeline currently only supports a batch size of 1."
        );
      let J = await n6(X),
        U = Q ? null : J.map((H) => [H.height, H.width]),
        { pixel_values: $, pixel_mask: B } = await this.processor(J),
        K = await this.model({ pixel_values: $, pixel_mask: B }),
        V = this.processor.feature_extractor.post_process_object_detection(
          K,
          Y,
          U
        ),
        W = this.model.config.id2label,
        L = V.map((H) =>
          H.boxes.map((F, N) => ({
            score: H.scores[N],
            label: W[H.classes[N]],
            box: vv(F, !Q),
          }))
        );
      return G ? L : L[0];
    }
  };
  IR = class IR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(
      X,
      Y,
      { threshold: Q = 0.1, topk: G = null, percentage: J = !1 } = {}
    ) {
      let U = Array.isArray(X),
        $ = await n6(X),
        B = this.tokenizer(Y, { padding: !0, truncation: !0 }),
        K = await this.processor($),
        V = [];
      for (let W = 0; W < $.length; ++W) {
        let L = $[W],
          H = J ? null : [[L.height, L.width]],
          F = K.pixel_values[W].unsqueeze_(0),
          N = await this.model({ ...B, pixel_values: F }),
          q = this.processor.feature_extractor.post_process_object_detection(
            N,
            Q,
            H,
            !0
          )[0],
          M = q.boxes
            .map((A, D) => ({
              score: q.scores[D],
              label: Y[q.classes[D]],
              box: vv(A, !J),
            }))
            .sort((A, D) => D.score - A.score);
        if (G !== null) M = M.slice(0, G);
        V.push(M);
      }
      return U ? V : V[0];
    }
  };
  PR = class PR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X, Y, Q = {}) {
      let G = (await n6(X))[0],
        { pixel_values: J } = await this.processor(G),
        U = `<s_docvqa><s_question>${Y}</s_question><s_answer>`,
        $ = this.tokenizer(U, {
          add_special_tokens: !1,
          padding: !0,
          truncation: !0,
        }).input_ids,
        B = await this.model.generate(J, {
          ...Q,
          decoder_input_ids: $,
          max_length: this.model.config.decoder.max_position_embeddings,
        }),
        V = this.tokenizer
          .batch_decode(B)[0]
          .match(/<s_answer>(.*?)<\/s_answer>/),
        W = null;
      if (V && V.length >= 2) W = V[1].trim();
      return [{ answer: W }];
    }
  };
  SR = class SR extends U5 {
    DEFAULT_VOCODER_ID = "Xenova/speecht5_hifigan";
    constructor(X) {
      super(X);
      this.vocoder = X.vocoder ?? null;
    }
    async _call(X, { speaker_embeddings: Y = null } = {}) {
      if (this.processor)
        return this._call_text_to_spectrogram(X, { speaker_embeddings: Y });
      else return this._call_text_to_waveform(X);
    }
    async _call_text_to_waveform(X) {
      let Y = this.tokenizer(X, { padding: !0, truncation: !0 }),
        { waveform: Q } = await this.model(Y),
        G = this.model.config.sampling_rate;
      return { audio: Q.data, sampling_rate: G };
    }
    async _call_text_to_spectrogram(X, { speaker_embeddings: Y }) {
      if (!this.vocoder)
        (console.log("No vocoder specified, using default HifiGan vocoder."),
          (this.vocoder = await $9.from_pretrained(this.DEFAULT_VOCODER_ID, {
            quantized: !1,
          })));
      if (typeof Y === "string" || Y instanceof URL)
        Y = new Float32Array(await (await fetch(Y)).arrayBuffer());
      if (Y instanceof Float32Array) Y = new I0("float32", Y, [1, Y.length]);
      else if (!(Y instanceof I0))
        throw Error(
          "Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`."
        );
      let { input_ids: Q } = this.tokenizer(X, { padding: !0, truncation: !0 }),
        { waveform: G } = await this.model.generate_speech(Q, Y, {
          vocoder: this.vocoder,
        }),
        J = this.processor.feature_extractor.config.sampling_rate;
      return { audio: G.data, sampling_rate: J };
    }
  };
  TR = class TR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X) {
      let Y = await n6(X),
        Q = await this.processor(Y),
        G = await this.model(Q),
        J = [];
      for (let U of G.reconstruction) {
        let $ = U.squeeze().clamp_(0, 1).mul_(255).round_().to("uint8");
        J.push(o5.fromTensor($));
      }
      return J.length > 1 ? J : J[0];
    }
  };
  bR = class bR extends U5 {
    constructor(X) {
      super(X);
    }
    async _call(X) {
      let Y = await n6(X),
        Q = await this.processor(Y),
        { predicted_depth: G } = await this.model(Q),
        J = [];
      for (let U = 0; U < Y.length; ++U) {
        let $ = J9(G[U], Y[U].size.reverse(), "bilinear", !1),
          B = $.mul_(255 / x5($.data)[0]).to("uint8");
        J.push({ predicted_depth: G[U], depth: o5.fromTensor(B) });
      }
      return J.length > 1 ? J : J[0];
    }
  };
  ((bv = Object.freeze({
    "text-classification": {
      tokenizer: j5,
      pipeline: BR,
      model: dQ,
      default: {
        model: "Xenova/distilbert-base-uncased-finetuned-sst-2-english",
      },
      type: "text",
    },
    "token-classification": {
      tokenizer: j5,
      pipeline: KR,
      model: SH,
      default: { model: "Xenova/bert-base-multilingual-cased-ner-hrl" },
      type: "text",
    },
    "question-answering": {
      tokenizer: j5,
      pipeline: VR,
      model: _H,
      default: { model: "Xenova/distilbert-base-cased-distilled-squad" },
      type: "text",
    },
    "fill-mask": {
      tokenizer: j5,
      pipeline: FR,
      model: yH,
      default: { model: "Xenova/bert-base-uncased" },
      type: "text",
    },
    summarization: {
      tokenizer: j5,
      pipeline: NR,
      model: i7,
      default: { model: "Xenova/distilbart-cnn-6-6" },
      type: "text",
    },
    translation: {
      tokenizer: j5,
      pipeline: z$,
      model: i7,
      default: { model: "Xenova/t5-small" },
      type: "text",
    },
    "text2text-generation": {
      tokenizer: j5,
      pipeline: eQ,
      model: i7,
      default: { model: "Xenova/flan-t5-small" },
      type: "text",
    },
    "text-generation": {
      tokenizer: j5,
      pipeline: MR,
      model: kH,
      default: { model: "Xenova/gpt2" },
      type: "text",
    },
    "zero-shot-classification": {
      tokenizer: j5,
      pipeline: AR,
      model: dQ,
      default: { model: "Xenova/distilbert-base-uncased-mnli" },
      type: "text",
    },
    "audio-classification": {
      pipeline: DR,
      model: cH,
      processor: s5,
      default: { model: "Xenova/wav2vec2-base-superb-ks" },
      type: "audio",
    },
    "zero-shot-audio-classification": {
      tokenizer: j5,
      pipeline: zR,
      model: $9,
      processor: s5,
      default: { model: "Xenova/clap-htsat-unfused" },
      type: "multimodal",
    },
    "automatic-speech-recognition": {
      tokenizer: j5,
      pipeline: ER,
      model: [TH, mH],
      processor: s5,
      default: { model: "Xenova/whisper-tiny.en" },
      type: "multimodal",
    },
    "text-to-audio": {
      tokenizer: j5,
      pipeline: SR,
      model: [vH, bH],
      processor: [s5, null],
      default: { model: "Xenova/speecht5_tts" },
      type: "text",
    },
    "image-to-text": {
      tokenizer: j5,
      pipeline: OR,
      model: fH,
      processor: s5,
      default: { model: "Xenova/vit-gpt2-image-captioning" },
      type: "multimodal",
    },
    "image-classification": {
      pipeline: ZR,
      model: xH,
      processor: s5,
      default: { model: "Xenova/vit-base-patch16-224" },
      type: "multimodal",
    },
    "image-segmentation": {
      pipeline: jR,
      model: [hH, gH],
      processor: s5,
      default: { model: "Xenova/detr-resnet-50-panoptic" },
      type: "multimodal",
    },
    "zero-shot-image-classification": {
      tokenizer: j5,
      pipeline: wR,
      model: $9,
      processor: s5,
      default: { model: "Xenova/clip-vit-base-patch32" },
      type: "multimodal",
    },
    "object-detection": {
      pipeline: CR,
      model: uH,
      processor: s5,
      default: { model: "Xenova/detr-resnet-50" },
      type: "multimodal",
    },
    "zero-shot-object-detection": {
      tokenizer: j5,
      pipeline: IR,
      model: lH,
      processor: s5,
      default: { model: "Xenova/owlvit-base-patch32" },
      type: "multimodal",
    },
    "document-question-answering": {
      tokenizer: j5,
      pipeline: PR,
      model: dH,
      processor: s5,
      default: { model: "Xenova/donut-base-finetuned-docvqa" },
      type: "multimodal",
    },
    "image-to-image": {
      pipeline: TR,
      model: pH,
      processor: s5,
      default: { model: "Xenova/swin2SR-classical-sr-x2-64" },
      type: "image",
    },
    "depth-estimation": {
      pipeline: bR,
      model: iH,
      processor: s5,
      default: { model: "Xenova/dpt-large" },
      type: "image",
    },
    "feature-extraction": {
      tokenizer: j5,
      pipeline: qR,
      model: $9,
      default: { model: "Xenova/all-MiniLM-L6-v2" },
      type: "text",
    },
    "image-feature-extraction": {
      processor: s5,
      pipeline: RR,
      model: [nH, $9],
      default: { model: "Xenova/vit-base-patch16-224-in21k" },
      type: "image",
    },
  })),
    (p40 = Object.freeze({
      "sentiment-analysis": "text-classification",
      ner: "token-classification",
      asr: "automatic-speech-recognition",
      "text-to-speech": "text-to-audio",
      embeddings: "feature-extraction",
    })));
});
var yv = {};
wD(yv, {
  window_function: () => e7,
  std_mean: () => zW,
  stack: () => XX,
  spectrogram: () => t7,
  softmax: () => Z5,
  round: () => Q9,
  read_audio: () => Pq,
  quantize_embeddings: () => MK,
  pipeline: () => i40,
  permute_data: () => HK,
  permute: () => KK,
  ones_like: () => NK,
  ones: () => fP,
  min: () => SQ,
  mel_filter_bank: () => zX,
  medianFilter: () => LK,
  mean_pooling: () => VK,
  mean: () => EW,
  max: () => x5,
  magnitude: () => JK,
  log_softmax: () => $K,
  layer_norm: () => g10,
  interpolate_data: () => WK,
  interpolate: () => J9,
  hanning: () => Iq,
  getTopItems: () => q4,
  env: () => A5,
  dynamicTimeWarping: () => FK,
  dot: () => SP,
  cos_sim: () => x10,
  cat: () => e9,
  bankers_round: () => BK,
  ZeroShotObjectDetectionPipeline: () => IR,
  ZeroShotImageClassificationPipeline: () => wR,
  ZeroShotClassificationPipeline: () => AR,
  ZeroShotAudioClassificationPipeline: () => zR,
  YolosPreTrainedModel: () => DH,
  YolosObjectDetectionOutput: () => aM,
  YolosModel: () => iM,
  YolosForObjectDetection: () => nM,
  YolosFeatureExtractor: () => aq,
  XVectorOutput: () => aA,
  XLMWithLMHeadModel: () => UN,
  XLMTokenizer: () => hK,
  XLMRobertaTokenizer: () => iK,
  XLMRobertaPreTrainedModel: () => MX,
  XLMRobertaModel: () => VN,
  XLMRobertaForTokenClassification: () => MN,
  XLMRobertaForSequenceClassification: () => NN,
  XLMRobertaForQuestionAnswering: () => AN,
  XLMRobertaForMaskedLM: () => FN,
  XLMPreTrainedModel: () => NX,
  XLMModel: () => $N,
  XLMForTokenClassification: () => BN,
  XLMForSequenceClassification: () => LN,
  XLMForQuestionAnswering: () => KN,
  WhisperTokenizer: () => GV,
  WhisperProcessor: () => WR,
  WhisperPreTrainedModel: () => gW,
  WhisperModel: () => DN,
  WhisperForConditionalGeneration: () => zN,
  WhisperFeatureExtractor: () => tq,
  WavLMPreTrainedModel: () => AX,
  WavLMModel: () => DA,
  WavLMForXVector: () => OA,
  WavLMForSequenceClassification: () => EA,
  WavLMForCTC: () => zA,
  WavLMForAudioFrameClassification: () => ZA,
  Wav2Vec2ProcessorWithLM: () => HR,
  Wav2Vec2PreTrainedModel: () => E4,
  Wav2Vec2Model: () => QA,
  Wav2Vec2ForSequenceClassification: () => JA,
  Wav2Vec2ForCTC: () => GA,
  Wav2Vec2ForAudioFrameClassification: () => WA,
  Wav2Vec2FeatureExtractor: () => eq,
  Wav2Vec2CTCTokenizer: () => UV,
  Wav2Vec2BertPreTrainedModel: () => uQ,
  Wav2Vec2BertModel: () => FA,
  Wav2Vec2BertForSequenceClassification: () => MA,
  Wav2Vec2BertForCTC: () => NA,
  VitsTokenizer: () => VV,
  VitsPreTrainedModel: () => hA,
  VitsModelOutput: () => oA,
  VitsModel: () => wH,
  VitMattePreTrainedModel: () => WM,
  VitMatteImageProcessor: () => sq,
  VitMatteForImageMatting: () => HM,
  VisionEncoderDecoderModel: () => uW,
  ViTPreTrainedModel: () => YH,
  ViTModel: () => YM,
  ViTImageProcessor: () => uq,
  ViTForImageClassification: () => QM,
  ViTFeatureExtractor: () => gq,
  UniSpeechSatPreTrainedModel: () => p7,
  UniSpeechSatModel: () => LA,
  UniSpeechSatForSequenceClassification: () => KA,
  UniSpeechSatForCTC: () => BA,
  UniSpeechSatForAudioFrameClassification: () => VA,
  UniSpeechPreTrainedModel: () => gQ,
  UniSpeechModel: () => HA,
  UniSpeechForSequenceClassification: () => UA,
  UniSpeechForCTC: () => $A,
  TranslationPipeline: () => z$,
  TrOCRPreTrainedModel: () => IA,
  TrOCRForCausalLM: () => PA,
  TokenizerModel: () => GX,
  TokenClassifierOutput: () => h5,
  TokenClassificationPipeline: () => KR,
  TextToAudioPipeline: () => SR,
  TextGenerationPipeline: () => MR,
  TextClassificationPipeline: () => BR,
  Text2TextGenerationPipeline: () => eQ,
  Tensor: () => I0,
  TableTransformerPreTrainedModel: () => LH,
  TableTransformerObjectDetectionOutput: () => ZM,
  TableTransformerModel: () => EM,
  TableTransformerForObjectDetection: () => OM,
  T5Tokenizer: () => uK,
  T5PreTrainedModel: () => kW,
  T5Model: () => gF,
  T5ForConditionalGeneration: () => uF,
  SwinPreTrainedModel: () => VH,
  SwinModel: () => PM,
  SwinForImageClassification: () => SM,
  Swin2SRPreTrainedModel: () => FH,
  Swin2SRModel: () => TM,
  Swin2SRImageProcessor: () => oq,
  Swin2SRForImageSuperResolution: () => bM,
  SummarizationPipeline: () => NR,
  Starcoder2PreTrainedModel: () => ZH,
  Starcoder2Model: () => bA,
  Starcoder2ForCausalLM: () => vA,
  StableLmPreTrainedModel: () => CH,
  StableLmModel: () => aS,
  StableLmForCausalLM: () => lA,
  SqueezeBertTokenizer: () => TK,
  SqueezeBertPreTrainedModel: () => l7,
  SqueezeBertModel: () => bF,
  SqueezeBertForSequenceClassification: () => kF,
  SqueezeBertForQuestionAnswering: () => yF,
  SqueezeBertForMaskedLM: () => vF,
  SpeechT5Tokenizer: () => BV,
  SpeechT5Processor: () => $R,
  SpeechT5PreTrainedModel: () => lQ,
  SpeechT5Model: () => iS,
  SpeechT5HifiGan: () => CA,
  SpeechT5ForTextToSpeech: () => wA,
  SpeechT5ForSpeechToText: () => jA,
  SpeechT5FeatureExtractor: () => GR,
  SiglipVisionModel: () => CN,
  SiglipTokenizer: () => HV,
  SiglipTextModel: () => wN,
  SiglipPreTrainedModel: () => lW,
  SiglipModel: () => jN,
  SiglipImageProcessor: () => xq,
  SequenceClassifierOutput: () => Z1,
  Seq2SeqLMOutput: () => nA,
  SegformerPreTrainedModel: () => cQ,
  SegformerModel: () => nS,
  SegformerForSemanticSegmentation: () => uA,
  SegformerForImageClassification: () => gA,
  SegformerFeatureExtractor: () => bq,
  SeamlessM4TFeatureExtractor: () => XR,
  SamProcessor: () => JR,
  SamPreTrainedModel: () => rM,
  SamModel: () => oM,
  SamImageSegmentationOutput: () => sM,
  SamImageProcessor: () => rq,
  RobertaTokenizer: () => cK,
  RobertaPreTrainedModel: () => FX,
  RobertaModel: () => QN,
  RobertaForTokenClassification: () => WN,
  RobertaForSequenceClassification: () => JN,
  RobertaForQuestionAnswering: () => HN,
  RobertaForMaskedLM: () => GN,
  RoFormerTokenizer: () => _K,
  RoFormerPreTrainedModel: () => WX,
  RoFormerModel: () => xV,
  RoFormerForTokenClassification: () => uV,
  RoFormerForSequenceClassification: () => gV,
  RoFormerForQuestionAnswering: () => lV,
  RoFormerForMaskedLM: () => hV,
  ResNetPreTrainedModel: () => KH,
  ResNetModel: () => CM,
  ResNetForImageClassification: () => IM,
  RawImage: () => o5,
  Qwen2Tokenizer: () => sK,
  Qwen2PreTrainedModel: () => oW,
  Qwen2Model: () => pN,
  Qwen2ForCausalLM: () => iN,
  QuestionAnsweringPipeline: () => VR,
  QuestionAnsweringModelOutput: () => r5,
  Processor: () => C4,
  PretrainedMixin: () => i1,
  PretrainedConfig: () => MV,
  PreTrainedTokenizer: () => W1,
  PreTrainedModel: () => j0,
  Pipeline: () => U5,
  PhiPreTrainedModel: () => sW,
  PhiModel: () => nN,
  PhiForCausalLM: () => aN,
  Owlv2PreTrainedModel: () => HH,
  Owlv2Model: () => FM,
  Owlv2ImageProcessor: () => cq,
  Owlv2ForObjectDetection: () => NM,
  OwlViTProcessor: () => UR,
  OwlViTPreTrainedModel: () => WH,
  OwlViTModel: () => KM,
  OwlViTForObjectDetection: () => VM,
  OwlViTFeatureExtractor: () => q$,
  ObjectDetectionPipeline: () => CR,
  OPTPreTrainedModel: () => XH,
  OPTModel: () => eN,
  OPTForCausalLM: () => XM,
  NougatTokenizer: () => KV,
  NougatImageProcessor: () => iq,
  NomicBertPreTrainedModel: () => _V,
  NomicBertModel: () => fV,
  NllbTokenizer: () => YV,
  MptPreTrainedModel: () => eW,
  MptModel: () => sN,
  MptForCausalLM: () => tN,
  ModelOutput: () => a5,
  MobileViTV2PreTrainedModel: () => JH,
  MobileViTV2Model: () => LM,
  MobileViTV2ForImageClassification: () => BM,
  MobileViTPreTrainedModel: () => GH,
  MobileViTModel: () => $M,
  MobileViTImageProcessor: () => mq,
  MobileViTForImageClassification: () => UM,
  MobileViTFeatureExtractor: () => A$,
  MobileBertTokenizer: () => SK,
  MobileBertPreTrainedModel: () => u7,
  MobileBertModel: () => OF,
  MobileBertForSequenceClassification: () => jF,
  MobileBertForQuestionAnswering: () => wF,
  MobileBertForMaskedLM: () => ZF,
  MistralPreTrainedModel: () => OH,
  MistralModel: () => SA,
  MistralForCausalLM: () => TA,
  MaskedLMOutput: () => g5,
  MarianTokenizer: () => $V,
  MarianPreTrainedModel: () => zH,
  MarianModel: () => tM,
  MarianMTModel: () => eM,
  MT5PreTrainedModel: () => _W,
  MT5Model: () => cF,
  MT5ForConditionalGeneration: () => dF,
  MPNetTokenizer: () => nK,
  MPNetPreTrainedModel: () => VX,
  MPNetModel: () => CF,
  MPNetForTokenClassification: () => SF,
  MPNetForSequenceClassification: () => PF,
  MPNetForQuestionAnswering: () => TF,
  MPNetForMaskedLM: () => IF,
  MBartTokenizer: () => PW,
  MBartPreTrainedModel: () => c7,
  MBartModel: () => aF,
  MBartForSequenceClassification: () => oF,
  MBartForConditionalGeneration: () => rF,
  MBartForCausalLM: () => sF,
  MBart50Tokenizer: () => mK,
  M2M100Tokenizer: () => QV,
  M2M100PreTrainedModel: () => EH,
  M2M100Model: () => XA,
  M2M100ForConditionalGeneration: () => YA,
  LongT5PreTrainedModel: () => yW,
  LongT5Model: () => lF,
  LongT5ForConditionalGeneration: () => mF,
  LlamaTokenizer: () => SW,
  LlamaPreTrainedModel: () => rW,
  LlamaModel: () => cN,
  LlamaForCausalLM: () => dN,
  ImageToTextPipeline: () => OR,
  ImageToImagePipeline: () => TR,
  ImageSegmentationPipeline: () => jR,
  ImageMattingOutput: () => rA,
  ImageFeatureExtractor: () => W5,
  ImageFeatureExtractionPipeline: () => RR,
  ImageClassificationPipeline: () => ZR,
  HubertPreTrainedModel: () => pS,
  HubertModel: () => AA,
  HubertForSequenceClassification: () => RA,
  HubertForCTC: () => qA,
  HerbertTokenizer: () => kK,
  Grok1Tokenizer: () => eK,
  GemmaTokenizer: () => tK,
  GPTNeoXTokenizer: () => rK,
  GPTNeoXPreTrainedModel: () => pW,
  GPTNeoXModel: () => _N,
  GPTNeoXForCausalLM: () => fN,
  GPTNeoPreTrainedModel: () => dW,
  GPTNeoModel: () => kN,
  GPTNeoForCausalLM: () => yN,
  GPTJPreTrainedModel: () => iW,
  GPTJModel: () => xN,
  GPTJForCausalLM: () => hN,
  GPTBigCodePreTrainedModel: () => nW,
  GPTBigCodeModel: () => gN,
  GPTBigCodeForCausalLM: () => uN,
  GPT2Tokenizer: () => IW,
  GPT2PreTrainedModel: () => cW,
  GPT2Model: () => bN,
  GPT2LMHeadModel: () => vN,
  GLPNPreTrainedModel: () => MH,
  GLPNModel: () => fM,
  GLPNForDepthEstimation: () => xM,
  GLPNFeatureExtractor: () => yq,
  FillMaskPipeline: () => FR,
  FeatureExtractor: () => w4,
  FeatureExtractionPipeline: () => qR,
  FastViTPreTrainedModel: () => QH,
  FastViTModel: () => GM,
  FastViTForImageClassification: () => JM,
  FalconTokenizer: () => aK,
  FalconPreTrainedModel: () => jH,
  FalconModel: () => kA,
  FalconForCausalLM: () => yA,
  FFT: () => DW,
  EsmTokenizer: () => oK,
  EsmPreTrainedModel: () => g7,
  EsmModel: () => RF,
  EsmForTokenClassification: () => EF,
  EsmForSequenceClassification: () => zF,
  EsmForMaskedLM: () => DF,
  ElectraTokenizer: () => gK,
  ElectraPreTrainedModel: () => $X,
  ElectraModel: () => nV,
  ElectraForTokenClassification: () => oV,
  ElectraForSequenceClassification: () => rV,
  ElectraForQuestionAnswering: () => sV,
  ElectraForMaskedLM: () => aV,
  EfficientNetPreTrainedModel: () => IH,
  EfficientNetModel: () => mA,
  EfficientNetImageProcessor: () => lq,
  EfficientNetForImageClassification: () => cA,
  DonutSwinPreTrainedModel: () => hM,
  DonutSwinModel: () => gM,
  DonutFeatureExtractor: () => R$,
  DocumentQuestionAnsweringPipeline: () => PR,
  DistilBertTokenizer: () => fK,
  DistilBertPreTrainedModel: () => KX,
  DistilBertModel: () => FF,
  DistilBertForTokenClassification: () => MF,
  DistilBertForSequenceClassification: () => NF,
  DistilBertForQuestionAnswering: () => AF,
  DistilBertForMaskedLM: () => qF,
  Dinov2PreTrainedModel: () => RH,
  Dinov2Model: () => dM,
  Dinov2ForImageClassification: () => pM,
  DetrSegmentationOutput: () => zM,
  DetrPreTrainedModel: () => hQ,
  DetrObjectDetectionOutput: () => UH,
  DetrModel: () => qM,
  DetrForSegmentation: () => DM,
  DetrForObjectDetection: () => RM,
  DetrFeatureExtractor: () => nq,
  DepthEstimationPipeline: () => bR,
  DepthAnythingPreTrainedModel: () => yM,
  DepthAnythingForDepthEstimation: () => _M,
  DeiTPreTrainedModel: () => BH,
  DeiTModel: () => jM,
  DeiTForImageClassification: () => wM,
  DeiTFeatureExtractor: () => dq,
  DebertaV2Tokenizer: () => vK,
  DebertaV2PreTrainedModel: () => BX,
  DebertaV2Model: () => UF,
  DebertaV2ForTokenClassification: () => KF,
  DebertaV2ForSequenceClassification: () => BF,
  DebertaV2ForQuestionAnswering: () => VF,
  DebertaV2ForMaskedLM: () => LF,
  DebertaTokenizer: () => bK,
  DebertaPreTrainedModel: () => LX,
  DebertaModel: () => GF,
  DebertaForTokenClassification: () => HF,
  DebertaForSequenceClassification: () => WF,
  DebertaForQuestionAnswering: () => $F,
  DebertaForMaskedLM: () => JF,
  DPTPreTrainedModel: () => NH,
  DPTModel: () => vM,
  DPTImageProcessor: () => vq,
  DPTForDepthEstimation: () => kM,
  DPTFeatureExtractor: () => N$,
  ConvNextV2PreTrainedModel: () => qH,
  ConvNextV2Model: () => mM,
  ConvNextV2ForImageClassification: () => cM,
  ConvNextPreTrainedModel: () => AH,
  ConvNextModel: () => uM,
  ConvNextImageProcessor: () => hq,
  ConvNextForImageClassification: () => lM,
  ConvNextFeatureExtractor: () => M$,
  ConvBertTokenizer: () => yK,
  ConvBertPreTrainedModel: () => HX,
  ConvBertModel: () => mV,
  ConvBertForTokenClassification: () => pV,
  ConvBertForSequenceClassification: () => dV,
  ConvBertForQuestionAnswering: () => iV,
  ConvBertForMaskedLM: () => cV,
  CohereTokenizer: () => FV,
  CodeLlamaTokenizer: () => pK,
  CodeGenTokenizer: () => JV,
  CodeGenPreTrainedModel: () => aW,
  CodeGenModel: () => lN,
  CodeGenForCausalLM: () => mN,
  ClapTextModelWithProjection: () => fA,
  ClapPreTrainedModel: () => mQ,
  ClapModel: () => _A,
  ClapFeatureExtractor: () => QR,
  ClapAudioModelWithProjection: () => xA,
  ChineseCLIPPreTrainedModel: () => IN,
  ChineseCLIPModel: () => PN,
  ChineseCLIPFeatureExtractor: () => fq,
  CausalLMOutputWithPast: () => OT,
  CausalLMOutput: () => U9,
  CamembertTokenizer: () => xK,
  CamembertPreTrainedModel: () => UX,
  CamembertModel: () => tV,
  CamembertForTokenClassification: () => YF,
  CamembertForSequenceClassification: () => XF,
  CamembertForQuestionAnswering: () => QF,
  CamembertForMaskedLM: () => eV,
  CLIPVisionModelWithProjection: () => ZN,
  CLIPTokenizer: () => WV,
  CLIPTextModelWithProjection: () => ON,
  CLIPSegPreTrainedModel: () => mW,
  CLIPSegModel: () => SN,
  CLIPSegForImageSegmentation: () => TN,
  CLIPPreTrainedModel: () => d7,
  CLIPModel: () => EN,
  CLIPFeatureExtractor: () => _q,
  BloomTokenizer: () => dK,
  BloomPreTrainedModel: () => tW,
  BloomModel: () => rN,
  BloomForCausalLM: () => oN,
  BlenderbotTokenizer: () => TW,
  BlenderbotSmallTokenizer: () => LV,
  BlenderbotSmallPreTrainedModel: () => xW,
  BlenderbotSmallModel: () => XN,
  BlenderbotSmallForConditionalGeneration: () => YN,
  BlenderbotPreTrainedModel: () => fW,
  BlenderbotModel: () => tF,
  BlenderbotForConditionalGeneration: () => eF,
  BitImageProcessor: () => kq,
  BertTokenizer: () => IK,
  BertPreTrainedModel: () => JX,
  BertModel: () => TV,
  BertForTokenClassification: () => kV,
  BertForSequenceClassification: () => vV,
  BertForQuestionAnswering: () => yV,
  BertForMaskedLM: () => bV,
  BeitPreTrainedModel: () => $H,
  BeitModel: () => MM,
  BeitForImageClassification: () => AM,
  BeitFeatureExtractor: () => pq,
  BaseModelOutput: () => dS,
  BartTokenizer: () => lK,
  BartPretrainedModel: () => xQ,
  BartModel: () => pF,
  BartForSequenceClassification: () => nF,
  BartForConditionalGeneration: () => iF,
  AutomaticSpeechRecognitionPipeline: () => ER,
  AutoTokenizer: () => j5,
  AutoProcessor: () => s5,
  AutoModelForZeroShotObjectDetection: () => lH,
  AutoModelForXVector: () => DT,
  AutoModelForVision2Seq: () => fH,
  AutoModelForTokenClassification: () => SH,
  AutoModelForTextToWaveform: () => vH,
  AutoModelForTextToSpectrogram: () => bH,
  AutoModelForSpeechSeq2Seq: () => TH,
  AutoModelForSequenceClassification: () => dQ,
  AutoModelForSeq2SeqLM: () => i7,
  AutoModelForSemanticSegmentation: () => gH,
  AutoModelForQuestionAnswering: () => _H,
  AutoModelForObjectDetection: () => uH,
  AutoModelForMaskedLM: () => yH,
  AutoModelForMaskGeneration: () => RT,
  AutoModelForImageToImage: () => pH,
  AutoModelForImageSegmentation: () => hH,
  AutoModelForImageMatting: () => ET,
  AutoModelForImageFeatureExtraction: () => nH,
  AutoModelForImageClassification: () => xH,
  AutoModelForDocumentQuestionAnswering: () => dH,
  AutoModelForDepthEstimation: () => iH,
  AutoModelForCausalLM: () => kH,
  AutoModelForCTC: () => mH,
  AutoModelForAudioFrameClassification: () => zT,
  AutoModelForAudioClassification: () => cH,
  AutoModel: () => $9,
  AutoConfig: () => z4,
  AudioClassificationPipeline: () => DR,
  AlbertTokenizer: () => PK,
  AlbertPreTrainedModel: () => m7,
  AlbertModel: () => _F,
  AlbertForSequenceClassification: () => fF,
  AlbertForQuestionAnswering: () => xF,
  AlbertForMaskedLM: () => hF,
  ASTPreTrainedModel: () => hW,
  ASTModel: () => qN,
  ASTForAudioClassification: () => RN,
  ASTFeatureExtractor: () => YR,
});
var tA = U8(() => {
  kv();
  AW();
  sA();
  NV();
  LR();
  AV();
  F$();
  V$();
  W9();
});
import { existsSync as XD } from "fs";
import { join as g$, resolve as BG } from "path";
var i$ = (X, Y, Q) => {
  return (G, J) => {
    let U = -1;
    return $(0);
    async function $(B) {
      if (B <= U) throw Error("next() called multiple times");
      U = B;
      let K,
        V = !1,
        W;
      if (X[B]) ((W = X[B][0][0]), (G.req.routeIndex = B));
      else W = (B === X.length && J) || void 0;
      if (W)
        try {
          K = await W(G, () => $(B + 1));
        } catch (L) {
          if (L instanceof Error && Y)
            ((G.error = L), (K = await Y(L, G)), (V = !0));
          else throw L;
        }
      else if (G.finalized === !1 && Q) K = await Q(G);
      if (K && (G.finalized === !1 || V)) G.res = K;
      return G;
    }
  };
};
var bX = class extends Error {
  res;
  status;
  constructor(X = 500, Y) {
    super(Y?.message, { cause: Y?.cause });
    ((this.res = Y?.res), (this.status = X));
  }
  getResponse() {
    if (this.res)
      return new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers,
      });
    return new Response(this.message, { status: this.status });
  }
};
var CD = Symbol();
var ID = async (X, Y = Object.create(null)) => {
  let { all: Q = !1, dot: G = !1 } = Y,
    U = (X instanceof qG ? X.raw.headers : X.headers).get("Content-Type");
  if (
    U?.startsWith("multipart/form-data") ||
    U?.startsWith("application/x-www-form-urlencoded")
  )
    return kk(X, { all: Q, dot: G });
  return {};
};
async function kk(X, Y) {
  let Q = await X.formData();
  if (Q) return yk(Q, Y);
  return {};
}
function yk(X, Y) {
  let Q = Object.create(null);
  if (
    (X.forEach((G, J) => {
      if (!(Y.all || J.endsWith("[]"))) Q[J] = G;
      else _k(Q, J, G);
    }),
    Y.dot)
  )
    Object.entries(Q).forEach(([G, J]) => {
      if (G.includes(".")) (fk(Q, G, J), delete Q[G]);
    });
  return Q;
}
var _k = (X, Y, Q) => {
    if (X[Y] !== void 0)
      if (Array.isArray(X[Y])) X[Y].push(Q);
      else X[Y] = [X[Y], Q];
    else if (!Y.endsWith("[]")) X[Y] = Q;
    else X[Y] = [Q];
  },
  fk = (X, Y, Q) => {
    let G = X,
      J = Y.split(".");
    J.forEach((U, $) => {
      if ($ === J.length - 1) G[U] = Q;
      else {
        if (
          !G[U] ||
          typeof G[U] !== "object" ||
          Array.isArray(G[U]) ||
          G[U] instanceof File
        )
          G[U] = Object.create(null);
        G = G[U];
      }
    });
  };
var a$ = (X) => {
    let Y = X.split("/");
    if (Y[0] === "") Y.shift();
    return Y;
  },
  PD = (X) => {
    let { groups: Y, path: Q } = xk(X),
      G = a$(Q);
    return hk(G, Y);
  },
  xk = (X) => {
    let Y = [];
    return (
      (X = X.replace(/\{[^}]+\}/g, (Q, G) => {
        let J = `@${G}`;
        return (Y.push([J, Q]), J);
      })),
      { groups: Y, path: X }
    );
  },
  hk = (X, Y) => {
    for (let Q = Y.length - 1; Q >= 0; Q--) {
      let [G] = Y[Q];
      for (let J = X.length - 1; J >= 0; J--)
        if (X[J].includes(G)) {
          X[J] = X[J].replace(G, Y[Q][1]);
          break;
        }
    }
    return X;
  },
  RG = {},
  SD = (X, Y) => {
    if (X === "*") return "*";
    let Q = X.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    if (Q) {
      let G = `${X}#${Y}`;
      if (!RG[G])
        if (Q[2])
          RG[G] =
            Y && Y[0] !== ":" && Y[0] !== "*"
              ? [G, Q[1], new RegExp(`^${Q[2]}(?=/${Y})`)]
              : [X, Q[1], new RegExp(`^${Q[2]}$`)];
        else RG[G] = [X, Q[1], !0];
      return RG[G];
    }
    return null;
  },
  vX = (X, Y) => {
    try {
      return Y(X);
    } catch {
      return X.replace(/(?:%[0-9A-Fa-f]{2})+/g, (Q) => {
        try {
          return Y(Q);
        } catch {
          return Q;
        }
      });
    }
  },
  gk = (X) => vX(X, decodeURI),
  r$ = (X) => {
    let Y = X.url,
      Q = Y.indexOf("/", Y.indexOf(":") + 4),
      G = Q;
    for (; G < Y.length; G++) {
      let J = Y.charCodeAt(G);
      if (J === 37) {
        let U = Y.indexOf("?", G),
          $ = Y.slice(Q, U === -1 ? void 0 : U);
        return gk($.includes("%25") ? $.replace(/%25/g, "%2525") : $);
      } else if (J === 63) break;
    }
    return Y.slice(Q, G);
  };
var TD = (X) => {
    let Y = r$(X);
    return Y.length > 1 && Y.at(-1) === "/" ? Y.slice(0, -1) : Y;
  },
  O9 = (X, Y, ...Q) => {
    if (Q.length) Y = O9(Y, ...Q);
    return `${X?.[0] === "/" ? "" : "/"}${X}${Y === "/" ? "" : `${X?.at(-1) === "/" ? "" : "/"}${Y?.[0] === "/" ? Y.slice(1) : Y}`}`;
  },
  DG = (X) => {
    if (X.charCodeAt(X.length - 1) !== 63 || !X.includes(":")) return null;
    let Y = X.split("/"),
      Q = [],
      G = "";
    return (
      Y.forEach((J) => {
        if (J !== "" && !/\:/.test(J)) G += "/" + J;
        else if (/\:/.test(J))
          if (/\?/.test(J)) {
            if (Q.length === 0 && G === "") Q.push("/");
            else Q.push(G);
            let U = J.replace("?", "");
            ((G += "/" + U), Q.push(G));
          } else G += "/" + J;
      }),
      Q.filter((J, U, $) => $.indexOf(J) === U)
    );
  },
  n$ = (X) => {
    if (!/[%+]/.test(X)) return X;
    if (X.indexOf("+") !== -1) X = X.replace(/\+/g, " ");
    return X.indexOf("%") !== -1 ? vX(X, qY) : X;
  },
  bD = (X, Y, Q) => {
    let G;
    if (!Q && Y && !/[%+]/.test(Y)) {
      let $ = X.indexOf("?", 8);
      if ($ === -1) return;
      if (!X.startsWith(Y, $ + 1)) $ = X.indexOf(`&${Y}`, $ + 1);
      while ($ !== -1) {
        let B = X.charCodeAt($ + Y.length + 1);
        if (B === 61) {
          let K = $ + Y.length + 2,
            V = X.indexOf("&", K);
          return n$(X.slice(K, V === -1 ? void 0 : V));
        } else if (B == 38 || isNaN(B)) return "";
        $ = X.indexOf(`&${Y}`, $ + 1);
      }
      if (((G = /[%+]/.test(X)), !G)) return;
    }
    let J = {};
    G ??= /[%+]/.test(X);
    let U = X.indexOf("?", 8);
    while (U !== -1) {
      let $ = X.indexOf("&", U + 1),
        B = X.indexOf("=", U);
      if (B > $ && $ !== -1) B = -1;
      let K = X.slice(U + 1, B === -1 ? ($ === -1 ? void 0 : $) : B);
      if (G) K = n$(K);
      if (((U = $), K === "")) continue;
      let V;
      if (B === -1) V = "";
      else if (((V = X.slice(B + 1, $ === -1 ? void 0 : $)), G)) V = n$(V);
      if (Q) {
        if (!(J[K] && Array.isArray(J[K]))) J[K] = [];
        J[K].push(V);
      } else J[K] ??= V;
    }
    return Y ? J[Y] : J;
  },
  vD = bD,
  kD = (X, Y) => {
    return bD(X, Y, !0);
  },
  qY = decodeURIComponent;
var yD = (X) => vX(X, qY),
  qG = class {
    raw;
    #X;
    #Y;
    routeIndex = 0;
    path;
    bodyCache = {};
    constructor(X, Y = "/", Q = [[]]) {
      ((this.raw = X), (this.path = Y), (this.#Y = Q), (this.#X = {}));
    }
    param(X) {
      return X ? this.#Q(X) : this.#W();
    }
    #Q(X) {
      let Y = this.#Y[0][this.routeIndex][1][X],
        Q = this.#J(Y);
      return Q && /\%/.test(Q) ? yD(Q) : Q;
    }
    #W() {
      let X = {},
        Y = Object.keys(this.#Y[0][this.routeIndex][1]);
      for (let Q of Y) {
        let G = this.#J(this.#Y[0][this.routeIndex][1][Q]);
        if (G !== void 0) X[Q] = /\%/.test(G) ? yD(G) : G;
      }
      return X;
    }
    #J(X) {
      return this.#Y[1] ? this.#Y[1][X] : X;
    }
    query(X) {
      return vD(this.url, X);
    }
    queries(X) {
      return kD(this.url, X);
    }
    header(X) {
      if (X) return this.raw.headers.get(X) ?? void 0;
      let Y = {};
      return (
        this.raw.headers.forEach((Q, G) => {
          Y[G] = Q;
        }),
        Y
      );
    }
    async parseBody(X) {
      return (this.bodyCache.parsedBody ??= await ID(this, X));
    }
    #G = (X) => {
      let { bodyCache: Y, raw: Q } = this,
        G = Y[X];
      if (G) return G;
      let J = Object.keys(Y)[0];
      if (J)
        return Y[J].then((U) => {
          if (J === "json") U = JSON.stringify(U);
          return new Response(U)[X]();
        });
      return (Y[X] = Q[X]());
    };
    json() {
      return this.#G("text").then((X) => JSON.parse(X));
    }
    text() {
      return this.#G("text");
    }
    arrayBuffer() {
      return this.#G("arrayBuffer");
    }
    blob() {
      return this.#G("blob");
    }
    formData() {
      return this.#G("formData");
    }
    addValidatedData(X, Y) {
      this.#X[X] = Y;
    }
    valid(X) {
      return this.#X[X];
    }
    get url() {
      return this.raw.url;
    }
    get method() {
      return this.raw.method;
    }
    get [CD]() {
      return this.#Y;
    }
    get matchedRoutes() {
      return this.#Y[0].map(([[, X]]) => X);
    }
    get routePath() {
      return this.#Y[0].map(([[, X]]) => X)[this.routeIndex].path;
    }
  };
var _D = { Stringify: 1, BeforeStream: 2, Stream: 3 },
  uk = (X, Y) => {
    let Q = new String(X);
    return ((Q.isEscaped = !0), (Q.callbacks = Y), Q);
  };
var o$ = async (X, Y, Q, G, J) => {
  if (typeof X === "object" && !(X instanceof String)) {
    if (!(X instanceof Promise)) X = X.toString();
    if (X instanceof Promise) X = await X;
  }
  let U = X.callbacks;
  if (!U?.length) return Promise.resolve(X);
  if (J) J[0] += X;
  else J = [X];
  let $ = Promise.all(
    U.map((B) => B({ phase: Y, buffer: J, context: G }))
  ).then((B) =>
    Promise.all(B.filter(Boolean).map((K) => o$(K, Y, !1, G, J))).then(
      () => J[0]
    )
  );
  if (Q) return uk(await $, U);
  else return $;
};
var lk = "text/plain; charset=UTF-8",
  s$ = (X, Y) => {
    return { "Content-Type": X, ...Y };
  },
  fD = class {
    #X;
    #Y;
    env = {};
    #Q;
    finalized = !1;
    error;
    #W;
    #J;
    #G;
    #B;
    #U;
    #L;
    #$;
    #K;
    #V;
    constructor(X, Y) {
      if (((this.#X = X), Y))
        ((this.#J = Y.executionCtx),
          (this.env = Y.env),
          (this.#L = Y.notFoundHandler),
          (this.#V = Y.path),
          (this.#K = Y.matchResult));
    }
    get req() {
      return ((this.#Y ??= new qG(this.#X, this.#V, this.#K)), this.#Y);
    }
    get event() {
      if (this.#J && "respondWith" in this.#J) return this.#J;
      else throw Error("This context has no FetchEvent");
    }
    get executionCtx() {
      if (this.#J) return this.#J;
      else throw Error("This context has no ExecutionContext");
    }
    get res() {
      return (this.#G ||= new Response(null, {
        headers: (this.#$ ??= new Headers()),
      }));
    }
    set res(X) {
      if (this.#G && X) {
        X = new Response(X.body, X);
        for (let [Y, Q] of this.#G.headers.entries()) {
          if (Y === "content-type") continue;
          if (Y === "set-cookie") {
            let G = this.#G.headers.getSetCookie();
            X.headers.delete("set-cookie");
            for (let J of G) X.headers.append("set-cookie", J);
          } else X.headers.set(Y, Q);
        }
      }
      ((this.#G = X), (this.finalized = !0));
    }
    render = (...X) => {
      return ((this.#U ??= (Y) => this.html(Y)), this.#U(...X));
    };
    setLayout = (X) => (this.#B = X);
    getLayout = () => this.#B;
    setRenderer = (X) => {
      this.#U = X;
    };
    header = (X, Y, Q) => {
      if (this.finalized) this.#G = new Response(this.#G.body, this.#G);
      let G = this.#G ? this.#G.headers : (this.#$ ??= new Headers());
      if (Y === void 0) G.delete(X);
      else if (Q?.append) G.append(X, Y);
      else G.set(X, Y);
    };
    status = (X) => {
      this.#W = X;
    };
    set = (X, Y) => {
      ((this.#Q ??= new Map()), this.#Q.set(X, Y));
    };
    get = (X) => {
      return this.#Q ? this.#Q.get(X) : void 0;
    };
    get var() {
      if (!this.#Q) return {};
      return Object.fromEntries(this.#Q);
    }
    #H(X, Y, Q) {
      let G = this.#G
        ? new Headers(this.#G.headers)
        : (this.#$ ?? new Headers());
      if (typeof Y === "object" && "headers" in Y) {
        let U =
          Y.headers instanceof Headers ? Y.headers : new Headers(Y.headers);
        for (let [$, B] of U)
          if ($.toLowerCase() === "set-cookie") G.append($, B);
          else G.set($, B);
      }
      if (Q)
        for (let [U, $] of Object.entries(Q))
          if (typeof $ === "string") G.set(U, $);
          else {
            G.delete(U);
            for (let B of $) G.append(U, B);
          }
      let J = typeof Y === "number" ? Y : (Y?.status ?? this.#W);
      return new Response(X, { status: J, headers: G });
    }
    newResponse = (...X) => this.#H(...X);
    body = (X, Y, Q) => this.#H(X, Y, Q);
    text = (X, Y, Q) => {
      return !this.#$ && !this.#W && !Y && !Q && !this.finalized
        ? new Response(X)
        : this.#H(X, Y, s$(lk, Q));
    };
    json = (X, Y, Q) => {
      return this.#H(JSON.stringify(X), Y, s$("application/json", Q));
    };
    html = (X, Y, Q) => {
      let G = (J) => this.#H(J, Y, s$("text/html; charset=UTF-8", Q));
      return typeof X === "object" ? o$(X, _D.Stringify, !1, {}).then(G) : G(X);
    };
    redirect = (X, Y) => {
      let Q = String(X);
      return (
        this.header("Location", !/[^\x00-\xFF]/.test(Q) ? Q : encodeURI(Q)),
        this.newResponse(null, Y ?? 302)
      );
    };
    notFound = () => {
      return ((this.#L ??= () => new Response()), this.#L(this));
    };
  };
var p1 = "ALL",
  xD = "all",
  hD = ["get", "post", "put", "delete", "options", "patch"],
  zG = "Can not add a route since the matcher is already built.",
  EG = class extends Error {};
var t$ = "__COMPOSED_HANDLER";
var mk = (X) => {
    return X.text("404 Not Found", 404);
  },
  gD = (X, Y) => {
    if ("getResponse" in X) {
      let Q = X.getResponse();
      return Y.newResponse(Q.body, Q);
    }
    return (console.error(X), Y.text("Internal Server Error", 500));
  },
  uD = class X {
    get;
    post;
    put;
    delete;
    options;
    patch;
    all;
    on;
    use;
    router;
    getPath;
    _basePath = "/";
    #X = "/";
    routes = [];
    constructor(Y = {}) {
      ([...hD, xD].forEach((U) => {
        this[U] = ($, ...B) => {
          if (typeof $ === "string") this.#X = $;
          else this.#W(U, this.#X, $);
          return (
            B.forEach((K) => {
              this.#W(U, this.#X, K);
            }),
            this
          );
        };
      }),
        (this.on = (U, $, ...B) => {
          for (let K of [$].flat()) {
            this.#X = K;
            for (let V of [U].flat())
              B.map((W) => {
                this.#W(V.toUpperCase(), this.#X, W);
              });
          }
          return this;
        }),
        (this.use = (U, ...$) => {
          if (typeof U === "string") this.#X = U;
          else ((this.#X = "*"), $.unshift(U));
          return (
            $.forEach((B) => {
              this.#W(p1, this.#X, B);
            }),
            this
          );
        }));
      let { strict: G, ...J } = Y;
      (Object.assign(this, J),
        (this.getPath = (G ?? !0) ? (Y.getPath ?? r$) : TD));
    }
    #Y() {
      let Y = new X({ router: this.router, getPath: this.getPath });
      return (
        (Y.errorHandler = this.errorHandler),
        (Y.#Q = this.#Q),
        (Y.routes = this.routes),
        Y
      );
    }
    #Q = mk;
    errorHandler = gD;
    route(Y, Q) {
      let G = this.basePath(Y);
      return (
        Q.routes.map((J) => {
          let U;
          if (Q.errorHandler === gD) U = J.handler;
          else
            ((U = async ($, B) =>
              (await i$([], Q.errorHandler)($, () => J.handler($, B))).res),
              (U[t$] = J.handler));
          G.#W(J.method, J.path, U);
        }),
        this
      );
    }
    basePath(Y) {
      let Q = this.#Y();
      return ((Q._basePath = O9(this._basePath, Y)), Q);
    }
    onError = (Y) => {
      return ((this.errorHandler = Y), this);
    };
    notFound = (Y) => {
      return ((this.#Q = Y), this);
    };
    mount(Y, Q, G) {
      let J, U;
      if (G)
        if (typeof G === "function") U = G;
        else if (((U = G.optionHandler), G.replaceRequest === !1)) J = (K) => K;
        else J = G.replaceRequest;
      let $ = U
        ? (K) => {
            let V = U(K);
            return Array.isArray(V) ? V : [V];
          }
        : (K) => {
            let V = void 0;
            try {
              V = K.executionCtx;
            } catch {}
            return [K.env, V];
          };
      J ||= (() => {
        let K = O9(this._basePath, Y),
          V = K === "/" ? 0 : K.length;
        return (W) => {
          let L = new URL(W.url);
          return ((L.pathname = L.pathname.slice(V) || "/"), new Request(L, W));
        };
      })();
      let B = async (K, V) => {
        let W = await Q(J(K.req.raw), ...$(K));
        if (W) return W;
        await V();
      };
      return (this.#W(p1, O9(Y, "*"), B), this);
    }
    #W(Y, Q, G) {
      ((Y = Y.toUpperCase()), (Q = O9(this._basePath, Q)));
      let J = { basePath: this._basePath, path: Q, method: Y, handler: G };
      (this.router.add(Y, Q, [G, J]), this.routes.push(J));
    }
    #J(Y, Q) {
      if (Y instanceof Error) return this.errorHandler(Y, Q);
      throw Y;
    }
    #G(Y, Q, G, J) {
      if (J === "HEAD")
        return (async () =>
          new Response(null, await this.#G(Y, Q, G, "GET")))();
      let U = this.getPath(Y, { env: G }),
        $ = this.router.match(J, U),
        B = new fD(Y, {
          path: U,
          matchResult: $,
          env: G,
          executionCtx: Q,
          notFoundHandler: this.#Q,
        });
      if ($[0].length === 1) {
        let V;
        try {
          V = $[0][0][0][0](B, async () => {
            B.res = await this.#Q(B);
          });
        } catch (W) {
          return this.#J(W, B);
        }
        return V instanceof Promise
          ? V.then((W) => W || (B.finalized ? B.res : this.#Q(B))).catch((W) =>
              this.#J(W, B)
            )
          : (V ?? this.#Q(B));
      }
      let K = i$($[0], this.errorHandler, this.#Q);
      return (async () => {
        try {
          let V = await K(B);
          if (!V.finalized)
            throw Error(
              "Context is not finalized. Did you forget to return a Response object or `await next()`?"
            );
          return V.res;
        } catch (V) {
          return this.#J(V, B);
        }
      })();
    }
    fetch = (Y, ...Q) => {
      return this.#G(Y, Q[1], Q[0], Y.method);
    };
    request = (Y, Q, G, J) => {
      if (Y instanceof Request)
        return this.fetch(Q ? new Request(Y, Q) : Y, G, J);
      return (
        (Y = Y.toString()),
        this.fetch(
          new Request(
            /^https?:\/\//.test(Y) ? Y : `http://localhost${O9("/", Y)}`,
            Q
          ),
          G,
          J
        )
      );
    };
    fire = () => {
      addEventListener("fetch", (Y) => {
        Y.respondWith(this.#G(Y.request, Y, void 0, Y.request.method));
      });
    };
  };
var RY = [];
function OG(X, Y) {
  let Q = this.buildAllMatchers(),
    G = (J, U) => {
      let $ = Q[J] || Q[p1],
        B = $[2][U];
      if (B) return B;
      let K = U.match($[0]);
      if (!K) return [[], RY];
      let V = K.indexOf("", 1);
      return [$[1][V], K];
    };
  return ((this.match = G), G(X, Y));
}
var ZG = "[^/]+",
  DY = ".*",
  zY = "(?:|/.*)",
  Z9 = Symbol(),
  ck = new Set(".\\+*[^]$()");
function dk(X, Y) {
  if (X.length === 1) return Y.length === 1 ? (X < Y ? -1 : 1) : -1;
  if (Y.length === 1) return 1;
  if (X === DY || X === zY) return 1;
  else if (Y === DY || Y === zY) return -1;
  if (X === ZG) return 1;
  else if (Y === ZG) return -1;
  return X.length === Y.length ? (X < Y ? -1 : 1) : Y.length - X.length;
}
var lD = class X {
  #X;
  #Y;
  #Q = Object.create(null);
  insert(Y, Q, G, J, U) {
    if (Y.length === 0) {
      if (this.#X !== void 0) throw Z9;
      if (U) return;
      this.#X = Q;
      return;
    }
    let [$, ...B] = Y,
      K =
        $ === "*"
          ? B.length === 0
            ? ["", "", DY]
            : ["", "", ZG]
          : $ === "/*"
            ? ["", "", zY]
            : $.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/),
      V;
    if (K) {
      let W = K[1],
        L = K[2] || ZG;
      if (W && K[2]) {
        if (L === ".*") throw Z9;
        if (
          ((L = L.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:")),
          /\((?!\?:)/.test(L))
        )
          throw Z9;
      }
      if (((V = this.#Q[L]), !V)) {
        if (Object.keys(this.#Q).some((H) => H !== DY && H !== zY)) throw Z9;
        if (U) return;
        if (((V = this.#Q[L] = new X()), W !== "")) V.#Y = J.varIndex++;
      }
      if (!U && W !== "") G.push([W, V.#Y]);
    } else if (((V = this.#Q[$]), !V)) {
      if (
        Object.keys(this.#Q).some((W) => W.length > 1 && W !== DY && W !== zY)
      )
        throw Z9;
      if (U) return;
      V = this.#Q[$] = new X();
    }
    V.insert(B, Q, G, J, U);
  }
  buildRegExpStr() {
    let Q = Object.keys(this.#Q)
      .sort(dk)
      .map((G) => {
        let J = this.#Q[G];
        return (
          (typeof J.#Y === "number"
            ? `(${G})@${J.#Y}`
            : ck.has(G)
              ? `\\${G}`
              : G) + J.buildRegExpStr()
        );
      });
    if (typeof this.#X === "number") Q.unshift(`#${this.#X}`);
    if (Q.length === 0) return "";
    if (Q.length === 1) return Q[0];
    return "(?:" + Q.join("|") + ")";
  }
};
var mD = class {
  #X = { varIndex: 0 };
  #Y = new lD();
  insert(X, Y, Q) {
    let G = [],
      J = [];
    for (let $ = 0; ; ) {
      let B = !1;
      if (
        ((X = X.replace(/\{[^}]+\}/g, (K) => {
          let V = `@\\${$}`;
          return ((J[$] = [V, K]), $++, (B = !0), V);
        })),
        !B)
      )
        break;
    }
    let U = X.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let $ = J.length - 1; $ >= 0; $--) {
      let [B] = J[$];
      for (let K = U.length - 1; K >= 0; K--)
        if (U[K].indexOf(B) !== -1) {
          U[K] = U[K].replace(B, J[$][1]);
          break;
        }
    }
    return (this.#Y.insert(U, Y, G, this.#X, Q), G);
  }
  buildRegExp() {
    let X = this.#Y.buildRegExpStr();
    if (X === "") return [/^$/, [], []];
    let Y = 0,
      Q = [],
      G = [];
    return (
      (X = X.replace(/#(\d+)|@(\d+)|\.\*\$/g, (J, U, $) => {
        if (U !== void 0) return ((Q[++Y] = Number(U)), "$()");
        if ($ !== void 0) return ((G[Number($)] = ++Y), "");
        return "";
      })),
      [new RegExp(`^${X}`), Q, G]
    );
  }
};
var pk = [/^$/, [], Object.create(null)],
  cD = Object.create(null);
function dD(X) {
  return (cD[X] ??= new RegExp(
    X === "*"
      ? ""
      : `^${X.replace(/\/\*$|([.\\+*[^\]$()])/g, (Y, Q) => (Q ? `\\${Q}` : "(?:|/.*)"))}$`
  ));
}
function ik() {
  cD = Object.create(null);
}
function nk(X) {
  let Y = new mD(),
    Q = [];
  if (X.length === 0) return pk;
  let G = X.map((V) => [!/\*|\/:/.test(V[0]), ...V]).sort(([V, W], [L, H]) =>
      V ? 1 : L ? -1 : W.length - H.length
    ),
    J = Object.create(null);
  for (let V = 0, W = -1, L = G.length; V < L; V++) {
    let [H, F, N] = G[V];
    if (H) J[F] = [N.map(([M]) => [M, Object.create(null)]), RY];
    else W++;
    let q;
    try {
      q = Y.insert(F, W, H);
    } catch (M) {
      throw M === Z9 ? new EG(F) : M;
    }
    if (H) continue;
    Q[W] = N.map(([M, A]) => {
      let D = Object.create(null);
      A -= 1;
      for (; A >= 0; A--) {
        let [R, z] = q[A];
        D[R] = z;
      }
      return [M, D];
    });
  }
  let [U, $, B] = Y.buildRegExp();
  for (let V = 0, W = Q.length; V < W; V++)
    for (let L = 0, H = Q[V].length; L < H; L++) {
      let F = Q[V][L]?.[1];
      if (!F) continue;
      let N = Object.keys(F);
      for (let q = 0, M = N.length; q < M; q++) F[N[q]] = B[F[N[q]]];
    }
  let K = [];
  for (let V in $) K[V] = Q[$[V]];
  return [U, K, J];
}
function kX(X, Y) {
  if (!X) return;
  for (let Q of Object.keys(X).sort((G, J) => J.length - G.length))
    if (dD(Q).test(Y)) return [...X[Q]];
  return;
}
var jG = class {
  name = "RegExpRouter";
  #X;
  #Y;
  constructor() {
    ((this.#X = { [p1]: Object.create(null) }),
      (this.#Y = { [p1]: Object.create(null) }));
  }
  add(X, Y, Q) {
    let G = this.#X,
      J = this.#Y;
    if (!G || !J) throw Error(zG);
    if (!G[X])
      [G, J].forEach((B) => {
        ((B[X] = Object.create(null)),
          Object.keys(B[p1]).forEach((K) => {
            B[X][K] = [...B[p1][K]];
          }));
      });
    if (Y === "/*") Y = "*";
    let U = (Y.match(/\/:/g) || []).length;
    if (/\*$/.test(Y)) {
      let B = dD(Y);
      if (X === p1)
        Object.keys(G).forEach((K) => {
          G[K][Y] ||= kX(G[K], Y) || kX(G[p1], Y) || [];
        });
      else G[X][Y] ||= kX(G[X], Y) || kX(G[p1], Y) || [];
      (Object.keys(G).forEach((K) => {
        if (X === p1 || X === K)
          Object.keys(G[K]).forEach((V) => {
            B.test(V) && G[K][V].push([Q, U]);
          });
      }),
        Object.keys(J).forEach((K) => {
          if (X === p1 || X === K)
            Object.keys(J[K]).forEach((V) => B.test(V) && J[K][V].push([Q, U]));
        }));
      return;
    }
    let $ = DG(Y) || [Y];
    for (let B = 0, K = $.length; B < K; B++) {
      let V = $[B];
      Object.keys(J).forEach((W) => {
        if (X === p1 || X === W)
          ((J[W][V] ||= [...(kX(G[W], V) || kX(G[p1], V) || [])]),
            J[W][V].push([Q, U - K + B + 1]));
      });
    }
  }
  match = OG;
  buildAllMatchers() {
    let X = Object.create(null);
    return (
      Object.keys(this.#Y)
        .concat(Object.keys(this.#X))
        .forEach((Y) => {
          X[Y] ||= this.#Q(Y);
        }),
      (this.#X = this.#Y = void 0),
      ik(),
      X
    );
  }
  #Q(X) {
    let Y = [],
      Q = X === p1;
    if (
      ([this.#X, this.#Y].forEach((G) => {
        let J = G[X] ? Object.keys(G[X]).map((U) => [U, G[X][U]]) : [];
        if (J.length !== 0) ((Q ||= !0), Y.push(...J));
        else if (X !== p1)
          Y.push(...Object.keys(G[p1]).map((U) => [U, G[p1][U]]));
      }),
      !Q)
    )
      return null;
    else return nk(Y);
  }
};
var ak = class {
  name = "PreparedRegExpRouter";
  #X;
  #Y;
  constructor(X, Y) {
    ((this.#X = X), (this.#Y = Y));
  }
  #Q(X, Y) {
    let Q = this.#X[X];
    (Q[1].forEach((G) => G && G.push(Y)),
      Object.values(Q[2]).forEach((G) => G[0].push(Y)));
  }
  #W(X, Y, Q, G, J) {
    let U = this.#X[X];
    if (!J) U[2][Y][0].push([Q, {}]);
    else
      G.forEach(($) => {
        if (typeof $ === "number") U[1][$].push([Q, J]);
        else U[2][$ || Y][0].push([Q, J]);
      });
  }
  add(X, Y, Q) {
    if (!this.#X[X]) {
      let J = this.#X[p1],
        U = {};
      for (let $ in J[2]) U[$] = [J[2][$][0].slice(), RY];
      this.#X[X] = [
        J[0],
        J[1].map(($) => (Array.isArray($) ? $.slice() : 0)),
        U,
      ];
    }
    if (Y === "/*" || Y === "*") {
      let J = [Q, {}];
      if (X === p1) for (let U in this.#X) this.#Q(U, J);
      else this.#Q(X, J);
      return;
    }
    let G = this.#Y[Y];
    if (!G) throw Error(`Path ${Y} is not registered`);
    for (let [J, U] of G)
      if (X === p1) for (let $ in this.#X) this.#W($, Y, Q, J, U);
      else this.#W(X, Y, Q, J, U);
  }
  buildAllMatchers() {
    return this.#X;
  }
  match = OG;
};
var e$ = class {
  name = "SmartRouter";
  #X = [];
  #Y = [];
  constructor(X) {
    this.#X = X.routers;
  }
  add(X, Y, Q) {
    if (!this.#Y) throw Error(zG);
    this.#Y.push([X, Y, Q]);
  }
  match(X, Y) {
    if (!this.#Y) throw Error("Fatal error");
    let Q = this.#X,
      G = this.#Y,
      J = Q.length,
      U = 0,
      $;
    for (; U < J; U++) {
      let B = Q[U];
      try {
        for (let K = 0, V = G.length; K < V; K++) B.add(...G[K]);
        $ = B.match(X, Y);
      } catch (K) {
        if (K instanceof EG) continue;
        throw K;
      }
      ((this.match = B.match.bind(B)), (this.#X = [B]), (this.#Y = void 0));
      break;
    }
    if (U === J) throw Error("Fatal error");
    return ((this.name = `SmartRouter + ${this.activeRouter.name}`), $);
  }
  get activeRouter() {
    if (this.#Y || this.#X.length !== 1)
      throw Error("No active router has been determined yet.");
    return this.#X[0];
  }
};
var EY = Object.create(null),
  pD = class X {
    #X;
    #Y;
    #Q;
    #W = 0;
    #J = EY;
    constructor(Y, Q, G) {
      if (((this.#Y = G || Object.create(null)), (this.#X = []), Y && Q)) {
        let J = Object.create(null);
        ((J[Y] = { handler: Q, possibleKeys: [], score: 0 }), (this.#X = [J]));
      }
      this.#Q = [];
    }
    insert(Y, Q, G) {
      this.#W = ++this.#W;
      let J = this,
        U = PD(Q),
        $ = [];
      for (let B = 0, K = U.length; B < K; B++) {
        let V = U[B],
          W = U[B + 1],
          L = SD(V, W),
          H = Array.isArray(L) ? L[0] : V;
        if (H in J.#Y) {
          if (((J = J.#Y[H]), L)) $.push(L[1]);
          continue;
        }
        if (((J.#Y[H] = new X()), L)) (J.#Q.push(L), $.push(L[1]));
        J = J.#Y[H];
      }
      return (
        J.#X.push({
          [Y]: {
            handler: G,
            possibleKeys: $.filter((B, K, V) => V.indexOf(B) === K),
            score: this.#W,
          },
        }),
        J
      );
    }
    #G(Y, Q, G, J) {
      let U = [];
      for (let $ = 0, B = Y.#X.length; $ < B; $++) {
        let K = Y.#X[$],
          V = K[Q] || K[p1],
          W = {};
        if (V !== void 0) {
          if (
            ((V.params = Object.create(null)),
            U.push(V),
            G !== EY || (J && J !== EY))
          )
            for (let L = 0, H = V.possibleKeys.length; L < H; L++) {
              let F = V.possibleKeys[L],
                N = W[V.score];
              ((V.params[F] = J?.[F] && !N ? J[F] : (G[F] ?? J?.[F])),
                (W[V.score] = !0));
            }
        }
      }
      return U;
    }
    search(Y, Q) {
      let G = [];
      this.#J = EY;
      let U = [this],
        $ = a$(Q),
        B = [];
      for (let K = 0, V = $.length; K < V; K++) {
        let W = $[K],
          L = K === V - 1,
          H = [];
        for (let F = 0, N = U.length; F < N; F++) {
          let q = U[F],
            M = q.#Y[W];
          if (M)
            if (((M.#J = q.#J), L)) {
              if (M.#Y["*"]) G.push(...this.#G(M.#Y["*"], Y, q.#J));
              G.push(...this.#G(M, Y, q.#J));
            } else H.push(M);
          for (let A = 0, D = q.#Q.length; A < D; A++) {
            let R = q.#Q[A],
              z = q.#J === EY ? {} : { ...q.#J };
            if (R === "*") {
              let I = q.#Y["*"];
              if (I) (G.push(...this.#G(I, Y, q.#J)), (I.#J = z), H.push(I));
              continue;
            }
            let [E, O, Z] = R;
            if (!W && !(Z instanceof RegExp)) continue;
            let j = q.#Y[E],
              w = $.slice(K).join("/");
            if (Z instanceof RegExp) {
              let I = Z.exec(w);
              if (I) {
                if (
                  ((z[O] = I[0]),
                  G.push(...this.#G(j, Y, q.#J, z)),
                  Object.keys(j.#Y).length)
                ) {
                  j.#J = z;
                  let T = I[0].match(/\//)?.length ?? 0;
                  (B[T] ||= []).push(j);
                }
                continue;
              }
            }
            if (Z === !0 || Z.test(W))
              if (((z[O] = W), L)) {
                if ((G.push(...this.#G(j, Y, z, q.#J)), j.#Y["*"]))
                  G.push(...this.#G(j.#Y["*"], Y, z, q.#J));
              } else ((j.#J = z), H.push(j));
          }
        }
        U = H.concat(B.shift() ?? []);
      }
      if (G.length > 1)
        G.sort((K, V) => {
          return K.score - V.score;
        });
      return [G.map(({ handler: K, params: V }) => [K, V])];
    }
  };
var XU = class {
  name = "TrieRouter";
  #X;
  constructor() {
    this.#X = new pD();
  }
  add(X, Y, Q) {
    let G = DG(Y);
    if (G) {
      for (let J = 0, U = G.length; J < U; J++) this.#X.insert(X, G[J], Q);
      return;
    }
    this.#X.insert(X, Y, Q);
  }
  match(X, Y) {
    return this.#X.search(X, Y);
  }
};
var c1 = class extends uD {
  constructor(X = {}) {
    super(X);
    this.router = X.router ?? new e$({ routers: [new jG(), new XU()] });
  }
};
var iD = (X) => {
  let Q = {
      ...{
        origin: "*",
        allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
        allowHeaders: [],
        exposeHeaders: [],
      },
      ...X,
    },
    G = ((U) => {
      if (typeof U === "string")
        if (U === "*") return () => U;
        else return ($) => (U === $ ? $ : null);
      else if (typeof U === "function") return U;
      else return ($) => (U.includes($) ? $ : null);
    })(Q.origin),
    J = ((U) => {
      if (typeof U === "function") return U;
      else if (Array.isArray(U)) return () => U;
      else return () => [];
    })(Q.allowMethods);
  return async function ($, B) {
    function K(W, L) {
      $.res.headers.set(W, L);
    }
    let V = await G($.req.header("origin") || "", $);
    if (V) K("Access-Control-Allow-Origin", V);
    if (Q.credentials) K("Access-Control-Allow-Credentials", "true");
    if (Q.exposeHeaders?.length)
      K("Access-Control-Expose-Headers", Q.exposeHeaders.join(","));
    if ($.req.method === "OPTIONS") {
      if (Q.origin !== "*") K("Vary", "Origin");
      if (Q.maxAge != null) K("Access-Control-Max-Age", Q.maxAge.toString());
      let W = await J($.req.header("origin") || "", $);
      if (W.length) K("Access-Control-Allow-Methods", W.join(","));
      let L = Q.allowHeaders;
      if (!L?.length) {
        let H = $.req.header("Access-Control-Request-Headers");
        if (H) L = H.split(/\s*,\s*/);
      }
      if (L?.length)
        (K("Access-Control-Allow-Headers", L.join(",")),
          $.res.headers.append("Vary", "Access-Control-Request-Headers"));
      return (
        $.res.headers.delete("Content-Length"),
        $.res.headers.delete("Content-Type"),
        new Response(null, {
          headers: $.res.headers,
          status: 204,
          statusText: "No Content",
        })
      );
    }
    if ((await B(), Q.origin !== "*"))
      $.header("Vary", "Origin", { append: !0 });
  };
};
import { stat as ek } from "fs/promises";
import { join as Xy } from "path";
var nD =
  /^\s*(?:text\/(?!event-stream(?:[;\s]|$))[^;\s]+|application\/(?:javascript|json|xml|xml-dtd|ecmascript|dart|postscript|rtf|tar|toml|vnd\.dart|vnd\.ms-fontobject|vnd\.ms-opentype|wasm|x-httpd-php|x-javascript|x-ns-proxy-autoconfig|x-sh|x-tar|x-virtualbox-hdd|x-virtualbox-ova|x-virtualbox-ovf|x-virtualbox-vbox|x-virtualbox-vdi|x-virtualbox-vhd|x-virtualbox-vmdk|x-www-form-urlencoded)|font\/(?:otf|ttf)|image\/(?:bmp|vnd\.adobe\.photoshop|vnd\.microsoft\.icon|vnd\.ms-dds|x-icon|x-ms-bmp)|message\/rfc822|model\/gltf-binary|x-shader\/x-fragment|x-shader\/x-vertex|[^;\s]+?\+(?:json|text|xml|yaml))(?:[;\s]|$)/i;
var YU = (X, Y = ok) => {
  let Q = /\.([a-zA-Z0-9]+?)$/,
    G = X.match(Q);
  if (!G) return;
  let J = Y[G[1]];
  if (J && J.startsWith("text")) J += "; charset=utf-8";
  return J;
};
var rk = {
    aac: "audio/aac",
    avi: "video/x-msvideo",
    avif: "image/avif",
    av1: "video/av1",
    bin: "application/octet-stream",
    bmp: "image/bmp",
    css: "text/css",
    csv: "text/csv",
    eot: "application/vnd.ms-fontobject",
    epub: "application/epub+zip",
    gif: "image/gif",
    gz: "application/gzip",
    htm: "text/html",
    html: "text/html",
    ico: "image/x-icon",
    ics: "text/calendar",
    jpeg: "image/jpeg",
    jpg: "image/jpeg",
    js: "text/javascript",
    json: "application/json",
    jsonld: "application/ld+json",
    map: "application/json",
    mid: "audio/x-midi",
    midi: "audio/x-midi",
    mjs: "text/javascript",
    mp3: "audio/mpeg",
    mp4: "video/mp4",
    mpeg: "video/mpeg",
    oga: "audio/ogg",
    ogv: "video/ogg",
    ogx: "application/ogg",
    opus: "audio/opus",
    otf: "font/otf",
    pdf: "application/pdf",
    png: "image/png",
    rtf: "application/rtf",
    svg: "image/svg+xml",
    tif: "image/tiff",
    tiff: "image/tiff",
    ts: "video/mp2t",
    ttf: "font/ttf",
    txt: "text/plain",
    wasm: "application/wasm",
    webm: "video/webm",
    weba: "audio/webm",
    webmanifest: "application/manifest+json",
    webp: "image/webp",
    woff: "font/woff",
    woff2: "font/woff2",
    xhtml: "application/xhtml+xml",
    xml: "application/xml",
    zip: "application/zip",
    "3gp": "video/3gpp",
    "3g2": "video/3gpp2",
    gltf: "model/gltf+json",
    glb: "model/gltf-binary",
  },
  ok = rk;
var aD = (...X) => {
  let Y = X.filter((J) => J !== "").join("/");
  Y = Y.replace(/(?<=\/)\/+/g, "");
  let Q = Y.split("/"),
    G = [];
  for (let J of Q)
    if (J === ".." && G.length > 0 && G.at(-1) !== "..") G.pop();
    else if (J !== ".") G.push(J);
  return G.join("/") || ".";
};
var rD = { br: ".br", zstd: ".zst", gzip: ".gz" },
  sk = Object.keys(rD),
  tk = "index.html",
  oD = (X) => {
    let Y = X.root ?? "./",
      Q = X.path,
      G = X.join ?? aD;
    return async (J, U) => {
      if (J.finalized) return U();
      let $;
      if (X.path) $ = X.path;
      else
        try {
          if (
            (($ = decodeURIComponent(J.req.path)),
            /(?:^|[\/\\])\.\.(?:$|[\/\\])/.test($))
          )
            throw Error();
        } catch {
          return (await X.onNotFound?.(J.req.path, J), U());
        }
      let B = G(Y, !Q && X.rewriteRequestPath ? X.rewriteRequestPath($) : $);
      if (X.isDir && (await X.isDir(B))) B = G(B, tk);
      let K = X.getContent,
        V = await K(B, J);
      if (V instanceof Response) return J.newResponse(V.body, V);
      if (V) {
        let W = (X.mimes && YU(B, X.mimes)) || YU(B);
        if (
          (J.header("Content-Type", W || "application/octet-stream"),
          X.precompressed && (!W || nD.test(W)))
        ) {
          let L = new Set(
            J.req
              .header("Accept-Encoding")
              ?.split(",")
              .map((H) => H.trim())
          );
          for (let H of sk) {
            if (!L.has(H)) continue;
            let F = await K(B + rD[H], J);
            if (F) {
              ((V = F),
                J.header("Content-Encoding", H),
                J.header("Vary", "Accept-Encoding", { append: !0 }));
              break;
            }
          }
        }
        return (await X.onFound?.(B, J), J.body(V));
      }
      (await X.onNotFound?.(B, J), await U());
      return;
    };
  };
var QU = (X) => {
  return async function (Q, G) {
    return oD({
      ...X,
      getContent: async ($) => {
        let B = Bun.file($);
        return (await B.exists()) ? B : null;
      },
      join: Xy,
      isDir: async ($) => {
        let B;
        try {
          B = (await ek($)).isDirectory();
        } catch {}
        return B;
      },
    })(Q, G);
  };
};
var GU = "x-hono-disable-ssg",
  a70 = (() => {
    try {
      return new Response("SSG is disabled", {
        status: 404,
        headers: { [GU]: "true" },
      });
    } catch {
      return null;
    }
  })();
var { write: RY0 } = Bun;
var Qy = class {
  #X;
  constructor(X) {
    ((this.#X = X),
      (this.raw = X.raw),
      (this.url = X.url ? new URL(X.url) : null),
      (this.protocol = X.protocol ?? null));
  }
  send(X, Y) {
    this.#X.send(X, Y ?? {});
  }
  raw;
  binaryType = "arraybuffer";
  get readyState() {
    return this.#X.readyState;
  }
  url;
  protocol;
  close(X, Y) {
    this.#X.close(X, Y);
  }
};
var sD = (X) => {
  return (...Y) => {
    if (typeof Y[0] === "function") {
      let [Q, G] = Y;
      return async function (U, $) {
        let B = await Q(U),
          K = await X(U, B, G);
        if (K) return K;
        await $();
      };
    } else {
      let [Q, G, J] = Y;
      return (async () => {
        let U = await X(Q, G, J);
        if (!U) throw Error("Failed to upgrade WebSocket");
        return U;
      })();
    }
  };
};
var JU = (X) => ("server" in X.env ? X.env.server : X.env);
var Gy = sD((X, Y) => {
  let Q = JU(X);
  if (!Q) throw TypeError("env has to include the 2nd argument of fetch.");
  if (
    Q.upgrade(X.req.raw, {
      data: { events: Y, url: new URL(X.req.url), protocol: X.req.url },
    })
  )
    return new Response(null);
  return;
});
var X0 = {};
wD(X0, {
  void: () => ly,
  util: () => C1,
  unknown: () => gy,
  union: () => py,
  undefined: () => fy,
  tuple: () => ay,
  transformer: () => J_,
  symbol: () => _y,
  string: () => Hz,
  strictObject: () => dy,
  setErrorMap: () => Hy,
  set: () => sy,
  record: () => ry,
  quotelessJson: () => Jy,
  promise: () => G_,
  preprocess: () => $_,
  pipeline: () => U_,
  ostring: () => L_,
  optional: () => W_,
  onumber: () => B_,
  oboolean: () => K_,
  objectUtil: () => WU,
  object: () => cy,
  number: () => $z,
  nullable: () => H_,
  null: () => xy,
  never: () => uy,
  nativeEnum: () => Q_,
  nan: () => vy,
  map: () => oy,
  makeIssue: () => OY,
  literal: () => X_,
  lazy: () => ey,
  late: () => Ty,
  isValid: () => P4,
  isDirty: () => CG,
  isAsync: () => _X,
  isAborted: () => wG,
  intersection: () => ny,
  instanceof: () => by,
  getParsedType: () => G6,
  getErrorMap: () => yX,
  function: () => ty,
  enum: () => Y_,
  effect: () => J_,
  discriminatedUnion: () => iy,
  defaultErrorMap: () => e6,
  datetimeRegex: () => Gz,
  date: () => yy,
  custom: () => Wz,
  coerce: () => V_,
  boolean: () => Uz,
  bigint: () => ky,
  array: () => my,
  any: () => hy,
  addIssueToContext: () => b0,
  ZodVoid: () => jY,
  ZodUnknown: () => S4,
  ZodUnion: () => lX,
  ZodUndefined: () => gX,
  ZodType: () => q1,
  ZodTuple: () => W6,
  ZodTransformer: () => h8,
  ZodSymbol: () => ZY,
  ZodString: () => y8,
  ZodSet: () => I9,
  ZodSchema: () => q1,
  ZodRecord: () => wY,
  ZodReadonly: () => aX,
  ZodPromise: () => P9,
  ZodPipeline: () => PY,
  ZodParsedType: () => C0,
  ZodOptional: () => f8,
  ZodObject: () => B5,
  ZodNumber: () => T4,
  ZodNullable: () => Y4,
  ZodNull: () => uX,
  ZodNever: () => J6,
  ZodNativeEnum: () => pX,
  ZodNaN: () => IY,
  ZodMap: () => CY,
  ZodLiteral: () => dX,
  ZodLazy: () => cX,
  ZodIssueCode: () => E0,
  ZodIntersection: () => mX,
  ZodFunction: () => xX,
  ZodFirstPartyTypeKind: () => o0,
  ZodError: () => t5,
  ZodEnum: () => v4,
  ZodEffects: () => h8,
  ZodDiscriminatedUnion: () => IG,
  ZodDefault: () => iX,
  ZodDate: () => w9,
  ZodCatch: () => nX,
  ZodBranded: () => PG,
  ZodBoolean: () => hX,
  ZodBigInt: () => b4,
  ZodArray: () => _8,
  ZodAny: () => C9,
  Schema: () => q1,
  ParseStatus: () => c5,
  OK: () => e5,
  NEVER: () => F_,
  INVALID: () => n0,
  EMPTY_PATH: () => $y,
  DIRTY: () => j9,
  BRAND: () => Sy,
});
var C1;
(function (X) {
  X.assertEqual = (J) => {};
  function Y(J) {}
  X.assertIs = Y;
  function Q(J) {
    throw Error();
  }
  ((X.assertNever = Q),
    (X.arrayToEnum = (J) => {
      let U = {};
      for (let $ of J) U[$] = $;
      return U;
    }),
    (X.getValidEnumValues = (J) => {
      let U = X.objectKeys(J).filter((B) => typeof J[J[B]] !== "number"),
        $ = {};
      for (let B of U) $[B] = J[B];
      return X.objectValues($);
    }),
    (X.objectValues = (J) => {
      return X.objectKeys(J).map(function (U) {
        return J[U];
      });
    }),
    (X.objectKeys =
      typeof Object.keys === "function"
        ? (J) => Object.keys(J)
        : (J) => {
            let U = [];
            for (let $ in J)
              if (Object.prototype.hasOwnProperty.call(J, $)) U.push($);
            return U;
          }),
    (X.find = (J, U) => {
      for (let $ of J) if (U($)) return $;
      return;
    }),
    (X.isInteger =
      typeof Number.isInteger === "function"
        ? (J) => Number.isInteger(J)
        : (J) =>
            typeof J === "number" &&
            Number.isFinite(J) &&
            Math.floor(J) === J));
  function G(J, U = " | ") {
    return J.map(($) => (typeof $ === "string" ? `'${$}'` : $)).join(U);
  }
  ((X.joinValues = G),
    (X.jsonStringifyReplacer = (J, U) => {
      if (typeof U === "bigint") return U.toString();
      return U;
    }));
})(C1 || (C1 = {}));
var WU;
(function (X) {
  X.mergeShapes = (Y, Q) => {
    return { ...Y, ...Q };
  };
})(WU || (WU = {}));
var C0 = C1.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  G6 = (X) => {
    switch (typeof X) {
      case "undefined":
        return C0.undefined;
      case "string":
        return C0.string;
      case "number":
        return Number.isNaN(X) ? C0.nan : C0.number;
      case "boolean":
        return C0.boolean;
      case "function":
        return C0.function;
      case "bigint":
        return C0.bigint;
      case "symbol":
        return C0.symbol;
      case "object":
        if (Array.isArray(X)) return C0.array;
        if (X === null) return C0.null;
        if (
          X.then &&
          typeof X.then === "function" &&
          X.catch &&
          typeof X.catch === "function"
        )
          return C0.promise;
        if (typeof Map < "u" && X instanceof Map) return C0.map;
        if (typeof Set < "u" && X instanceof Set) return C0.set;
        if (typeof Date < "u" && X instanceof Date) return C0.date;
        return C0.object;
      default:
        return C0.unknown;
    }
  };
var E0 = C1.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]),
  Jy = (X) => {
    return JSON.stringify(X, null, 2).replace(/"([^"]+)":/g, "$1:");
  };
class t5 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(X) {
    super();
    ((this.issues = []),
      (this.addIssue = (Q) => {
        this.issues = [...this.issues, Q];
      }),
      (this.addIssues = (Q = []) => {
        this.issues = [...this.issues, ...Q];
      }));
    let Y = new.target.prototype;
    if (Object.setPrototypeOf) Object.setPrototypeOf(this, Y);
    else this.__proto__ = Y;
    ((this.name = "ZodError"), (this.issues = X));
  }
  format(X) {
    let Y =
        X ||
        function (J) {
          return J.message;
        },
      Q = { _errors: [] },
      G = (J) => {
        for (let U of J.issues)
          if (U.code === "invalid_union") U.unionErrors.map(G);
          else if (U.code === "invalid_return_type") G(U.returnTypeError);
          else if (U.code === "invalid_arguments") G(U.argumentsError);
          else if (U.path.length === 0) Q._errors.push(Y(U));
          else {
            let $ = Q,
              B = 0;
            while (B < U.path.length) {
              let K = U.path[B];
              if (B !== U.path.length - 1) $[K] = $[K] || { _errors: [] };
              else (($[K] = $[K] || { _errors: [] }), $[K]._errors.push(Y(U)));
              (($ = $[K]), B++);
            }
          }
      };
    return (G(this), Q);
  }
  static assert(X) {
    if (!(X instanceof t5)) throw Error(`Not a ZodError: ${X}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, C1.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(X = (Y) => Y.message) {
    let Y = {},
      Q = [];
    for (let G of this.issues)
      if (G.path.length > 0) {
        let J = G.path[0];
        ((Y[J] = Y[J] || []), Y[J].push(X(G)));
      } else Q.push(X(G));
    return { formErrors: Q, fieldErrors: Y };
  }
  get formErrors() {
    return this.flatten();
  }
}
t5.create = (X) => {
  return new t5(X);
};
var Wy = (X, Y) => {
    let Q;
    switch (X.code) {
      case E0.invalid_type:
        if (X.received === C0.undefined) Q = "Required";
        else Q = `Expected ${X.expected}, received ${X.received}`;
        break;
      case E0.invalid_literal:
        Q = `Invalid literal value, expected ${JSON.stringify(X.expected, C1.jsonStringifyReplacer)}`;
        break;
      case E0.unrecognized_keys:
        Q = `Unrecognized key(s) in object: ${C1.joinValues(X.keys, ", ")}`;
        break;
      case E0.invalid_union:
        Q = "Invalid input";
        break;
      case E0.invalid_union_discriminator:
        Q = `Invalid discriminator value. Expected ${C1.joinValues(X.options)}`;
        break;
      case E0.invalid_enum_value:
        Q = `Invalid enum value. Expected ${C1.joinValues(X.options)}, received '${X.received}'`;
        break;
      case E0.invalid_arguments:
        Q = "Invalid function arguments";
        break;
      case E0.invalid_return_type:
        Q = "Invalid function return type";
        break;
      case E0.invalid_date:
        Q = "Invalid date";
        break;
      case E0.invalid_string:
        if (typeof X.validation === "object")
          if ("includes" in X.validation) {
            if (
              ((Q = `Invalid input: must include "${X.validation.includes}"`),
              typeof X.validation.position === "number")
            )
              Q = `${Q} at one or more positions greater than or equal to ${X.validation.position}`;
          } else if ("startsWith" in X.validation)
            Q = `Invalid input: must start with "${X.validation.startsWith}"`;
          else if ("endsWith" in X.validation)
            Q = `Invalid input: must end with "${X.validation.endsWith}"`;
          else C1.assertNever(X.validation);
        else if (X.validation !== "regex") Q = `Invalid ${X.validation}`;
        else Q = "Invalid";
        break;
      case E0.too_small:
        if (X.type === "array")
          Q = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "more than"} ${X.minimum} element(s)`;
        else if (X.type === "string")
          Q = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "over"} ${X.minimum} character(s)`;
        else if (X.type === "number")
          Q = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
        else if (X.type === "bigint")
          Q = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
        else if (X.type === "date")
          Q = `Date must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(X.minimum))}`;
        else Q = "Invalid input";
        break;
      case E0.too_big:
        if (X.type === "array")
          Q = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "less than"} ${X.maximum} element(s)`;
        else if (X.type === "string")
          Q = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "under"} ${X.maximum} character(s)`;
        else if (X.type === "number")
          Q = `Number must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
        else if (X.type === "bigint")
          Q = `BigInt must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
        else if (X.type === "date")
          Q = `Date must be ${X.exact ? "exactly" : X.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(X.maximum))}`;
        else Q = "Invalid input";
        break;
      case E0.custom:
        Q = "Invalid input";
        break;
      case E0.invalid_intersection_types:
        Q = "Intersection results could not be merged";
        break;
      case E0.not_multiple_of:
        Q = `Number must be a multiple of ${X.multipleOf}`;
        break;
      case E0.not_finite:
        Q = "Number must be finite";
        break;
      default:
        ((Q = Y.defaultError), C1.assertNever(X));
    }
    return { message: Q };
  },
  e6 = Wy;
var tD = e6;
function Hy(X) {
  tD = X;
}
function yX() {
  return tD;
}
var OY = (X) => {
    let { data: Y, path: Q, errorMaps: G, issueData: J } = X,
      U = [...Q, ...(J.path || [])],
      $ = { ...J, path: U };
    if (J.message !== void 0) return { ...J, path: U, message: J.message };
    let B = "",
      K = G.filter((V) => !!V)
        .slice()
        .reverse();
    for (let V of K) B = V($, { data: Y, defaultError: B }).message;
    return { ...J, path: U, message: B };
  },
  $y = [];
function b0(X, Y) {
  let Q = yX(),
    G = OY({
      issueData: Y,
      data: X.data,
      path: X.path,
      errorMaps: [
        X.common.contextualErrorMap,
        X.schemaErrorMap,
        Q,
        Q === e6 ? void 0 : e6,
      ].filter((J) => !!J),
    });
  X.common.issues.push(G);
}
class c5 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray(X, Y) {
    let Q = [];
    for (let G of Y) {
      if (G.status === "aborted") return n0;
      if (G.status === "dirty") X.dirty();
      Q.push(G.value);
    }
    return { status: X.value, value: Q };
  }
  static async mergeObjectAsync(X, Y) {
    let Q = [];
    for (let G of Y) {
      let J = await G.key,
        U = await G.value;
      Q.push({ key: J, value: U });
    }
    return c5.mergeObjectSync(X, Q);
  }
  static mergeObjectSync(X, Y) {
    let Q = {};
    for (let G of Y) {
      let { key: J, value: U } = G;
      if (J.status === "aborted") return n0;
      if (U.status === "aborted") return n0;
      if (J.status === "dirty") X.dirty();
      if (U.status === "dirty") X.dirty();
      if (J.value !== "__proto__" && (typeof U.value < "u" || G.alwaysSet))
        Q[J.value] = U.value;
    }
    return { status: X.value, value: Q };
  }
}
var n0 = Object.freeze({ status: "aborted" }),
  j9 = (X) => ({ status: "dirty", value: X }),
  e5 = (X) => ({ status: "valid", value: X }),
  wG = (X) => X.status === "aborted",
  CG = (X) => X.status === "dirty",
  P4 = (X) => X.status === "valid",
  _X = (X) => typeof Promise < "u" && X instanceof Promise;
var h0;
(function (X) {
  ((X.errToObj = (Y) => (typeof Y === "string" ? { message: Y } : Y || {})),
    (X.toString = (Y) => (typeof Y === "string" ? Y : Y?.message)));
})(h0 || (h0 = {}));
class x8 {
  constructor(X, Y, Q, G) {
    ((this._cachedPath = []),
      (this.parent = X),
      (this.data = Y),
      (this._path = Q),
      (this._key = G));
  }
  get path() {
    if (!this._cachedPath.length)
      if (Array.isArray(this._key))
        this._cachedPath.push(...this._path, ...this._key);
      else this._cachedPath.push(...this._path, this._key);
    return this._cachedPath;
  }
}
var eD = (X, Y) => {
  if (P4(Y)) return { success: !0, data: Y.value };
  else {
    if (!X.common.issues.length)
      throw Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error) return this._error;
        let Q = new t5(X.common.issues);
        return ((this._error = Q), this._error);
      },
    };
  }
};
function U1(X) {
  if (!X) return {};
  let {
    errorMap: Y,
    invalid_type_error: Q,
    required_error: G,
    description: J,
  } = X;
  if (Y && (Q || G))
    throw Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    );
  if (Y) return { errorMap: Y, description: J };
  return {
    errorMap: ($, B) => {
      let { message: K } = X;
      if ($.code === "invalid_enum_value")
        return { message: K ?? B.defaultError };
      if (typeof B.data > "u") return { message: K ?? G ?? B.defaultError };
      if ($.code !== "invalid_type") return { message: B.defaultError };
      return { message: K ?? Q ?? B.defaultError };
    },
    description: J,
  };
}
class q1 {
  get description() {
    return this._def.description;
  }
  _getType(X) {
    return G6(X.data);
  }
  _getOrReturnCtx(X, Y) {
    return (
      Y || {
        common: X.parent.common,
        data: X.data,
        parsedType: G6(X.data),
        schemaErrorMap: this._def.errorMap,
        path: X.path,
        parent: X.parent,
      }
    );
  }
  _processInputParams(X) {
    return {
      status: new c5(),
      ctx: {
        common: X.parent.common,
        data: X.data,
        parsedType: G6(X.data),
        schemaErrorMap: this._def.errorMap,
        path: X.path,
        parent: X.parent,
      },
    };
  }
  _parseSync(X) {
    let Y = this._parse(X);
    if (_X(Y)) throw Error("Synchronous parse encountered promise.");
    return Y;
  }
  _parseAsync(X) {
    let Y = this._parse(X);
    return Promise.resolve(Y);
  }
  parse(X, Y) {
    let Q = this.safeParse(X, Y);
    if (Q.success) return Q.data;
    throw Q.error;
  }
  safeParse(X, Y) {
    let Q = {
        common: {
          issues: [],
          async: Y?.async ?? !1,
          contextualErrorMap: Y?.errorMap,
        },
        path: Y?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: X,
        parsedType: G6(X),
      },
      G = this._parseSync({ data: X, path: Q.path, parent: Q });
    return eD(Q, G);
  }
  "~validate"(X) {
    let Y = {
      common: { issues: [], async: !!this["~standard"].async },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: X,
      parsedType: G6(X),
    };
    if (!this["~standard"].async)
      try {
        let Q = this._parseSync({ data: X, path: [], parent: Y });
        return P4(Q) ? { value: Q.value } : { issues: Y.common.issues };
      } catch (Q) {
        if (Q?.message?.toLowerCase()?.includes("encountered"))
          this["~standard"].async = !0;
        Y.common = { issues: [], async: !0 };
      }
    return this._parseAsync({ data: X, path: [], parent: Y }).then((Q) =>
      P4(Q) ? { value: Q.value } : { issues: Y.common.issues }
    );
  }
  async parseAsync(X, Y) {
    let Q = await this.safeParseAsync(X, Y);
    if (Q.success) return Q.data;
    throw Q.error;
  }
  async safeParseAsync(X, Y) {
    let Q = {
        common: { issues: [], contextualErrorMap: Y?.errorMap, async: !0 },
        path: Y?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: X,
        parsedType: G6(X),
      },
      G = this._parse({ data: X, path: Q.path, parent: Q }),
      J = await (_X(G) ? G : Promise.resolve(G));
    return eD(Q, J);
  }
  refine(X, Y) {
    let Q = (G) => {
      if (typeof Y === "string" || typeof Y > "u") return { message: Y };
      else if (typeof Y === "function") return Y(G);
      else return Y;
    };
    return this._refinement((G, J) => {
      let U = X(G),
        $ = () => J.addIssue({ code: E0.custom, ...Q(G) });
      if (typeof Promise < "u" && U instanceof Promise)
        return U.then((B) => {
          if (!B) return ($(), !1);
          else return !0;
        });
      if (!U) return ($(), !1);
      else return !0;
    });
  }
  refinement(X, Y) {
    return this._refinement((Q, G) => {
      if (!X(Q)) return (G.addIssue(typeof Y === "function" ? Y(Q, G) : Y), !1);
      else return !0;
    });
  }
  _refinement(X) {
    return new h8({
      schema: this,
      typeName: o0.ZodEffects,
      effect: { type: "refinement", refinement: X },
    });
  }
  superRefine(X) {
    return this._refinement(X);
  }
  constructor(X) {
    ((this.spa = this.safeParseAsync),
      (this._def = X),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this)),
      (this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (Y) => this["~validate"](Y),
      }));
  }
  optional() {
    return f8.create(this, this._def);
  }
  nullable() {
    return Y4.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return _8.create(this);
  }
  promise() {
    return P9.create(this, this._def);
  }
  or(X) {
    return lX.create([this, X], this._def);
  }
  and(X) {
    return mX.create(this, X, this._def);
  }
  transform(X) {
    return new h8({
      ...U1(this._def),
      schema: this,
      typeName: o0.ZodEffects,
      effect: { type: "transform", transform: X },
    });
  }
  default(X) {
    let Y = typeof X === "function" ? X : () => X;
    return new iX({
      ...U1(this._def),
      innerType: this,
      defaultValue: Y,
      typeName: o0.ZodDefault,
    });
  }
  brand() {
    return new PG({ typeName: o0.ZodBranded, type: this, ...U1(this._def) });
  }
  catch(X) {
    let Y = typeof X === "function" ? X : () => X;
    return new nX({
      ...U1(this._def),
      innerType: this,
      catchValue: Y,
      typeName: o0.ZodCatch,
    });
  }
  describe(X) {
    return new this.constructor({ ...this._def, description: X });
  }
  pipe(X) {
    return PY.create(this, X);
  }
  readonly() {
    return aX.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var Uy = /^c[^\s-]{8,}$/i,
  Ly = /^[0-9a-z]+$/,
  By = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
  Ky =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  Vy = /^[a-z0-9_-]{21}$/i,
  Fy = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  Ny =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  My =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  Ay = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  HU,
  qy =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  Ry =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  Dy =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  zy =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  Ey = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  Oy = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  Yz =
    "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  Zy = new RegExp(`^${Yz}$`);
function Qz(X) {
  let Y = "[0-5]\\d";
  if (X.precision) Y = `${Y}\\.\\d{${X.precision}}`;
  else if (X.precision == null) Y = `${Y}(\\.\\d+)?`;
  let Q = X.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${Y})${Q}`;
}
function jy(X) {
  return new RegExp(`^${Qz(X)}$`);
}
function Gz(X) {
  let Y = `${Yz}T${Qz(X)}`,
    Q = [];
  if ((Q.push(X.local ? "Z?" : "Z"), X.offset)) Q.push("([+-]\\d{2}:?\\d{2})");
  return ((Y = `${Y}(${Q.join("|")})`), new RegExp(`^${Y}$`));
}
function wy(X, Y) {
  if ((Y === "v4" || !Y) && qy.test(X)) return !0;
  if ((Y === "v6" || !Y) && Dy.test(X)) return !0;
  return !1;
}
function Cy(X, Y) {
  if (!Fy.test(X)) return !1;
  try {
    let [Q] = X.split(".");
    if (!Q) return !1;
    let G = Q.replace(/-/g, "+")
        .replace(/_/g, "/")
        .padEnd(Q.length + ((4 - (Q.length % 4)) % 4), "="),
      J = JSON.parse(atob(G));
    if (typeof J !== "object" || J === null) return !1;
    if ("typ" in J && J?.typ !== "JWT") return !1;
    if (!J.alg) return !1;
    if (Y && J.alg !== Y) return !1;
    return !0;
  } catch {
    return !1;
  }
}
function Iy(X, Y) {
  if ((Y === "v4" || !Y) && Ry.test(X)) return !0;
  if ((Y === "v6" || !Y) && zy.test(X)) return !0;
  return !1;
}
class y8 extends q1 {
  _parse(X) {
    if (this._def.coerce) X.data = String(X.data);
    if (this._getType(X) !== C0.string) {
      let J = this._getOrReturnCtx(X);
      return (
        b0(J, {
          code: E0.invalid_type,
          expected: C0.string,
          received: J.parsedType,
        }),
        n0
      );
    }
    let Q = new c5(),
      G = void 0;
    for (let J of this._def.checks)
      if (J.kind === "min") {
        if (X.data.length < J.value)
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              code: E0.too_small,
              minimum: J.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "max") {
        if (X.data.length > J.value)
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              code: E0.too_big,
              maximum: J.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "length") {
        let U = X.data.length > J.value,
          $ = X.data.length < J.value;
        if (U || $) {
          if (((G = this._getOrReturnCtx(X, G)), U))
            b0(G, {
              code: E0.too_big,
              maximum: J.value,
              type: "string",
              inclusive: !0,
              exact: !0,
              message: J.message,
            });
          else if ($)
            b0(G, {
              code: E0.too_small,
              minimum: J.value,
              type: "string",
              inclusive: !0,
              exact: !0,
              message: J.message,
            });
          Q.dirty();
        }
      } else if (J.kind === "email") {
        if (!My.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "email",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "emoji") {
        if (!HU) HU = new RegExp(Ay, "u");
        if (!HU.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "emoji",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "uuid") {
        if (!Ky.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "uuid",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "nanoid") {
        if (!Vy.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "nanoid",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "cuid") {
        if (!Uy.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "cuid",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "cuid2") {
        if (!Ly.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "cuid2",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "ulid") {
        if (!By.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "ulid",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "url")
        try {
          new URL(X.data);
        } catch {
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "url",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
        }
      else if (J.kind === "regex") {
        if (((J.regex.lastIndex = 0), !J.regex.test(X.data)))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "regex",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "trim") X.data = X.data.trim();
      else if (J.kind === "includes") {
        if (!X.data.includes(J.value, J.position))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              code: E0.invalid_string,
              validation: { includes: J.value, position: J.position },
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "toLowerCase") X.data = X.data.toLowerCase();
      else if (J.kind === "toUpperCase") X.data = X.data.toUpperCase();
      else if (J.kind === "startsWith") {
        if (!X.data.startsWith(J.value))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              code: E0.invalid_string,
              validation: { startsWith: J.value },
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "endsWith") {
        if (!X.data.endsWith(J.value))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              code: E0.invalid_string,
              validation: { endsWith: J.value },
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "datetime") {
        if (!Gz(J).test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              code: E0.invalid_string,
              validation: "datetime",
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "date") {
        if (!Zy.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              code: E0.invalid_string,
              validation: "date",
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "time") {
        if (!jy(J).test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              code: E0.invalid_string,
              validation: "time",
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "duration") {
        if (!Ny.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "duration",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "ip") {
        if (!wy(X.data, J.version))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "ip",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "jwt") {
        if (!Cy(X.data, J.alg))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "jwt",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "cidr") {
        if (!Iy(X.data, J.version))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "cidr",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "base64") {
        if (!Ey.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "base64",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "base64url") {
        if (!Oy.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              validation: "base64url",
              code: E0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else C1.assertNever(J);
    return { status: Q.value, value: X.data };
  }
  _regex(X, Y, Q) {
    return this.refinement((G) => X.test(G), {
      validation: Y,
      code: E0.invalid_string,
      ...h0.errToObj(Q),
    });
  }
  _addCheck(X) {
    return new y8({ ...this._def, checks: [...this._def.checks, X] });
  }
  email(X) {
    return this._addCheck({ kind: "email", ...h0.errToObj(X) });
  }
  url(X) {
    return this._addCheck({ kind: "url", ...h0.errToObj(X) });
  }
  emoji(X) {
    return this._addCheck({ kind: "emoji", ...h0.errToObj(X) });
  }
  uuid(X) {
    return this._addCheck({ kind: "uuid", ...h0.errToObj(X) });
  }
  nanoid(X) {
    return this._addCheck({ kind: "nanoid", ...h0.errToObj(X) });
  }
  cuid(X) {
    return this._addCheck({ kind: "cuid", ...h0.errToObj(X) });
  }
  cuid2(X) {
    return this._addCheck({ kind: "cuid2", ...h0.errToObj(X) });
  }
  ulid(X) {
    return this._addCheck({ kind: "ulid", ...h0.errToObj(X) });
  }
  base64(X) {
    return this._addCheck({ kind: "base64", ...h0.errToObj(X) });
  }
  base64url(X) {
    return this._addCheck({ kind: "base64url", ...h0.errToObj(X) });
  }
  jwt(X) {
    return this._addCheck({ kind: "jwt", ...h0.errToObj(X) });
  }
  ip(X) {
    return this._addCheck({ kind: "ip", ...h0.errToObj(X) });
  }
  cidr(X) {
    return this._addCheck({ kind: "cidr", ...h0.errToObj(X) });
  }
  datetime(X) {
    if (typeof X === "string")
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: X,
      });
    return this._addCheck({
      kind: "datetime",
      precision: typeof X?.precision > "u" ? null : X?.precision,
      offset: X?.offset ?? !1,
      local: X?.local ?? !1,
      ...h0.errToObj(X?.message),
    });
  }
  date(X) {
    return this._addCheck({ kind: "date", message: X });
  }
  time(X) {
    if (typeof X === "string")
      return this._addCheck({ kind: "time", precision: null, message: X });
    return this._addCheck({
      kind: "time",
      precision: typeof X?.precision > "u" ? null : X?.precision,
      ...h0.errToObj(X?.message),
    });
  }
  duration(X) {
    return this._addCheck({ kind: "duration", ...h0.errToObj(X) });
  }
  regex(X, Y) {
    return this._addCheck({ kind: "regex", regex: X, ...h0.errToObj(Y) });
  }
  includes(X, Y) {
    return this._addCheck({
      kind: "includes",
      value: X,
      position: Y?.position,
      ...h0.errToObj(Y?.message),
    });
  }
  startsWith(X, Y) {
    return this._addCheck({ kind: "startsWith", value: X, ...h0.errToObj(Y) });
  }
  endsWith(X, Y) {
    return this._addCheck({ kind: "endsWith", value: X, ...h0.errToObj(Y) });
  }
  min(X, Y) {
    return this._addCheck({ kind: "min", value: X, ...h0.errToObj(Y) });
  }
  max(X, Y) {
    return this._addCheck({ kind: "max", value: X, ...h0.errToObj(Y) });
  }
  length(X, Y) {
    return this._addCheck({ kind: "length", value: X, ...h0.errToObj(Y) });
  }
  nonempty(X) {
    return this.min(1, h0.errToObj(X));
  }
  trim() {
    return new y8({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    });
  }
  toLowerCase() {
    return new y8({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    });
  }
  toUpperCase() {
    return new y8({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((X) => X.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((X) => X.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((X) => X.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((X) => X.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((X) => X.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((X) => X.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((X) => X.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((X) => X.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((X) => X.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((X) => X.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((X) => X.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((X) => X.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((X) => X.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((X) => X.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((X) => X.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((X) => X.kind === "base64url");
  }
  get minLength() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "min") {
        if (X === null || Y.value > X) X = Y.value;
      }
    return X;
  }
  get maxLength() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "max") {
        if (X === null || Y.value < X) X = Y.value;
      }
    return X;
  }
}
y8.create = (X) => {
  return new y8({
    checks: [],
    typeName: o0.ZodString,
    coerce: X?.coerce ?? !1,
    ...U1(X),
  });
};
function Py(X, Y) {
  let Q = (X.toString().split(".")[1] || "").length,
    G = (Y.toString().split(".")[1] || "").length,
    J = Q > G ? Q : G,
    U = Number.parseInt(X.toFixed(J).replace(".", "")),
    $ = Number.parseInt(Y.toFixed(J).replace(".", ""));
  return (U % $) / 10 ** J;
}
class T4 extends q1 {
  constructor() {
    super(...arguments);
    ((this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf));
  }
  _parse(X) {
    if (this._def.coerce) X.data = Number(X.data);
    if (this._getType(X) !== C0.number) {
      let J = this._getOrReturnCtx(X);
      return (
        b0(J, {
          code: E0.invalid_type,
          expected: C0.number,
          received: J.parsedType,
        }),
        n0
      );
    }
    let Q = void 0,
      G = new c5();
    for (let J of this._def.checks)
      if (J.kind === "int") {
        if (!C1.isInteger(X.data))
          ((Q = this._getOrReturnCtx(X, Q)),
            b0(Q, {
              code: E0.invalid_type,
              expected: "integer",
              received: "float",
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "min") {
        if (J.inclusive ? X.data < J.value : X.data <= J.value)
          ((Q = this._getOrReturnCtx(X, Q)),
            b0(Q, {
              code: E0.too_small,
              minimum: J.value,
              type: "number",
              inclusive: J.inclusive,
              exact: !1,
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "max") {
        if (J.inclusive ? X.data > J.value : X.data >= J.value)
          ((Q = this._getOrReturnCtx(X, Q)),
            b0(Q, {
              code: E0.too_big,
              maximum: J.value,
              type: "number",
              inclusive: J.inclusive,
              exact: !1,
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "multipleOf") {
        if (Py(X.data, J.value) !== 0)
          ((Q = this._getOrReturnCtx(X, Q)),
            b0(Q, {
              code: E0.not_multiple_of,
              multipleOf: J.value,
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "finite") {
        if (!Number.isFinite(X.data))
          ((Q = this._getOrReturnCtx(X, Q)),
            b0(Q, { code: E0.not_finite, message: J.message }),
            G.dirty());
      } else C1.assertNever(J);
    return { status: G.value, value: X.data };
  }
  gte(X, Y) {
    return this.setLimit("min", X, !0, h0.toString(Y));
  }
  gt(X, Y) {
    return this.setLimit("min", X, !1, h0.toString(Y));
  }
  lte(X, Y) {
    return this.setLimit("max", X, !0, h0.toString(Y));
  }
  lt(X, Y) {
    return this.setLimit("max", X, !1, h0.toString(Y));
  }
  setLimit(X, Y, Q, G) {
    return new T4({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: X, value: Y, inclusive: Q, message: h0.toString(G) },
      ],
    });
  }
  _addCheck(X) {
    return new T4({ ...this._def, checks: [...this._def.checks, X] });
  }
  int(X) {
    return this._addCheck({ kind: "int", message: h0.toString(X) });
  }
  positive(X) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: h0.toString(X),
    });
  }
  negative(X) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: h0.toString(X),
    });
  }
  nonpositive(X) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: h0.toString(X),
    });
  }
  nonnegative(X) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: h0.toString(X),
    });
  }
  multipleOf(X, Y) {
    return this._addCheck({
      kind: "multipleOf",
      value: X,
      message: h0.toString(Y),
    });
  }
  finite(X) {
    return this._addCheck({ kind: "finite", message: h0.toString(X) });
  }
  safe(X) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: h0.toString(X),
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: h0.toString(X),
    });
  }
  get minValue() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "min") {
        if (X === null || Y.value > X) X = Y.value;
      }
    return X;
  }
  get maxValue() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "max") {
        if (X === null || Y.value < X) X = Y.value;
      }
    return X;
  }
  get isInt() {
    return !!this._def.checks.find(
      (X) =>
        X.kind === "int" || (X.kind === "multipleOf" && C1.isInteger(X.value))
    );
  }
  get isFinite() {
    let X = null,
      Y = null;
    for (let Q of this._def.checks)
      if (Q.kind === "finite" || Q.kind === "int" || Q.kind === "multipleOf")
        return !0;
      else if (Q.kind === "min") {
        if (Y === null || Q.value > Y) Y = Q.value;
      } else if (Q.kind === "max") {
        if (X === null || Q.value < X) X = Q.value;
      }
    return Number.isFinite(Y) && Number.isFinite(X);
  }
}
T4.create = (X) => {
  return new T4({
    checks: [],
    typeName: o0.ZodNumber,
    coerce: X?.coerce || !1,
    ...U1(X),
  });
};
class b4 extends q1 {
  constructor() {
    super(...arguments);
    ((this.min = this.gte), (this.max = this.lte));
  }
  _parse(X) {
    if (this._def.coerce)
      try {
        X.data = BigInt(X.data);
      } catch {
        return this._getInvalidInput(X);
      }
    if (this._getType(X) !== C0.bigint) return this._getInvalidInput(X);
    let Q = void 0,
      G = new c5();
    for (let J of this._def.checks)
      if (J.kind === "min") {
        if (J.inclusive ? X.data < J.value : X.data <= J.value)
          ((Q = this._getOrReturnCtx(X, Q)),
            b0(Q, {
              code: E0.too_small,
              type: "bigint",
              minimum: J.value,
              inclusive: J.inclusive,
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "max") {
        if (J.inclusive ? X.data > J.value : X.data >= J.value)
          ((Q = this._getOrReturnCtx(X, Q)),
            b0(Q, {
              code: E0.too_big,
              type: "bigint",
              maximum: J.value,
              inclusive: J.inclusive,
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "multipleOf") {
        if (X.data % J.value !== BigInt(0))
          ((Q = this._getOrReturnCtx(X, Q)),
            b0(Q, {
              code: E0.not_multiple_of,
              multipleOf: J.value,
              message: J.message,
            }),
            G.dirty());
      } else C1.assertNever(J);
    return { status: G.value, value: X.data };
  }
  _getInvalidInput(X) {
    let Y = this._getOrReturnCtx(X);
    return (
      b0(Y, {
        code: E0.invalid_type,
        expected: C0.bigint,
        received: Y.parsedType,
      }),
      n0
    );
  }
  gte(X, Y) {
    return this.setLimit("min", X, !0, h0.toString(Y));
  }
  gt(X, Y) {
    return this.setLimit("min", X, !1, h0.toString(Y));
  }
  lte(X, Y) {
    return this.setLimit("max", X, !0, h0.toString(Y));
  }
  lt(X, Y) {
    return this.setLimit("max", X, !1, h0.toString(Y));
  }
  setLimit(X, Y, Q, G) {
    return new b4({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: X, value: Y, inclusive: Q, message: h0.toString(G) },
      ],
    });
  }
  _addCheck(X) {
    return new b4({ ...this._def, checks: [...this._def.checks, X] });
  }
  positive(X) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: h0.toString(X),
    });
  }
  negative(X) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: h0.toString(X),
    });
  }
  nonpositive(X) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: h0.toString(X),
    });
  }
  nonnegative(X) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: h0.toString(X),
    });
  }
  multipleOf(X, Y) {
    return this._addCheck({
      kind: "multipleOf",
      value: X,
      message: h0.toString(Y),
    });
  }
  get minValue() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "min") {
        if (X === null || Y.value > X) X = Y.value;
      }
    return X;
  }
  get maxValue() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "max") {
        if (X === null || Y.value < X) X = Y.value;
      }
    return X;
  }
}
b4.create = (X) => {
  return new b4({
    checks: [],
    typeName: o0.ZodBigInt,
    coerce: X?.coerce ?? !1,
    ...U1(X),
  });
};
class hX extends q1 {
  _parse(X) {
    if (this._def.coerce) X.data = Boolean(X.data);
    if (this._getType(X) !== C0.boolean) {
      let Q = this._getOrReturnCtx(X);
      return (
        b0(Q, {
          code: E0.invalid_type,
          expected: C0.boolean,
          received: Q.parsedType,
        }),
        n0
      );
    }
    return e5(X.data);
  }
}
hX.create = (X) => {
  return new hX({ typeName: o0.ZodBoolean, coerce: X?.coerce || !1, ...U1(X) });
};
class w9 extends q1 {
  _parse(X) {
    if (this._def.coerce) X.data = new Date(X.data);
    if (this._getType(X) !== C0.date) {
      let J = this._getOrReturnCtx(X);
      return (
        b0(J, {
          code: E0.invalid_type,
          expected: C0.date,
          received: J.parsedType,
        }),
        n0
      );
    }
    if (Number.isNaN(X.data.getTime())) {
      let J = this._getOrReturnCtx(X);
      return (b0(J, { code: E0.invalid_date }), n0);
    }
    let Q = new c5(),
      G = void 0;
    for (let J of this._def.checks)
      if (J.kind === "min") {
        if (X.data.getTime() < J.value)
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              code: E0.too_small,
              message: J.message,
              inclusive: !0,
              exact: !1,
              minimum: J.value,
              type: "date",
            }),
            Q.dirty());
      } else if (J.kind === "max") {
        if (X.data.getTime() > J.value)
          ((G = this._getOrReturnCtx(X, G)),
            b0(G, {
              code: E0.too_big,
              message: J.message,
              inclusive: !0,
              exact: !1,
              maximum: J.value,
              type: "date",
            }),
            Q.dirty());
      } else C1.assertNever(J);
    return { status: Q.value, value: new Date(X.data.getTime()) };
  }
  _addCheck(X) {
    return new w9({ ...this._def, checks: [...this._def.checks, X] });
  }
  min(X, Y) {
    return this._addCheck({
      kind: "min",
      value: X.getTime(),
      message: h0.toString(Y),
    });
  }
  max(X, Y) {
    return this._addCheck({
      kind: "max",
      value: X.getTime(),
      message: h0.toString(Y),
    });
  }
  get minDate() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "min") {
        if (X === null || Y.value > X) X = Y.value;
      }
    return X != null ? new Date(X) : null;
  }
  get maxDate() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "max") {
        if (X === null || Y.value < X) X = Y.value;
      }
    return X != null ? new Date(X) : null;
  }
}
w9.create = (X) => {
  return new w9({
    checks: [],
    coerce: X?.coerce || !1,
    typeName: o0.ZodDate,
    ...U1(X),
  });
};
class ZY extends q1 {
  _parse(X) {
    if (this._getType(X) !== C0.symbol) {
      let Q = this._getOrReturnCtx(X);
      return (
        b0(Q, {
          code: E0.invalid_type,
          expected: C0.symbol,
          received: Q.parsedType,
        }),
        n0
      );
    }
    return e5(X.data);
  }
}
ZY.create = (X) => {
  return new ZY({ typeName: o0.ZodSymbol, ...U1(X) });
};
class gX extends q1 {
  _parse(X) {
    if (this._getType(X) !== C0.undefined) {
      let Q = this._getOrReturnCtx(X);
      return (
        b0(Q, {
          code: E0.invalid_type,
          expected: C0.undefined,
          received: Q.parsedType,
        }),
        n0
      );
    }
    return e5(X.data);
  }
}
gX.create = (X) => {
  return new gX({ typeName: o0.ZodUndefined, ...U1(X) });
};
class uX extends q1 {
  _parse(X) {
    if (this._getType(X) !== C0.null) {
      let Q = this._getOrReturnCtx(X);
      return (
        b0(Q, {
          code: E0.invalid_type,
          expected: C0.null,
          received: Q.parsedType,
        }),
        n0
      );
    }
    return e5(X.data);
  }
}
uX.create = (X) => {
  return new uX({ typeName: o0.ZodNull, ...U1(X) });
};
class C9 extends q1 {
  constructor() {
    super(...arguments);
    this._any = !0;
  }
  _parse(X) {
    return e5(X.data);
  }
}
C9.create = (X) => {
  return new C9({ typeName: o0.ZodAny, ...U1(X) });
};
class S4 extends q1 {
  constructor() {
    super(...arguments);
    this._unknown = !0;
  }
  _parse(X) {
    return e5(X.data);
  }
}
S4.create = (X) => {
  return new S4({ typeName: o0.ZodUnknown, ...U1(X) });
};
class J6 extends q1 {
  _parse(X) {
    let Y = this._getOrReturnCtx(X);
    return (
      b0(Y, {
        code: E0.invalid_type,
        expected: C0.never,
        received: Y.parsedType,
      }),
      n0
    );
  }
}
J6.create = (X) => {
  return new J6({ typeName: o0.ZodNever, ...U1(X) });
};
class jY extends q1 {
  _parse(X) {
    if (this._getType(X) !== C0.undefined) {
      let Q = this._getOrReturnCtx(X);
      return (
        b0(Q, {
          code: E0.invalid_type,
          expected: C0.void,
          received: Q.parsedType,
        }),
        n0
      );
    }
    return e5(X.data);
  }
}
jY.create = (X) => {
  return new jY({ typeName: o0.ZodVoid, ...U1(X) });
};
class _8 extends q1 {
  _parse(X) {
    let { ctx: Y, status: Q } = this._processInputParams(X),
      G = this._def;
    if (Y.parsedType !== C0.array)
      return (
        b0(Y, {
          code: E0.invalid_type,
          expected: C0.array,
          received: Y.parsedType,
        }),
        n0
      );
    if (G.exactLength !== null) {
      let U = Y.data.length > G.exactLength.value,
        $ = Y.data.length < G.exactLength.value;
      if (U || $)
        (b0(Y, {
          code: U ? E0.too_big : E0.too_small,
          minimum: $ ? G.exactLength.value : void 0,
          maximum: U ? G.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: G.exactLength.message,
        }),
          Q.dirty());
    }
    if (G.minLength !== null) {
      if (Y.data.length < G.minLength.value)
        (b0(Y, {
          code: E0.too_small,
          minimum: G.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: G.minLength.message,
        }),
          Q.dirty());
    }
    if (G.maxLength !== null) {
      if (Y.data.length > G.maxLength.value)
        (b0(Y, {
          code: E0.too_big,
          maximum: G.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: G.maxLength.message,
        }),
          Q.dirty());
    }
    if (Y.common.async)
      return Promise.all(
        [...Y.data].map((U, $) => {
          return G.type._parseAsync(new x8(Y, U, Y.path, $));
        })
      ).then((U) => {
        return c5.mergeArray(Q, U);
      });
    let J = [...Y.data].map((U, $) => {
      return G.type._parseSync(new x8(Y, U, Y.path, $));
    });
    return c5.mergeArray(Q, J);
  }
  get element() {
    return this._def.type;
  }
  min(X, Y) {
    return new _8({
      ...this._def,
      minLength: { value: X, message: h0.toString(Y) },
    });
  }
  max(X, Y) {
    return new _8({
      ...this._def,
      maxLength: { value: X, message: h0.toString(Y) },
    });
  }
  length(X, Y) {
    return new _8({
      ...this._def,
      exactLength: { value: X, message: h0.toString(Y) },
    });
  }
  nonempty(X) {
    return this.min(1, X);
  }
}
_8.create = (X, Y) => {
  return new _8({
    type: X,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: o0.ZodArray,
    ...U1(Y),
  });
};
function fX(X) {
  if (X instanceof B5) {
    let Y = {};
    for (let Q in X.shape) {
      let G = X.shape[Q];
      Y[Q] = f8.create(fX(G));
    }
    return new B5({ ...X._def, shape: () => Y });
  } else if (X instanceof _8) return new _8({ ...X._def, type: fX(X.element) });
  else if (X instanceof f8) return f8.create(fX(X.unwrap()));
  else if (X instanceof Y4) return Y4.create(fX(X.unwrap()));
  else if (X instanceof W6) return W6.create(X.items.map((Y) => fX(Y)));
  else return X;
}
class B5 extends q1 {
  constructor() {
    super(...arguments);
    ((this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend));
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    let X = this._def.shape(),
      Y = C1.objectKeys(X);
    return ((this._cached = { shape: X, keys: Y }), this._cached);
  }
  _parse(X) {
    if (this._getType(X) !== C0.object) {
      let K = this._getOrReturnCtx(X);
      return (
        b0(K, {
          code: E0.invalid_type,
          expected: C0.object,
          received: K.parsedType,
        }),
        n0
      );
    }
    let { status: Q, ctx: G } = this._processInputParams(X),
      { shape: J, keys: U } = this._getCached(),
      $ = [];
    if (
      !(this._def.catchall instanceof J6 && this._def.unknownKeys === "strip")
    ) {
      for (let K in G.data) if (!U.includes(K)) $.push(K);
    }
    let B = [];
    for (let K of U) {
      let V = J[K],
        W = G.data[K];
      B.push({
        key: { status: "valid", value: K },
        value: V._parse(new x8(G, W, G.path, K)),
        alwaysSet: K in G.data,
      });
    }
    if (this._def.catchall instanceof J6) {
      let K = this._def.unknownKeys;
      if (K === "passthrough")
        for (let V of $)
          B.push({
            key: { status: "valid", value: V },
            value: { status: "valid", value: G.data[V] },
          });
      else if (K === "strict") {
        if ($.length > 0)
          (b0(G, { code: E0.unrecognized_keys, keys: $ }), Q.dirty());
      } else if (K === "strip");
      else throw Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let K = this._def.catchall;
      for (let V of $) {
        let W = G.data[V];
        B.push({
          key: { status: "valid", value: V },
          value: K._parse(new x8(G, W, G.path, V)),
          alwaysSet: V in G.data,
        });
      }
    }
    if (G.common.async)
      return Promise.resolve()
        .then(async () => {
          let K = [];
          for (let V of B) {
            let W = await V.key,
              L = await V.value;
            K.push({ key: W, value: L, alwaysSet: V.alwaysSet });
          }
          return K;
        })
        .then((K) => {
          return c5.mergeObjectSync(Q, K);
        });
    else return c5.mergeObjectSync(Q, B);
  }
  get shape() {
    return this._def.shape();
  }
  strict(X) {
    return (
      h0.errToObj,
      new B5({
        ...this._def,
        unknownKeys: "strict",
        ...(X !== void 0
          ? {
              errorMap: (Y, Q) => {
                let G = this._def.errorMap?.(Y, Q).message ?? Q.defaultError;
                if (Y.code === "unrecognized_keys")
                  return { message: h0.errToObj(X).message ?? G };
                return { message: G };
              },
            }
          : {}),
      })
    );
  }
  strip() {
    return new B5({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new B5({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(X) {
    return new B5({
      ...this._def,
      shape: () => ({ ...this._def.shape(), ...X }),
    });
  }
  merge(X) {
    return new B5({
      unknownKeys: X._def.unknownKeys,
      catchall: X._def.catchall,
      shape: () => ({ ...this._def.shape(), ...X._def.shape() }),
      typeName: o0.ZodObject,
    });
  }
  setKey(X, Y) {
    return this.augment({ [X]: Y });
  }
  catchall(X) {
    return new B5({ ...this._def, catchall: X });
  }
  pick(X) {
    let Y = {};
    for (let Q of C1.objectKeys(X))
      if (X[Q] && this.shape[Q]) Y[Q] = this.shape[Q];
    return new B5({ ...this._def, shape: () => Y });
  }
  omit(X) {
    let Y = {};
    for (let Q of C1.objectKeys(this.shape)) if (!X[Q]) Y[Q] = this.shape[Q];
    return new B5({ ...this._def, shape: () => Y });
  }
  deepPartial() {
    return fX(this);
  }
  partial(X) {
    let Y = {};
    for (let Q of C1.objectKeys(this.shape)) {
      let G = this.shape[Q];
      if (X && !X[Q]) Y[Q] = G;
      else Y[Q] = G.optional();
    }
    return new B5({ ...this._def, shape: () => Y });
  }
  required(X) {
    let Y = {};
    for (let Q of C1.objectKeys(this.shape))
      if (X && !X[Q]) Y[Q] = this.shape[Q];
      else {
        let J = this.shape[Q];
        while (J instanceof f8) J = J._def.innerType;
        Y[Q] = J;
      }
    return new B5({ ...this._def, shape: () => Y });
  }
  keyof() {
    return Jz(C1.objectKeys(this.shape));
  }
}
B5.create = (X, Y) => {
  return new B5({
    shape: () => X,
    unknownKeys: "strip",
    catchall: J6.create(),
    typeName: o0.ZodObject,
    ...U1(Y),
  });
};
B5.strictCreate = (X, Y) => {
  return new B5({
    shape: () => X,
    unknownKeys: "strict",
    catchall: J6.create(),
    typeName: o0.ZodObject,
    ...U1(Y),
  });
};
B5.lazycreate = (X, Y) => {
  return new B5({
    shape: X,
    unknownKeys: "strip",
    catchall: J6.create(),
    typeName: o0.ZodObject,
    ...U1(Y),
  });
};
class lX extends q1 {
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X),
      Q = this._def.options;
    function G(J) {
      for (let $ of J) if ($.result.status === "valid") return $.result;
      for (let $ of J)
        if ($.result.status === "dirty")
          return (Y.common.issues.push(...$.ctx.common.issues), $.result);
      let U = J.map(($) => new t5($.ctx.common.issues));
      return (b0(Y, { code: E0.invalid_union, unionErrors: U }), n0);
    }
    if (Y.common.async)
      return Promise.all(
        Q.map(async (J) => {
          let U = { ...Y, common: { ...Y.common, issues: [] }, parent: null };
          return {
            result: await J._parseAsync({
              data: Y.data,
              path: Y.path,
              parent: U,
            }),
            ctx: U,
          };
        })
      ).then(G);
    else {
      let J = void 0,
        U = [];
      for (let B of Q) {
        let K = { ...Y, common: { ...Y.common, issues: [] }, parent: null },
          V = B._parseSync({ data: Y.data, path: Y.path, parent: K });
        if (V.status === "valid") return V;
        else if (V.status === "dirty" && !J) J = { result: V, ctx: K };
        if (K.common.issues.length) U.push(K.common.issues);
      }
      if (J) return (Y.common.issues.push(...J.ctx.common.issues), J.result);
      let $ = U.map((B) => new t5(B));
      return (b0(Y, { code: E0.invalid_union, unionErrors: $ }), n0);
    }
  }
  get options() {
    return this._def.options;
  }
}
lX.create = (X, Y) => {
  return new lX({ options: X, typeName: o0.ZodUnion, ...U1(Y) });
};
var X4 = (X) => {
  if (X instanceof cX) return X4(X.schema);
  else if (X instanceof h8) return X4(X.innerType());
  else if (X instanceof dX) return [X.value];
  else if (X instanceof v4) return X.options;
  else if (X instanceof pX) return C1.objectValues(X.enum);
  else if (X instanceof iX) return X4(X._def.innerType);
  else if (X instanceof gX) return [void 0];
  else if (X instanceof uX) return [null];
  else if (X instanceof f8) return [void 0, ...X4(X.unwrap())];
  else if (X instanceof Y4) return [null, ...X4(X.unwrap())];
  else if (X instanceof PG) return X4(X.unwrap());
  else if (X instanceof aX) return X4(X.unwrap());
  else if (X instanceof nX) return X4(X._def.innerType);
  else return [];
};
class IG extends q1 {
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X);
    if (Y.parsedType !== C0.object)
      return (
        b0(Y, {
          code: E0.invalid_type,
          expected: C0.object,
          received: Y.parsedType,
        }),
        n0
      );
    let Q = this.discriminator,
      G = Y.data[Q],
      J = this.optionsMap.get(G);
    if (!J)
      return (
        b0(Y, {
          code: E0.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [Q],
        }),
        n0
      );
    if (Y.common.async)
      return J._parseAsync({ data: Y.data, path: Y.path, parent: Y });
    else return J._parseSync({ data: Y.data, path: Y.path, parent: Y });
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(X, Y, Q) {
    let G = new Map();
    for (let J of Y) {
      let U = X4(J.shape[X]);
      if (!U.length)
        throw Error(
          `A discriminator value for key \`${X}\` could not be extracted from all schema options`
        );
      for (let $ of U) {
        if (G.has($))
          throw Error(
            `Discriminator property ${String(X)} has duplicate value ${String($)}`
          );
        G.set($, J);
      }
    }
    return new IG({
      typeName: o0.ZodDiscriminatedUnion,
      discriminator: X,
      options: Y,
      optionsMap: G,
      ...U1(Q),
    });
  }
}
function $U(X, Y) {
  let Q = G6(X),
    G = G6(Y);
  if (X === Y) return { valid: !0, data: X };
  else if (Q === C0.object && G === C0.object) {
    let J = C1.objectKeys(Y),
      U = C1.objectKeys(X).filter((B) => J.indexOf(B) !== -1),
      $ = { ...X, ...Y };
    for (let B of U) {
      let K = $U(X[B], Y[B]);
      if (!K.valid) return { valid: !1 };
      $[B] = K.data;
    }
    return { valid: !0, data: $ };
  } else if (Q === C0.array && G === C0.array) {
    if (X.length !== Y.length) return { valid: !1 };
    let J = [];
    for (let U = 0; U < X.length; U++) {
      let $ = X[U],
        B = Y[U],
        K = $U($, B);
      if (!K.valid) return { valid: !1 };
      J.push(K.data);
    }
    return { valid: !0, data: J };
  } else if (Q === C0.date && G === C0.date && +X === +Y)
    return { valid: !0, data: X };
  else return { valid: !1 };
}
class mX extends q1 {
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X),
      G = (J, U) => {
        if (wG(J) || wG(U)) return n0;
        let $ = $U(J.value, U.value);
        if (!$.valid)
          return (b0(Q, { code: E0.invalid_intersection_types }), n0);
        if (CG(J) || CG(U)) Y.dirty();
        return { status: Y.value, value: $.data };
      };
    if (Q.common.async)
      return Promise.all([
        this._def.left._parseAsync({ data: Q.data, path: Q.path, parent: Q }),
        this._def.right._parseAsync({ data: Q.data, path: Q.path, parent: Q }),
      ]).then(([J, U]) => G(J, U));
    else
      return G(
        this._def.left._parseSync({ data: Q.data, path: Q.path, parent: Q }),
        this._def.right._parseSync({ data: Q.data, path: Q.path, parent: Q })
      );
  }
}
mX.create = (X, Y, Q) => {
  return new mX({ left: X, right: Y, typeName: o0.ZodIntersection, ...U1(Q) });
};
class W6 extends q1 {
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== C0.array)
      return (
        b0(Q, {
          code: E0.invalid_type,
          expected: C0.array,
          received: Q.parsedType,
        }),
        n0
      );
    if (Q.data.length < this._def.items.length)
      return (
        b0(Q, {
          code: E0.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        n0
      );
    if (!this._def.rest && Q.data.length > this._def.items.length)
      (b0(Q, {
        code: E0.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array",
      }),
        Y.dirty());
    let J = [...Q.data]
      .map((U, $) => {
        let B = this._def.items[$] || this._def.rest;
        if (!B) return null;
        return B._parse(new x8(Q, U, Q.path, $));
      })
      .filter((U) => !!U);
    if (Q.common.async)
      return Promise.all(J).then((U) => {
        return c5.mergeArray(Y, U);
      });
    else return c5.mergeArray(Y, J);
  }
  get items() {
    return this._def.items;
  }
  rest(X) {
    return new W6({ ...this._def, rest: X });
  }
}
W6.create = (X, Y) => {
  if (!Array.isArray(X))
    throw Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new W6({ items: X, typeName: o0.ZodTuple, rest: null, ...U1(Y) });
};
class wY extends q1 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== C0.object)
      return (
        b0(Q, {
          code: E0.invalid_type,
          expected: C0.object,
          received: Q.parsedType,
        }),
        n0
      );
    let G = [],
      J = this._def.keyType,
      U = this._def.valueType;
    for (let $ in Q.data)
      G.push({
        key: J._parse(new x8(Q, $, Q.path, $)),
        value: U._parse(new x8(Q, Q.data[$], Q.path, $)),
        alwaysSet: $ in Q.data,
      });
    if (Q.common.async) return c5.mergeObjectAsync(Y, G);
    else return c5.mergeObjectSync(Y, G);
  }
  get element() {
    return this._def.valueType;
  }
  static create(X, Y, Q) {
    if (Y instanceof q1)
      return new wY({
        keyType: X,
        valueType: Y,
        typeName: o0.ZodRecord,
        ...U1(Q),
      });
    return new wY({
      keyType: y8.create(),
      valueType: X,
      typeName: o0.ZodRecord,
      ...U1(Y),
    });
  }
}
class CY extends q1 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== C0.map)
      return (
        b0(Q, {
          code: E0.invalid_type,
          expected: C0.map,
          received: Q.parsedType,
        }),
        n0
      );
    let G = this._def.keyType,
      J = this._def.valueType,
      U = [...Q.data.entries()].map(([$, B], K) => {
        return {
          key: G._parse(new x8(Q, $, Q.path, [K, "key"])),
          value: J._parse(new x8(Q, B, Q.path, [K, "value"])),
        };
      });
    if (Q.common.async) {
      let $ = new Map();
      return Promise.resolve().then(async () => {
        for (let B of U) {
          let K = await B.key,
            V = await B.value;
          if (K.status === "aborted" || V.status === "aborted") return n0;
          if (K.status === "dirty" || V.status === "dirty") Y.dirty();
          $.set(K.value, V.value);
        }
        return { status: Y.value, value: $ };
      });
    } else {
      let $ = new Map();
      for (let B of U) {
        let { key: K, value: V } = B;
        if (K.status === "aborted" || V.status === "aborted") return n0;
        if (K.status === "dirty" || V.status === "dirty") Y.dirty();
        $.set(K.value, V.value);
      }
      return { status: Y.value, value: $ };
    }
  }
}
CY.create = (X, Y, Q) => {
  return new CY({ valueType: Y, keyType: X, typeName: o0.ZodMap, ...U1(Q) });
};
class I9 extends q1 {
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== C0.set)
      return (
        b0(Q, {
          code: E0.invalid_type,
          expected: C0.set,
          received: Q.parsedType,
        }),
        n0
      );
    let G = this._def;
    if (G.minSize !== null) {
      if (Q.data.size < G.minSize.value)
        (b0(Q, {
          code: E0.too_small,
          minimum: G.minSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: G.minSize.message,
        }),
          Y.dirty());
    }
    if (G.maxSize !== null) {
      if (Q.data.size > G.maxSize.value)
        (b0(Q, {
          code: E0.too_big,
          maximum: G.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: G.maxSize.message,
        }),
          Y.dirty());
    }
    let J = this._def.valueType;
    function U(B) {
      let K = new Set();
      for (let V of B) {
        if (V.status === "aborted") return n0;
        if (V.status === "dirty") Y.dirty();
        K.add(V.value);
      }
      return { status: Y.value, value: K };
    }
    let $ = [...Q.data.values()].map((B, K) =>
      J._parse(new x8(Q, B, Q.path, K))
    );
    if (Q.common.async) return Promise.all($).then((B) => U(B));
    else return U($);
  }
  min(X, Y) {
    return new I9({
      ...this._def,
      minSize: { value: X, message: h0.toString(Y) },
    });
  }
  max(X, Y) {
    return new I9({
      ...this._def,
      maxSize: { value: X, message: h0.toString(Y) },
    });
  }
  size(X, Y) {
    return this.min(X, Y).max(X, Y);
  }
  nonempty(X) {
    return this.min(1, X);
  }
}
I9.create = (X, Y) => {
  return new I9({
    valueType: X,
    minSize: null,
    maxSize: null,
    typeName: o0.ZodSet,
    ...U1(Y),
  });
};
class xX extends q1 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X);
    if (Y.parsedType !== C0.function)
      return (
        b0(Y, {
          code: E0.invalid_type,
          expected: C0.function,
          received: Y.parsedType,
        }),
        n0
      );
    function Q($, B) {
      return OY({
        data: $,
        path: Y.path,
        errorMaps: [
          Y.common.contextualErrorMap,
          Y.schemaErrorMap,
          yX(),
          e6,
        ].filter((K) => !!K),
        issueData: { code: E0.invalid_arguments, argumentsError: B },
      });
    }
    function G($, B) {
      return OY({
        data: $,
        path: Y.path,
        errorMaps: [
          Y.common.contextualErrorMap,
          Y.schemaErrorMap,
          yX(),
          e6,
        ].filter((K) => !!K),
        issueData: { code: E0.invalid_return_type, returnTypeError: B },
      });
    }
    let J = { errorMap: Y.common.contextualErrorMap },
      U = Y.data;
    if (this._def.returns instanceof P9) {
      let $ = this;
      return e5(async function (...B) {
        let K = new t5([]),
          V = await $._def.args.parseAsync(B, J).catch((H) => {
            throw (K.addIssue(Q(B, H)), K);
          }),
          W = await Reflect.apply(U, this, V);
        return await $._def.returns._def.type.parseAsync(W, J).catch((H) => {
          throw (K.addIssue(G(W, H)), K);
        });
      });
    } else {
      let $ = this;
      return e5(function (...B) {
        let K = $._def.args.safeParse(B, J);
        if (!K.success) throw new t5([Q(B, K.error)]);
        let V = Reflect.apply(U, this, K.data),
          W = $._def.returns.safeParse(V, J);
        if (!W.success) throw new t5([G(V, W.error)]);
        return W.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...X) {
    return new xX({ ...this._def, args: W6.create(X).rest(S4.create()) });
  }
  returns(X) {
    return new xX({ ...this._def, returns: X });
  }
  implement(X) {
    return this.parse(X);
  }
  strictImplement(X) {
    return this.parse(X);
  }
  static create(X, Y, Q) {
    return new xX({
      args: X ? X : W6.create([]).rest(S4.create()),
      returns: Y || S4.create(),
      typeName: o0.ZodFunction,
      ...U1(Q),
    });
  }
}
class cX extends q1 {
  get schema() {
    return this._def.getter();
  }
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X);
    return this._def.getter()._parse({ data: Y.data, path: Y.path, parent: Y });
  }
}
cX.create = (X, Y) => {
  return new cX({ getter: X, typeName: o0.ZodLazy, ...U1(Y) });
};
class dX extends q1 {
  _parse(X) {
    if (X.data !== this._def.value) {
      let Y = this._getOrReturnCtx(X);
      return (
        b0(Y, {
          received: Y.data,
          code: E0.invalid_literal,
          expected: this._def.value,
        }),
        n0
      );
    }
    return { status: "valid", value: X.data };
  }
  get value() {
    return this._def.value;
  }
}
dX.create = (X, Y) => {
  return new dX({ value: X, typeName: o0.ZodLiteral, ...U1(Y) });
};
function Jz(X, Y) {
  return new v4({ values: X, typeName: o0.ZodEnum, ...U1(Y) });
}
class v4 extends q1 {
  _parse(X) {
    if (typeof X.data !== "string") {
      let Y = this._getOrReturnCtx(X),
        Q = this._def.values;
      return (
        b0(Y, {
          expected: C1.joinValues(Q),
          received: Y.parsedType,
          code: E0.invalid_type,
        }),
        n0
      );
    }
    if (!this._cache) this._cache = new Set(this._def.values);
    if (!this._cache.has(X.data)) {
      let Y = this._getOrReturnCtx(X),
        Q = this._def.values;
      return (
        b0(Y, { received: Y.data, code: E0.invalid_enum_value, options: Q }),
        n0
      );
    }
    return e5(X.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let X = {};
    for (let Y of this._def.values) X[Y] = Y;
    return X;
  }
  get Values() {
    let X = {};
    for (let Y of this._def.values) X[Y] = Y;
    return X;
  }
  get Enum() {
    let X = {};
    for (let Y of this._def.values) X[Y] = Y;
    return X;
  }
  extract(X, Y = this._def) {
    return v4.create(X, { ...this._def, ...Y });
  }
  exclude(X, Y = this._def) {
    return v4.create(
      this.options.filter((Q) => !X.includes(Q)),
      { ...this._def, ...Y }
    );
  }
}
v4.create = Jz;
class pX extends q1 {
  _parse(X) {
    let Y = C1.getValidEnumValues(this._def.values),
      Q = this._getOrReturnCtx(X);
    if (Q.parsedType !== C0.string && Q.parsedType !== C0.number) {
      let G = C1.objectValues(Y);
      return (
        b0(Q, {
          expected: C1.joinValues(G),
          received: Q.parsedType,
          code: E0.invalid_type,
        }),
        n0
      );
    }
    if (!this._cache)
      this._cache = new Set(C1.getValidEnumValues(this._def.values));
    if (!this._cache.has(X.data)) {
      let G = C1.objectValues(Y);
      return (
        b0(Q, { received: Q.data, code: E0.invalid_enum_value, options: G }),
        n0
      );
    }
    return e5(X.data);
  }
  get enum() {
    return this._def.values;
  }
}
pX.create = (X, Y) => {
  return new pX({ values: X, typeName: o0.ZodNativeEnum, ...U1(Y) });
};
class P9 extends q1 {
  unwrap() {
    return this._def.type;
  }
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X);
    if (Y.parsedType !== C0.promise && Y.common.async === !1)
      return (
        b0(Y, {
          code: E0.invalid_type,
          expected: C0.promise,
          received: Y.parsedType,
        }),
        n0
      );
    let Q = Y.parsedType === C0.promise ? Y.data : Promise.resolve(Y.data);
    return e5(
      Q.then((G) => {
        return this._def.type.parseAsync(G, {
          path: Y.path,
          errorMap: Y.common.contextualErrorMap,
        });
      })
    );
  }
}
P9.create = (X, Y) => {
  return new P9({ type: X, typeName: o0.ZodPromise, ...U1(Y) });
};
class h8 extends q1 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === o0.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X),
      G = this._def.effect || null,
      J = {
        addIssue: (U) => {
          if ((b0(Q, U), U.fatal)) Y.abort();
          else Y.dirty();
        },
        get path() {
          return Q.path;
        },
      };
    if (((J.addIssue = J.addIssue.bind(J)), G.type === "preprocess")) {
      let U = G.transform(Q.data, J);
      if (Q.common.async)
        return Promise.resolve(U).then(async ($) => {
          if (Y.value === "aborted") return n0;
          let B = await this._def.schema._parseAsync({
            data: $,
            path: Q.path,
            parent: Q,
          });
          if (B.status === "aborted") return n0;
          if (B.status === "dirty") return j9(B.value);
          if (Y.value === "dirty") return j9(B.value);
          return B;
        });
      else {
        if (Y.value === "aborted") return n0;
        let $ = this._def.schema._parseSync({
          data: U,
          path: Q.path,
          parent: Q,
        });
        if ($.status === "aborted") return n0;
        if ($.status === "dirty") return j9($.value);
        if (Y.value === "dirty") return j9($.value);
        return $;
      }
    }
    if (G.type === "refinement") {
      let U = ($) => {
        let B = G.refinement($, J);
        if (Q.common.async) return Promise.resolve(B);
        if (B instanceof Promise)
          throw Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return $;
      };
      if (Q.common.async === !1) {
        let $ = this._def.schema._parseSync({
          data: Q.data,
          path: Q.path,
          parent: Q,
        });
        if ($.status === "aborted") return n0;
        if ($.status === "dirty") Y.dirty();
        return (U($.value), { status: Y.value, value: $.value });
      } else
        return this._def.schema
          ._parseAsync({ data: Q.data, path: Q.path, parent: Q })
          .then(($) => {
            if ($.status === "aborted") return n0;
            if ($.status === "dirty") Y.dirty();
            return U($.value).then(() => {
              return { status: Y.value, value: $.value };
            });
          });
    }
    if (G.type === "transform")
      if (Q.common.async === !1) {
        let U = this._def.schema._parseSync({
          data: Q.data,
          path: Q.path,
          parent: Q,
        });
        if (!P4(U)) return n0;
        let $ = G.transform(U.value, J);
        if ($ instanceof Promise)
          throw Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return { status: Y.value, value: $ };
      } else
        return this._def.schema
          ._parseAsync({ data: Q.data, path: Q.path, parent: Q })
          .then((U) => {
            if (!P4(U)) return n0;
            return Promise.resolve(G.transform(U.value, J)).then(($) => ({
              status: Y.value,
              value: $,
            }));
          });
    C1.assertNever(G);
  }
}
h8.create = (X, Y, Q) => {
  return new h8({ schema: X, typeName: o0.ZodEffects, effect: Y, ...U1(Q) });
};
h8.createWithPreprocess = (X, Y, Q) => {
  return new h8({
    schema: Y,
    effect: { type: "preprocess", transform: X },
    typeName: o0.ZodEffects,
    ...U1(Q),
  });
};
class f8 extends q1 {
  _parse(X) {
    if (this._getType(X) === C0.undefined) return e5(void 0);
    return this._def.innerType._parse(X);
  }
  unwrap() {
    return this._def.innerType;
  }
}
f8.create = (X, Y) => {
  return new f8({ innerType: X, typeName: o0.ZodOptional, ...U1(Y) });
};
class Y4 extends q1 {
  _parse(X) {
    if (this._getType(X) === C0.null) return e5(null);
    return this._def.innerType._parse(X);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Y4.create = (X, Y) => {
  return new Y4({ innerType: X, typeName: o0.ZodNullable, ...U1(Y) });
};
class iX extends q1 {
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X),
      Q = Y.data;
    if (Y.parsedType === C0.undefined) Q = this._def.defaultValue();
    return this._def.innerType._parse({ data: Q, path: Y.path, parent: Y });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
iX.create = (X, Y) => {
  return new iX({
    innerType: X,
    typeName: o0.ZodDefault,
    defaultValue: typeof Y.default === "function" ? Y.default : () => Y.default,
    ...U1(Y),
  });
};
class nX extends q1 {
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X),
      Q = { ...Y, common: { ...Y.common, issues: [] } },
      G = this._def.innerType._parse({
        data: Q.data,
        path: Q.path,
        parent: { ...Q },
      });
    if (_X(G))
      return G.then((J) => {
        return {
          status: "valid",
          value:
            J.status === "valid"
              ? J.value
              : this._def.catchValue({
                  get error() {
                    return new t5(Q.common.issues);
                  },
                  input: Q.data,
                }),
        };
      });
    else
      return {
        status: "valid",
        value:
          G.status === "valid"
            ? G.value
            : this._def.catchValue({
                get error() {
                  return new t5(Q.common.issues);
                },
                input: Q.data,
              }),
      };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
nX.create = (X, Y) => {
  return new nX({
    innerType: X,
    typeName: o0.ZodCatch,
    catchValue: typeof Y.catch === "function" ? Y.catch : () => Y.catch,
    ...U1(Y),
  });
};
class IY extends q1 {
  _parse(X) {
    if (this._getType(X) !== C0.nan) {
      let Q = this._getOrReturnCtx(X);
      return (
        b0(Q, {
          code: E0.invalid_type,
          expected: C0.nan,
          received: Q.parsedType,
        }),
        n0
      );
    }
    return { status: "valid", value: X.data };
  }
}
IY.create = (X) => {
  return new IY({ typeName: o0.ZodNaN, ...U1(X) });
};
var Sy = Symbol("zod_brand");
class PG extends q1 {
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X),
      Q = Y.data;
    return this._def.type._parse({ data: Q, path: Y.path, parent: Y });
  }
  unwrap() {
    return this._def.type;
  }
}
class PY extends q1 {
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X);
    if (Q.common.async)
      return (async () => {
        let J = await this._def.in._parseAsync({
          data: Q.data,
          path: Q.path,
          parent: Q,
        });
        if (J.status === "aborted") return n0;
        if (J.status === "dirty") return (Y.dirty(), j9(J.value));
        else
          return this._def.out._parseAsync({
            data: J.value,
            path: Q.path,
            parent: Q,
          });
      })();
    else {
      let G = this._def.in._parseSync({
        data: Q.data,
        path: Q.path,
        parent: Q,
      });
      if (G.status === "aborted") return n0;
      if (G.status === "dirty")
        return (Y.dirty(), { status: "dirty", value: G.value });
      else
        return this._def.out._parseSync({
          data: G.value,
          path: Q.path,
          parent: Q,
        });
    }
  }
  static create(X, Y) {
    return new PY({ in: X, out: Y, typeName: o0.ZodPipeline });
  }
}
class aX extends q1 {
  _parse(X) {
    let Y = this._def.innerType._parse(X),
      Q = (G) => {
        if (P4(G)) G.value = Object.freeze(G.value);
        return G;
      };
    return _X(Y) ? Y.then((G) => Q(G)) : Q(Y);
  }
  unwrap() {
    return this._def.innerType;
  }
}
aX.create = (X, Y) => {
  return new aX({ innerType: X, typeName: o0.ZodReadonly, ...U1(Y) });
};
function Xz(X, Y) {
  let Q =
    typeof X === "function" ? X(Y) : typeof X === "string" ? { message: X } : X;
  return typeof Q === "string" ? { message: Q } : Q;
}
function Wz(X, Y = {}, Q) {
  if (X)
    return C9.create().superRefine((G, J) => {
      let U = X(G);
      if (U instanceof Promise)
        return U.then(($) => {
          if (!$) {
            let B = Xz(Y, G),
              K = B.fatal ?? Q ?? !0;
            J.addIssue({ code: "custom", ...B, fatal: K });
          }
        });
      if (!U) {
        let $ = Xz(Y, G),
          B = $.fatal ?? Q ?? !0;
        J.addIssue({ code: "custom", ...$, fatal: B });
      }
      return;
    });
  return C9.create();
}
var Ty = { object: B5.lazycreate },
  o0;
(function (X) {
  ((X.ZodString = "ZodString"),
    (X.ZodNumber = "ZodNumber"),
    (X.ZodNaN = "ZodNaN"),
    (X.ZodBigInt = "ZodBigInt"),
    (X.ZodBoolean = "ZodBoolean"),
    (X.ZodDate = "ZodDate"),
    (X.ZodSymbol = "ZodSymbol"),
    (X.ZodUndefined = "ZodUndefined"),
    (X.ZodNull = "ZodNull"),
    (X.ZodAny = "ZodAny"),
    (X.ZodUnknown = "ZodUnknown"),
    (X.ZodNever = "ZodNever"),
    (X.ZodVoid = "ZodVoid"),
    (X.ZodArray = "ZodArray"),
    (X.ZodObject = "ZodObject"),
    (X.ZodUnion = "ZodUnion"),
    (X.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (X.ZodIntersection = "ZodIntersection"),
    (X.ZodTuple = "ZodTuple"),
    (X.ZodRecord = "ZodRecord"),
    (X.ZodMap = "ZodMap"),
    (X.ZodSet = "ZodSet"),
    (X.ZodFunction = "ZodFunction"),
    (X.ZodLazy = "ZodLazy"),
    (X.ZodLiteral = "ZodLiteral"),
    (X.ZodEnum = "ZodEnum"),
    (X.ZodEffects = "ZodEffects"),
    (X.ZodNativeEnum = "ZodNativeEnum"),
    (X.ZodOptional = "ZodOptional"),
    (X.ZodNullable = "ZodNullable"),
    (X.ZodDefault = "ZodDefault"),
    (X.ZodCatch = "ZodCatch"),
    (X.ZodPromise = "ZodPromise"),
    (X.ZodBranded = "ZodBranded"),
    (X.ZodPipeline = "ZodPipeline"),
    (X.ZodReadonly = "ZodReadonly"));
})(o0 || (o0 = {}));
var by = (X, Y = { message: `Input not instance of ${X.name}` }) =>
    Wz((Q) => Q instanceof X, Y),
  Hz = y8.create,
  $z = T4.create,
  vy = IY.create,
  ky = b4.create,
  Uz = hX.create,
  yy = w9.create,
  _y = ZY.create,
  fy = gX.create,
  xy = uX.create,
  hy = C9.create,
  gy = S4.create,
  uy = J6.create,
  ly = jY.create,
  my = _8.create,
  cy = B5.create,
  dy = B5.strictCreate,
  py = lX.create,
  iy = IG.create,
  ny = mX.create,
  ay = W6.create,
  ry = wY.create,
  oy = CY.create,
  sy = I9.create,
  ty = xX.create,
  ey = cX.create,
  X_ = dX.create,
  Y_ = v4.create,
  Q_ = pX.create,
  G_ = P9.create,
  J_ = h8.create,
  W_ = f8.create,
  H_ = Y4.create,
  $_ = h8.createWithPreprocess,
  U_ = PY.create,
  L_ = () => Hz().optional(),
  B_ = () => $z().optional(),
  K_ = () => Uz().optional(),
  V_ = {
    string: (X) => y8.create({ ...X, coerce: !0 }),
    number: (X) => T4.create({ ...X, coerce: !0 }),
    boolean: (X) => hX.create({ ...X, coerce: !0 }),
    bigint: (X) => b4.create({ ...X, coerce: !0 }),
    date: (X) => w9.create({ ...X, coerce: !0 }),
  };
var F_ = n0;
var N1 = {
  VALIDATION_ERROR: "VALIDATION_ERROR",
  SESSION_NOT_FOUND: "SESSION_NOT_FOUND",
  WORK_ITEM_NOT_FOUND: "WORK_ITEM_NOT_FOUND",
  PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
  MESSAGE_NOT_FOUND: "MESSAGE_NOT_FOUND",
  SUMMARY_NOT_FOUND: "SUMMARY_NOT_FOUND",
  SESSION_BUSY: "SESSION_BUSY",
  SUMMARIZATION_FAILED: "SUMMARIZATION_FAILED",
  DATABASE_ERROR: "DATABASE_ERROR",
  INTERNAL_ERROR: "INTERNAL_ERROR",
};
class R1 extends Error {
  code;
  status;
  details;
  constructor(X, Y, Q = 500, G) {
    super(Y);
    this.code = X;
    this.status = Q;
    this.details = G;
    this.name = "AppError";
  }
}
function N_(X) {
  return {
    issues: X.errors.map((Y) => ({
      path: Y.path.join("."),
      message: Y.message,
    })),
  };
}
function Lz() {
  return async (X, Y) => {
    try {
      await Y();
    } catch (Q) {
      console.error("Error caught in middleware:", Q);
      let G, J;
      if (Q instanceof R1)
        ((J = Q.status),
          (G = {
            error: { code: Q.code, message: Q.message, details: Q.details },
          }));
      else if (Q instanceof t5)
        ((J = 400),
          (G = {
            error: {
              code: N1.VALIDATION_ERROR,
              message: "Validation failed",
              details: N_(Q),
            },
          }));
      else if (Q instanceof bX)
        ((J = Q.status),
          (G = {
            error: {
              code:
                J === 404
                  ? "NOT_FOUND"
                  : J === 400
                    ? N1.VALIDATION_ERROR
                    : N1.INTERNAL_ERROR,
              message: Q.message,
            },
          }));
      else
        ((J = 500),
          (G = {
            error: {
              code: N1.INTERNAL_ERROR,
              message: Q instanceof Error ? Q.message : "Internal server error",
            },
          }));
      return X.json(G, J);
    }
  };
}
function Bz(X) {
  let Y = {
    error: {
      code: "NOT_FOUND",
      message: `Route ${X.req.method} ${X.req.path} not found`,
    },
  };
  return X.json(Y, 404);
}
var Kz = { debug: 0, info: 1, warn: 2, error: 3 };
function M_(X) {
  if (X >= 500) return `\x1B[31m${X}\x1B[0m`;
  if (X >= 400) return `\x1B[33m${X}\x1B[0m`;
  if (X >= 300) return `\x1B[36m${X}\x1B[0m`;
  return `\x1B[32m${X}\x1B[0m`;
}
function A_(X) {
  return `${{ GET: "\x1B[32m", POST: "\x1B[34m", PUT: "\x1B[33m", PATCH: "\x1B[33m", DELETE: "\x1B[31m" }[X] || "\x1B[0m"}${X}\x1B[0m`;
}
function Vz(X = {}) {
  let { enabled: Y = !0, level: Q = "info", timestamp: G = !0 } = X,
    J = Kz[Q];
  return async (U, $) => {
    if (!Y || Kz.info < J) {
      await $();
      return;
    }
    let B = Date.now(),
      K = U.req.method,
      V = U.req.path;
    await $();
    let W = Date.now() - B,
      L = U.res.status,
      H = G ? `[${new Date().toISOString()}] ` : "",
      F = A_(K),
      N = M_(L);
    console.log(`${H}${F} ${V} ${N} ${W}ms`);
  };
}
var q_ = /^[\w!#$%&'*.^`|~+-]+$/,
  R_ = /^[ !#-:<-[\]-~]*$/,
  UU = (X, Y) => {
    if (Y && X.indexOf(Y) === -1) return {};
    let Q = X.trim().split(";"),
      G = {};
    for (let J of Q) {
      J = J.trim();
      let U = J.indexOf("=");
      if (U === -1) continue;
      let $ = J.substring(0, U).trim();
      if ((Y && Y !== $) || !q_.test($)) continue;
      let B = J.substring(U + 1).trim();
      if (B.startsWith('"') && B.endsWith('"')) B = B.slice(1, -1);
      if (R_.test(B)) {
        if (((G[$] = B.indexOf("%") !== -1 ? vX(B, qY) : B), Y)) break;
      }
    }
    return G;
  };
var Fz = (X, Y, Q) => {
  let G = X.req.raw.headers.get("Cookie");
  if (typeof Y === "string") {
    if (!G) return;
    let U = Y;
    if (Q === "secure") U = "__Secure-" + Y;
    else if (Q === "host") U = "__Host-" + Y;
    return UU(G, U)[U];
  }
  if (!G) return {};
  return UU(G);
};
var Nz = (X, Y) => {
  return new Response(X, { headers: { "Content-Type": Y } }).formData();
};
var D_ = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/,
  z_ = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/,
  E_ = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/,
  LU = (X, Y) => {
    return async (Q, G) => {
      let J = {},
        U = Q.req.header("Content-Type");
      switch (X) {
        case "json":
          if (!U || !D_.test(U)) break;
          try {
            J = await Q.req.json();
          } catch {
            throw new bX(400, { message: "Malformed JSON in request body" });
          }
          break;
        case "form": {
          if (!U || !(z_.test(U) || E_.test(U))) break;
          let B;
          if (Q.req.bodyCache.formData) B = await Q.req.bodyCache.formData;
          else
            try {
              let V = await Q.req.arrayBuffer();
              ((B = await Nz(V, U)), (Q.req.bodyCache.formData = B));
            } catch (V) {
              let W = "Malformed FormData request.";
              throw (
                (W += V instanceof Error ? ` ${V.message}` : ` ${String(V)}`),
                new bX(400, { message: W })
              );
            }
          let K = {};
          (B.forEach((V, W) => {
            if (W.endsWith("[]")) (K[W] ??= []).push(V);
            else if (Array.isArray(K[W])) K[W].push(V);
            else if (W in K) K[W] = [K[W], V];
            else K[W] = V;
          }),
            (J = K));
          break;
        }
        case "query":
          J = Object.fromEntries(
            Object.entries(Q.req.queries()).map(([B, K]) => {
              return K.length === 1 ? [B, K[0]] : [B, K];
            })
          );
          break;
        case "param":
          J = Q.req.param();
          break;
        case "header":
          J = Q.req.header();
          break;
        case "cookie":
          J = Fz(Q);
          break;
      }
      let $ = await Y(J, Q);
      if ($ instanceof Response) return $;
      return (Q.req.addValidatedData(X, $), await G());
    };
  };
function O_(X, Y, Q, G) {
  return LU(X, async (J, U) => {
    let $ = J;
    if ((X === "header" && "_def" in Y) || (X === "header" && "_zod" in Y)) {
      let K = Object.keys("in" in Y ? Y.in.shape : Y.shape),
        V = Object.fromEntries(K.map((W) => [W.toLowerCase(), W]));
      $ = Object.fromEntries(Object.entries(J).map(([W, L]) => [V[W] || W, L]));
    }
    let B =
      G && G.validationFunction
        ? await G.validationFunction(Y, $)
        : await Y.safeParseAsync($);
    if (Q) {
      let K = await Q({ data: $, ...B, target: X }, U);
      if (K) {
        if (K instanceof Response) return K;
        if ("response" in K) return K.response;
      }
    }
    if (!B.success) return U.json(B, 400);
    return B.data;
  });
}
var s0 = O_;
var S9 = X0.object({
    page: X0.coerce.number().int().positive().default(1),
    limit: X0.coerce.number().int().positive().max(100).default(20),
  }),
  Mz = X0.object({
    name: X0.string().min(1).max(255),
    workingDir: X0.string().min(1),
    task: X0.string().optional(),
    workItemId: X0.string().optional(),
    projectId: X0.string().optional(),
    continueChat: X0.boolean().default(!1),
    dangerouslySkipPermissions: X0.boolean().default(!1),
    enableContextInjection: X0.boolean().default(!0),
  }),
  Az = X0.object({
    name: X0.string().min(1).max(255).optional(),
    task: X0.string().optional(),
    status: X0.enum(["idle", "processing", "completed", "error"]).optional(),
    workItemId: X0.string().nullable().optional(),
    projectId: X0.string().nullable().optional(),
    error: X0.string().nullable().optional(),
  }),
  BU = S9.extend({
    status: X0.enum(["idle", "processing", "completed", "error"]).optional(),
    projectId: X0.string().optional(),
    workItemId: X0.string().optional(),
    includeDeleted: X0.coerce.boolean().default(!1),
  }),
  qz = X0.object({ message: X0.string().min(1) }),
  Rz = X0.object({
    sessionIds: X0.array(X0.string())
      .min(1, "At least 1 session ID is required")
      .max(100, "Cannot delete more than 100 sessions at once"),
  }),
  _Q0 = X0.object({ content: X0.string().min(1) }),
  fQ0 = S9.extend({
    type: X0.enum([
      "user",
      "assistant",
      "system",
      "tool_use",
      "tool_result",
      "thinking",
      "error",
    ]).optional(),
    from: X0.coerce.date().optional(),
    to: X0.coerce.date().optional(),
  }),
  xQ0 = X0.object({
    q: X0.string().min(1),
    limit: X0.coerce.number().int().positive().max(50).default(10),
    projectId: X0.string().optional(),
    from: X0.coerce.date().optional(),
    to: X0.coerce.date().optional(),
  }),
  Dz = S9,
  hQ0 = X0.object({
    name: X0.string().min(1).max(255),
    description: X0.string().optional(),
    status: X0.enum([
      "planning",
      "in_progress",
      "review",
      "completed",
      "blocked",
    ]).default("planning"),
    projectId: X0.string().optional(),
    tags: X0.array(X0.string()).default([]),
    priority: X0.number().int().min(0).max(10).default(0),
  }),
  gQ0 = X0.object({
    name: X0.string().min(1).max(255).optional(),
    description: X0.string().nullable().optional(),
    status: X0.enum([
      "planning",
      "in_progress",
      "review",
      "completed",
      "blocked",
    ]).optional(),
    projectId: X0.string().nullable().optional(),
    tags: X0.array(X0.string()).optional(),
    priority: X0.number().int().min(0).max(10).optional(),
  }),
  uQ0 = S9.extend({
    status: X0.enum([
      "planning",
      "in_progress",
      "review",
      "completed",
      "blocked",
    ]).optional(),
    projectId: X0.string().optional(),
  }),
  zz = X0.object({
    name: X0.string().min(1).max(255),
    path: X0.string().min(1),
    description: X0.string().optional(),
  }),
  Ez = X0.object({
    name: X0.string().min(1).max(255).optional(),
    description: X0.string().nullable().optional(),
  }),
  lQ0 = X0.object({
    event: X0.string(),
    sessionId: X0.string(),
    projectDir: X0.string(),
    timestamp: X0.string(),
    data: X0.record(X0.unknown()),
  }),
  KU = X0.object({
    sourceSessionIds: X0.array(X0.string()).min(
      2,
      "At least 2 sessions are required for merge"
    ),
    projectId: X0.string().optional(),
  }),
  Oz = S9.extend({
    status: X0.enum(["pending", "processing", "completed", "error"]).optional(),
    projectId: X0.string().optional(),
  }),
  Zz = X0.object({
    sourceSessionId: X0.string().min(1, "Source session ID is required"),
    targetClaudeSessionId: X0.string().min(
      1,
      "Target Claude session ID is required"
    ),
  }),
  rX = X0.object({
    projectPath: X0.string().optional(),
    source: X0.enum(["global", "project", "plugin", "all"]).default("all"),
  });
var Z_ = {
  SESSION: "ch_ss",
  MERGE: "ch_mg",
  PROJECT: "ch_pj",
  OBSERVATION: "ch_ob",
  EDGE: "ch_ed",
};
function k4(X, Y) {
  let Q = Z_[X];
  if (!Q) throw Error(`Invalid entity type: ${X}`);
  if (Y < 1 || Y > 9999)
    throw Error("Sequence number must be between 1 and 9999");
  let G = String(Y).padStart(4, "0");
  return `${Q}_${G}`;
}
import { Database as gz } from "bun:sqlite";
function j_(X) {
  X.exec(`
    CREATE TABLE IF NOT EXISTS migrations (
      version INTEGER PRIMARY KEY,
      name TEXT NOT NULL,
      applied_at TEXT NOT NULL DEFAULT (datetime('now'))
    )
  `);
}
function w_(X) {
  return X.prepare("SELECT version FROM migrations ORDER BY version")
    .all()
    .map((Q) => Q.version);
}
function jz(X) {
  let Y = P8();
  j_(Y);
  let Q = new Set(w_(Y)),
    G = [...X].sort((J, U) => J.version - U.version);
  for (let J of G) {
    if (Q.has(J.version)) continue;
    console.log(`Applying migration ${J.version}: ${J.name}`);
    try {
      (Y.exec("BEGIN TRANSACTION"),
        J.up(Y),
        Y.prepare("INSERT INTO migrations (version, name) VALUES (?, ?)").run(
          J.version,
          J.name
        ),
        Y.exec("COMMIT"),
        console.log(`Migration ${J.version} applied successfully`));
    } catch (U) {
      throw (
        Y.exec("ROLLBACK"),
        Error(
          `Migration ${J.version} failed: ${U instanceof Error ? U.message : String(U)}`
        )
      );
    }
  }
}
var wz = {
  version: 1,
  name: "initial_schema",
  up(X) {
    (X.exec(`
      CREATE TABLE projects (
        project_id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        path TEXT NOT NULL UNIQUE,
        description TEXT,
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        updated_at TEXT NOT NULL DEFAULT (datetime('now'))
      )
    `),
      X.exec(`
      CREATE INDEX idx_projects_path ON projects(path)
    `),
      X.exec(`
      CREATE TABLE work_items (
        work_item_id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        status TEXT NOT NULL DEFAULT 'planning'
          CHECK (status IN ('planning', 'in_progress', 'review', 'completed', 'blocked')),
        project_id TEXT REFERENCES projects(project_id) ON DELETE SET NULL,
        tags TEXT DEFAULT '[]',
        priority INTEGER DEFAULT 0,
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        updated_at TEXT NOT NULL DEFAULT (datetime('now'))
      )
    `),
      X.exec(`
      CREATE INDEX idx_work_items_project ON work_items(project_id)
    `),
      X.exec(`
      CREATE INDEX idx_work_items_status ON work_items(status)
    `));
  },
  down(X) {
    (X.exec("DROP TABLE IF EXISTS work_items"),
      X.exec("DROP TABLE IF EXISTS projects"));
  },
};
var Cz = {
  version: 2,
  name: "create_sessions_messages",
  up(X) {
    (X.exec(`
      CREATE TABLE sessions (
        session_id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        working_dir TEXT NOT NULL,
        task TEXT,
        status TEXT NOT NULL DEFAULT 'idle'
          CHECK (status IN ('idle', 'processing', 'completed', 'error')),
        claude_session_id TEXT,
        work_item_id TEXT REFERENCES work_items(work_item_id) ON DELETE SET NULL,
        project_id TEXT REFERENCES projects(project_id) ON DELETE SET NULL,
        continue_chat INTEGER DEFAULT 0,
        dangerously_skip_permissions INTEGER DEFAULT 0,
        error TEXT,
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        updated_at TEXT NOT NULL DEFAULT (datetime('now')),
        deleted_at TEXT
      )
    `),
      X.exec(`
      CREATE INDEX idx_sessions_status ON sessions(status)
    `),
      X.exec(`
      CREATE INDEX idx_sessions_work_item ON sessions(work_item_id)
    `),
      X.exec(`
      CREATE INDEX idx_sessions_project ON sessions(project_id)
    `),
      X.exec(`
      CREATE INDEX idx_sessions_created ON sessions(created_at)
    `),
      X.exec(`
      CREATE TABLE messages (
        message_id TEXT PRIMARY KEY,
        session_id TEXT NOT NULL REFERENCES sessions(session_id) ON DELETE CASCADE,
        type TEXT NOT NULL
          CHECK (type IN ('user', 'assistant', 'system', 'tool_use', 'tool_result', 'thinking', 'error')),
        content TEXT NOT NULL,
        compressed INTEGER DEFAULT 0,
        original_size INTEGER,
        compressed_size INTEGER,
        metadata TEXT,
        timestamp TEXT NOT NULL DEFAULT (datetime('now'))
      )
    `),
      X.exec(`
      CREATE INDEX idx_messages_session ON messages(session_id)
    `),
      X.exec(`
      CREATE INDEX idx_messages_timestamp ON messages(timestamp)
    `),
      X.exec(`
      CREATE INDEX idx_messages_type ON messages(type)
    `));
  },
  down(X) {
    (X.exec("DROP TABLE IF EXISTS messages"),
      X.exec("DROP TABLE IF EXISTS sessions"));
  },
};
var Iz = {
  version: 3,
  name: "create_summaries",
  up(X) {
    (X.exec(`
      CREATE TABLE summaries (
        summary_id TEXT PRIMARY KEY,
        session_id TEXT NOT NULL UNIQUE,
        short_summary TEXT NOT NULL,
        detailed_summary TEXT NOT NULL,
        key_decisions TEXT NOT NULL DEFAULT '[]',
        files_modified TEXT NOT NULL DEFAULT '[]',
        tools_used TEXT NOT NULL DEFAULT '[]',
        topics TEXT NOT NULL DEFAULT '[]',
        original_token_count INTEGER NOT NULL DEFAULT 0,
        summary_token_count INTEGER NOT NULL DEFAULT 0,
        compression_ratio REAL NOT NULL DEFAULT 0.0,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        FOREIGN KEY (session_id) REFERENCES sessions(session_id) ON DELETE CASCADE
      )
    `),
      X.exec(`
      CREATE UNIQUE INDEX idx_summaries_session_id ON summaries(session_id)
    `),
      X.exec(`
      CREATE INDEX idx_summaries_created_at ON summaries(created_at)
    `));
  },
  down(X) {
    X.exec("DROP TABLE IF EXISTS summaries");
  },
};
function y_(X) {
  try {
    return (TG().load(X), !0);
  } catch {
    return (
      console.warn(
        "[Migration 4] sqlite-vec extension not available. Vector search disabled."
      ),
      !1
    );
  }
}
var bz = {
  version: 4,
  name: "create_embeddings",
  up(X) {
    if (y_(X))
      X.exec(`
        CREATE VIRTUAL TABLE IF NOT EXISTS vec_embeddings USING vec0(
          embedding float[1024]
        )
      `);
    (X.exec(`
      CREATE TABLE IF NOT EXISTS embedding_index (
        embedding_id INTEGER PRIMARY KEY,
        source_type TEXT NOT NULL CHECK (source_type IN ('summary', 'message', 'work_item')),
        source_id TEXT NOT NULL,
        session_id TEXT REFERENCES sessions(session_id) ON DELETE CASCADE,
        content_preview TEXT,
        created_at TEXT NOT NULL DEFAULT (datetime('now'))
      )
    `),
      X.exec(`
      CREATE INDEX IF NOT EXISTS idx_embedding_source
      ON embedding_index(source_type, source_id)
    `),
      X.exec(`
      CREATE INDEX IF NOT EXISTS idx_embedding_session
      ON embedding_index(session_id)
    `));
  },
  down(X) {
    X.exec("DROP TABLE IF EXISTS embedding_index");
    try {
      X.exec("DROP TABLE IF EXISTS vec_embeddings");
    } catch {}
  },
};
var vz = {
  version: 5,
  name: "add_extended_summary_fields",
  up(X) {
    (X.exec(`
      ALTER TABLE summaries ADD COLUMN changes TEXT NOT NULL DEFAULT '[]'
    `),
      X.exec(`
      ALTER TABLE summaries ADD COLUMN errors TEXT NOT NULL DEFAULT '[]'
    `),
      X.exec(`
      ALTER TABLE summaries ADD COLUMN decisions TEXT NOT NULL DEFAULT '[]'
    `));
  },
  down(X) {
    console.warn(
      "Migration 005 down: SQLite does not support DROP COLUMN. Skipping."
    );
  },
};
var kz = {
  version: 6,
  name: "create_merges",
  up(X) {
    (X.exec(`
      CREATE TABLE merges (
        merge_id TEXT PRIMARY KEY,
        source_session_ids TEXT NOT NULL,
        result_summary TEXT NOT NULL DEFAULT '',
        result_detailed_summary TEXT,
        status TEXT NOT NULL DEFAULT 'pending' CHECK(status IN ('pending', 'processing', 'completed', 'error')),
        project_id TEXT,
        error TEXT,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL,
        FOREIGN KEY (project_id) REFERENCES projects(project_id) ON DELETE SET NULL
      )
    `),
      X.exec(`
      CREATE INDEX idx_merges_status ON merges(status)
    `),
      X.exec(`
      CREATE INDEX idx_merges_project_id ON merges(project_id)
    `),
      X.exec(`
      CREATE INDEX idx_merges_created_at ON merges(created_at)
    `),
      X.exec(`
      CREATE TABLE merge_sessions (
        merge_id TEXT NOT NULL,
        session_id TEXT NOT NULL,
        display_order INTEGER NOT NULL DEFAULT 0,
        PRIMARY KEY (merge_id, session_id),
        FOREIGN KEY (merge_id) REFERENCES merges(merge_id) ON DELETE CASCADE,
        FOREIGN KEY (session_id) REFERENCES sessions(session_id) ON DELETE CASCADE
      )
    `),
      X.exec(`
      CREATE INDEX idx_merge_sessions_session_id ON merge_sessions(session_id)
    `));
  },
  down(X) {
    (X.exec("DROP TABLE IF EXISTS merge_sessions"),
      X.exec("DROP TABLE IF EXISTS merges"));
  },
};
var yz = {
  version: 7,
  name: "create_observations",
  up(X) {
    (X.exec(`
      CREATE TABLE IF NOT EXISTS observations (
        observation_id TEXT PRIMARY KEY,
        session_id TEXT NOT NULL REFERENCES sessions(session_id) ON DELETE CASCADE,
        type TEXT NOT NULL CHECK (type IN ('tool_use', 'decision', 'error', 'learning', 'note', 'file_change')),
        title TEXT NOT NULL,
        content TEXT NOT NULL,
        metadata TEXT,
        created_at TEXT NOT NULL
      )
    `),
      X.exec(`
      CREATE INDEX IF NOT EXISTS idx_observations_session ON observations(session_id)
    `),
      X.exec(`
      CREATE INDEX IF NOT EXISTS idx_observations_type ON observations(type)
    `),
      X.exec(`
      CREATE INDEX IF NOT EXISTS idx_observations_created ON observations(created_at)
    `));
  },
  down(X) {
    X.exec("DROP TABLE IF EXISTS observations");
  },
};
function __(X) {
  try {
    return (TG().load(X), !0);
  } catch {
    return (
      console.warn(
        "[Migration 8] sqlite-vec extension not available. Vector search disabled."
      ),
      !1
    );
  }
}
var _z = {
  version: 8,
  name: "add_local_embeddings",
  up(X) {
    if (__(X))
      X.exec(`
        CREATE VIRTUAL TABLE IF NOT EXISTS vec_embeddings_local USING vec0(
          embedding float[384]
        )
      `);
    try {
      X.exec(`
        ALTER TABLE embedding_index ADD COLUMN dimension INTEGER DEFAULT 1024
      `);
    } catch (Q) {
      if (!Q.message?.includes("duplicate column")) throw Q;
    }
    try {
      X.exec(`
        ALTER TABLE embedding_index ADD COLUMN provider TEXT DEFAULT 'voyage'
      `);
    } catch (Q) {
      if (!Q.message?.includes("duplicate column")) throw Q;
    }
  },
  down(X) {
    try {
      X.exec("DROP TABLE IF EXISTS vec_embeddings_local");
    } catch {}
  },
};
var fz = {
  version: 9,
  name: "add_session_edges",
  up(X) {
    (X.exec(`
      CREATE TABLE IF NOT EXISTS session_edges (
        edge_id TEXT PRIMARY KEY,
        source_session_id TEXT NOT NULL,
        target_claude_session_id TEXT NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        FOREIGN KEY (source_session_id) REFERENCES sessions(session_id) ON DELETE CASCADE
      )
    `),
      X.exec(`
      CREATE INDEX IF NOT EXISTS idx_edges_target ON session_edges(target_claude_session_id)
    `),
      X.exec(`
      CREATE INDEX IF NOT EXISTS idx_edges_source ON session_edges(source_session_id)
    `));
  },
  down(X) {
    X.exec("DROP TABLE IF EXISTS session_edges");
  },
};
var xz = {
  version: 10,
  name: "add_token_counts",
  up(X) {
    (X.exec(`
      ALTER TABLE sessions ADD COLUMN input_tokens INTEGER DEFAULT 0
    `),
      X.exec(`
      ALTER TABLE sessions ADD COLUMN output_tokens INTEGER DEFAULT 0
    `));
  },
  down(X) {
    console.warn(
      "SQLite does not support dropping columns. Manual migration required."
    );
  },
};
var hz = {
  version: 11,
  name: "add_session_classification",
  up(X) {
    (X.exec(`
      ALTER TABLE sessions ADD COLUMN importance TEXT DEFAULT NULL
    `),
      X.exec(`
      ALTER TABLE sessions ADD COLUMN category TEXT DEFAULT NULL
    `),
      X.exec(`
      ALTER TABLE sessions ADD COLUMN has_issues INTEGER DEFAULT 0
    `),
      X.exec(`
      ALTER TABLE sessions ADD COLUMN issue_type TEXT DEFAULT NULL
    `));
  },
  down(X) {
    console.warn(
      "SQLite does not support dropping columns. Manual migration required."
    );
  },
};
var f_ = process.env.DATABASE_PATH || ":memory:",
  bG = null;
function x_() {
  if (process.platform !== "darwin") return;
  let X = [
    "/opt/homebrew/opt/sqlite/lib/libsqlite3.dylib",
    "/usr/local/opt/sqlite3/lib/libsqlite3.dylib",
    "/usr/local/opt/sqlite/lib/libsqlite3.dylib",
  ];
  for (let Y of X)
    try {
      if (Bun.file(Y).size > 0) {
        (gz.setCustomSQLite(Y), console.log(`[DB] Using custom SQLite: ${Y}`));
        return;
      }
    } catch {}
  console.warn(`[DB] Custom SQLite not found. sqlite-vec may not work on MacOS.
     Install with: brew install sqlite3`);
}
x_();
function P8() {
  if (!bG) ((bG = new gz(f_)), bG.run("PRAGMA journal_mode = WAL"));
  return bG;
}
function X5(X, ...Y) {
  return P8()
    .prepare(X)
    .all(...Y);
}
function b1(X, ...Y) {
  return (
    P8()
      .prepare(X)
      .get(...Y) ?? null
  );
}
function f1(X, ...Y) {
  let J = P8()
    .prepare(X)
    .run(...Y);
  return { changes: J.changes, lastInsertRowid: Number(J.lastInsertRowid) };
}
var h_ = [wz, Cz, Iz, bz, vz, kz, yz, _z, fz, xz, hz];
function uz() {
  (console.log("Running database migrations..."),
    jz(h_),
    console.log("Migrations completed."));
}
import { randomUUID as g_ } from "crypto";
function H6(X) {
  let Y = g_();
  return X ? `${X}-${Y}` : Y;
}
function K5() {
  return new Date().toISOString();
}
function g8(X, Y, Q) {
  let G = Math.ceil(X / Q);
  return {
    page: Y,
    limit: Q,
    total: X,
    totalPages: G,
    hasNext: Y < G,
    hasPrev: Y > 1,
  };
}
function y4(X, Y = ["created_at", "updated_at"]) {
  let Q = {};
  for (let [G, J] of Object.entries(X)) {
    let U = G.replace(/_([a-z])/g, ($, B) => B.toUpperCase());
    if (Y.includes(G) && typeof J === "string") Q[U] = new Date(J);
    else Q[U] = J;
  }
  return Q;
}
function vG(X) {
  return {
    ...y4(X, ["created_at", "updated_at", "deleted_at"]),
    hasIssues: X.has_issues === 1,
  };
}
function u_() {
  return (
    (b1(`SELECT MAX(
      CAST(SUBSTR(session_id, 7) AS INTEGER)
    ) as max_seq
    FROM sessions
    WHERE session_id LIKE 'ch_ss_%'
      AND LENGTH(session_id) = 10`)?.max_seq ?? 0) + 1
  );
}
function T9(X) {
  try {
    let Y = u_(),
      Q = k4("SESSION", Y),
      G = K5();
    return (
      f1(
        `INSERT INTO sessions (
        session_id, name, working_dir, task, status,
        work_item_id, project_id, continue_chat, dangerously_skip_permissions,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, 'idle', ?, ?, ?, ?, ?, ?)`,
        Q,
        X.name,
        X.workingDir,
        X.task ?? null,
        X.workItemId ?? null,
        X.projectId ?? null,
        X.continueChat ? 1 : 0,
        X.dangerouslySkipPermissions ? 1 : 0,
        G,
        G
      ),
      a1(Q)
    );
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to create session: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function u8(X) {
  return a1(X);
}
function a1(X) {
  try {
    if (X.startsWith("ch_ss_")) {
      let Q = b1("SELECT * FROM sessions WHERE session_id = ?", X);
      return Q ? vG(Q) : null;
    }
    let Y = b1("SELECT * FROM sessions WHERE claude_session_id = ?", X);
    return Y ? vG(Y) : null;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to get session: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function oX(X) {
  try {
    let Y = b1("SELECT * FROM sessions WHERE claude_session_id = ?", X);
    return Y ? vG(Y) : null;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to get session by Claude ID: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function SY(X = {}) {
  try {
    let {
        page: Y = 1,
        limit: Q = 20,
        status: G,
        projectId: J,
        workItemId: U,
        includeDeleted: $ = !1,
      } = X,
      B = [],
      K = [];
    if (!$) B.push("deleted_at IS NULL");
    if (G) (B.push("status = ?"), K.push(G));
    if (J) (B.push("project_id = ?"), K.push(J));
    if (U) (B.push("work_item_id = ?"), K.push(U));
    let V = B.length > 0 ? `WHERE ${B.join(" AND ")}` : "",
      L = b1(`SELECT COUNT(*) as count FROM sessions ${V}`, ...K)?.count ?? 0,
      H = (Y - 1) * Q;
    return {
      items: X5(
        `SELECT * FROM sessions ${V} ORDER BY updated_at DESC LIMIT ? OFFSET ?`,
        ...K,
        Q,
        H
      ).map(vG),
      pagination: g8(L, Y, Q),
    };
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to list sessions: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function l8(X, Y) {
  try {
    let Q = a1(X);
    if (!Q) return null;
    let G = Q.sessionId,
      J = [],
      U = [];
    if (Y.name !== void 0) (J.push("name = ?"), U.push(Y.name));
    if (Y.task !== void 0) (J.push("task = ?"), U.push(Y.task));
    if (Y.status !== void 0) (J.push("status = ?"), U.push(Y.status));
    if (Y.claudeSessionId !== void 0)
      (J.push("claude_session_id = ?"), U.push(Y.claudeSessionId));
    if (Y.workItemId !== void 0)
      (J.push("work_item_id = ?"), U.push(Y.workItemId));
    if (Y.projectId !== void 0) (J.push("project_id = ?"), U.push(Y.projectId));
    if (Y.error !== void 0) (J.push("error = ?"), U.push(Y.error));
    if (J.length === 0) return Q;
    return (
      J.push("updated_at = ?"),
      U.push(K5()),
      U.push(G),
      f1(`UPDATE sessions SET ${J.join(", ")} WHERE session_id = ?`, ...U),
      a1(G)
    );
  } catch (Q) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to update session: ${Q instanceof Error ? Q.message : "Unknown error"}`,
      500
    );
  }
}
function FU(X) {
  try {
    let Y = a1(X);
    if (!Y) return !1;
    let Q = Y.sessionId;
    return (
      f1(
        "UPDATE sessions SET deleted_at = ?, updated_at = ? WHERE session_id = ? AND deleted_at IS NULL",
        K5(),
        K5(),
        Q
      ).changes > 0
    );
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to delete session: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function l_(X) {
  return {
    id: X.session_id,
    sessionName: X.name,
    status: X.status,
    tags: [],
    summaryPreview: X.summary_preview || "",
    createdAt: new Date(X.created_at),
    updatedAt: new Date(X.updated_at),
  };
}
function lz(X = {}) {
  try {
    let {
        page: Y = 1,
        limit: Q = 20,
        status: G,
        projectId: J,
        workItemId: U,
      } = X,
      $ = ["s.deleted_at IS NULL"],
      B = [];
    if (G) ($.push("s.status = ?"), B.push(G));
    if (J) ($.push("s.project_id = ?"), B.push(J));
    if (U) ($.push("s.work_item_id = ?"), B.push(U));
    let K = `WHERE ${$.join(" AND ")}`,
      W = b1(`SELECT COUNT(*) as count FROM sessions s ${K}`, ...B)?.count ?? 0,
      L = (Y - 1) * Q,
      H = X5(
        `SELECT
        s.session_id,
        s.name,
        s.status,
        s.created_at,
        s.updated_at,
        COALESCE(SUBSTR(sum.short_summary, 1, 100), '') as summary_preview
      FROM sessions s
      LEFT JOIN summaries sum ON s.session_id = sum.session_id
      ${K}
      ORDER BY s.updated_at DESC
      LIMIT ? OFFSET ?`,
        ...B,
        Q,
        L
      ),
      F = g8(W, Y, Q);
    return {
      sessions: H.map(l_),
      pagination: {
        total: F.total,
        page: F.page,
        totalPages: F.totalPages,
        hasNext: F.hasNext,
        hasPrev: F.hasPrev,
      },
    };
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to list session index: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function m_(X) {
  return {
    summaryId: X.summary_id,
    sessionId: X.session_id,
    shortSummary: X.short_summary,
    detailedSummary: X.detailed_summary,
    keyDecisions: JSON.parse(X.key_decisions || "[]"),
    filesModified: JSON.parse(X.files_modified || "[]"),
    toolsUsed: JSON.parse(X.tools_used || "[]"),
    topics: JSON.parse(X.topics || "[]"),
    originalTokenCount: X.original_token_count,
    summaryTokenCount: X.summary_token_count,
    compressionRatio: X.compression_ratio,
    createdAt: new Date(X.created_at),
    updatedAt: new Date(X.updated_at),
    changes: JSON.parse(X.changes || "[]"),
    errors: JSON.parse(X.errors || "[]"),
    decisions: JSON.parse(X.decisions || "[]"),
  };
}
function mz(X, Y, Q = 30) {
  try {
    let G = [
        "status = 'processing'",
        "deleted_at IS NULL",
        "datetime(updated_at) < datetime('now', '-' || ? || ' minutes')",
      ],
      J = [Q];
    if (X) (G.push("project_id = ?"), J.push(X));
    if (Y) (G.push("session_id != ?"), J.push(Y));
    let U = G.join(" AND "),
      $ = K5();
    return f1(
      `UPDATE sessions SET status = 'completed', updated_at = ? WHERE ${U}`,
      $,
      ...J
    ).changes;
  } catch (G) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to cleanup stale sessions: ${G instanceof Error ? G.message : "Unknown error"}`,
      500
    );
  }
}
function NU(X = 1) {
  try {
    let Y = K5();
    return f1(
      `UPDATE sessions
       SET status = 'completed', updated_at = ?
       WHERE status = 'processing'
         AND deleted_at IS NULL
         AND datetime(updated_at) < datetime('now', '-' || ? || ' hours')`,
      Y,
      X
    ).changes;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to cleanup timed out sessions: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function cz(X) {
  try {
    let Y = a1(X);
    if (!Y) return null;
    let Q = Y.sessionId,
      G = b1("SELECT * FROM summaries WHERE session_id = ?", Q);
    return G ? m_(G) : null;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to get session summary: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function dz(X) {
  try {
    let Y = K5();
    return (
      f1(
        "UPDATE sessions SET updated_at = ? WHERE session_id = ? AND deleted_at IS NULL",
        Y,
        X
      ).changes > 0
    );
  } catch (Y) {
    return (
      console.warn(
        `[Session] Failed to touch session ${X}:`,
        Y instanceof Error ? Y.message : "Unknown error"
      ),
      !1
    );
  }
}
function MU(X, Y) {
  try {
    let Q = a1(X);
    if (!Q) return null;
    let G = Q.sessionId,
      J = K5();
    return (
      f1(
        `UPDATE sessions
       SET input_tokens = ?,
           output_tokens = ?,
           updated_at = ?
       WHERE session_id = ?`,
        Y.inputTokens,
        Y.outputTokens,
        J,
        G
      ),
      a1(G)
    );
  } catch (Q) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to set session tokens: ${Q instanceof Error ? Q.message : "Unknown error"}`,
      500
    );
  }
}
function pz(X, Y) {
  try {
    let Q = a1(X);
    if (!Q) return null;
    let G = Q.sessionId,
      J = [],
      U = [];
    if (Y.importance !== void 0)
      (J.push("importance = ?"), U.push(Y.importance));
    if (Y.category !== void 0) (J.push("category = ?"), U.push(Y.category));
    if (Y.hasIssues !== void 0)
      (J.push("has_issues = ?"), U.push(Y.hasIssues ? 1 : 0));
    if (Y.issueType !== void 0) (J.push("issue_type = ?"), U.push(Y.issueType));
    if (J.length === 0) return Q;
    return (
      J.push("updated_at = ?"),
      U.push(K5()),
      U.push(G),
      f1(`UPDATE sessions SET ${J.join(", ")} WHERE session_id = ?`, ...U),
      a1(G)
    );
  } catch (Q) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to update session classification: ${Q instanceof Error ? Q.message : "Unknown error"}`,
      500
    );
  }
}
function c_(X) {
  if (X.includes(".."))
    throw new R1(N1.VALIDATION_ERROR, "Path cannot contain '..'", 400);
  if (!X || X.trim().length === 0)
    throw new R1(N1.VALIDATION_ERROR, "Path cannot be empty", 400);
  if (!/^[a-zA-Z0-9\-_./~]+$/.test(X))
    throw new R1(N1.VALIDATION_ERROR, "Path contains invalid characters", 400);
}
function d_() {
  let X = b1("SELECT MAX(project_id) as maxId FROM projects"),
    Y = 1;
  if (X?.maxId) {
    let Q = X.maxId.match(/ch_pj_(\d+)/);
    if (Q) Y = parseInt(Q[1], 10) + 1;
  }
  return `ch_pj_${String(Y).padStart(4, "0")}`;
}
function AU(X) {
  return y4(X, ["created_at", "updated_at"]);
}
function yG(X) {
  try {
    if (
      (c_(X.path), b1("SELECT project_id FROM projects WHERE path = ?", X.path))
    )
      throw new R1(
        N1.VALIDATION_ERROR,
        "Project with this path already exists",
        409
      );
    let Q = d_(),
      G = K5(),
      J = X.description ?? null;
    return (
      f1(
        `INSERT INTO projects (
        project_id, name, path, description,
        created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?)`,
        Q,
        X.name,
        X.path,
        J,
        G,
        G
      ),
      {
        projectId: Q,
        name: X.name,
        path: X.path,
        description: J ?? void 0,
        createdAt: new Date(G),
        updatedAt: new Date(G),
      }
    );
  } catch (Y) {
    if (Y instanceof R1) throw Y;
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to create project: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function kG(X) {
  try {
    let Y = b1("SELECT * FROM projects WHERE project_id = ?", X);
    return Y ? AU(Y) : null;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to get project: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function iz(X = {}) {
  try {
    let { page: Y = 1, limit: Q = 20 } = X,
      J = b1("SELECT COUNT(*) as count FROM projects")?.count ?? 0,
      U = (Y - 1) * Q;
    return {
      items: X5(
        "SELECT * FROM projects ORDER BY updated_at DESC LIMIT ? OFFSET ?",
        Q,
        U
      ).map(AU),
      pagination: g8(J, Y, Q),
    };
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to list projects: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function nz(X, Y) {
  try {
    let Q = [],
      G = [];
    if (Y.name !== void 0) (Q.push("name = ?"), G.push(Y.name));
    if (Y.description !== void 0)
      (Q.push("description = ?"), G.push(Y.description));
    if (Q.length === 0) return kG(X);
    if (
      (Q.push("updated_at = ?"),
      G.push(K5()),
      G.push(X),
      f1(`UPDATE projects SET ${Q.join(", ")} WHERE project_id = ?`, ...G)
        .changes === 0)
    )
      return null;
    return kG(X);
  } catch (Q) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to update project: ${Q instanceof Error ? Q.message : "Unknown error"}`,
      500
    );
  }
}
function az(X) {
  try {
    return f1("DELETE FROM projects WHERE project_id = ?", X).changes > 0;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to delete project: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function rz(X) {
  try {
    let Y = b1("SELECT * FROM projects WHERE path = ?", X);
    return Y ? AU(Y) : null;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to get project by path: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function p_(X) {
  return y4(X, ["created_at", "updated_at"]);
}
function qU(X) {
  if (!X) return "";
  return X.length > 1 && X.endsWith("/") ? X.slice(0, -1) : X;
}
function i_(X, Y) {
  let Q = qU(X),
    G = qU(Y);
  if (!Q || !G) return !1;
  if (Q === G) return !0;
  return Q.startsWith(G + "/");
}
function RU(X) {
  if (!X || X.trim() === "") return null;
  let Q = X5("SELECT * FROM projects ORDER BY LENGTH(path) DESC").map(p_);
  for (let G of Q) if (i_(X, G.path)) return G;
  return null;
}
function n_(X) {
  let Y = X.split(/[/\\]/).filter(Boolean);
  return Y[Y.length - 1] || "Unknown Project";
}
function oz(X, Y = {}) {
  let { autoCreate: Q = !0 } = Y;
  if (!X || X.trim() === "") return null;
  let G = RU(X);
  if (G) return G;
  if (!Q) return null;
  let J = qU(X),
    U = rz(J);
  if (U) return U;
  try {
    let $ = n_(X);
    return yG({ name: $, path: J });
  } catch {
    return null;
  }
}
function a_(X) {
  if (!X) return;
  try {
    return JSON.parse(X);
  } catch (Y) {
    console.warn(`[Observation] Invalid JSON in metadata: ${X.slice(0, 100)}`);
    return;
  }
}
function DU(X) {
  return {
    observationId: X.observation_id,
    sessionId: X.session_id,
    type: X.type,
    title: X.title,
    content: X.content,
    metadata: a_(X.metadata),
    createdAt: new Date(X.created_at),
  };
}
function r_() {
  return (
    (b1(`SELECT MAX(
      CAST(SUBSTR(observation_id, 7) AS INTEGER)
    ) as max_seq
    FROM observations
    WHERE observation_id LIKE 'ch_ob_%'
      AND LENGTH(observation_id) = 10`)?.max_seq ?? 0) + 1
  );
}
function Q4(X) {
  try {
    let Y = r_(),
      Q = k4("OBSERVATION", Y),
      G = K5();
    return (
      f1(
        `INSERT INTO observations (
        observation_id, session_id, type, title, content, metadata, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
        Q,
        X.sessionId,
        X.type,
        X.title,
        X.content,
        X.metadata ? JSON.stringify(X.metadata) : null,
        G
      ),
      b9(Q)
    );
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to create observation: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function b9(X) {
  try {
    let Y = b1("SELECT * FROM observations WHERE observation_id = ?", X);
    return Y ? DU(Y) : null;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to get observation: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function v9(X = {}) {
  try {
    let { page: Y = 1, limit: Q = 20, sessionId: G, type: J } = X,
      U = [],
      $ = [];
    if (G) (U.push("session_id = ?"), $.push(G));
    if (J) (U.push("type = ?"), $.push(J));
    let B = U.length > 0 ? `WHERE ${U.join(" AND ")}` : "",
      V =
        b1(`SELECT COUNT(*) as count FROM observations ${B}`, ...$)?.count ?? 0,
      W = (Y - 1) * Q;
    return {
      items: X5(
        `SELECT * FROM observations ${B} ORDER BY created_at DESC LIMIT ? OFFSET ?`,
        ...$,
        Q,
        W
      ).map(DU),
      pagination: g8(V, Y, Q),
    };
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to list observations: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function zU(X, Y = {}) {
  try {
    let { limit: Q = 10, type: G, sessionId: J } = Y,
      U = ["(title LIKE ? OR content LIKE ?)"],
      $ = `%${X}%`,
      B = [$, $];
    if (G) (U.push("type = ?"), B.push(G));
    if (J) (U.push("session_id = ?"), B.push(J));
    let K = `WHERE ${U.join(" AND ")}`;
    return X5(
      `SELECT * FROM observations ${K} ORDER BY created_at DESC LIMIT ?`,
      ...B,
      Q
    ).map(DU);
  } catch (Q) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to search observations: ${Q instanceof Error ? Q.message : "Unknown error"}`,
      500
    );
  }
}
function _G(X) {
  try {
    return (
      f1("DELETE FROM observations WHERE observation_id = ?", X).changes > 0
    );
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to delete observation: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function sz(X) {
  if (!X) return 0;
  let Y = X.match(/[\u3000-\u9fff]/g) || [],
    Q = X.length - Y.length,
    G = Y.length / 1.5,
    J = Q / 4;
  return Math.ceil(G + J);
}
function EU(X) {
  if (X.length === 0) return new Map();
  try {
    let Y = X.map(() => "?").join(","),
      Q = X5(
        `SELECT session_id, title, content FROM observations WHERE session_id IN (${Y})`,
        ...X
      ),
      G = new Map();
    for (let J of X) G.set(J, 0);
    for (let J of Q) {
      let U = G.get(J.session_id) || 0,
        $ = sz(J.title) + sz(J.content);
      G.set(J.session_id, U + $);
    }
    return G;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to get sessions token counts: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
import { join as XE } from "path";
import { fileURLToPath as cx } from "url";
import { setMaxListeners as dx } from "events";
import { spawn as ix } from "child_process";
import { createInterface as nx } from "readline";
import * as i0 from "fs";
import { stat as ax, open as WJ0 } from "fs/promises";
import { join as hg } from "path";
import { homedir as gg } from "os";
import { dirname as IU, join as sE } from "path";
import { cwd as ug } from "process";
import { realpathSync as lg } from "fs";
import { randomUUID as mg } from "crypto";
import { randomUUID as Wu } from "crypto";
import { appendFileSync as Hu, existsSync as $u, mkdirSync as Uu } from "fs";
import { join as $E } from "path";
import { randomUUID as Vu } from "crypto";
var {
    create: o_,
    getPrototypeOf: s_,
    defineProperty: CU,
    getOwnPropertyNames: t_,
  } = Object,
  e_ = Object.prototype.hasOwnProperty,
  vE = (X, Y, Q) => {
    Q = X != null ? o_(s_(X)) : {};
    let G =
      Y || !X || !X.__esModule
        ? CU(Q, "default", { value: X, enumerable: !0 })
        : Q;
    for (let J of t_(X))
      if (!e_.call(G, J)) CU(G, J, { get: () => X[J], enumerable: !0 });
    return G;
  },
  L0 = (X, Y) => () => (Y || X((Y = { exports: {} }).exports, Y), Y.exports),
  kE = (X, Y) => {
    for (var Q in Y)
      CU(X, Q, {
        get: Y[Q],
        enumerable: !0,
        configurable: !0,
        set: (G) => (Y[Q] = () => G),
      });
  };
var lG = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.regexpCode =
        X.getEsmExportName =
        X.getProperty =
        X.safeStringify =
        X.stringify =
        X.strConcat =
        X.addCodeArg =
        X.str =
        X._ =
        X.nil =
        X._Code =
        X.Name =
        X.IDENTIFIER =
        X._CodeOrName =
          void 0));
    class Y {}
    ((X._CodeOrName = Y), (X.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i));
    class Q extends Y {
      constructor(A) {
        super();
        if (!X.IDENTIFIER.test(A))
          throw Error("CodeGen: name must be a valid identifier");
        this.str = A;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    X.Name = Q;
    class G extends Y {
      constructor(A) {
        super();
        this._items = typeof A === "string" ? [A] : A;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1) return !1;
        let A = this._items[0];
        return A === "" || A === '""';
      }
      get str() {
        var A;
        return (A = this._str) !== null && A !== void 0
          ? A
          : (this._str = this._items.reduce((D, R) => `${D}${R}`, ""));
      }
      get names() {
        var A;
        return (A = this._names) !== null && A !== void 0
          ? A
          : (this._names = this._items.reduce((D, R) => {
              if (R instanceof Q) D[R.str] = (D[R.str] || 0) + 1;
              return D;
            }, {}));
      }
    }
    ((X._Code = G), (X.nil = new G("")));
    function J(A, ...D) {
      let R = [A[0]],
        z = 0;
      while (z < D.length) (B(R, D[z]), R.push(A[++z]));
      return new G(R);
    }
    X._ = J;
    var U = new G("+");
    function $(A, ...D) {
      let R = [F(A[0])],
        z = 0;
      while (z < D.length) (R.push(U), B(R, D[z]), R.push(U, F(A[++z])));
      return (K(R), new G(R));
    }
    X.str = $;
    function B(A, D) {
      if (D instanceof G) A.push(...D._items);
      else if (D instanceof Q) A.push(D);
      else A.push(L(D));
    }
    X.addCodeArg = B;
    function K(A) {
      let D = 1;
      while (D < A.length - 1) {
        if (A[D] === U) {
          let R = V(A[D - 1], A[D + 1]);
          if (R !== void 0) {
            A.splice(D - 1, 3, R);
            continue;
          }
          A[D++] = "+";
        }
        D++;
      }
    }
    function V(A, D) {
      if (D === '""') return A;
      if (A === '""') return D;
      if (typeof A == "string") {
        if (D instanceof Q || A[A.length - 1] !== '"') return;
        if (typeof D != "string") return `${A.slice(0, -1)}${D}"`;
        if (D[0] === '"') return A.slice(0, -1) + D.slice(1);
        return;
      }
      if (typeof D == "string" && D[0] === '"' && !(A instanceof Q))
        return `"${A}${D.slice(1)}`;
      return;
    }
    function W(A, D) {
      return D.emptyStr() ? A : A.emptyStr() ? D : $`${A}${D}`;
    }
    X.strConcat = W;
    function L(A) {
      return typeof A == "number" || typeof A == "boolean" || A === null
        ? A
        : F(Array.isArray(A) ? A.join(",") : A);
    }
    function H(A) {
      return new G(F(A));
    }
    X.stringify = H;
    function F(A) {
      return JSON.stringify(A)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
    }
    X.safeStringify = F;
    function N(A) {
      return typeof A == "string" && X.IDENTIFIER.test(A)
        ? new G(`.${A}`)
        : J`[${A}]`;
    }
    X.getProperty = N;
    function q(A) {
      if (typeof A == "string" && X.IDENTIFIER.test(A)) return new G(`${A}`);
      throw Error(
        `CodeGen: invalid export name: ${A}, use explicit $id name mapping`
      );
    }
    X.getEsmExportName = q;
    function M(A) {
      return new G(A.toString());
    }
    X.regexpCode = M;
  }),
  tz = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.ValueScope =
        X.ValueScopeName =
        X.Scope =
        X.varKinds =
        X.UsedValueState =
          void 0));
    var Y = lG();
    class Q extends Error {
      constructor(K) {
        super(`CodeGen: "code" for ${K} not defined`);
        this.value = K.value;
      }
    }
    var G;
    ((function (K) {
      ((K[(K.Started = 0)] = "Started"), (K[(K.Completed = 1)] = "Completed"));
    })(G || (X.UsedValueState = G = {})),
      (X.varKinds = {
        const: new Y.Name("const"),
        let: new Y.Name("let"),
        var: new Y.Name("var"),
      }));
    class J {
      constructor({ prefixes: K, parent: V } = {}) {
        ((this._names = {}), (this._prefixes = K), (this._parent = V));
      }
      toName(K) {
        return K instanceof Y.Name ? K : this.name(K);
      }
      name(K) {
        return new Y.Name(this._newName(K));
      }
      _newName(K) {
        let V = this._names[K] || this._nameGroup(K);
        return `${K}${V.index++}`;
      }
      _nameGroup(K) {
        var V, W;
        if (
          ((W =
            (V = this._parent) === null || V === void 0
              ? void 0
              : V._prefixes) === null || W === void 0
            ? void 0
            : W.has(K)) ||
          (this._prefixes && !this._prefixes.has(K))
        )
          throw Error(`CodeGen: prefix "${K}" is not allowed in this scope`);
        return (this._names[K] = { prefix: K, index: 0 });
      }
    }
    X.Scope = J;
    class U extends Y.Name {
      constructor(K, V) {
        super(V);
        this.prefix = K;
      }
      setValue(K, { property: V, itemIndex: W }) {
        ((this.value = K), (this.scopePath = Y._`.${new Y.Name(V)}[${W}]`));
      }
    }
    X.ValueScopeName = U;
    var $ = Y._`\n`;
    class B extends J {
      constructor(K) {
        super(K);
        ((this._values = {}),
          (this._scope = K.scope),
          (this.opts = { ...K, _n: K.lines ? $ : Y.nil }));
      }
      get() {
        return this._scope;
      }
      name(K) {
        return new U(K, this._newName(K));
      }
      value(K, V) {
        var W;
        if (V.ref === void 0)
          throw Error("CodeGen: ref must be passed in value");
        let L = this.toName(K),
          { prefix: H } = L,
          F = (W = V.key) !== null && W !== void 0 ? W : V.ref,
          N = this._values[H];
        if (N) {
          let A = N.get(F);
          if (A) return A;
        } else N = this._values[H] = new Map();
        N.set(F, L);
        let q = this._scope[H] || (this._scope[H] = []),
          M = q.length;
        return (
          (q[M] = V.ref),
          L.setValue(V, { property: H, itemIndex: M }),
          L
        );
      }
      getValue(K, V) {
        let W = this._values[K];
        if (!W) return;
        return W.get(V);
      }
      scopeRefs(K, V = this._values) {
        return this._reduceValues(V, (W) => {
          if (W.scopePath === void 0)
            throw Error(`CodeGen: name "${W}" has no value`);
          return Y._`${K}${W.scopePath}`;
        });
      }
      scopeCode(K = this._values, V, W) {
        return this._reduceValues(
          K,
          (L) => {
            if (L.value === void 0)
              throw Error(`CodeGen: name "${L}" has no value`);
            return L.value.code;
          },
          V,
          W
        );
      }
      _reduceValues(K, V, W = {}, L) {
        let H = Y.nil;
        for (let F in K) {
          let N = K[F];
          if (!N) continue;
          let q = (W[F] = W[F] || new Map());
          N.forEach((M) => {
            if (q.has(M)) return;
            q.set(M, G.Started);
            let A = V(M);
            if (A) {
              let D = this.opts.es5 ? X.varKinds.var : X.varKinds.const;
              H = Y._`${H}${D} ${M} = ${A};${this.opts._n}`;
            } else if ((A = L === null || L === void 0 ? void 0 : L(M)))
              H = Y._`${H}${A}${this.opts._n}`;
            else throw new Q(M);
            q.set(M, G.Completed);
          });
        }
        return H;
      }
    }
    X.ValueScope = B;
  }),
  I1 = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.or =
        X.and =
        X.not =
        X.CodeGen =
        X.operators =
        X.varKinds =
        X.ValueScopeName =
        X.ValueScope =
        X.Scope =
        X.Name =
        X.regexpCode =
        X.stringify =
        X.getProperty =
        X.nil =
        X.strConcat =
        X.str =
        X._ =
          void 0));
    var Y = lG(),
      Q = tz(),
      G = lG();
    (Object.defineProperty(X, "_", {
      enumerable: !0,
      get: function () {
        return G._;
      },
    }),
      Object.defineProperty(X, "str", {
        enumerable: !0,
        get: function () {
          return G.str;
        },
      }),
      Object.defineProperty(X, "strConcat", {
        enumerable: !0,
        get: function () {
          return G.strConcat;
        },
      }),
      Object.defineProperty(X, "nil", {
        enumerable: !0,
        get: function () {
          return G.nil;
        },
      }),
      Object.defineProperty(X, "getProperty", {
        enumerable: !0,
        get: function () {
          return G.getProperty;
        },
      }),
      Object.defineProperty(X, "stringify", {
        enumerable: !0,
        get: function () {
          return G.stringify;
        },
      }),
      Object.defineProperty(X, "regexpCode", {
        enumerable: !0,
        get: function () {
          return G.regexpCode;
        },
      }),
      Object.defineProperty(X, "Name", {
        enumerable: !0,
        get: function () {
          return G.Name;
        },
      }));
    var J = tz();
    (Object.defineProperty(X, "Scope", {
      enumerable: !0,
      get: function () {
        return J.Scope;
      },
    }),
      Object.defineProperty(X, "ValueScope", {
        enumerable: !0,
        get: function () {
          return J.ValueScope;
        },
      }),
      Object.defineProperty(X, "ValueScopeName", {
        enumerable: !0,
        get: function () {
          return J.ValueScopeName;
        },
      }),
      Object.defineProperty(X, "varKinds", {
        enumerable: !0,
        get: function () {
          return J.varKinds;
        },
      }),
      (X.operators = {
        GT: new Y._Code(">"),
        GTE: new Y._Code(">="),
        LT: new Y._Code("<"),
        LTE: new Y._Code("<="),
        EQ: new Y._Code("==="),
        NEQ: new Y._Code("!=="),
        NOT: new Y._Code("!"),
        OR: new Y._Code("||"),
        AND: new Y._Code("&&"),
        ADD: new Y._Code("+"),
      }));
    class U {
      optimizeNodes() {
        return this;
      }
      optimizeNames(C, v) {
        return this;
      }
    }
    class $ extends U {
      constructor(C, v, k) {
        super();
        ((this.varKind = C), (this.name = v), (this.rhs = k));
      }
      render({ es5: C, _n: v }) {
        let k = C ? Q.varKinds.var : this.varKind,
          o = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${k} ${this.name}${o};` + v;
      }
      optimizeNames(C, v) {
        if (!C[this.name.str]) return;
        if (this.rhs) this.rhs = f(this.rhs, C, v);
        return this;
      }
      get names() {
        return this.rhs instanceof Y._CodeOrName ? this.rhs.names : {};
      }
    }
    class B extends U {
      constructor(C, v, k) {
        super();
        ((this.lhs = C), (this.rhs = v), (this.sideEffects = k));
      }
      render({ _n: C }) {
        return `${this.lhs} = ${this.rhs};` + C;
      }
      optimizeNames(C, v) {
        if (this.lhs instanceof Y.Name && !C[this.lhs.str] && !this.sideEffects)
          return;
        return ((this.rhs = f(this.rhs, C, v)), this);
      }
      get names() {
        let C = this.lhs instanceof Y.Name ? {} : { ...this.lhs.names };
        return _(C, this.rhs);
      }
    }
    class K extends B {
      constructor(C, v, k, o) {
        super(C, k, o);
        this.op = v;
      }
      render({ _n: C }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + C;
      }
    }
    class V extends U {
      constructor(C) {
        super();
        ((this.label = C), (this.names = {}));
      }
      render({ _n: C }) {
        return `${this.label}:` + C;
      }
    }
    class W extends U {
      constructor(C) {
        super();
        ((this.label = C), (this.names = {}));
      }
      render({ _n: C }) {
        return `break${this.label ? ` ${this.label}` : ""};` + C;
      }
    }
    class L extends U {
      constructor(C) {
        super();
        this.error = C;
      }
      render({ _n: C }) {
        return `throw ${this.error};` + C;
      }
      get names() {
        return this.error.names;
      }
    }
    class H extends U {
      constructor(C) {
        super();
        this.code = C;
      }
      render({ _n: C }) {
        return `${this.code};` + C;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(C, v) {
        return ((this.code = f(this.code, C, v)), this);
      }
      get names() {
        return this.code instanceof Y._CodeOrName ? this.code.names : {};
      }
    }
    class F extends U {
      constructor(C = []) {
        super();
        this.nodes = C;
      }
      render(C) {
        return this.nodes.reduce((v, k) => v + k.render(C), "");
      }
      optimizeNodes() {
        let { nodes: C } = this,
          v = C.length;
        while (v--) {
          let k = C[v].optimizeNodes();
          if (Array.isArray(k)) C.splice(v, 1, ...k);
          else if (k) C[v] = k;
          else C.splice(v, 1);
        }
        return C.length > 0 ? this : void 0;
      }
      optimizeNames(C, v) {
        let { nodes: k } = this,
          o = k.length;
        while (o--) {
          let J0 = k[o];
          if (J0.optimizeNames(C, v)) continue;
          (l(C, J0.names), k.splice(o, 1));
        }
        return k.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((C, v) => y(C, v.names), {});
      }
    }
    class N extends F {
      render(C) {
        return "{" + C._n + super.render(C) + "}" + C._n;
      }
    }
    class q extends F {}
    class M extends N {}
    M.kind = "else";
    class A extends N {
      constructor(C, v) {
        super(v);
        this.condition = C;
      }
      render(C) {
        let v = `if(${this.condition})` + super.render(C);
        if (this.else) v += "else " + this.else.render(C);
        return v;
      }
      optimizeNodes() {
        super.optimizeNodes();
        let C = this.condition;
        if (C === !0) return this.nodes;
        let v = this.else;
        if (v) {
          let k = v.optimizeNodes();
          v = this.else = Array.isArray(k) ? new M(k) : k;
        }
        if (v) {
          if (C === !1) return v instanceof A ? v : v.nodes;
          if (this.nodes.length) return this;
          return new A(h(C), v instanceof A ? [v] : v.nodes);
        }
        if (C === !1 || !this.nodes.length) return;
        return this;
      }
      optimizeNames(C, v) {
        var k;
        if (
          ((this.else =
            (k = this.else) === null || k === void 0
              ? void 0
              : k.optimizeNames(C, v)),
          !(super.optimizeNames(C, v) || this.else))
        )
          return;
        return ((this.condition = f(this.condition, C, v)), this);
      }
      get names() {
        let C = super.names;
        if ((_(C, this.condition), this.else)) y(C, this.else.names);
        return C;
      }
    }
    A.kind = "if";
    class D extends N {}
    D.kind = "for";
    class R extends D {
      constructor(C) {
        super();
        this.iteration = C;
      }
      render(C) {
        return `for(${this.iteration})` + super.render(C);
      }
      optimizeNames(C, v) {
        if (!super.optimizeNames(C, v)) return;
        return ((this.iteration = f(this.iteration, C, v)), this);
      }
      get names() {
        return y(super.names, this.iteration.names);
      }
    }
    class z extends D {
      constructor(C, v, k, o) {
        super();
        ((this.varKind = C), (this.name = v), (this.from = k), (this.to = o));
      }
      render(C) {
        let v = C.es5 ? Q.varKinds.var : this.varKind,
          { name: k, from: o, to: J0 } = this;
        return `for(${v} ${k}=${o}; ${k}<${J0}; ${k}++)` + super.render(C);
      }
      get names() {
        let C = _(super.names, this.from);
        return _(C, this.to);
      }
    }
    class E extends D {
      constructor(C, v, k, o) {
        super();
        ((this.loop = C),
          (this.varKind = v),
          (this.name = k),
          (this.iterable = o));
      }
      render(C) {
        return (
          `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
          super.render(C)
        );
      }
      optimizeNames(C, v) {
        if (!super.optimizeNames(C, v)) return;
        return ((this.iterable = f(this.iterable, C, v)), this);
      }
      get names() {
        return y(super.names, this.iterable.names);
      }
    }
    class O extends N {
      constructor(C, v, k) {
        super();
        ((this.name = C), (this.args = v), (this.async = k));
      }
      render(C) {
        return (
          `${this.async ? "async " : ""}function ${this.name}(${this.args})` +
          super.render(C)
        );
      }
    }
    O.kind = "func";
    class Z extends F {
      render(C) {
        return "return " + super.render(C);
      }
    }
    Z.kind = "return";
    class j extends N {
      render(C) {
        let v = "try" + super.render(C);
        if (this.catch) v += this.catch.render(C);
        if (this.finally) v += this.finally.render(C);
        return v;
      }
      optimizeNodes() {
        var C, v;
        return (
          super.optimizeNodes(),
          (C = this.catch) === null || C === void 0 || C.optimizeNodes(),
          (v = this.finally) === null || v === void 0 || v.optimizeNodes(),
          this
        );
      }
      optimizeNames(C, v) {
        var k, o;
        return (
          super.optimizeNames(C, v),
          (k = this.catch) === null || k === void 0 || k.optimizeNames(C, v),
          (o = this.finally) === null || o === void 0 || o.optimizeNames(C, v),
          this
        );
      }
      get names() {
        let C = super.names;
        if (this.catch) y(C, this.catch.names);
        if (this.finally) y(C, this.finally.names);
        return C;
      }
    }
    class w extends N {
      constructor(C) {
        super();
        this.error = C;
      }
      render(C) {
        return `catch(${this.error})` + super.render(C);
      }
    }
    w.kind = "catch";
    class I extends N {
      render(C) {
        return "finally" + super.render(C);
      }
    }
    I.kind = "finally";
    class T {
      constructor(C, v = {}) {
        ((this._values = {}),
          (this._blockStarts = []),
          (this._constants = {}),
          (this.opts = {
            ...v,
            _n: v.lines
              ? `
`
              : "",
          }),
          (this._extScope = C),
          (this._scope = new Q.Scope({ parent: C })),
          (this._nodes = [new q()]));
      }
      toString() {
        return this._root.render(this.opts);
      }
      name(C) {
        return this._scope.name(C);
      }
      scopeName(C) {
        return this._extScope.name(C);
      }
      scopeValue(C, v) {
        let k = this._extScope.value(C, v);
        return (
          (this._values[k.prefix] || (this._values[k.prefix] = new Set())).add(
            k
          ),
          k
        );
      }
      getScopeValue(C, v) {
        return this._extScope.getValue(C, v);
      }
      scopeRefs(C) {
        return this._extScope.scopeRefs(C, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(C, v, k, o) {
        let J0 = this._scope.toName(v);
        if (k !== void 0 && o) this._constants[J0.str] = k;
        return (this._leafNode(new $(C, J0, k)), J0);
      }
      const(C, v, k) {
        return this._def(Q.varKinds.const, C, v, k);
      }
      let(C, v, k) {
        return this._def(Q.varKinds.let, C, v, k);
      }
      var(C, v, k) {
        return this._def(Q.varKinds.var, C, v, k);
      }
      assign(C, v, k) {
        return this._leafNode(new B(C, v, k));
      }
      add(C, v) {
        return this._leafNode(new K(C, X.operators.ADD, v));
      }
      code(C) {
        if (typeof C == "function") C();
        else if (C !== Y.nil) this._leafNode(new H(C));
        return this;
      }
      object(...C) {
        let v = ["{"];
        for (let [k, o] of C) {
          if (v.length > 1) v.push(",");
          if ((v.push(k), k !== o || this.opts.es5))
            (v.push(":"), (0, Y.addCodeArg)(v, o));
        }
        return (v.push("}"), new Y._Code(v));
      }
      if(C, v, k) {
        if ((this._blockNode(new A(C)), v && k))
          this.code(v).else().code(k).endIf();
        else if (v) this.code(v).endIf();
        else if (k) throw Error('CodeGen: "else" body without "then" body');
        return this;
      }
      elseIf(C) {
        return this._elseNode(new A(C));
      }
      else() {
        return this._elseNode(new M());
      }
      endIf() {
        return this._endBlockNode(A, M);
      }
      _for(C, v) {
        if ((this._blockNode(C), v)) this.code(v).endFor();
        return this;
      }
      for(C, v) {
        return this._for(new R(C), v);
      }
      forRange(
        C,
        v,
        k,
        o,
        J0 = this.opts.es5 ? Q.varKinds.var : Q.varKinds.let
      ) {
        let z0 = this._scope.toName(C);
        return this._for(new z(J0, z0, v, k), () => o(z0));
      }
      forOf(C, v, k, o = Q.varKinds.const) {
        let J0 = this._scope.toName(C);
        if (this.opts.es5) {
          let z0 = v instanceof Y.Name ? v : this.var("_arr", v);
          return this.forRange("_i", 0, Y._`${z0}.length`, (A0) => {
            (this.var(J0, Y._`${z0}[${A0}]`), k(J0));
          });
        }
        return this._for(new E("of", o, J0, v), () => k(J0));
      }
      forIn(C, v, k, o = this.opts.es5 ? Q.varKinds.var : Q.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(C, Y._`Object.keys(${v})`, k);
        let J0 = this._scope.toName(C);
        return this._for(new E("in", o, J0, v), () => k(J0));
      }
      endFor() {
        return this._endBlockNode(D);
      }
      label(C) {
        return this._leafNode(new V(C));
      }
      break(C) {
        return this._leafNode(new W(C));
      }
      return(C) {
        let v = new Z();
        if ((this._blockNode(v), this.code(C), v.nodes.length !== 1))
          throw Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Z);
      }
      try(C, v, k) {
        if (!v && !k)
          throw Error('CodeGen: "try" without "catch" and "finally"');
        let o = new j();
        if ((this._blockNode(o), this.code(C), v)) {
          let J0 = this.name("e");
          ((this._currNode = o.catch = new w(J0)), v(J0));
        }
        if (k) ((this._currNode = o.finally = new I()), this.code(k));
        return this._endBlockNode(w, I);
      }
      throw(C) {
        return this._leafNode(new L(C));
      }
      block(C, v) {
        if ((this._blockStarts.push(this._nodes.length), C))
          this.code(C).endBlock(v);
        return this;
      }
      endBlock(C) {
        let v = this._blockStarts.pop();
        if (v === void 0) throw Error("CodeGen: not in self-balancing block");
        let k = this._nodes.length - v;
        if (k < 0 || (C !== void 0 && k !== C))
          throw Error(`CodeGen: wrong number of nodes: ${k} vs ${C} expected`);
        return ((this._nodes.length = v), this);
      }
      func(C, v = Y.nil, k, o) {
        if ((this._blockNode(new O(C, v, k)), o)) this.code(o).endFunc();
        return this;
      }
      endFunc() {
        return this._endBlockNode(O);
      }
      optimize(C = 1) {
        while (C-- > 0)
          (this._root.optimizeNodes(),
            this._root.optimizeNames(this._root.names, this._constants));
      }
      _leafNode(C) {
        return (this._currNode.nodes.push(C), this);
      }
      _blockNode(C) {
        (this._currNode.nodes.push(C), this._nodes.push(C));
      }
      _endBlockNode(C, v) {
        let k = this._currNode;
        if (k instanceof C || (v && k instanceof v))
          return (this._nodes.pop(), this);
        throw Error(
          `CodeGen: not in block "${v ? `${C.kind}/${v.kind}` : C.kind}"`
        );
      }
      _elseNode(C) {
        let v = this._currNode;
        if (!(v instanceof A)) throw Error('CodeGen: "else" without "if"');
        return ((this._currNode = v.else = C), this);
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        let C = this._nodes;
        return C[C.length - 1];
      }
      set _currNode(C) {
        let v = this._nodes;
        v[v.length - 1] = C;
      }
    }
    X.CodeGen = T;
    function y(C, v) {
      for (let k in v) C[k] = (C[k] || 0) + (v[k] || 0);
      return C;
    }
    function _(C, v) {
      return v instanceof Y._CodeOrName ? y(C, v.names) : C;
    }
    function f(C, v, k) {
      if (C instanceof Y.Name) return o(C);
      if (!J0(C)) return C;
      return new Y._Code(
        C._items.reduce((z0, A0) => {
          if (A0 instanceof Y.Name) A0 = o(A0);
          if (A0 instanceof Y._Code) z0.push(...A0._items);
          else z0.push(A0);
          return z0;
        }, [])
      );
      function o(z0) {
        let A0 = k[z0.str];
        if (A0 === void 0 || v[z0.str] !== 1) return z0;
        return (delete v[z0.str], A0);
      }
      function J0(z0) {
        return (
          z0 instanceof Y._Code &&
          z0._items.some(
            (A0) =>
              A0 instanceof Y.Name && v[A0.str] === 1 && k[A0.str] !== void 0
          )
        );
      }
    }
    function l(C, v) {
      for (let k in v) C[k] = (C[k] || 0) - (v[k] || 0);
    }
    function h(C) {
      return typeof C == "boolean" || typeof C == "number" || C === null
        ? !C
        : Y._`!${r(C)}`;
    }
    X.not = h;
    var p = x(X.operators.AND);
    function N0(...C) {
      return C.reduce(p);
    }
    X.and = N0;
    var e = x(X.operators.OR);
    function P(...C) {
      return C.reduce(e);
    }
    X.or = P;
    function x(C) {
      return (v, k) =>
        v === Y.nil ? k : k === Y.nil ? v : Y._`${r(v)} ${C} ${r(k)}`;
    }
    function r(C) {
      return C instanceof Y.Name ? C : Y._`(${C})`;
    }
  }),
  l1 = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.checkStrictMode =
        X.getErrorPath =
        X.Type =
        X.useFunc =
        X.setEvaluated =
        X.evaluatedPropsToName =
        X.mergeEvaluated =
        X.eachItem =
        X.unescapeJsonPointer =
        X.escapeJsonPointer =
        X.escapeFragment =
        X.unescapeFragment =
        X.schemaRefOrVal =
        X.schemaHasRulesButRef =
        X.schemaHasRules =
        X.checkUnknownRules =
        X.alwaysValidSchema =
        X.toHash =
          void 0));
    var Y = I1(),
      Q = lG();
    function G(O) {
      let Z = {};
      for (let j of O) Z[j] = !0;
      return Z;
    }
    X.toHash = G;
    function J(O, Z) {
      if (typeof Z == "boolean") return Z;
      if (Object.keys(Z).length === 0) return !0;
      return (U(O, Z), !$(Z, O.self.RULES.all));
    }
    X.alwaysValidSchema = J;
    function U(O, Z = O.schema) {
      let { opts: j, self: w } = O;
      if (!j.strictSchema) return;
      if (typeof Z === "boolean") return;
      let I = w.RULES.keywords;
      for (let T in Z) if (!I[T]) E(O, `unknown keyword: "${T}"`);
    }
    X.checkUnknownRules = U;
    function $(O, Z) {
      if (typeof O == "boolean") return !O;
      for (let j in O) if (Z[j]) return !0;
      return !1;
    }
    X.schemaHasRules = $;
    function B(O, Z) {
      if (typeof O == "boolean") return !O;
      for (let j in O) if (j !== "$ref" && Z.all[j]) return !0;
      return !1;
    }
    X.schemaHasRulesButRef = B;
    function K({ topSchemaRef: O, schemaPath: Z }, j, w, I) {
      if (!I) {
        if (typeof j == "number" || typeof j == "boolean") return j;
        if (typeof j == "string") return Y._`${j}`;
      }
      return Y._`${O}${Z}${(0, Y.getProperty)(w)}`;
    }
    X.schemaRefOrVal = K;
    function V(O) {
      return H(decodeURIComponent(O));
    }
    X.unescapeFragment = V;
    function W(O) {
      return encodeURIComponent(L(O));
    }
    X.escapeFragment = W;
    function L(O) {
      if (typeof O == "number") return `${O}`;
      return O.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    X.escapeJsonPointer = L;
    function H(O) {
      return O.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    X.unescapeJsonPointer = H;
    function F(O, Z) {
      if (Array.isArray(O)) for (let j of O) Z(j);
      else Z(O);
    }
    X.eachItem = F;
    function N({
      mergeNames: O,
      mergeToName: Z,
      mergeValues: j,
      resultToName: w,
    }) {
      return (I, T, y, _) => {
        let f =
          y === void 0
            ? T
            : y instanceof Y.Name
              ? (T instanceof Y.Name ? O(I, T, y) : Z(I, T, y), y)
              : T instanceof Y.Name
                ? (Z(I, y, T), T)
                : j(T, y);
        return _ === Y.Name && !(f instanceof Y.Name) ? w(I, f) : f;
      };
    }
    X.mergeEvaluated = {
      props: N({
        mergeNames: (O, Z, j) =>
          O.if(Y._`${j} !== true && ${Z} !== undefined`, () => {
            O.if(
              Y._`${Z} === true`,
              () => O.assign(j, !0),
              () =>
                O.assign(j, Y._`${j} || {}`).code(
                  Y._`Object.assign(${j}, ${Z})`
                )
            );
          }),
        mergeToName: (O, Z, j) =>
          O.if(Y._`${j} !== true`, () => {
            if (Z === !0) O.assign(j, !0);
            else (O.assign(j, Y._`${j} || {}`), M(O, j, Z));
          }),
        mergeValues: (O, Z) => (O === !0 ? !0 : { ...O, ...Z }),
        resultToName: q,
      }),
      items: N({
        mergeNames: (O, Z, j) =>
          O.if(Y._`${j} !== true && ${Z} !== undefined`, () =>
            O.assign(j, Y._`${Z} === true ? true : ${j} > ${Z} ? ${j} : ${Z}`)
          ),
        mergeToName: (O, Z, j) =>
          O.if(Y._`${j} !== true`, () =>
            O.assign(j, Z === !0 ? !0 : Y._`${j} > ${Z} ? ${j} : ${Z}`)
          ),
        mergeValues: (O, Z) => (O === !0 ? !0 : Math.max(O, Z)),
        resultToName: (O, Z) => O.var("items", Z),
      }),
    };
    function q(O, Z) {
      if (Z === !0) return O.var("props", !0);
      let j = O.var("props", Y._`{}`);
      if (Z !== void 0) M(O, j, Z);
      return j;
    }
    X.evaluatedPropsToName = q;
    function M(O, Z, j) {
      Object.keys(j).forEach((w) =>
        O.assign(Y._`${Z}${(0, Y.getProperty)(w)}`, !0)
      );
    }
    X.setEvaluated = M;
    var A = {};
    function D(O, Z) {
      return O.scopeValue("func", {
        ref: Z,
        code: A[Z.code] || (A[Z.code] = new Q._Code(Z.code)),
      });
    }
    X.useFunc = D;
    var R;
    (function (O) {
      ((O[(O.Num = 0)] = "Num"), (O[(O.Str = 1)] = "Str"));
    })(R || (X.Type = R = {}));
    function z(O, Z, j) {
      if (O instanceof Y.Name) {
        let w = Z === R.Num;
        return j
          ? w
            ? Y._`"[" + ${O} + "]"`
            : Y._`"['" + ${O} + "']"`
          : w
            ? Y._`"/" + ${O}`
            : Y._`"/" + ${O}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return j ? (0, Y.getProperty)(O).toString() : "/" + L(O);
    }
    X.getErrorPath = z;
    function E(O, Z, j = O.opts.strictSchema) {
      if (!j) return;
      if (((Z = `strict mode: ${Z}`), j === !0)) throw Error(Z);
      O.self.logger.warn(Z);
    }
    X.checkStrictMode = E;
  }),
  g4 = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = {
        data: new Y.Name("data"),
        valCxt: new Y.Name("valCxt"),
        instancePath: new Y.Name("instancePath"),
        parentData: new Y.Name("parentData"),
        parentDataProperty: new Y.Name("parentDataProperty"),
        rootData: new Y.Name("rootData"),
        dynamicAnchors: new Y.Name("dynamicAnchors"),
        vErrors: new Y.Name("vErrors"),
        errors: new Y.Name("errors"),
        this: new Y.Name("this"),
        self: new Y.Name("self"),
        scope: new Y.Name("scope"),
        json: new Y.Name("json"),
        jsonPos: new Y.Name("jsonPos"),
        jsonLen: new Y.Name("jsonLen"),
        jsonPart: new Y.Name("jsonPart"),
      };
    X.default = Q;
  }),
  QJ = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.extendErrors =
        X.resetErrorsCount =
        X.reportExtraError =
        X.reportError =
        X.keyword$DataError =
        X.keywordError =
          void 0));
    var Y = I1(),
      Q = l1(),
      G = g4();
    ((X.keywordError = {
      message: ({ keyword: M }) => Y.str`must pass "${M}" keyword validation`,
    }),
      (X.keyword$DataError = {
        message: ({ keyword: M, schemaType: A }) =>
          A
            ? Y.str`"${M}" keyword must be ${A} ($data)`
            : Y.str`"${M}" keyword is invalid ($data)`,
      }));
    function J(M, A = X.keywordError, D, R) {
      let { it: z } = M,
        { gen: E, compositeRule: O, allErrors: Z } = z,
        j = L(M, A, D);
      if (R !== null && R !== void 0 ? R : O || Z) K(E, j);
      else V(z, Y._`[${j}]`);
    }
    X.reportError = J;
    function U(M, A = X.keywordError, D) {
      let { it: R } = M,
        { gen: z, compositeRule: E, allErrors: O } = R,
        Z = L(M, A, D);
      if ((K(z, Z), !(E || O))) V(R, G.default.vErrors);
    }
    X.reportExtraError = U;
    function $(M, A) {
      (M.assign(G.default.errors, A),
        M.if(Y._`${G.default.vErrors} !== null`, () =>
          M.if(
            A,
            () => M.assign(Y._`${G.default.vErrors}.length`, A),
            () => M.assign(G.default.vErrors, null)
          )
        ));
    }
    X.resetErrorsCount = $;
    function B({
      gen: M,
      keyword: A,
      schemaValue: D,
      data: R,
      errsCount: z,
      it: E,
    }) {
      if (z === void 0) throw Error("ajv implementation error");
      let O = M.name("err");
      M.forRange("i", z, G.default.errors, (Z) => {
        if (
          (M.const(O, Y._`${G.default.vErrors}[${Z}]`),
          M.if(Y._`${O}.instancePath === undefined`, () =>
            M.assign(
              Y._`${O}.instancePath`,
              (0, Y.strConcat)(G.default.instancePath, E.errorPath)
            )
          ),
          M.assign(Y._`${O}.schemaPath`, Y.str`${E.errSchemaPath}/${A}`),
          E.opts.verbose)
        )
          (M.assign(Y._`${O}.schema`, D), M.assign(Y._`${O}.data`, R));
      });
    }
    X.extendErrors = B;
    function K(M, A) {
      let D = M.const("err", A);
      (M.if(
        Y._`${G.default.vErrors} === null`,
        () => M.assign(G.default.vErrors, Y._`[${D}]`),
        Y._`${G.default.vErrors}.push(${D})`
      ),
        M.code(Y._`${G.default.errors}++`));
    }
    function V(M, A) {
      let { gen: D, validateName: R, schemaEnv: z } = M;
      if (z.$async) D.throw(Y._`new ${M.ValidationError}(${A})`);
      else (D.assign(Y._`${R}.errors`, A), D.return(!1));
    }
    var W = {
      keyword: new Y.Name("keyword"),
      schemaPath: new Y.Name("schemaPath"),
      params: new Y.Name("params"),
      propertyName: new Y.Name("propertyName"),
      message: new Y.Name("message"),
      schema: new Y.Name("schema"),
      parentSchema: new Y.Name("parentSchema"),
    };
    function L(M, A, D) {
      let { createErrors: R } = M.it;
      if (R === !1) return Y._`{}`;
      return H(M, A, D);
    }
    function H(M, A, D = {}) {
      let { gen: R, it: z } = M,
        E = [F(z, D), N(M, D)];
      return (q(M, A, E), R.object(...E));
    }
    function F({ errorPath: M }, { instancePath: A }) {
      let D = A ? Y.str`${M}${(0, Q.getErrorPath)(A, Q.Type.Str)}` : M;
      return [
        G.default.instancePath,
        (0, Y.strConcat)(G.default.instancePath, D),
      ];
    }
    function N(
      { keyword: M, it: { errSchemaPath: A } },
      { schemaPath: D, parentSchema: R }
    ) {
      let z = R ? A : Y.str`${A}/${M}`;
      if (D) z = Y.str`${z}${(0, Q.getErrorPath)(D, Q.Type.Str)}`;
      return [W.schemaPath, z];
    }
    function q(M, { params: A, message: D }, R) {
      let { keyword: z, data: E, schemaValue: O, it: Z } = M,
        { opts: j, propertyName: w, topSchemaRef: I, schemaPath: T } = Z;
      if (
        (R.push(
          [W.keyword, z],
          [W.params, typeof A == "function" ? A(M) : A || Y._`{}`]
        ),
        j.messages)
      )
        R.push([W.message, typeof D == "function" ? D(M) : D]);
      if (j.verbose)
        R.push(
          [W.schema, O],
          [W.parentSchema, Y._`${I}${T}`],
          [G.default.data, E]
        );
      if (w) R.push([W.propertyName, w]);
    }
  }),
  Xf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.boolOrEmptySchema = X.topBoolOrEmptySchema = void 0));
    var Y = QJ(),
      Q = I1(),
      G = g4(),
      J = { message: "boolean schema is false" };
    function U(K) {
      let { gen: V, schema: W, validateName: L } = K;
      if (W === !1) B(K, !1);
      else if (typeof W == "object" && W.$async === !0)
        V.return(G.default.data);
      else (V.assign(Q._`${L}.errors`, null), V.return(!0));
    }
    X.topBoolOrEmptySchema = U;
    function $(K, V) {
      let { gen: W, schema: L } = K;
      if (L === !1) (W.var(V, !1), B(K));
      else W.var(V, !0);
    }
    X.boolOrEmptySchema = $;
    function B(K, V) {
      let { gen: W, data: L } = K,
        H = {
          gen: W,
          keyword: "false schema",
          data: L,
          schema: !1,
          schemaCode: !1,
          schemaValue: !1,
          params: {},
          it: K,
        };
      (0, Y.reportError)(H, J, void 0, V);
    }
  }),
  yE = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.getRules = X.isJSONType = void 0));
    var Y = [
        "string",
        "number",
        "integer",
        "boolean",
        "null",
        "object",
        "array",
      ],
      Q = new Set(Y);
    function G(U) {
      return typeof U == "string" && Q.has(U);
    }
    X.isJSONType = G;
    function J() {
      let U = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
      };
      return {
        types: { ...U, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, U.number, U.string, U.array, U.object],
        post: { rules: [] },
        all: {},
        keywords: {},
      };
    }
    X.getRules = J;
  }),
  _E = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.shouldUseRule = X.shouldUseGroup = X.schemaHasRulesForType = void 0));
    function Y({ schema: J, self: U }, $) {
      let B = U.RULES.types[$];
      return B && B !== !0 && Q(J, B);
    }
    X.schemaHasRulesForType = Y;
    function Q(J, U) {
      return U.rules.some(($) => G(J, $));
    }
    X.shouldUseGroup = Q;
    function G(J, U) {
      var $;
      return (
        J[U.keyword] !== void 0 ||
        (($ = U.definition.implements) === null || $ === void 0
          ? void 0
          : $.some((B) => J[B] !== void 0))
      );
    }
    X.shouldUseRule = G;
  }),
  mG = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.reportTypeError =
        X.checkDataTypes =
        X.checkDataType =
        X.coerceAndCheckDataType =
        X.getJSONTypes =
        X.getSchemaTypes =
        X.DataType =
          void 0));
    var Y = yE(),
      Q = _E(),
      G = QJ(),
      J = I1(),
      U = l1(),
      $;
    (function (R) {
      ((R[(R.Correct = 0)] = "Correct"), (R[(R.Wrong = 1)] = "Wrong"));
    })($ || (X.DataType = $ = {}));
    function B(R) {
      let z = K(R.type);
      if (z.includes("null")) {
        if (R.nullable === !1)
          throw Error("type: null contradicts nullable: false");
      } else {
        if (!z.length && R.nullable !== void 0)
          throw Error('"nullable" cannot be used without "type"');
        if (R.nullable === !0) z.push("null");
      }
      return z;
    }
    X.getSchemaTypes = B;
    function K(R) {
      let z = Array.isArray(R) ? R : R ? [R] : [];
      if (z.every(Y.isJSONType)) return z;
      throw Error("type must be JSONType or JSONType[]: " + z.join(","));
    }
    X.getJSONTypes = K;
    function V(R, z) {
      let { gen: E, data: O, opts: Z } = R,
        j = L(z, Z.coerceTypes),
        w =
          z.length > 0 &&
          !(
            j.length === 0 &&
            z.length === 1 &&
            (0, Q.schemaHasRulesForType)(R, z[0])
          );
      if (w) {
        let I = q(z, O, Z.strictNumbers, $.Wrong);
        E.if(I, () => {
          if (j.length) H(R, z, j);
          else A(R);
        });
      }
      return w;
    }
    X.coerceAndCheckDataType = V;
    var W = new Set(["string", "number", "integer", "boolean", "null"]);
    function L(R, z) {
      return z
        ? R.filter((E) => W.has(E) || (z === "array" && E === "array"))
        : [];
    }
    function H(R, z, E) {
      let { gen: O, data: Z, opts: j } = R,
        w = O.let("dataType", J._`typeof ${Z}`),
        I = O.let("coerced", J._`undefined`);
      if (j.coerceTypes === "array")
        O.if(
          J._`${w} == 'object' && Array.isArray(${Z}) && ${Z}.length == 1`,
          () =>
            O.assign(Z, J._`${Z}[0]`)
              .assign(w, J._`typeof ${Z}`)
              .if(q(z, Z, j.strictNumbers), () => O.assign(I, Z))
        );
      O.if(J._`${I} !== undefined`);
      for (let y of E)
        if (W.has(y) || (y === "array" && j.coerceTypes === "array")) T(y);
      (O.else(),
        A(R),
        O.endIf(),
        O.if(J._`${I} !== undefined`, () => {
          (O.assign(Z, I), F(R, I));
        }));
      function T(y) {
        switch (y) {
          case "string":
            O.elseIf(J._`${w} == "number" || ${w} == "boolean"`)
              .assign(I, J._`"" + ${Z}`)
              .elseIf(J._`${Z} === null`)
              .assign(I, J._`""`);
            return;
          case "number":
            O.elseIf(
              J._`${w} == "boolean" || ${Z} === null
              || (${w} == "string" && ${Z} && ${Z} == +${Z})`
            ).assign(I, J._`+${Z}`);
            return;
          case "integer":
            O.elseIf(
              J._`${w} === "boolean" || ${Z} === null
              || (${w} === "string" && ${Z} && ${Z} == +${Z} && !(${Z} % 1))`
            ).assign(I, J._`+${Z}`);
            return;
          case "boolean":
            O.elseIf(J._`${Z} === "false" || ${Z} === 0 || ${Z} === null`)
              .assign(I, !1)
              .elseIf(J._`${Z} === "true" || ${Z} === 1`)
              .assign(I, !0);
            return;
          case "null":
            (O.elseIf(J._`${Z} === "" || ${Z} === 0 || ${Z} === false`),
              O.assign(I, null));
            return;
          case "array":
            O.elseIf(
              J._`${w} === "string" || ${w} === "number"
              || ${w} === "boolean" || ${Z} === null`
            ).assign(I, J._`[${Z}]`);
        }
      }
    }
    function F({ gen: R, parentData: z, parentDataProperty: E }, O) {
      R.if(J._`${z} !== undefined`, () => R.assign(J._`${z}[${E}]`, O));
    }
    function N(R, z, E, O = $.Correct) {
      let Z = O === $.Correct ? J.operators.EQ : J.operators.NEQ,
        j;
      switch (R) {
        case "null":
          return J._`${z} ${Z} null`;
        case "array":
          j = J._`Array.isArray(${z})`;
          break;
        case "object":
          j = J._`${z} && typeof ${z} == "object" && !Array.isArray(${z})`;
          break;
        case "integer":
          j = w(J._`!(${z} % 1) && !isNaN(${z})`);
          break;
        case "number":
          j = w();
          break;
        default:
          return J._`typeof ${z} ${Z} ${R}`;
      }
      return O === $.Correct ? j : (0, J.not)(j);
      function w(I = J.nil) {
        return (0, J.and)(
          J._`typeof ${z} == "number"`,
          I,
          E ? J._`isFinite(${z})` : J.nil
        );
      }
    }
    X.checkDataType = N;
    function q(R, z, E, O) {
      if (R.length === 1) return N(R[0], z, E, O);
      let Z,
        j = (0, U.toHash)(R);
      if (j.array && j.object) {
        let w = J._`typeof ${z} != "object"`;
        ((Z = j.null ? w : J._`!${z} || ${w}`),
          delete j.null,
          delete j.array,
          delete j.object);
      } else Z = J.nil;
      if (j.number) delete j.integer;
      for (let w in j) Z = (0, J.and)(Z, N(w, z, E, O));
      return Z;
    }
    X.checkDataTypes = q;
    var M = {
      message: ({ schema: R }) => `must be ${R}`,
      params: ({ schema: R, schemaValue: z }) =>
        typeof R == "string" ? J._`{type: ${R}}` : J._`{type: ${z}}`,
    };
    function A(R) {
      let z = D(R);
      (0, G.reportError)(z, M);
    }
    X.reportTypeError = A;
    function D(R) {
      let { gen: z, data: E, schema: O } = R,
        Z = (0, U.schemaRefOrVal)(R, O, "type");
      return {
        gen: z,
        keyword: "type",
        data: E,
        schema: O.type,
        schemaCode: Z,
        schemaValue: Z,
        parentSchema: O,
        params: {},
        it: R,
      };
    }
  }),
  Yf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.assignDefaults = void 0));
    var Y = I1(),
      Q = l1();
    function G(U, $) {
      let { properties: B, items: K } = U.schema;
      if ($ === "object" && B) for (let V in B) J(U, V, B[V].default);
      else if ($ === "array" && Array.isArray(K))
        K.forEach((V, W) => J(U, W, V.default));
    }
    X.assignDefaults = G;
    function J(U, $, B) {
      let { gen: K, compositeRule: V, data: W, opts: L } = U;
      if (B === void 0) return;
      let H = Y._`${W}${(0, Y.getProperty)($)}`;
      if (V) {
        (0, Q.checkStrictMode)(U, `default is ignored for: ${H}`);
        return;
      }
      let F = Y._`${H} === undefined`;
      if (L.useDefaults === "empty")
        F = Y._`${F} || ${H} === null || ${H} === ""`;
      K.if(F, Y._`${H} = ${(0, Y.stringify)(B)}`);
    }
  }),
  d8 = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.validateUnion =
        X.validateArray =
        X.usePattern =
        X.callValidateCode =
        X.schemaProperties =
        X.allSchemaProperties =
        X.noPropertyInData =
        X.propertyInData =
        X.isOwnProperty =
        X.hasPropFunc =
        X.reportMissingProp =
        X.checkMissingProp =
        X.checkReportMissingProp =
          void 0));
    var Y = I1(),
      Q = l1(),
      G = g4(),
      J = l1();
    function U(R, z) {
      let { gen: E, data: O, it: Z } = R;
      E.if(L(E, O, z, Z.opts.ownProperties), () => {
        (R.setParams({ missingProperty: Y._`${z}` }, !0), R.error());
      });
    }
    X.checkReportMissingProp = U;
    function $({ gen: R, data: z, it: { opts: E } }, O, Z) {
      return (0, Y.or)(
        ...O.map((j) =>
          (0, Y.and)(L(R, z, j, E.ownProperties), Y._`${Z} = ${j}`)
        )
      );
    }
    X.checkMissingProp = $;
    function B(R, z) {
      (R.setParams({ missingProperty: z }, !0), R.error());
    }
    X.reportMissingProp = B;
    function K(R) {
      return R.scopeValue("func", {
        ref: Object.prototype.hasOwnProperty,
        code: Y._`Object.prototype.hasOwnProperty`,
      });
    }
    X.hasPropFunc = K;
    function V(R, z, E) {
      return Y._`${K(R)}.call(${z}, ${E})`;
    }
    X.isOwnProperty = V;
    function W(R, z, E, O) {
      let Z = Y._`${z}${(0, Y.getProperty)(E)} !== undefined`;
      return O ? Y._`${Z} && ${V(R, z, E)}` : Z;
    }
    X.propertyInData = W;
    function L(R, z, E, O) {
      let Z = Y._`${z}${(0, Y.getProperty)(E)} === undefined`;
      return O ? (0, Y.or)(Z, (0, Y.not)(V(R, z, E))) : Z;
    }
    X.noPropertyInData = L;
    function H(R) {
      return R ? Object.keys(R).filter((z) => z !== "__proto__") : [];
    }
    X.allSchemaProperties = H;
    function F(R, z) {
      return H(z).filter((E) => !(0, Q.alwaysValidSchema)(R, z[E]));
    }
    X.schemaProperties = F;
    function N(
      {
        schemaCode: R,
        data: z,
        it: { gen: E, topSchemaRef: O, schemaPath: Z, errorPath: j },
        it: w,
      },
      I,
      T,
      y
    ) {
      let _ = y ? Y._`${R}, ${z}, ${O}${Z}` : z,
        f = [
          [G.default.instancePath, (0, Y.strConcat)(G.default.instancePath, j)],
          [G.default.parentData, w.parentData],
          [G.default.parentDataProperty, w.parentDataProperty],
          [G.default.rootData, G.default.rootData],
        ];
      if (w.opts.dynamicRef)
        f.push([G.default.dynamicAnchors, G.default.dynamicAnchors]);
      let l = Y._`${_}, ${E.object(...f)}`;
      return T !== Y.nil ? Y._`${I}.call(${T}, ${l})` : Y._`${I}(${l})`;
    }
    X.callValidateCode = N;
    var q = Y._`new RegExp`;
    function M({ gen: R, it: { opts: z } }, E) {
      let O = z.unicodeRegExp ? "u" : "",
        { regExp: Z } = z.code,
        j = Z(E, O);
      return R.scopeValue("pattern", {
        key: j.toString(),
        ref: j,
        code: Y._`${Z.code === "new RegExp" ? q : (0, J.useFunc)(R, Z)}(${E}, ${O})`,
      });
    }
    X.usePattern = M;
    function A(R) {
      let { gen: z, data: E, keyword: O, it: Z } = R,
        j = z.name("valid");
      if (Z.allErrors) {
        let I = z.let("valid", !0);
        return (w(() => z.assign(I, !1)), I);
      }
      return (z.var(j, !0), w(() => z.break()), j);
      function w(I) {
        let T = z.const("len", Y._`${E}.length`);
        z.forRange("i", 0, T, (y) => {
          (R.subschema(
            { keyword: O, dataProp: y, dataPropType: Q.Type.Num },
            j
          ),
            z.if((0, Y.not)(j), I));
        });
      }
    }
    X.validateArray = A;
    function D(R) {
      let { gen: z, schema: E, keyword: O, it: Z } = R;
      if (!Array.isArray(E)) throw Error("ajv implementation error");
      if (E.some((T) => (0, Q.alwaysValidSchema)(Z, T)) && !Z.opts.unevaluated)
        return;
      let w = z.let("valid", !1),
        I = z.name("_valid");
      (z.block(() =>
        E.forEach((T, y) => {
          let _ = R.subschema(
            { keyword: O, schemaProp: y, compositeRule: !0 },
            I
          );
          if ((z.assign(w, Y._`${w} || ${I}`), !R.mergeValidEvaluated(_, I)))
            z.if((0, Y.not)(w));
        })
      ),
        R.result(
          w,
          () => R.reset(),
          () => R.error(!0)
        ));
    }
    X.validateUnion = D;
  }),
  Qf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.validateKeywordUsage =
        X.validSchemaType =
        X.funcKeywordCode =
        X.macroKeywordCode =
          void 0));
    var Y = I1(),
      Q = g4(),
      G = d8(),
      J = QJ();
    function U(F, N) {
      let { gen: q, keyword: M, schema: A, parentSchema: D, it: R } = F,
        z = N.macro.call(R.self, A, D, R),
        E = W(q, M, z);
      if (R.opts.validateSchema !== !1) R.self.validateSchema(z, !0);
      let O = q.name("valid");
      (F.subschema(
        {
          schema: z,
          schemaPath: Y.nil,
          errSchemaPath: `${R.errSchemaPath}/${M}`,
          topSchemaRef: E,
          compositeRule: !0,
        },
        O
      ),
        F.pass(O, () => F.error(!0)));
    }
    X.macroKeywordCode = U;
    function $(F, N) {
      var q;
      let {
        gen: M,
        keyword: A,
        schema: D,
        parentSchema: R,
        $data: z,
        it: E,
      } = F;
      V(E, N);
      let O = !z && N.compile ? N.compile.call(E.self, D, R, E) : N.validate,
        Z = W(M, A, O),
        j = M.let("valid");
      (F.block$data(j, w),
        F.ok((q = N.valid) !== null && q !== void 0 ? q : j));
      function w() {
        if (N.errors === !1) {
          if ((y(), N.modifying)) B(F);
          _(() => F.error());
        } else {
          let f = N.async ? I() : T();
          if (N.modifying) B(F);
          _(() => K(F, f));
        }
      }
      function I() {
        let f = M.let("ruleErrs", null);
        return (
          M.try(
            () => y(Y._`await `),
            (l) =>
              M.assign(j, !1).if(
                Y._`${l} instanceof ${E.ValidationError}`,
                () => M.assign(f, Y._`${l}.errors`),
                () => M.throw(l)
              )
          ),
          f
        );
      }
      function T() {
        let f = Y._`${Z}.errors`;
        return (M.assign(f, null), y(Y.nil), f);
      }
      function y(f = N.async ? Y._`await ` : Y.nil) {
        let l = E.opts.passContext ? Q.default.this : Q.default.self,
          h = !(("compile" in N && !z) || N.schema === !1);
        M.assign(
          j,
          Y._`${f}${(0, G.callValidateCode)(F, Z, l, h)}`,
          N.modifying
        );
      }
      function _(f) {
        var l;
        M.if((0, Y.not)((l = N.valid) !== null && l !== void 0 ? l : j), f);
      }
    }
    X.funcKeywordCode = $;
    function B(F) {
      let { gen: N, data: q, it: M } = F;
      N.if(M.parentData, () =>
        N.assign(q, Y._`${M.parentData}[${M.parentDataProperty}]`)
      );
    }
    function K(F, N) {
      let { gen: q } = F;
      q.if(
        Y._`Array.isArray(${N})`,
        () => {
          (q
            .assign(
              Q.default.vErrors,
              Y._`${Q.default.vErrors} === null ? ${N} : ${Q.default.vErrors}.concat(${N})`
            )
            .assign(Q.default.errors, Y._`${Q.default.vErrors}.length`),
            (0, J.extendErrors)(F));
        },
        () => F.error()
      );
    }
    function V({ schemaEnv: F }, N) {
      if (N.async && !F.$async) throw Error("async keyword in sync schema");
    }
    function W(F, N, q) {
      if (q === void 0) throw Error(`keyword "${N}" failed to compile`);
      return F.scopeValue(
        "keyword",
        typeof q == "function"
          ? { ref: q }
          : { ref: q, code: (0, Y.stringify)(q) }
      );
    }
    function L(F, N, q = !1) {
      return (
        !N.length ||
        N.some((M) =>
          M === "array"
            ? Array.isArray(F)
            : M === "object"
              ? F && typeof F == "object" && !Array.isArray(F)
              : typeof F == M || (q && typeof F > "u")
        )
      );
    }
    X.validSchemaType = L;
    function H({ schema: F, opts: N, self: q, errSchemaPath: M }, A, D) {
      if (Array.isArray(A.keyword) ? !A.keyword.includes(D) : A.keyword !== D)
        throw Error("ajv implementation error");
      let R = A.dependencies;
      if (
        R === null || R === void 0
          ? void 0
          : R.some((z) => !Object.prototype.hasOwnProperty.call(F, z))
      )
        throw Error(
          `parent schema must have dependencies of ${D}: ${R.join(",")}`
        );
      if (A.validateSchema) {
        if (!A.validateSchema(F[D])) {
          let E =
            `keyword "${D}" value is invalid at path "${M}": ` +
            q.errorsText(A.validateSchema.errors);
          if (N.validateSchema === "log") q.logger.error(E);
          else throw Error(E);
        }
      }
    }
    X.validateKeywordUsage = H;
  }),
  Gf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.extendSubschemaMode =
        X.extendSubschemaData =
        X.getSubschema =
          void 0));
    var Y = I1(),
      Q = l1();
    function G(
      $,
      {
        keyword: B,
        schemaProp: K,
        schema: V,
        schemaPath: W,
        errSchemaPath: L,
        topSchemaRef: H,
      }
    ) {
      if (B !== void 0 && V !== void 0)
        throw Error('both "keyword" and "schema" passed, only one allowed');
      if (B !== void 0) {
        let F = $.schema[B];
        return K === void 0
          ? {
              schema: F,
              schemaPath: Y._`${$.schemaPath}${(0, Y.getProperty)(B)}`,
              errSchemaPath: `${$.errSchemaPath}/${B}`,
            }
          : {
              schema: F[K],
              schemaPath: Y._`${$.schemaPath}${(0, Y.getProperty)(B)}${(0, Y.getProperty)(K)}`,
              errSchemaPath: `${$.errSchemaPath}/${B}/${(0, Q.escapeFragment)(K)}`,
            };
      }
      if (V !== void 0) {
        if (W === void 0 || L === void 0 || H === void 0)
          throw Error(
            '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"'
          );
        return { schema: V, schemaPath: W, topSchemaRef: H, errSchemaPath: L };
      }
      throw Error('either "keyword" or "schema" must be passed');
    }
    X.getSubschema = G;
    function J(
      $,
      B,
      { dataProp: K, dataPropType: V, data: W, dataTypes: L, propertyName: H }
    ) {
      if (W !== void 0 && K !== void 0)
        throw Error('both "data" and "dataProp" passed, only one allowed');
      let { gen: F } = B;
      if (K !== void 0) {
        let { errorPath: q, dataPathArr: M, opts: A } = B,
          D = F.let("data", Y._`${B.data}${(0, Y.getProperty)(K)}`, !0);
        (N(D),
          ($.errorPath = Y.str`${q}${(0, Q.getErrorPath)(K, V, A.jsPropertySyntax)}`),
          ($.parentDataProperty = Y._`${K}`),
          ($.dataPathArr = [...M, $.parentDataProperty]));
      }
      if (W !== void 0) {
        let q = W instanceof Y.Name ? W : F.let("data", W, !0);
        if ((N(q), H !== void 0)) $.propertyName = H;
      }
      if (L) $.dataTypes = L;
      function N(q) {
        (($.data = q),
          ($.dataLevel = B.dataLevel + 1),
          ($.dataTypes = []),
          (B.definedProperties = new Set()),
          ($.parentData = B.data),
          ($.dataNames = [...B.dataNames, q]));
      }
    }
    X.extendSubschemaData = J;
    function U(
      $,
      {
        jtdDiscriminator: B,
        jtdMetadata: K,
        compositeRule: V,
        createErrors: W,
        allErrors: L,
      }
    ) {
      if (V !== void 0) $.compositeRule = V;
      if (W !== void 0) $.createErrors = W;
      if (L !== void 0) $.allErrors = L;
      (($.jtdDiscriminator = B), ($.jtdMetadata = K));
    }
    X.extendSubschemaMode = U;
  }),
  GJ = L0((X, Y) => {
    Y.exports = function Q(G, J) {
      if (G === J) return !0;
      if (G && J && typeof G == "object" && typeof J == "object") {
        if (G.constructor !== J.constructor) return !1;
        var U, $, B;
        if (Array.isArray(G)) {
          if (((U = G.length), U != J.length)) return !1;
          for ($ = U; $-- !== 0; ) if (!Q(G[$], J[$])) return !1;
          return !0;
        }
        if (G.constructor === RegExp)
          return G.source === J.source && G.flags === J.flags;
        if (G.valueOf !== Object.prototype.valueOf)
          return G.valueOf() === J.valueOf();
        if (G.toString !== Object.prototype.toString)
          return G.toString() === J.toString();
        if (((B = Object.keys(G)), (U = B.length), U !== Object.keys(J).length))
          return !1;
        for ($ = U; $-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(J, B[$])) return !1;
        for ($ = U; $-- !== 0; ) {
          var K = B[$];
          if (!Q(G[K], J[K])) return !1;
        }
        return !0;
      }
      return G !== G && J !== J;
    };
  }),
  Jf = L0((X, Y) => {
    var Q = (Y.exports = function (U, $, B) {
      if (typeof $ == "function") ((B = $), ($ = {}));
      B = $.cb || B;
      var K = typeof B == "function" ? B : B.pre || function () {},
        V = B.post || function () {};
      G($, K, V, U, "", U);
    });
    ((Q.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0,
    }),
      (Q.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 }),
      (Q.propsKeywords = {
        $defs: !0,
        definitions: !0,
        properties: !0,
        patternProperties: !0,
        dependencies: !0,
      }),
      (Q.skipKeywords = {
        default: !0,
        enum: !0,
        const: !0,
        required: !0,
        maximum: !0,
        minimum: !0,
        exclusiveMaximum: !0,
        exclusiveMinimum: !0,
        multipleOf: !0,
        maxLength: !0,
        minLength: !0,
        pattern: !0,
        format: !0,
        maxItems: !0,
        minItems: !0,
        uniqueItems: !0,
        maxProperties: !0,
        minProperties: !0,
      }));
    function G(U, $, B, K, V, W, L, H, F, N) {
      if (K && typeof K == "object" && !Array.isArray(K)) {
        $(K, V, W, L, H, F, N);
        for (var q in K) {
          var M = K[q];
          if (Array.isArray(M)) {
            if (q in Q.arrayKeywords)
              for (var A = 0; A < M.length; A++)
                G(U, $, B, M[A], V + "/" + q + "/" + A, W, V, q, K, A);
          } else if (q in Q.propsKeywords) {
            if (M && typeof M == "object")
              for (var D in M)
                G(U, $, B, M[D], V + "/" + q + "/" + J(D), W, V, q, K, D);
          } else if (q in Q.keywords || (U.allKeys && !(q in Q.skipKeywords)))
            G(U, $, B, M, V + "/" + q, W, V, q, K);
        }
        B(K, V, W, L, H, F, N);
      }
    }
    function J(U) {
      return U.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }),
  JJ = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.getSchemaRefs =
        X.resolveUrl =
        X.normalizeId =
        X._getFullPath =
        X.getFullPath =
        X.inlineRef =
          void 0));
    var Y = l1(),
      Q = GJ(),
      G = Jf(),
      J = new Set([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum",
        "const",
      ]);
    function U(M, A = !0) {
      if (typeof M == "boolean") return !0;
      if (A === !0) return !B(M);
      if (!A) return !1;
      return K(M) <= A;
    }
    X.inlineRef = U;
    var $ = new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor",
    ]);
    function B(M) {
      for (let A in M) {
        if ($.has(A)) return !0;
        let D = M[A];
        if (Array.isArray(D) && D.some(B)) return !0;
        if (typeof D == "object" && B(D)) return !0;
      }
      return !1;
    }
    function K(M) {
      let A = 0;
      for (let D in M) {
        if (D === "$ref") return 1 / 0;
        if ((A++, J.has(D))) continue;
        if (typeof M[D] == "object") (0, Y.eachItem)(M[D], (R) => (A += K(R)));
        if (A === 1 / 0) return 1 / 0;
      }
      return A;
    }
    function V(M, A = "", D) {
      if (D !== !1) A = H(A);
      let R = M.parse(A);
      return W(M, R);
    }
    X.getFullPath = V;
    function W(M, A) {
      return M.serialize(A).split("#")[0] + "#";
    }
    X._getFullPath = W;
    var L = /#\/?$/;
    function H(M) {
      return M ? M.replace(L, "") : "";
    }
    X.normalizeId = H;
    function F(M, A, D) {
      return ((D = H(D)), M.resolve(A, D));
    }
    X.resolveUrl = F;
    var N = /^[a-z_][-a-z0-9._]*$/i;
    function q(M, A) {
      if (typeof M == "boolean") return {};
      let { schemaId: D, uriResolver: R } = this.opts,
        z = H(M[D] || A),
        E = { "": z },
        O = V(R, z, !1),
        Z = {},
        j = new Set();
      return (
        G(M, { allKeys: !0 }, (T, y, _, f) => {
          if (f === void 0) return;
          let l = O + y,
            h = E[f];
          if (typeof T[D] == "string") h = p.call(this, T[D]);
          (N0.call(this, T.$anchor),
            N0.call(this, T.$dynamicAnchor),
            (E[y] = h));
          function p(e) {
            let P = this.opts.uriResolver.resolve;
            if (((e = H(h ? P(h, e) : e)), j.has(e))) throw I(e);
            j.add(e);
            let x = this.refs[e];
            if (typeof x == "string") x = this.refs[x];
            if (typeof x == "object") w(T, x.schema, e);
            else if (e !== H(l))
              if (e[0] === "#") (w(T, Z[e], e), (Z[e] = T));
              else this.refs[e] = l;
            return e;
          }
          function N0(e) {
            if (typeof e == "string") {
              if (!N.test(e)) throw Error(`invalid anchor "${e}"`);
              p.call(this, `#${e}`);
            }
          }
        }),
        Z
      );
      function w(T, y, _) {
        if (y !== void 0 && !Q(T, y)) throw I(_);
      }
      function I(T) {
        return Error(`reference "${T}" resolves to more than one schema`);
      }
    }
    X.getSchemaRefs = q;
  }),
  WJ = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.getData = X.KeywordCxt = X.validateFunctionCode = void 0));
    var Y = Xf(),
      Q = mG(),
      G = _E(),
      J = mG(),
      U = Yf(),
      $ = Qf(),
      B = Gf(),
      K = I1(),
      V = g4(),
      W = JJ(),
      L = l1(),
      H = QJ();
    function F(b) {
      if (O(b)) {
        if ((j(b), E(b))) {
          A(b);
          return;
        }
      }
      N(b, () => (0, Y.topBoolOrEmptySchema)(b));
    }
    X.validateFunctionCode = F;
    function N(
      { gen: b, validateName: m, schema: n, schemaEnv: M0, opts: D0 },
      Z0
    ) {
      if (D0.code.es5)
        b.func(
          m,
          K._`${V.default.data}, ${V.default.valCxt}`,
          M0.$async,
          () => {
            (b.code(K._`"use strict"; ${R(n, D0)}`), M(b, D0), b.code(Z0));
          }
        );
      else
        b.func(m, K._`${V.default.data}, ${q(D0)}`, M0.$async, () =>
          b.code(R(n, D0)).code(Z0)
        );
    }
    function q(b) {
      return K._`{${V.default.instancePath}="", ${V.default.parentData}, ${V.default.parentDataProperty}, ${V.default.rootData}=${V.default.data}${b.dynamicRef ? K._`, ${V.default.dynamicAnchors}={}` : K.nil}}={}`;
    }
    function M(b, m) {
      b.if(
        V.default.valCxt,
        () => {
          if (
            (b.var(
              V.default.instancePath,
              K._`${V.default.valCxt}.${V.default.instancePath}`
            ),
            b.var(
              V.default.parentData,
              K._`${V.default.valCxt}.${V.default.parentData}`
            ),
            b.var(
              V.default.parentDataProperty,
              K._`${V.default.valCxt}.${V.default.parentDataProperty}`
            ),
            b.var(
              V.default.rootData,
              K._`${V.default.valCxt}.${V.default.rootData}`
            ),
            m.dynamicRef)
          )
            b.var(
              V.default.dynamicAnchors,
              K._`${V.default.valCxt}.${V.default.dynamicAnchors}`
            );
        },
        () => {
          if (
            (b.var(V.default.instancePath, K._`""`),
            b.var(V.default.parentData, K._`undefined`),
            b.var(V.default.parentDataProperty, K._`undefined`),
            b.var(V.default.rootData, V.default.data),
            m.dynamicRef)
          )
            b.var(V.default.dynamicAnchors, K._`{}`);
        }
      );
    }
    function A(b) {
      let { schema: m, opts: n, gen: M0 } = b;
      N(b, () => {
        if (n.$comment && m.$comment) f(b);
        if (
          (T(b),
          M0.let(V.default.vErrors, null),
          M0.let(V.default.errors, 0),
          n.unevaluated)
        )
          D(b);
        (w(b), l(b));
      });
      return;
    }
    function D(b) {
      let { gen: m, validateName: n } = b;
      ((b.evaluated = m.const("evaluated", K._`${n}.evaluated`)),
        m.if(K._`${b.evaluated}.dynamicProps`, () =>
          m.assign(K._`${b.evaluated}.props`, K._`undefined`)
        ),
        m.if(K._`${b.evaluated}.dynamicItems`, () =>
          m.assign(K._`${b.evaluated}.items`, K._`undefined`)
        ));
    }
    function R(b, m) {
      let n = typeof b == "object" && b[m.schemaId];
      return n && (m.code.source || m.code.process)
        ? K._`/*# sourceURL=${n} */`
        : K.nil;
    }
    function z(b, m) {
      if (O(b)) {
        if ((j(b), E(b))) {
          Z(b, m);
          return;
        }
      }
      (0, Y.boolOrEmptySchema)(b, m);
    }
    function E({ schema: b, self: m }) {
      if (typeof b == "boolean") return !b;
      for (let n in b) if (m.RULES.all[n]) return !0;
      return !1;
    }
    function O(b) {
      return typeof b.schema != "boolean";
    }
    function Z(b, m) {
      let { schema: n, gen: M0, opts: D0 } = b;
      if (D0.$comment && n.$comment) f(b);
      (y(b), _(b));
      let Z0 = M0.const("_errs", V.default.errors);
      (w(b, Z0), M0.var(m, K._`${Z0} === ${V.default.errors}`));
    }
    function j(b) {
      ((0, L.checkUnknownRules)(b), I(b));
    }
    function w(b, m) {
      if (b.opts.jtd) return p(b, [], !1, m);
      let n = (0, Q.getSchemaTypes)(b.schema),
        M0 = (0, Q.coerceAndCheckDataType)(b, n);
      p(b, n, !M0, m);
    }
    function I(b) {
      let { schema: m, errSchemaPath: n, opts: M0, self: D0 } = b;
      if (
        m.$ref &&
        M0.ignoreKeywordsWithRef &&
        (0, L.schemaHasRulesButRef)(m, D0.RULES)
      )
        D0.logger.warn(`$ref: keywords ignored in schema at path "${n}"`);
    }
    function T(b) {
      let { schema: m, opts: n } = b;
      if (m.default !== void 0 && n.useDefaults && n.strictSchema)
        (0, L.checkStrictMode)(b, "default is ignored in the schema root");
    }
    function y(b) {
      let m = b.schema[b.opts.schemaId];
      if (m) b.baseId = (0, W.resolveUrl)(b.opts.uriResolver, b.baseId, m);
    }
    function _(b) {
      if (b.schema.$async && !b.schemaEnv.$async)
        throw Error("async schema in sync schema");
    }
    function f({
      gen: b,
      schemaEnv: m,
      schema: n,
      errSchemaPath: M0,
      opts: D0,
    }) {
      let Z0 = n.$comment;
      if (D0.$comment === !0) b.code(K._`${V.default.self}.logger.log(${Z0})`);
      else if (typeof D0.$comment == "function") {
        let B1 = K.str`${M0}/$comment`,
          j1 = b.scopeValue("root", { ref: m.root });
        b.code(
          K._`${V.default.self}.opts.$comment(${Z0}, ${B1}, ${j1}.schema)`
        );
      }
    }
    function l(b) {
      let {
        gen: m,
        schemaEnv: n,
        validateName: M0,
        ValidationError: D0,
        opts: Z0,
      } = b;
      if (n.$async)
        m.if(
          K._`${V.default.errors} === 0`,
          () => m.return(V.default.data),
          () => m.throw(K._`new ${D0}(${V.default.vErrors})`)
        );
      else {
        if ((m.assign(K._`${M0}.errors`, V.default.vErrors), Z0.unevaluated))
          h(b);
        m.return(K._`${V.default.errors} === 0`);
      }
    }
    function h({ gen: b, evaluated: m, props: n, items: M0 }) {
      if (n instanceof K.Name) b.assign(K._`${m}.props`, n);
      if (M0 instanceof K.Name) b.assign(K._`${m}.items`, M0);
    }
    function p(b, m, n, M0) {
      let {
          gen: D0,
          schema: Z0,
          data: B1,
          allErrors: j1,
          opts: v1,
          self: M1,
        } = b,
        { RULES: x0 } = M1;
      if (
        Z0.$ref &&
        (v1.ignoreKeywordsWithRef || !(0, L.schemaHasRulesButRef)(Z0, x0))
      ) {
        D0.block(() => z0(b, "$ref", x0.all.$ref.definition));
        return;
      }
      if (!v1.jtd) e(b, m);
      D0.block(() => {
        for (let g1 of x0.rules) h1(g1);
        h1(x0.post);
      });
      function h1(g1) {
        if (!(0, G.shouldUseGroup)(Z0, g1)) return;
        if (g1.type) {
          if (
            (D0.if((0, J.checkDataType)(g1.type, B1, v1.strictNumbers)),
            N0(b, g1),
            m.length === 1 && m[0] === g1.type && n)
          )
            (D0.else(), (0, J.reportTypeError)(b));
          D0.endIf();
        } else N0(b, g1);
        if (!j1) D0.if(K._`${V.default.errors} === ${M0 || 0}`);
      }
    }
    function N0(b, m) {
      let {
        gen: n,
        schema: M0,
        opts: { useDefaults: D0 },
      } = b;
      if (D0) (0, U.assignDefaults)(b, m.type);
      n.block(() => {
        for (let Z0 of m.rules)
          if ((0, G.shouldUseRule)(M0, Z0))
            z0(b, Z0.keyword, Z0.definition, m.type);
      });
    }
    function e(b, m) {
      if (b.schemaEnv.meta || !b.opts.strictTypes) return;
      if ((P(b, m), !b.opts.allowUnionTypes)) x(b, m);
      r(b, b.dataTypes);
    }
    function P(b, m) {
      if (!m.length) return;
      if (!b.dataTypes.length) {
        b.dataTypes = m;
        return;
      }
      (m.forEach((n) => {
        if (!v(b.dataTypes, n))
          o(b, `type "${n}" not allowed by context "${b.dataTypes.join(",")}"`);
      }),
        k(b, m));
    }
    function x(b, m) {
      if (m.length > 1 && !(m.length === 2 && m.includes("null")))
        o(b, "use allowUnionTypes to allow union type keyword");
    }
    function r(b, m) {
      let n = b.self.RULES.all;
      for (let M0 in n) {
        let D0 = n[M0];
        if (typeof D0 == "object" && (0, G.shouldUseRule)(b.schema, D0)) {
          let { type: Z0 } = D0.definition;
          if (Z0.length && !Z0.some((B1) => C(m, B1)))
            o(b, `missing type "${Z0.join(",")}" for keyword "${M0}"`);
        }
      }
    }
    function C(b, m) {
      return b.includes(m) || (m === "number" && b.includes("integer"));
    }
    function v(b, m) {
      return b.includes(m) || (m === "integer" && b.includes("number"));
    }
    function k(b, m) {
      let n = [];
      for (let M0 of b.dataTypes)
        if (v(m, M0)) n.push(M0);
        else if (m.includes("integer") && M0 === "number") n.push("integer");
      b.dataTypes = n;
    }
    function o(b, m) {
      let n = b.schemaEnv.baseId + b.errSchemaPath;
      ((m += ` at "${n}" (strictTypes)`),
        (0, L.checkStrictMode)(b, m, b.opts.strictTypes));
    }
    class J0 {
      constructor(b, m, n) {
        if (
          ((0, $.validateKeywordUsage)(b, m, n),
          (this.gen = b.gen),
          (this.allErrors = b.allErrors),
          (this.keyword = n),
          (this.data = b.data),
          (this.schema = b.schema[n]),
          (this.$data =
            m.$data && b.opts.$data && this.schema && this.schema.$data),
          (this.schemaValue = (0, L.schemaRefOrVal)(
            b,
            this.schema,
            n,
            this.$data
          )),
          (this.schemaType = m.schemaType),
          (this.parentSchema = b.schema),
          (this.params = {}),
          (this.it = b),
          (this.def = m),
          this.$data)
        )
          this.schemaCode = b.gen.const("vSchema", Y1(this.$data, b));
        else if (
          ((this.schemaCode = this.schemaValue),
          !(0, $.validSchemaType)(this.schema, m.schemaType, m.allowUndefined))
        )
          throw Error(`${n} value must be ${JSON.stringify(m.schemaType)}`);
        if ("code" in m ? m.trackErrors : m.errors !== !1)
          this.errsCount = b.gen.const("_errs", V.default.errors);
      }
      result(b, m, n) {
        this.failResult((0, K.not)(b), m, n);
      }
      failResult(b, m, n) {
        if ((this.gen.if(b), n)) n();
        else this.error();
        if (m) {
          if ((this.gen.else(), m(), this.allErrors)) this.gen.endIf();
        } else if (this.allErrors) this.gen.endIf();
        else this.gen.else();
      }
      pass(b, m) {
        this.failResult((0, K.not)(b), void 0, m);
      }
      fail(b) {
        if (b === void 0) {
          if ((this.error(), !this.allErrors)) this.gen.if(!1);
          return;
        }
        if ((this.gen.if(b), this.error(), this.allErrors)) this.gen.endIf();
        else this.gen.else();
      }
      fail$data(b) {
        if (!this.$data) return this.fail(b);
        let { schemaCode: m } = this;
        this.fail(
          K._`${m} !== undefined && (${(0, K.or)(this.invalid$data(), b)})`
        );
      }
      error(b, m, n) {
        if (m) {
          (this.setParams(m), this._error(b, n), this.setParams({}));
          return;
        }
        this._error(b, n);
      }
      _error(b, m) {
        (b ? H.reportExtraError : H.reportError)(this, this.def.error, m);
      }
      $dataError() {
        (0, H.reportError)(this, this.def.$dataError || H.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw Error('add "trackErrors" to keyword definition');
        (0, H.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(b) {
        if (!this.allErrors) this.gen.if(b);
      }
      setParams(b, m) {
        if (m) Object.assign(this.params, b);
        else this.params = b;
      }
      block$data(b, m, n = K.nil) {
        this.gen.block(() => {
          (this.check$data(b, n), m());
        });
      }
      check$data(b = K.nil, m = K.nil) {
        if (!this.$data) return;
        let { gen: n, schemaCode: M0, schemaType: D0, def: Z0 } = this;
        if ((n.if((0, K.or)(K._`${M0} === undefined`, m)), b !== K.nil))
          n.assign(b, !0);
        if (D0.length || Z0.validateSchema) {
          if ((n.elseIf(this.invalid$data()), this.$dataError(), b !== K.nil))
            n.assign(b, !1);
        }
        n.else();
      }
      invalid$data() {
        let { gen: b, schemaCode: m, schemaType: n, def: M0, it: D0 } = this;
        return (0, K.or)(Z0(), B1());
        function Z0() {
          if (n.length) {
            if (!(m instanceof K.Name)) throw Error("ajv implementation error");
            let j1 = Array.isArray(n) ? n : [n];
            return K._`${(0, J.checkDataTypes)(j1, m, D0.opts.strictNumbers, J.DataType.Wrong)}`;
          }
          return K.nil;
        }
        function B1() {
          if (M0.validateSchema) {
            let j1 = b.scopeValue("validate$data", { ref: M0.validateSchema });
            return K._`!${j1}(${m})`;
          }
          return K.nil;
        }
      }
      subschema(b, m) {
        let n = (0, B.getSubschema)(this.it, b);
        ((0, B.extendSubschemaData)(n, this.it, b),
          (0, B.extendSubschemaMode)(n, b));
        let M0 = { ...this.it, ...n, items: void 0, props: void 0 };
        return (z(M0, m), M0);
      }
      mergeEvaluated(b, m) {
        let { it: n, gen: M0 } = this;
        if (!n.opts.unevaluated) return;
        if (n.props !== !0 && b.props !== void 0)
          n.props = L.mergeEvaluated.props(M0, b.props, n.props, m);
        if (n.items !== !0 && b.items !== void 0)
          n.items = L.mergeEvaluated.items(M0, b.items, n.items, m);
      }
      mergeValidEvaluated(b, m) {
        let { it: n, gen: M0 } = this;
        if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
          return (M0.if(m, () => this.mergeEvaluated(b, K.Name)), !0);
      }
    }
    X.KeywordCxt = J0;
    function z0(b, m, n, M0) {
      let D0 = new J0(b, n, m);
      if ("code" in n) n.code(D0, M0);
      else if (D0.$data && n.validate) (0, $.funcKeywordCode)(D0, n);
      else if ("macro" in n) (0, $.macroKeywordCode)(D0, n);
      else if (n.compile || n.validate) (0, $.funcKeywordCode)(D0, n);
    }
    var A0 = /^\/(?:[^~]|~0|~1)*$/,
      w0 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function Y1(b, { dataLevel: m, dataNames: n, dataPathArr: M0 }) {
      let D0, Z0;
      if (b === "") return V.default.rootData;
      if (b[0] === "/") {
        if (!A0.test(b)) throw Error(`Invalid JSON-pointer: ${b}`);
        ((D0 = b), (Z0 = V.default.rootData));
      } else {
        let M1 = w0.exec(b);
        if (!M1) throw Error(`Invalid JSON-pointer: ${b}`);
        let x0 = +M1[1];
        if (((D0 = M1[2]), D0 === "#")) {
          if (x0 >= m) throw Error(v1("property/index", x0));
          return M0[m - x0];
        }
        if (x0 > m) throw Error(v1("data", x0));
        if (((Z0 = n[m - x0]), !D0)) return Z0;
      }
      let B1 = Z0,
        j1 = D0.split("/");
      for (let M1 of j1)
        if (M1)
          ((Z0 = K._`${Z0}${(0, K.getProperty)((0, L.unescapeJsonPointer)(M1))}`),
            (B1 = K._`${B1} && ${Z0}`));
      return B1;
      function v1(M1, x0) {
        return `Cannot access ${M1} ${x0} levels up, current level is ${m}`;
      }
    }
    X.getData = Y1;
  }),
  fU = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    class Y extends Error {
      constructor(Q) {
        super("validation failed");
        ((this.errors = Q), (this.ajv = this.validation = !0));
      }
    }
    X.default = Y;
  }),
  HJ = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = JJ();
    class Q extends Error {
      constructor(G, J, U, $) {
        super($ || `can't resolve reference ${U} from id ${J}`);
        ((this.missingRef = (0, Y.resolveUrl)(G, J, U)),
          (this.missingSchema = (0, Y.normalizeId)(
            (0, Y.getFullPath)(G, this.missingRef)
          )));
      }
    }
    X.default = Q;
  }),
  xU = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.resolveSchema =
        X.getCompilingSchema =
        X.resolveRef =
        X.compileSchema =
        X.SchemaEnv =
          void 0));
    var Y = I1(),
      Q = fU(),
      G = g4(),
      J = JJ(),
      U = l1(),
      $ = WJ();
    class B {
      constructor(A) {
        var D;
        ((this.refs = {}), (this.dynamicAnchors = {}));
        let R;
        if (typeof A.schema == "object") R = A.schema;
        ((this.schema = A.schema),
          (this.schemaId = A.schemaId),
          (this.root = A.root || this),
          (this.baseId =
            (D = A.baseId) !== null && D !== void 0
              ? D
              : (0, J.normalizeId)(
                  R === null || R === void 0 ? void 0 : R[A.schemaId || "$id"]
                )),
          (this.schemaPath = A.schemaPath),
          (this.localRefs = A.localRefs),
          (this.meta = A.meta),
          (this.$async = R === null || R === void 0 ? void 0 : R.$async),
          (this.refs = {}));
      }
    }
    X.SchemaEnv = B;
    function K(A) {
      let D = L.call(this, A);
      if (D) return D;
      let R = (0, J.getFullPath)(this.opts.uriResolver, A.root.baseId),
        { es5: z, lines: E } = this.opts.code,
        { ownProperties: O } = this.opts,
        Z = new Y.CodeGen(this.scope, { es5: z, lines: E, ownProperties: O }),
        j;
      if (A.$async)
        j = Z.scopeValue("Error", {
          ref: Q.default,
          code: Y._`require("ajv/dist/runtime/validation_error").default`,
        });
      let w = Z.scopeName("validate");
      A.validateName = w;
      let I = {
          gen: Z,
          allErrors: this.opts.allErrors,
          data: G.default.data,
          parentData: G.default.parentData,
          parentDataProperty: G.default.parentDataProperty,
          dataNames: [G.default.data],
          dataPathArr: [Y.nil],
          dataLevel: 0,
          dataTypes: [],
          definedProperties: new Set(),
          topSchemaRef: Z.scopeValue(
            "schema",
            this.opts.code.source === !0
              ? { ref: A.schema, code: (0, Y.stringify)(A.schema) }
              : { ref: A.schema }
          ),
          validateName: w,
          ValidationError: j,
          schema: A.schema,
          schemaEnv: A,
          rootId: R,
          baseId: A.baseId || R,
          schemaPath: Y.nil,
          errSchemaPath: A.schemaPath || (this.opts.jtd ? "" : "#"),
          errorPath: Y._`""`,
          opts: this.opts,
          self: this,
        },
        T;
      try {
        (this._compilations.add(A),
          (0, $.validateFunctionCode)(I),
          Z.optimize(this.opts.code.optimize));
        let y = Z.toString();
        if (
          ((T = `${Z.scopeRefs(G.default.scope)}return ${y}`),
          this.opts.code.process)
        )
          T = this.opts.code.process(T, A);
        let f = Function(
          `${G.default.self}`,
          `${G.default.scope}`,
          T
        )(this, this.scope.get());
        if (
          (this.scope.value(w, { ref: f }),
          (f.errors = null),
          (f.schema = A.schema),
          (f.schemaEnv = A),
          A.$async)
        )
          f.$async = !0;
        if (this.opts.code.source === !0)
          f.source = {
            validateName: w,
            validateCode: y,
            scopeValues: Z._values,
          };
        if (this.opts.unevaluated) {
          let { props: l, items: h } = I;
          if (
            ((f.evaluated = {
              props: l instanceof Y.Name ? void 0 : l,
              items: h instanceof Y.Name ? void 0 : h,
              dynamicProps: l instanceof Y.Name,
              dynamicItems: h instanceof Y.Name,
            }),
            f.source)
          )
            f.source.evaluated = (0, Y.stringify)(f.evaluated);
        }
        return ((A.validate = f), A);
      } catch (y) {
        if ((delete A.validate, delete A.validateName, T))
          this.logger.error("Error compiling schema, function code:", T);
        throw y;
      } finally {
        this._compilations.delete(A);
      }
    }
    X.compileSchema = K;
    function V(A, D, R) {
      var z;
      R = (0, J.resolveUrl)(this.opts.uriResolver, D, R);
      let E = A.refs[R];
      if (E) return E;
      let O = F.call(this, A, R);
      if (O === void 0) {
        let Z = (z = A.localRefs) === null || z === void 0 ? void 0 : z[R],
          { schemaId: j } = this.opts;
        if (Z) O = new B({ schema: Z, schemaId: j, root: A, baseId: D });
      }
      if (O === void 0) return;
      return (A.refs[R] = W.call(this, O));
    }
    X.resolveRef = V;
    function W(A) {
      if ((0, J.inlineRef)(A.schema, this.opts.inlineRefs)) return A.schema;
      return A.validate ? A : K.call(this, A);
    }
    function L(A) {
      for (let D of this._compilations) if (H(D, A)) return D;
    }
    X.getCompilingSchema = L;
    function H(A, D) {
      return (
        A.schema === D.schema && A.root === D.root && A.baseId === D.baseId
      );
    }
    function F(A, D) {
      let R;
      while (typeof (R = this.refs[D]) == "string") D = R;
      return R || this.schemas[D] || N.call(this, A, D);
    }
    function N(A, D) {
      let R = this.opts.uriResolver.parse(D),
        z = (0, J._getFullPath)(this.opts.uriResolver, R),
        E = (0, J.getFullPath)(this.opts.uriResolver, A.baseId, void 0);
      if (Object.keys(A.schema).length > 0 && z === E)
        return M.call(this, R, A);
      let O = (0, J.normalizeId)(z),
        Z = this.refs[O] || this.schemas[O];
      if (typeof Z == "string") {
        let j = N.call(this, A, Z);
        if (
          typeof (j === null || j === void 0 ? void 0 : j.schema) !== "object"
        )
          return;
        return M.call(this, R, j);
      }
      if (typeof (Z === null || Z === void 0 ? void 0 : Z.schema) !== "object")
        return;
      if (!Z.validate) K.call(this, Z);
      if (O === (0, J.normalizeId)(D)) {
        let { schema: j } = Z,
          { schemaId: w } = this.opts,
          I = j[w];
        if (I) E = (0, J.resolveUrl)(this.opts.uriResolver, E, I);
        return new B({ schema: j, schemaId: w, root: A, baseId: E });
      }
      return M.call(this, R, Z);
    }
    X.resolveSchema = N;
    var q = new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions",
    ]);
    function M(A, { baseId: D, schema: R, root: z }) {
      var E;
      if (((E = A.fragment) === null || E === void 0 ? void 0 : E[0]) !== "/")
        return;
      for (let j of A.fragment.slice(1).split("/")) {
        if (typeof R === "boolean") return;
        let w = R[(0, U.unescapeFragment)(j)];
        if (w === void 0) return;
        R = w;
        let I = typeof R === "object" && R[this.opts.schemaId];
        if (!q.has(j) && I) D = (0, J.resolveUrl)(this.opts.uriResolver, D, I);
      }
      let O;
      if (
        typeof R != "boolean" &&
        R.$ref &&
        !(0, U.schemaHasRulesButRef)(R, this.RULES)
      ) {
        let j = (0, J.resolveUrl)(this.opts.uriResolver, D, R.$ref);
        O = N.call(this, z, j);
      }
      let { schemaId: Z } = this.opts;
      if (
        ((O = O || new B({ schema: R, schemaId: Z, root: z, baseId: D })),
        O.schema !== O.root.schema)
      )
        return O;
      return;
    }
  }),
  Wf = L0((X, Y) => {
    Y.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description:
        "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" },
          ],
        },
      },
      additionalProperties: !1,
    };
  }),
  Hf = L0((X, Y) => {
    var Q = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15,
    };
    Y.exports = { HEX: Q };
  }),
  $f = L0((X, Y) => {
    var { HEX: Q } = Hf(),
      G =
        /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function J(A) {
      if (V(A, ".") < 3) return { host: A, isIPV4: !1 };
      let D = A.match(G) || [],
        [R] = D;
      if (R) return { host: K(R, "."), isIPV4: !0 };
      else return { host: A, isIPV4: !1 };
    }
    function U(A, D = !1) {
      let R = "",
        z = !0;
      for (let E of A) {
        if (Q[E] === void 0) return;
        if (E !== "0" && z === !0) z = !1;
        if (!z) R += E;
      }
      if (D && R.length === 0) R = "0";
      return R;
    }
    function $(A) {
      let D = 0,
        R = { error: !1, address: "", zone: "" },
        z = [],
        E = [],
        O = !1,
        Z = !1,
        j = !1;
      function w() {
        if (E.length) {
          if (O === !1) {
            let I = U(E);
            if (I !== void 0) z.push(I);
            else return ((R.error = !0), !1);
          }
          E.length = 0;
        }
        return !0;
      }
      for (let I = 0; I < A.length; I++) {
        let T = A[I];
        if (T === "[" || T === "]") continue;
        if (T === ":") {
          if (Z === !0) j = !0;
          if (!w()) break;
          if ((D++, z.push(":"), D > 7)) {
            R.error = !0;
            break;
          }
          if (I - 1 >= 0 && A[I - 1] === ":") Z = !0;
          continue;
        } else if (T === "%") {
          if (!w()) break;
          O = !0;
        } else {
          E.push(T);
          continue;
        }
      }
      if (E.length)
        if (O) R.zone = E.join("");
        else if (j) z.push(E.join(""));
        else z.push(U(E));
      return ((R.address = z.join("")), R);
    }
    function B(A) {
      if (V(A, ":") < 2) return { host: A, isIPV6: !1 };
      let D = $(A);
      if (!D.error) {
        let { address: R, address: z } = D;
        if (D.zone) ((R += "%" + D.zone), (z += "%25" + D.zone));
        return { host: R, escapedHost: z, isIPV6: !0 };
      } else return { host: A, isIPV6: !1 };
    }
    function K(A, D) {
      let R = "",
        z = !0,
        E = A.length;
      for (let O = 0; O < E; O++) {
        let Z = A[O];
        if (Z === "0" && z) {
          if ((O + 1 <= E && A[O + 1] === D) || O + 1 === E)
            ((R += Z), (z = !1));
        } else {
          if (Z === D) z = !0;
          else z = !1;
          R += Z;
        }
      }
      return R;
    }
    function V(A, D) {
      let R = 0;
      for (let z = 0; z < A.length; z++) if (A[z] === D) R++;
      return R;
    }
    var W = /^\.\.?\//u,
      L = /^\/\.(?:\/|$)/u,
      H = /^\/\.\.(?:\/|$)/u,
      F = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function N(A) {
      let D = [];
      while (A.length)
        if (A.match(W)) A = A.replace(W, "");
        else if (A.match(L)) A = A.replace(L, "/");
        else if (A.match(H)) ((A = A.replace(H, "/")), D.pop());
        else if (A === "." || A === "..") A = "";
        else {
          let R = A.match(F);
          if (R) {
            let z = R[0];
            ((A = A.slice(z.length)), D.push(z));
          } else throw Error("Unexpected dot segment condition");
        }
      return D.join("");
    }
    function q(A, D) {
      let R = D !== !0 ? escape : unescape;
      if (A.scheme !== void 0) A.scheme = R(A.scheme);
      if (A.userinfo !== void 0) A.userinfo = R(A.userinfo);
      if (A.host !== void 0) A.host = R(A.host);
      if (A.path !== void 0) A.path = R(A.path);
      if (A.query !== void 0) A.query = R(A.query);
      if (A.fragment !== void 0) A.fragment = R(A.fragment);
      return A;
    }
    function M(A) {
      let D = [];
      if (A.userinfo !== void 0) (D.push(A.userinfo), D.push("@"));
      if (A.host !== void 0) {
        let R = unescape(A.host),
          z = J(R);
        if (z.isIPV4) R = z.host;
        else {
          let E = B(z.host);
          if (E.isIPV6 === !0) R = `[${E.escapedHost}]`;
          else R = A.host;
        }
        D.push(R);
      }
      if (typeof A.port === "number" || typeof A.port === "string")
        (D.push(":"), D.push(String(A.port)));
      return D.length ? D.join("") : void 0;
    }
    Y.exports = {
      recomposeAuthority: M,
      normalizeComponentEncoding: q,
      removeDotSegments: N,
      normalizeIPv4: J,
      normalizeIPv6: B,
      stringArrayToHexStripped: U,
    };
  }),
  Uf = L0((X, Y) => {
    var Q = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu,
      G = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function J(z) {
      return typeof z.secure === "boolean"
        ? z.secure
        : String(z.scheme).toLowerCase() === "wss";
    }
    function U(z) {
      if (!z.host) z.error = z.error || "HTTP URIs must have a host.";
      return z;
    }
    function $(z) {
      let E = String(z.scheme).toLowerCase() === "https";
      if (z.port === (E ? 443 : 80) || z.port === "") z.port = void 0;
      if (!z.path) z.path = "/";
      return z;
    }
    function B(z) {
      return (
        (z.secure = J(z)),
        (z.resourceName = (z.path || "/") + (z.query ? "?" + z.query : "")),
        (z.path = void 0),
        (z.query = void 0),
        z
      );
    }
    function K(z) {
      if (z.port === (J(z) ? 443 : 80) || z.port === "") z.port = void 0;
      if (typeof z.secure === "boolean")
        ((z.scheme = z.secure ? "wss" : "ws"), (z.secure = void 0));
      if (z.resourceName) {
        let [E, O] = z.resourceName.split("?");
        ((z.path = E && E !== "/" ? E : void 0),
          (z.query = O),
          (z.resourceName = void 0));
      }
      return ((z.fragment = void 0), z);
    }
    function V(z, E) {
      if (!z.path) return ((z.error = "URN can not be parsed"), z);
      let O = z.path.match(G);
      if (O) {
        let Z = E.scheme || z.scheme || "urn";
        ((z.nid = O[1].toLowerCase()), (z.nss = O[2]));
        let j = `${Z}:${E.nid || z.nid}`,
          w = R[j];
        if (((z.path = void 0), w)) z = w.parse(z, E);
      } else z.error = z.error || "URN can not be parsed.";
      return z;
    }
    function W(z, E) {
      let O = E.scheme || z.scheme || "urn",
        Z = z.nid.toLowerCase(),
        j = `${O}:${E.nid || Z}`,
        w = R[j];
      if (w) z = w.serialize(z, E);
      let I = z,
        T = z.nss;
      return ((I.path = `${Z || E.nid}:${T}`), (E.skipEscape = !0), I);
    }
    function L(z, E) {
      let O = z;
      if (
        ((O.uuid = O.nss),
        (O.nss = void 0),
        !E.tolerant && (!O.uuid || !Q.test(O.uuid)))
      )
        O.error = O.error || "UUID is not valid.";
      return O;
    }
    function H(z) {
      let E = z;
      return ((E.nss = (z.uuid || "").toLowerCase()), E);
    }
    var F = { scheme: "http", domainHost: !0, parse: U, serialize: $ },
      N = { scheme: "https", domainHost: F.domainHost, parse: U, serialize: $ },
      q = { scheme: "ws", domainHost: !0, parse: B, serialize: K },
      M = {
        scheme: "wss",
        domainHost: q.domainHost,
        parse: q.parse,
        serialize: q.serialize,
      },
      A = { scheme: "urn", parse: V, serialize: W, skipNormalize: !0 },
      D = { scheme: "urn:uuid", parse: L, serialize: H, skipNormalize: !0 },
      R = { http: F, https: N, ws: q, wss: M, urn: A, "urn:uuid": D };
    Y.exports = R;
  }),
  fE = L0((X, Y) => {
    var {
        normalizeIPv6: Q,
        normalizeIPv4: G,
        removeDotSegments: J,
        recomposeAuthority: U,
        normalizeComponentEncoding: $,
      } = $f(),
      B = Uf();
    function K(D, R) {
      if (typeof D === "string") D = H(M(D, R), R);
      else if (typeof D === "object") D = M(H(D, R), R);
      return D;
    }
    function V(D, R, z) {
      let E = Object.assign({ scheme: "null" }, z),
        O = W(M(D, E), M(R, E), E, !0);
      return H(O, { ...E, skipEscape: !0 });
    }
    function W(D, R, z, E) {
      let O = {};
      if (!E) ((D = M(H(D, z), z)), (R = M(H(R, z), z)));
      if (((z = z || {}), !z.tolerant && R.scheme))
        ((O.scheme = R.scheme),
          (O.userinfo = R.userinfo),
          (O.host = R.host),
          (O.port = R.port),
          (O.path = J(R.path || "")),
          (O.query = R.query));
      else {
        if (R.userinfo !== void 0 || R.host !== void 0 || R.port !== void 0)
          ((O.userinfo = R.userinfo),
            (O.host = R.host),
            (O.port = R.port),
            (O.path = J(R.path || "")),
            (O.query = R.query));
        else {
          if (!R.path)
            if (((O.path = D.path), R.query !== void 0)) O.query = R.query;
            else O.query = D.query;
          else {
            if (R.path.charAt(0) === "/") O.path = J(R.path);
            else {
              if (
                (D.userinfo !== void 0 ||
                  D.host !== void 0 ||
                  D.port !== void 0) &&
                !D.path
              )
                O.path = "/" + R.path;
              else if (!D.path) O.path = R.path;
              else
                O.path = D.path.slice(0, D.path.lastIndexOf("/") + 1) + R.path;
              O.path = J(O.path);
            }
            O.query = R.query;
          }
          ((O.userinfo = D.userinfo), (O.host = D.host), (O.port = D.port));
        }
        O.scheme = D.scheme;
      }
      return ((O.fragment = R.fragment), O);
    }
    function L(D, R, z) {
      if (typeof D === "string")
        ((D = unescape(D)), (D = H($(M(D, z), !0), { ...z, skipEscape: !0 })));
      else if (typeof D === "object") D = H($(D, !0), { ...z, skipEscape: !0 });
      if (typeof R === "string")
        ((R = unescape(R)), (R = H($(M(R, z), !0), { ...z, skipEscape: !0 })));
      else if (typeof R === "object") R = H($(R, !0), { ...z, skipEscape: !0 });
      return D.toLowerCase() === R.toLowerCase();
    }
    function H(D, R) {
      let z = {
          host: D.host,
          scheme: D.scheme,
          userinfo: D.userinfo,
          port: D.port,
          path: D.path,
          query: D.query,
          nid: D.nid,
          nss: D.nss,
          uuid: D.uuid,
          fragment: D.fragment,
          reference: D.reference,
          resourceName: D.resourceName,
          secure: D.secure,
          error: "",
        },
        E = Object.assign({}, R),
        O = [],
        Z = B[(E.scheme || z.scheme || "").toLowerCase()];
      if (Z && Z.serialize) Z.serialize(z, E);
      if (z.path !== void 0)
        if (!E.skipEscape) {
          if (((z.path = escape(z.path)), z.scheme !== void 0))
            z.path = z.path.split("%3A").join(":");
        } else z.path = unescape(z.path);
      if (E.reference !== "suffix" && z.scheme) O.push(z.scheme, ":");
      let j = U(z);
      if (j !== void 0) {
        if (E.reference !== "suffix") O.push("//");
        if ((O.push(j), z.path && z.path.charAt(0) !== "/")) O.push("/");
      }
      if (z.path !== void 0) {
        let w = z.path;
        if (!E.absolutePath && (!Z || !Z.absolutePath)) w = J(w);
        if (j === void 0) w = w.replace(/^\/\//u, "/%2F");
        O.push(w);
      }
      if (z.query !== void 0) O.push("?", z.query);
      if (z.fragment !== void 0) O.push("#", z.fragment);
      return O.join("");
    }
    var F = Array.from({ length: 127 }, (D, R) =>
      /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(R))
    );
    function N(D) {
      let R = 0;
      for (let z = 0, E = D.length; z < E; ++z)
        if (((R = D.charCodeAt(z)), R > 126 || F[R])) return !0;
      return !1;
    }
    var q =
      /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function M(D, R) {
      let z = Object.assign({}, R),
        E = {
          scheme: void 0,
          userinfo: void 0,
          host: "",
          port: void 0,
          path: "",
          query: void 0,
          fragment: void 0,
        },
        O = D.indexOf("%") !== -1,
        Z = !1;
      if (z.reference === "suffix")
        D = (z.scheme ? z.scheme + ":" : "") + "//" + D;
      let j = D.match(q);
      if (j) {
        if (
          ((E.scheme = j[1]),
          (E.userinfo = j[3]),
          (E.host = j[4]),
          (E.port = parseInt(j[5], 10)),
          (E.path = j[6] || ""),
          (E.query = j[7]),
          (E.fragment = j[8]),
          isNaN(E.port))
        )
          E.port = j[5];
        if (E.host) {
          let I = G(E.host);
          if (I.isIPV4 === !1) {
            let T = Q(I.host);
            ((E.host = T.host.toLowerCase()), (Z = T.isIPV6));
          } else ((E.host = I.host), (Z = !0));
        }
        if (
          E.scheme === void 0 &&
          E.userinfo === void 0 &&
          E.host === void 0 &&
          E.port === void 0 &&
          E.query === void 0 &&
          !E.path
        )
          E.reference = "same-document";
        else if (E.scheme === void 0) E.reference = "relative";
        else if (E.fragment === void 0) E.reference = "absolute";
        else E.reference = "uri";
        if (
          z.reference &&
          z.reference !== "suffix" &&
          z.reference !== E.reference
        )
          E.error = E.error || "URI is not a " + z.reference + " reference.";
        let w = B[(z.scheme || E.scheme || "").toLowerCase()];
        if (!z.unicodeSupport && (!w || !w.unicodeSupport)) {
          if (
            E.host &&
            (z.domainHost || (w && w.domainHost)) &&
            Z === !1 &&
            N(E.host)
          )
            try {
              E.host = URL.domainToASCII(E.host.toLowerCase());
            } catch (I) {
              E.error =
                E.error ||
                "Host's domain name can not be converted to ASCII: " + I;
            }
        }
        if (!w || (w && !w.skipNormalize)) {
          if (O && E.scheme !== void 0) E.scheme = unescape(E.scheme);
          if (O && E.host !== void 0) E.host = unescape(E.host);
          if (E.path) E.path = escape(unescape(E.path));
          if (E.fragment)
            E.fragment = encodeURI(decodeURIComponent(E.fragment));
        }
        if (w && w.parse) w.parse(E, z);
      } else E.error = E.error || "URI can not be parsed.";
      return E;
    }
    var A = {
      SCHEMES: B,
      normalize: K,
      resolve: V,
      resolveComponents: W,
      equal: L,
      serialize: H,
      parse: M,
    };
    ((Y.exports = A), (Y.exports.default = A), (Y.exports.fastUri = A));
  }),
  Lf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = fE();
    ((Y.code = 'require("ajv/dist/runtime/uri").default'), (X.default = Y));
  }),
  Bf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.CodeGen =
        X.Name =
        X.nil =
        X.stringify =
        X.str =
        X._ =
        X.KeywordCxt =
          void 0));
    var Y = WJ();
    Object.defineProperty(X, "KeywordCxt", {
      enumerable: !0,
      get: function () {
        return Y.KeywordCxt;
      },
    });
    var Q = I1();
    (Object.defineProperty(X, "_", {
      enumerable: !0,
      get: function () {
        return Q._;
      },
    }),
      Object.defineProperty(X, "str", {
        enumerable: !0,
        get: function () {
          return Q.str;
        },
      }),
      Object.defineProperty(X, "stringify", {
        enumerable: !0,
        get: function () {
          return Q.stringify;
        },
      }),
      Object.defineProperty(X, "nil", {
        enumerable: !0,
        get: function () {
          return Q.nil;
        },
      }),
      Object.defineProperty(X, "Name", {
        enumerable: !0,
        get: function () {
          return Q.Name;
        },
      }),
      Object.defineProperty(X, "CodeGen", {
        enumerable: !0,
        get: function () {
          return Q.CodeGen;
        },
      }));
    var G = fU(),
      J = HJ(),
      U = yE(),
      $ = xU(),
      B = I1(),
      K = JJ(),
      V = mG(),
      W = l1(),
      L = Wf(),
      H = Lf(),
      F = (P, x) => new RegExp(P, x);
    F.code = "new RegExp";
    var N = ["removeAdditional", "useDefaults", "coerceTypes"],
      q = new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error",
      ]),
      M = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs:
          "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode:
          "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats:
          "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now.",
      },
      A = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode:
          '"minLength"/"maxLength" account for unicode characters by default.',
      },
      D = 200;
    function R(P) {
      var x,
        r,
        C,
        v,
        k,
        o,
        J0,
        z0,
        A0,
        w0,
        Y1,
        b,
        m,
        n,
        M0,
        D0,
        Z0,
        B1,
        j1,
        v1,
        M1,
        x0,
        h1,
        g1,
        b5;
      let r0 = P.strict,
        q8 = (x = P.code) === null || x === void 0 ? void 0 : x.optimize,
        w8 = q8 === !0 || q8 === void 0 ? 1 : q8 || 0,
        Y6 =
          (C = (r = P.code) === null || r === void 0 ? void 0 : r.regExp) !==
            null && C !== void 0
            ? C
            : F,
        R8 = (v = P.uriResolver) !== null && v !== void 0 ? v : H.default;
      return {
        strictSchema:
          (o = (k = P.strictSchema) !== null && k !== void 0 ? k : r0) !==
            null && o !== void 0
            ? o
            : !0,
        strictNumbers:
          (z0 = (J0 = P.strictNumbers) !== null && J0 !== void 0 ? J0 : r0) !==
            null && z0 !== void 0
            ? z0
            : !0,
        strictTypes:
          (w0 = (A0 = P.strictTypes) !== null && A0 !== void 0 ? A0 : r0) !==
            null && w0 !== void 0
            ? w0
            : "log",
        strictTuples:
          (b = (Y1 = P.strictTuples) !== null && Y1 !== void 0 ? Y1 : r0) !==
            null && b !== void 0
            ? b
            : "log",
        strictRequired:
          (n = (m = P.strictRequired) !== null && m !== void 0 ? m : r0) !==
            null && n !== void 0
            ? n
            : !1,
        code: P.code
          ? { ...P.code, optimize: w8, regExp: Y6 }
          : { optimize: w8, regExp: Y6 },
        loopRequired: (M0 = P.loopRequired) !== null && M0 !== void 0 ? M0 : D,
        loopEnum: (D0 = P.loopEnum) !== null && D0 !== void 0 ? D0 : D,
        meta: (Z0 = P.meta) !== null && Z0 !== void 0 ? Z0 : !0,
        messages: (B1 = P.messages) !== null && B1 !== void 0 ? B1 : !0,
        inlineRefs: (j1 = P.inlineRefs) !== null && j1 !== void 0 ? j1 : !0,
        schemaId: (v1 = P.schemaId) !== null && v1 !== void 0 ? v1 : "$id",
        addUsedSchema:
          (M1 = P.addUsedSchema) !== null && M1 !== void 0 ? M1 : !0,
        validateSchema:
          (x0 = P.validateSchema) !== null && x0 !== void 0 ? x0 : !0,
        validateFormats:
          (h1 = P.validateFormats) !== null && h1 !== void 0 ? h1 : !0,
        unicodeRegExp:
          (g1 = P.unicodeRegExp) !== null && g1 !== void 0 ? g1 : !0,
        int32range: (b5 = P.int32range) !== null && b5 !== void 0 ? b5 : !0,
        uriResolver: R8,
      };
    }
    class z {
      constructor(P = {}) {
        ((this.schemas = {}),
          (this.refs = {}),
          (this.formats = {}),
          (this._compilations = new Set()),
          (this._loading = {}),
          (this._cache = new Map()),
          (P = this.opts = { ...P, ...R(P) }));
        let { es5: x, lines: r } = this.opts.code;
        ((this.scope = new B.ValueScope({
          scope: {},
          prefixes: q,
          es5: x,
          lines: r,
        })),
          (this.logger = y(P.logger)));
        let C = P.validateFormats;
        if (
          ((P.validateFormats = !1),
          (this.RULES = (0, U.getRules)()),
          E.call(this, M, P, "NOT SUPPORTED"),
          E.call(this, A, P, "DEPRECATED", "warn"),
          (this._metaOpts = I.call(this)),
          P.formats)
        )
          j.call(this);
        if ((this._addVocabularies(), this._addDefaultMetaSchema(), P.keywords))
          w.call(this, P.keywords);
        if (typeof P.meta == "object") this.addMetaSchema(P.meta);
        (Z.call(this), (P.validateFormats = C));
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        let { $data: P, meta: x, schemaId: r } = this.opts,
          C = L;
        if (r === "id") ((C = { ...L }), (C.id = C.$id), delete C.$id);
        if (x && P) this.addMetaSchema(C, C[r], !1);
      }
      defaultMeta() {
        let { meta: P, schemaId: x } = this.opts;
        return (this.opts.defaultMeta =
          typeof P == "object" ? P[x] || P : void 0);
      }
      validate(P, x) {
        let r;
        if (typeof P == "string") {
          if (((r = this.getSchema(P)), !r))
            throw Error(`no schema with key or ref "${P}"`);
        } else r = this.compile(P);
        let C = r(x);
        if (!("$async" in r)) this.errors = r.errors;
        return C;
      }
      compile(P, x) {
        let r = this._addSchema(P, x);
        return r.validate || this._compileSchemaEnv(r);
      }
      compileAsync(P, x) {
        if (typeof this.opts.loadSchema != "function")
          throw Error("options.loadSchema should be a function");
        let { loadSchema: r } = this.opts;
        return C.call(this, P, x);
        async function C(A0, w0) {
          await v.call(this, A0.$schema);
          let Y1 = this._addSchema(A0, w0);
          return Y1.validate || k.call(this, Y1);
        }
        async function v(A0) {
          if (A0 && !this.getSchema(A0)) await C.call(this, { $ref: A0 }, !0);
        }
        async function k(A0) {
          try {
            return this._compileSchemaEnv(A0);
          } catch (w0) {
            if (!(w0 instanceof J.default)) throw w0;
            return (
              o.call(this, w0),
              await J0.call(this, w0.missingSchema),
              k.call(this, A0)
            );
          }
        }
        function o({ missingSchema: A0, missingRef: w0 }) {
          if (this.refs[A0])
            throw Error(
              `AnySchema ${A0} is loaded but ${w0} cannot be resolved`
            );
        }
        async function J0(A0) {
          let w0 = await z0.call(this, A0);
          if (!this.refs[A0]) await v.call(this, w0.$schema);
          if (!this.refs[A0]) this.addSchema(w0, A0, x);
        }
        async function z0(A0) {
          let w0 = this._loading[A0];
          if (w0) return w0;
          try {
            return await (this._loading[A0] = r(A0));
          } finally {
            delete this._loading[A0];
          }
        }
      }
      addSchema(P, x, r, C = this.opts.validateSchema) {
        if (Array.isArray(P)) {
          for (let k of P) this.addSchema(k, void 0, r, C);
          return this;
        }
        let v;
        if (typeof P === "object") {
          let { schemaId: k } = this.opts;
          if (((v = P[k]), v !== void 0 && typeof v != "string"))
            throw Error(`schema ${k} must be string`);
        }
        return (
          (x = (0, K.normalizeId)(x || v)),
          this._checkUnique(x),
          (this.schemas[x] = this._addSchema(P, r, x, C, !0)),
          this
        );
      }
      addMetaSchema(P, x, r = this.opts.validateSchema) {
        return (this.addSchema(P, x, !0, r), this);
      }
      validateSchema(P, x) {
        if (typeof P == "boolean") return !0;
        let r;
        if (((r = P.$schema), r !== void 0 && typeof r != "string"))
          throw Error("$schema must be a string");
        if (((r = r || this.opts.defaultMeta || this.defaultMeta()), !r))
          return (
            this.logger.warn("meta-schema not available"),
            (this.errors = null),
            !0
          );
        let C = this.validate(r, P);
        if (!C && x) {
          let v = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log") this.logger.error(v);
          else throw Error(v);
        }
        return C;
      }
      getSchema(P) {
        let x;
        while (typeof (x = O.call(this, P)) == "string") P = x;
        if (x === void 0) {
          let { schemaId: r } = this.opts,
            C = new $.SchemaEnv({ schema: {}, schemaId: r });
          if (((x = $.resolveSchema.call(this, C, P)), !x)) return;
          this.refs[P] = x;
        }
        return x.validate || this._compileSchemaEnv(x);
      }
      removeSchema(P) {
        if (P instanceof RegExp)
          return (
            this._removeAllSchemas(this.schemas, P),
            this._removeAllSchemas(this.refs, P),
            this
          );
        switch (typeof P) {
          case "undefined":
            return (
              this._removeAllSchemas(this.schemas),
              this._removeAllSchemas(this.refs),
              this._cache.clear(),
              this
            );
          case "string": {
            let x = O.call(this, P);
            if (typeof x == "object") this._cache.delete(x.schema);
            return (delete this.schemas[P], delete this.refs[P], this);
          }
          case "object": {
            let x = P;
            this._cache.delete(x);
            let r = P[this.opts.schemaId];
            if (r)
              ((r = (0, K.normalizeId)(r)),
                delete this.schemas[r],
                delete this.refs[r]);
            return this;
          }
          default:
            throw Error("ajv.removeSchema: invalid parameter");
        }
      }
      addVocabulary(P) {
        for (let x of P) this.addKeyword(x);
        return this;
      }
      addKeyword(P, x) {
        let r;
        if (typeof P == "string") {
          if (((r = P), typeof x == "object"))
            (this.logger.warn(
              "these parameters are deprecated, see docs for addKeyword"
            ),
              (x.keyword = r));
        } else if (typeof P == "object" && x === void 0) {
          if (((x = P), (r = x.keyword), Array.isArray(r) && !r.length))
            throw Error(
              "addKeywords: keyword must be string or non-empty array"
            );
        } else throw Error("invalid addKeywords parameters");
        if ((f.call(this, r, x), !x))
          return ((0, W.eachItem)(r, (v) => l.call(this, v)), this);
        p.call(this, x);
        let C = {
          ...x,
          type: (0, V.getJSONTypes)(x.type),
          schemaType: (0, V.getJSONTypes)(x.schemaType),
        };
        return (
          (0, W.eachItem)(
            r,
            C.type.length === 0
              ? (v) => l.call(this, v, C)
              : (v) => C.type.forEach((k) => l.call(this, v, C, k))
          ),
          this
        );
      }
      getKeyword(P) {
        let x = this.RULES.all[P];
        return typeof x == "object" ? x.definition : !!x;
      }
      removeKeyword(P) {
        let { RULES: x } = this;
        (delete x.keywords[P], delete x.all[P]);
        for (let r of x.rules) {
          let C = r.rules.findIndex((v) => v.keyword === P);
          if (C >= 0) r.rules.splice(C, 1);
        }
        return this;
      }
      addFormat(P, x) {
        if (typeof x == "string") x = new RegExp(x);
        return ((this.formats[P] = x), this);
      }
      errorsText(
        P = this.errors,
        { separator: x = ", ", dataVar: r = "data" } = {}
      ) {
        if (!P || P.length === 0) return "No errors";
        return P.map((C) => `${r}${C.instancePath} ${C.message}`).reduce(
          (C, v) => C + x + v
        );
      }
      $dataMetaSchema(P, x) {
        let r = this.RULES.all;
        P = JSON.parse(JSON.stringify(P));
        for (let C of x) {
          let v = C.split("/").slice(1),
            k = P;
          for (let o of v) k = k[o];
          for (let o in r) {
            let J0 = r[o];
            if (typeof J0 != "object") continue;
            let { $data: z0 } = J0.definition,
              A0 = k[o];
            if (z0 && A0) k[o] = e(A0);
          }
        }
        return P;
      }
      _removeAllSchemas(P, x) {
        for (let r in P) {
          let C = P[r];
          if (!x || x.test(r)) {
            if (typeof C == "string") delete P[r];
            else if (C && !C.meta) (this._cache.delete(C.schema), delete P[r]);
          }
        }
      }
      _addSchema(
        P,
        x,
        r,
        C = this.opts.validateSchema,
        v = this.opts.addUsedSchema
      ) {
        let k,
          { schemaId: o } = this.opts;
        if (typeof P == "object") k = P[o];
        else if (this.opts.jtd) throw Error("schema must be object");
        else if (typeof P != "boolean")
          throw Error("schema must be object or boolean");
        let J0 = this._cache.get(P);
        if (J0 !== void 0) return J0;
        r = (0, K.normalizeId)(k || r);
        let z0 = K.getSchemaRefs.call(this, P, r);
        if (
          ((J0 = new $.SchemaEnv({
            schema: P,
            schemaId: o,
            meta: x,
            baseId: r,
            localRefs: z0,
          })),
          this._cache.set(J0.schema, J0),
          v && !r.startsWith("#"))
        ) {
          if (r) this._checkUnique(r);
          this.refs[r] = J0;
        }
        if (C) this.validateSchema(P, !0);
        return J0;
      }
      _checkUnique(P) {
        if (this.schemas[P] || this.refs[P])
          throw Error(`schema with key or id "${P}" already exists`);
      }
      _compileSchemaEnv(P) {
        if (P.meta) this._compileMetaSchema(P);
        else $.compileSchema.call(this, P);
        if (!P.validate) throw Error("ajv implementation error");
        return P.validate;
      }
      _compileMetaSchema(P) {
        let x = this.opts;
        this.opts = this._metaOpts;
        try {
          $.compileSchema.call(this, P);
        } finally {
          this.opts = x;
        }
      }
    }
    ((z.ValidationError = G.default),
      (z.MissingRefError = J.default),
      (X.default = z));
    function E(P, x, r, C = "error") {
      for (let v in P) {
        let k = v;
        if (k in x) this.logger[C](`${r}: option ${v}. ${P[k]}`);
      }
    }
    function O(P) {
      return ((P = (0, K.normalizeId)(P)), this.schemas[P] || this.refs[P]);
    }
    function Z() {
      let P = this.opts.schemas;
      if (!P) return;
      if (Array.isArray(P)) this.addSchema(P);
      else for (let x in P) this.addSchema(P[x], x);
    }
    function j() {
      for (let P in this.opts.formats) {
        let x = this.opts.formats[P];
        if (x) this.addFormat(P, x);
      }
    }
    function w(P) {
      if (Array.isArray(P)) {
        this.addVocabulary(P);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (let x in P) {
        let r = P[x];
        if (!r.keyword) r.keyword = x;
        this.addKeyword(r);
      }
    }
    function I() {
      let P = { ...this.opts };
      for (let x of N) delete P[x];
      return P;
    }
    var T = { log() {}, warn() {}, error() {} };
    function y(P) {
      if (P === !1) return T;
      if (P === void 0) return console;
      if (P.log && P.warn && P.error) return P;
      throw Error("logger must implement log, warn and error methods");
    }
    var _ = /^[a-z_$][a-z0-9_$:-]*$/i;
    function f(P, x) {
      let { RULES: r } = this;
      if (
        ((0, W.eachItem)(P, (C) => {
          if (r.keywords[C]) throw Error(`Keyword ${C} is already defined`);
          if (!_.test(C)) throw Error(`Keyword ${C} has invalid name`);
        }),
        !x)
      )
        return;
      if (x.$data && !("code" in x || "validate" in x))
        throw Error('$data keyword must have "code" or "validate" function');
    }
    function l(P, x, r) {
      var C;
      let v = x === null || x === void 0 ? void 0 : x.post;
      if (r && v) throw Error('keyword with "post" flag cannot have "type"');
      let { RULES: k } = this,
        o = v ? k.post : k.rules.find(({ type: z0 }) => z0 === r);
      if (!o) ((o = { type: r, rules: [] }), k.rules.push(o));
      if (((k.keywords[P] = !0), !x)) return;
      let J0 = {
        keyword: P,
        definition: {
          ...x,
          type: (0, V.getJSONTypes)(x.type),
          schemaType: (0, V.getJSONTypes)(x.schemaType),
        },
      };
      if (x.before) h.call(this, o, J0, x.before);
      else o.rules.push(J0);
      ((k.all[P] = J0),
        (C = x.implements) === null ||
          C === void 0 ||
          C.forEach((z0) => this.addKeyword(z0)));
    }
    function h(P, x, r) {
      let C = P.rules.findIndex((v) => v.keyword === r);
      if (C >= 0) P.rules.splice(C, 0, x);
      else (P.rules.push(x), this.logger.warn(`rule ${r} is not defined`));
    }
    function p(P) {
      let { metaSchema: x } = P;
      if (x === void 0) return;
      if (P.$data && this.opts.$data) x = e(x);
      P.validateSchema = this.compile(x, !0);
    }
    var N0 = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    };
    function e(P) {
      return { anyOf: [P, N0] };
    }
  }),
  Kf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = {
      keyword: "id",
      code() {
        throw Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      },
    };
    X.default = Y;
  }),
  Vf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.callRef = X.getValidate = void 0));
    var Y = HJ(),
      Q = d8(),
      G = I1(),
      J = g4(),
      U = xU(),
      $ = l1(),
      B = {
        keyword: "$ref",
        schemaType: "string",
        code(W) {
          let { gen: L, schema: H, it: F } = W,
            { baseId: N, schemaEnv: q, validateName: M, opts: A, self: D } = F,
            { root: R } = q;
          if ((H === "#" || H === "#/") && N === R.baseId) return E();
          let z = U.resolveRef.call(D, R, N, H);
          if (z === void 0) throw new Y.default(F.opts.uriResolver, N, H);
          if (z instanceof U.SchemaEnv) return O(z);
          return Z(z);
          function E() {
            if (q === R) return V(W, M, q, q.$async);
            let j = L.scopeValue("root", { ref: R });
            return V(W, G._`${j}.validate`, R, R.$async);
          }
          function O(j) {
            let w = K(W, j);
            V(W, w, j, j.$async);
          }
          function Z(j) {
            let w = L.scopeValue(
                "schema",
                A.code.source === !0
                  ? { ref: j, code: (0, G.stringify)(j) }
                  : { ref: j }
              ),
              I = L.name("valid"),
              T = W.subschema(
                {
                  schema: j,
                  dataTypes: [],
                  schemaPath: G.nil,
                  topSchemaRef: w,
                  errSchemaPath: H,
                },
                I
              );
            (W.mergeEvaluated(T), W.ok(I));
          }
        },
      };
    function K(W, L) {
      let { gen: H } = W;
      return L.validate
        ? H.scopeValue("validate", { ref: L.validate })
        : G._`${H.scopeValue("wrapper", { ref: L })}.validate`;
    }
    X.getValidate = K;
    function V(W, L, H, F) {
      let { gen: N, it: q } = W,
        { allErrors: M, schemaEnv: A, opts: D } = q,
        R = D.passContext ? J.default.this : G.nil;
      if (F) z();
      else E();
      function z() {
        if (!A.$async) throw Error("async schema referenced by sync schema");
        let j = N.let("valid");
        (N.try(
          () => {
            if (
              (N.code(G._`await ${(0, Q.callValidateCode)(W, L, R)}`), Z(L), !M)
            )
              N.assign(j, !0);
          },
          (w) => {
            if (
              (N.if(G._`!(${w} instanceof ${q.ValidationError})`, () =>
                N.throw(w)
              ),
              O(w),
              !M)
            )
              N.assign(j, !1);
          }
        ),
          W.ok(j));
      }
      function E() {
        W.result(
          (0, Q.callValidateCode)(W, L, R),
          () => Z(L),
          () => O(L)
        );
      }
      function O(j) {
        let w = G._`${j}.errors`;
        (N.assign(
          J.default.vErrors,
          G._`${J.default.vErrors} === null ? ${w} : ${J.default.vErrors}.concat(${w})`
        ),
          N.assign(J.default.errors, G._`${J.default.vErrors}.length`));
      }
      function Z(j) {
        var w;
        if (!q.opts.unevaluated) return;
        let I =
          (w = H === null || H === void 0 ? void 0 : H.validate) === null ||
          w === void 0
            ? void 0
            : w.evaluated;
        if (q.props !== !0)
          if (I && !I.dynamicProps) {
            if (I.props !== void 0)
              q.props = $.mergeEvaluated.props(N, I.props, q.props);
          } else {
            let T = N.var("props", G._`${j}.evaluated.props`);
            q.props = $.mergeEvaluated.props(N, T, q.props, G.Name);
          }
        if (q.items !== !0)
          if (I && !I.dynamicItems) {
            if (I.items !== void 0)
              q.items = $.mergeEvaluated.items(N, I.items, q.items);
          } else {
            let T = N.var("items", G._`${j}.evaluated.items`);
            q.items = $.mergeEvaluated.items(N, T, q.items, G.Name);
          }
      }
    }
    ((X.callRef = V), (X.default = B));
  }),
  Ff = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = Kf(),
      Q = Vf(),
      G = [
        "$schema",
        "$id",
        "$defs",
        "$vocabulary",
        { keyword: "$comment" },
        "definitions",
        Y.default,
        Q.default,
      ];
    X.default = G;
  }),
  Nf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = Y.operators,
      G = {
        maximum: { okStr: "<=", ok: Q.LTE, fail: Q.GT },
        minimum: { okStr: ">=", ok: Q.GTE, fail: Q.LT },
        exclusiveMaximum: { okStr: "<", ok: Q.LT, fail: Q.GTE },
        exclusiveMinimum: { okStr: ">", ok: Q.GT, fail: Q.LTE },
      },
      J = {
        message: ({ keyword: $, schemaCode: B }) =>
          Y.str`must be ${G[$].okStr} ${B}`,
        params: ({ keyword: $, schemaCode: B }) =>
          Y._`{comparison: ${G[$].okStr}, limit: ${B}}`,
      },
      U = {
        keyword: Object.keys(G),
        type: "number",
        schemaType: "number",
        $data: !0,
        error: J,
        code($) {
          let { keyword: B, data: K, schemaCode: V } = $;
          $.fail$data(Y._`${K} ${G[B].fail} ${V} || isNaN(${K})`);
        },
      };
    X.default = U;
  }),
  Mf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = {
        message: ({ schemaCode: J }) => Y.str`must be multiple of ${J}`,
        params: ({ schemaCode: J }) => Y._`{multipleOf: ${J}}`,
      },
      G = {
        keyword: "multipleOf",
        type: "number",
        schemaType: "number",
        $data: !0,
        error: Q,
        code(J) {
          let { gen: U, data: $, schemaCode: B, it: K } = J,
            V = K.opts.multipleOfPrecision,
            W = U.let("res"),
            L = V
              ? Y._`Math.abs(Math.round(${W}) - ${W}) > 1e-${V}`
              : Y._`${W} !== parseInt(${W})`;
          J.fail$data(Y._`(${B} === 0 || (${W} = ${$}/${B}, ${L}))`);
        },
      };
    X.default = G;
  }),
  Af = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    function Y(Q) {
      let G = Q.length,
        J = 0,
        U = 0,
        $;
      while (U < G)
        if ((J++, ($ = Q.charCodeAt(U++)), $ >= 55296 && $ <= 56319 && U < G)) {
          if ((($ = Q.charCodeAt(U)), ($ & 64512) === 56320)) U++;
        }
      return J;
    }
    ((X.default = Y),
      (Y.code = 'require("ajv/dist/runtime/ucs2length").default'));
  }),
  qf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = l1(),
      G = Af(),
      J = {
        message({ keyword: $, schemaCode: B }) {
          let K = $ === "maxLength" ? "more" : "fewer";
          return Y.str`must NOT have ${K} than ${B} characters`;
        },
        params: ({ schemaCode: $ }) => Y._`{limit: ${$}}`,
      },
      U = {
        keyword: ["maxLength", "minLength"],
        type: "string",
        schemaType: "number",
        $data: !0,
        error: J,
        code($) {
          let { keyword: B, data: K, schemaCode: V, it: W } = $,
            L = B === "maxLength" ? Y.operators.GT : Y.operators.LT,
            H =
              W.opts.unicode === !1
                ? Y._`${K}.length`
                : Y._`${(0, Q.useFunc)($.gen, G.default)}(${K})`;
          $.fail$data(Y._`${H} ${L} ${V}`);
        },
      };
    X.default = U;
  }),
  Rf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = d8(),
      Q = I1(),
      G = {
        message: ({ schemaCode: U }) => Q.str`must match pattern "${U}"`,
        params: ({ schemaCode: U }) => Q._`{pattern: ${U}}`,
      },
      J = {
        keyword: "pattern",
        type: "string",
        schemaType: "string",
        $data: !0,
        error: G,
        code(U) {
          let { data: $, $data: B, schema: K, schemaCode: V, it: W } = U,
            L = W.opts.unicodeRegExp ? "u" : "",
            H = B ? Q._`(new RegExp(${V}, ${L}))` : (0, Y.usePattern)(U, K);
          U.fail$data(Q._`!${H}.test(${$})`);
        },
      };
    X.default = J;
  }),
  Df = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = {
        message({ keyword: J, schemaCode: U }) {
          let $ = J === "maxProperties" ? "more" : "fewer";
          return Y.str`must NOT have ${$} than ${U} properties`;
        },
        params: ({ schemaCode: J }) => Y._`{limit: ${J}}`,
      },
      G = {
        keyword: ["maxProperties", "minProperties"],
        type: "object",
        schemaType: "number",
        $data: !0,
        error: Q,
        code(J) {
          let { keyword: U, data: $, schemaCode: B } = J,
            K = U === "maxProperties" ? Y.operators.GT : Y.operators.LT;
          J.fail$data(Y._`Object.keys(${$}).length ${K} ${B}`);
        },
      };
    X.default = G;
  }),
  zf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = d8(),
      Q = I1(),
      G = l1(),
      J = {
        message: ({ params: { missingProperty: $ } }) =>
          Q.str`must have required property '${$}'`,
        params: ({ params: { missingProperty: $ } }) =>
          Q._`{missingProperty: ${$}}`,
      },
      U = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: !0,
        error: J,
        code($) {
          let {
              gen: B,
              schema: K,
              schemaCode: V,
              data: W,
              $data: L,
              it: H,
            } = $,
            { opts: F } = H;
          if (!L && K.length === 0) return;
          let N = K.length >= F.loopRequired;
          if (H.allErrors) q();
          else M();
          if (F.strictRequired) {
            let R = $.parentSchema.properties,
              { definedProperties: z } = $.it;
            for (let E of K)
              if (
                (R === null || R === void 0 ? void 0 : R[E]) === void 0 &&
                !z.has(E)
              ) {
                let O = H.schemaEnv.baseId + H.errSchemaPath,
                  Z = `required property "${E}" is not defined at "${O}" (strictRequired)`;
                (0, G.checkStrictMode)(H, Z, H.opts.strictRequired);
              }
          }
          function q() {
            if (N || L) $.block$data(Q.nil, A);
            else for (let R of K) (0, Y.checkReportMissingProp)($, R);
          }
          function M() {
            let R = B.let("missing");
            if (N || L) {
              let z = B.let("valid", !0);
              ($.block$data(z, () => D(R, z)), $.ok(z));
            } else
              (B.if((0, Y.checkMissingProp)($, K, R)),
                (0, Y.reportMissingProp)($, R),
                B.else());
          }
          function A() {
            B.forOf("prop", V, (R) => {
              ($.setParams({ missingProperty: R }),
                B.if((0, Y.noPropertyInData)(B, W, R, F.ownProperties), () =>
                  $.error()
                ));
            });
          }
          function D(R, z) {
            ($.setParams({ missingProperty: R }),
              B.forOf(
                R,
                V,
                () => {
                  (B.assign(z, (0, Y.propertyInData)(B, W, R, F.ownProperties)),
                    B.if((0, Q.not)(z), () => {
                      ($.error(), B.break());
                    }));
                },
                Q.nil
              ));
          }
        },
      };
    X.default = U;
  }),
  Ef = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = {
        message({ keyword: J, schemaCode: U }) {
          let $ = J === "maxItems" ? "more" : "fewer";
          return Y.str`must NOT have ${$} than ${U} items`;
        },
        params: ({ schemaCode: J }) => Y._`{limit: ${J}}`,
      },
      G = {
        keyword: ["maxItems", "minItems"],
        type: "array",
        schemaType: "number",
        $data: !0,
        error: Q,
        code(J) {
          let { keyword: U, data: $, schemaCode: B } = J,
            K = U === "maxItems" ? Y.operators.GT : Y.operators.LT;
          J.fail$data(Y._`${$}.length ${K} ${B}`);
        },
      };
    X.default = G;
  }),
  hU = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = GJ();
    ((Y.code = 'require("ajv/dist/runtime/equal").default'), (X.default = Y));
  }),
  Of = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = mG(),
      Q = I1(),
      G = l1(),
      J = hU(),
      U = {
        message: ({ params: { i: B, j: K } }) =>
          Q.str`must NOT have duplicate items (items ## ${K} and ${B} are identical)`,
        params: ({ params: { i: B, j: K } }) => Q._`{i: ${B}, j: ${K}}`,
      },
      $ = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: !0,
        error: U,
        code(B) {
          let {
            gen: K,
            data: V,
            $data: W,
            schema: L,
            parentSchema: H,
            schemaCode: F,
            it: N,
          } = B;
          if (!W && !L) return;
          let q = K.let("valid"),
            M = H.items ? (0, Y.getSchemaTypes)(H.items) : [];
          (B.block$data(q, A, Q._`${F} === false`), B.ok(q));
          function A() {
            let E = K.let("i", Q._`${V}.length`),
              O = K.let("j");
            (B.setParams({ i: E, j: O }),
              K.assign(q, !0),
              K.if(Q._`${E} > 1`, () => (D() ? R : z)(E, O)));
          }
          function D() {
            return (
              M.length > 0 && !M.some((E) => E === "object" || E === "array")
            );
          }
          function R(E, O) {
            let Z = K.name("item"),
              j = (0, Y.checkDataTypes)(
                M,
                Z,
                N.opts.strictNumbers,
                Y.DataType.Wrong
              ),
              w = K.const("indices", Q._`{}`);
            K.for(Q._`;${E}--;`, () => {
              if (
                (K.let(Z, Q._`${V}[${E}]`),
                K.if(j, Q._`continue`),
                M.length > 1)
              )
                K.if(Q._`typeof ${Z} == "string"`, Q._`${Z} += "_"`);
              K.if(Q._`typeof ${w}[${Z}] == "number"`, () => {
                (K.assign(O, Q._`${w}[${Z}]`),
                  B.error(),
                  K.assign(q, !1).break());
              }).code(Q._`${w}[${Z}] = ${E}`);
            });
          }
          function z(E, O) {
            let Z = (0, G.useFunc)(K, J.default),
              j = K.name("outer");
            K.label(j).for(Q._`;${E}--;`, () =>
              K.for(Q._`${O} = ${E}; ${O}--;`, () =>
                K.if(Q._`${Z}(${V}[${E}], ${V}[${O}])`, () => {
                  (B.error(), K.assign(q, !1).break(j));
                })
              )
            );
          }
        },
      };
    X.default = $;
  }),
  Zf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = l1(),
      G = hU(),
      J = {
        message: "must be equal to constant",
        params: ({ schemaCode: $ }) => Y._`{allowedValue: ${$}}`,
      },
      U = {
        keyword: "const",
        $data: !0,
        error: J,
        code($) {
          let { gen: B, data: K, $data: V, schemaCode: W, schema: L } = $;
          if (V || (L && typeof L == "object"))
            $.fail$data(Y._`!${(0, Q.useFunc)(B, G.default)}(${K}, ${W})`);
          else $.fail(Y._`${L} !== ${K}`);
        },
      };
    X.default = U;
  }),
  jf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = l1(),
      G = hU(),
      J = {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode: $ }) => Y._`{allowedValues: ${$}}`,
      },
      U = {
        keyword: "enum",
        schemaType: "array",
        $data: !0,
        error: J,
        code($) {
          let {
            gen: B,
            data: K,
            $data: V,
            schema: W,
            schemaCode: L,
            it: H,
          } = $;
          if (!V && W.length === 0)
            throw Error("enum must have non-empty array");
          let F = W.length >= H.opts.loopEnum,
            N,
            q = () =>
              N !== null && N !== void 0
                ? N
                : (N = (0, Q.useFunc)(B, G.default)),
            M;
          if (F || V) ((M = B.let("valid")), $.block$data(M, A));
          else {
            if (!Array.isArray(W)) throw Error("ajv implementation error");
            let R = B.const("vSchema", L);
            M = (0, Y.or)(...W.map((z, E) => D(R, E)));
          }
          $.pass(M);
          function A() {
            (B.assign(M, !1),
              B.forOf("v", L, (R) =>
                B.if(Y._`${q()}(${K}, ${R})`, () => B.assign(M, !0).break())
              ));
          }
          function D(R, z) {
            let E = W[z];
            return typeof E === "object" && E !== null
              ? Y._`${q()}(${K}, ${R}[${z}])`
              : Y._`${K} === ${E}`;
          }
        },
      };
    X.default = U;
  }),
  wf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = Nf(),
      Q = Mf(),
      G = qf(),
      J = Rf(),
      U = Df(),
      $ = zf(),
      B = Ef(),
      K = Of(),
      V = Zf(),
      W = jf(),
      L = [
        Y.default,
        Q.default,
        G.default,
        J.default,
        U.default,
        $.default,
        B.default,
        K.default,
        { keyword: "type", schemaType: ["string", "array"] },
        { keyword: "nullable", schemaType: "boolean" },
        V.default,
        W.default,
      ];
    X.default = L;
  }),
  xE = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.validateAdditionalItems = void 0));
    var Y = I1(),
      Q = l1(),
      G = {
        message: ({ params: { len: $ } }) =>
          Y.str`must NOT have more than ${$} items`,
        params: ({ params: { len: $ } }) => Y._`{limit: ${$}}`,
      },
      J = {
        keyword: "additionalItems",
        type: "array",
        schemaType: ["boolean", "object"],
        before: "uniqueItems",
        error: G,
        code($) {
          let { parentSchema: B, it: K } = $,
            { items: V } = B;
          if (!Array.isArray(V)) {
            (0, Q.checkStrictMode)(
              K,
              '"additionalItems" is ignored when "items" is not an array of schemas'
            );
            return;
          }
          U($, V);
        },
      };
    function U($, B) {
      let { gen: K, schema: V, data: W, keyword: L, it: H } = $;
      H.items = !0;
      let F = K.const("len", Y._`${W}.length`);
      if (V === !1)
        ($.setParams({ len: B.length }), $.pass(Y._`${F} <= ${B.length}`));
      else if (typeof V == "object" && !(0, Q.alwaysValidSchema)(H, V)) {
        let q = K.var("valid", Y._`${F} <= ${B.length}`);
        (K.if((0, Y.not)(q), () => N(q)), $.ok(q));
      }
      function N(q) {
        K.forRange("i", B.length, F, (M) => {
          if (
            ($.subschema(
              { keyword: L, dataProp: M, dataPropType: Q.Type.Num },
              q
            ),
            !H.allErrors)
          )
            K.if((0, Y.not)(q), () => K.break());
        });
      }
    }
    ((X.validateAdditionalItems = U), (X.default = J));
  }),
  hE = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.validateTuple = void 0));
    var Y = I1(),
      Q = l1(),
      G = d8(),
      J = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "array", "boolean"],
        before: "uniqueItems",
        code($) {
          let { schema: B, it: K } = $;
          if (Array.isArray(B)) return U($, "additionalItems", B);
          if (((K.items = !0), (0, Q.alwaysValidSchema)(K, B))) return;
          $.ok((0, G.validateArray)($));
        },
      };
    function U($, B, K = $.schema) {
      let { gen: V, parentSchema: W, data: L, keyword: H, it: F } = $;
      if ((M(W), F.opts.unevaluated && K.length && F.items !== !0))
        F.items = Q.mergeEvaluated.items(V, K.length, F.items);
      let N = V.name("valid"),
        q = V.const("len", Y._`${L}.length`);
      K.forEach((A, D) => {
        if ((0, Q.alwaysValidSchema)(F, A)) return;
        (V.if(Y._`${q} > ${D}`, () =>
          $.subschema({ keyword: H, schemaProp: D, dataProp: D }, N)
        ),
          $.ok(N));
      });
      function M(A) {
        let { opts: D, errSchemaPath: R } = F,
          z = K.length,
          E = z === A.minItems && (z === A.maxItems || A[B] === !1);
        if (D.strictTuples && !E) {
          let O = `"${H}" is ${z}-tuple, but minItems or maxItems/${B} are not specified or different at path "${R}"`;
          (0, Q.checkStrictMode)(F, O, D.strictTuples);
        }
      }
    }
    ((X.validateTuple = U), (X.default = J));
  }),
  Cf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = hE(),
      Q = {
        keyword: "prefixItems",
        type: "array",
        schemaType: ["array"],
        before: "uniqueItems",
        code: (G) => (0, Y.validateTuple)(G, "items"),
      };
    X.default = Q;
  }),
  If = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = l1(),
      G = d8(),
      J = xE(),
      U = {
        message: ({ params: { len: B } }) =>
          Y.str`must NOT have more than ${B} items`,
        params: ({ params: { len: B } }) => Y._`{limit: ${B}}`,
      },
      $ = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        error: U,
        code(B) {
          let { schema: K, parentSchema: V, it: W } = B,
            { prefixItems: L } = V;
          if (((W.items = !0), (0, Q.alwaysValidSchema)(W, K))) return;
          if (L) (0, J.validateAdditionalItems)(B, L);
          else B.ok((0, G.validateArray)(B));
        },
      };
    X.default = $;
  }),
  Pf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = l1(),
      G = {
        message: ({ params: { min: U, max: $ } }) =>
          $ === void 0
            ? Y.str`must contain at least ${U} valid item(s)`
            : Y.str`must contain at least ${U} and no more than ${$} valid item(s)`,
        params: ({ params: { min: U, max: $ } }) =>
          $ === void 0
            ? Y._`{minContains: ${U}}`
            : Y._`{minContains: ${U}, maxContains: ${$}}`,
      },
      J = {
        keyword: "contains",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        trackErrors: !0,
        error: G,
        code(U) {
          let { gen: $, schema: B, parentSchema: K, data: V, it: W } = U,
            L,
            H,
            { minContains: F, maxContains: N } = K;
          if (W.opts.next) ((L = F === void 0 ? 1 : F), (H = N));
          else L = 1;
          let q = $.const("len", Y._`${V}.length`);
          if ((U.setParams({ min: L, max: H }), H === void 0 && L === 0)) {
            (0, Q.checkStrictMode)(
              W,
              '"minContains" == 0 without "maxContains": "contains" keyword ignored'
            );
            return;
          }
          if (H !== void 0 && L > H) {
            ((0, Q.checkStrictMode)(
              W,
              '"minContains" > "maxContains" is always invalid'
            ),
              U.fail());
            return;
          }
          if ((0, Q.alwaysValidSchema)(W, B)) {
            let z = Y._`${q} >= ${L}`;
            if (H !== void 0) z = Y._`${z} && ${q} <= ${H}`;
            U.pass(z);
            return;
          }
          W.items = !0;
          let M = $.name("valid");
          if (H === void 0 && L === 1) D(M, () => $.if(M, () => $.break()));
          else if (L === 0) {
            if (($.let(M, !0), H !== void 0)) $.if(Y._`${V}.length > 0`, A);
          } else ($.let(M, !1), A());
          U.result(M, () => U.reset());
          function A() {
            let z = $.name("_valid"),
              E = $.let("count", 0);
            D(z, () => $.if(z, () => R(E)));
          }
          function D(z, E) {
            $.forRange("i", 0, q, (O) => {
              (U.subschema(
                {
                  keyword: "contains",
                  dataProp: O,
                  dataPropType: Q.Type.Num,
                  compositeRule: !0,
                },
                z
              ),
                E());
            });
          }
          function R(z) {
            if (($.code(Y._`${z}++`), H === void 0))
              $.if(Y._`${z} >= ${L}`, () => $.assign(M, !0).break());
            else if (
              ($.if(Y._`${z} > ${H}`, () => $.assign(M, !1).break()), L === 1)
            )
              $.assign(M, !0);
            else $.if(Y._`${z} >= ${L}`, () => $.assign(M, !0));
          }
        },
      };
    X.default = J;
  }),
  Sf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.validateSchemaDeps = X.validatePropertyDeps = X.error = void 0));
    var Y = I1(),
      Q = l1(),
      G = d8();
    X.error = {
      message: ({ params: { property: K, depsCount: V, deps: W } }) => {
        let L = V === 1 ? "property" : "properties";
        return Y.str`must have ${L} ${W} when property ${K} is present`;
      },
      params: ({
        params: { property: K, depsCount: V, deps: W, missingProperty: L },
      }) => Y._`{property: ${K},
    missingProperty: ${L},
    depsCount: ${V},
    deps: ${W}}`,
    };
    var J = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: X.error,
      code(K) {
        let [V, W] = U(K);
        ($(K, V), B(K, W));
      },
    };
    function U({ schema: K }) {
      let V = {},
        W = {};
      for (let L in K) {
        if (L === "__proto__") continue;
        let H = Array.isArray(K[L]) ? V : W;
        H[L] = K[L];
      }
      return [V, W];
    }
    function $(K, V = K.schema) {
      let { gen: W, data: L, it: H } = K;
      if (Object.keys(V).length === 0) return;
      let F = W.let("missing");
      for (let N in V) {
        let q = V[N];
        if (q.length === 0) continue;
        let M = (0, G.propertyInData)(W, L, N, H.opts.ownProperties);
        if (
          (K.setParams({
            property: N,
            depsCount: q.length,
            deps: q.join(", "),
          }),
          H.allErrors)
        )
          W.if(M, () => {
            for (let A of q) (0, G.checkReportMissingProp)(K, A);
          });
        else
          (W.if(Y._`${M} && (${(0, G.checkMissingProp)(K, q, F)})`),
            (0, G.reportMissingProp)(K, F),
            W.else());
      }
    }
    X.validatePropertyDeps = $;
    function B(K, V = K.schema) {
      let { gen: W, data: L, keyword: H, it: F } = K,
        N = W.name("valid");
      for (let q in V) {
        if ((0, Q.alwaysValidSchema)(F, V[q])) continue;
        (W.if(
          (0, G.propertyInData)(W, L, q, F.opts.ownProperties),
          () => {
            let M = K.subschema({ keyword: H, schemaProp: q }, N);
            K.mergeValidEvaluated(M, N);
          },
          () => W.var(N, !0)
        ),
          K.ok(N));
      }
    }
    ((X.validateSchemaDeps = B), (X.default = J));
  }),
  Tf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = l1(),
      G = {
        message: "property name must be valid",
        params: ({ params: U }) => Y._`{propertyName: ${U.propertyName}}`,
      },
      J = {
        keyword: "propertyNames",
        type: "object",
        schemaType: ["object", "boolean"],
        error: G,
        code(U) {
          let { gen: $, schema: B, data: K, it: V } = U;
          if ((0, Q.alwaysValidSchema)(V, B)) return;
          let W = $.name("valid");
          ($.forIn("key", K, (L) => {
            (U.setParams({ propertyName: L }),
              U.subschema(
                {
                  keyword: "propertyNames",
                  data: L,
                  dataTypes: ["string"],
                  propertyName: L,
                  compositeRule: !0,
                },
                W
              ),
              $.if((0, Y.not)(W), () => {
                if ((U.error(!0), !V.allErrors)) $.break();
              }));
          }),
            U.ok(W));
        },
      };
    X.default = J;
  }),
  gE = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = d8(),
      Q = I1(),
      G = g4(),
      J = l1(),
      U = {
        message: "must NOT have additional properties",
        params: ({ params: B }) =>
          Q._`{additionalProperty: ${B.additionalProperty}}`,
      },
      $ = {
        keyword: "additionalProperties",
        type: ["object"],
        schemaType: ["boolean", "object"],
        allowUndefined: !0,
        trackErrors: !0,
        error: U,
        code(B) {
          let {
            gen: K,
            schema: V,
            parentSchema: W,
            data: L,
            errsCount: H,
            it: F,
          } = B;
          if (!H) throw Error("ajv implementation error");
          let { allErrors: N, opts: q } = F;
          if (
            ((F.props = !0),
            q.removeAdditional !== "all" && (0, J.alwaysValidSchema)(F, V))
          )
            return;
          let M = (0, Y.allSchemaProperties)(W.properties),
            A = (0, Y.allSchemaProperties)(W.patternProperties);
          (D(), B.ok(Q._`${H} === ${G.default.errors}`));
          function D() {
            K.forIn("key", L, (Z) => {
              if (!M.length && !A.length) E(Z);
              else K.if(R(Z), () => E(Z));
            });
          }
          function R(Z) {
            let j;
            if (M.length > 8) {
              let w = (0, J.schemaRefOrVal)(F, W.properties, "properties");
              j = (0, Y.isOwnProperty)(K, w, Z);
            } else if (M.length)
              j = (0, Q.or)(...M.map((w) => Q._`${Z} === ${w}`));
            else j = Q.nil;
            if (A.length)
              j = (0, Q.or)(
                j,
                ...A.map((w) => Q._`${(0, Y.usePattern)(B, w)}.test(${Z})`)
              );
            return (0, Q.not)(j);
          }
          function z(Z) {
            K.code(Q._`delete ${L}[${Z}]`);
          }
          function E(Z) {
            if (
              q.removeAdditional === "all" ||
              (q.removeAdditional && V === !1)
            ) {
              z(Z);
              return;
            }
            if (V === !1) {
              if ((B.setParams({ additionalProperty: Z }), B.error(), !N))
                K.break();
              return;
            }
            if (typeof V == "object" && !(0, J.alwaysValidSchema)(F, V)) {
              let j = K.name("valid");
              if (q.removeAdditional === "failing")
                (O(Z, j, !1),
                  K.if((0, Q.not)(j), () => {
                    (B.reset(), z(Z));
                  }));
              else if ((O(Z, j), !N)) K.if((0, Q.not)(j), () => K.break());
            }
          }
          function O(Z, j, w) {
            let I = {
              keyword: "additionalProperties",
              dataProp: Z,
              dataPropType: J.Type.Str,
            };
            if (w === !1)
              Object.assign(I, {
                compositeRule: !0,
                createErrors: !1,
                allErrors: !1,
              });
            B.subschema(I, j);
          }
        },
      };
    X.default = $;
  }),
  bf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = WJ(),
      Q = d8(),
      G = l1(),
      J = gE(),
      U = {
        keyword: "properties",
        type: "object",
        schemaType: "object",
        code($) {
          let { gen: B, schema: K, parentSchema: V, data: W, it: L } = $;
          if (
            L.opts.removeAdditional === "all" &&
            V.additionalProperties === void 0
          )
            J.default.code(
              new Y.KeywordCxt(L, J.default, "additionalProperties")
            );
          let H = (0, Q.allSchemaProperties)(K);
          for (let A of H) L.definedProperties.add(A);
          if (L.opts.unevaluated && H.length && L.props !== !0)
            L.props = G.mergeEvaluated.props(B, (0, G.toHash)(H), L.props);
          let F = H.filter((A) => !(0, G.alwaysValidSchema)(L, K[A]));
          if (F.length === 0) return;
          let N = B.name("valid");
          for (let A of F) {
            if (q(A)) M(A);
            else {
              if (
                (B.if((0, Q.propertyInData)(B, W, A, L.opts.ownProperties)),
                M(A),
                !L.allErrors)
              )
                B.else().var(N, !0);
              B.endIf();
            }
            ($.it.definedProperties.add(A), $.ok(N));
          }
          function q(A) {
            return (
              L.opts.useDefaults && !L.compositeRule && K[A].default !== void 0
            );
          }
          function M(A) {
            $.subschema(
              { keyword: "properties", schemaProp: A, dataProp: A },
              N
            );
          }
        },
      };
    X.default = U;
  }),
  vf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = d8(),
      Q = I1(),
      G = l1(),
      J = l1(),
      U = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code($) {
          let { gen: B, schema: K, data: V, parentSchema: W, it: L } = $,
            { opts: H } = L,
            F = (0, Y.allSchemaProperties)(K),
            N = F.filter((E) => (0, G.alwaysValidSchema)(L, K[E]));
          if (
            F.length === 0 ||
            (N.length === F.length && (!L.opts.unevaluated || L.props === !0))
          )
            return;
          let q = H.strictSchema && !H.allowMatchingProperties && W.properties,
            M = B.name("valid");
          if (L.props !== !0 && !(L.props instanceof Q.Name))
            L.props = (0, J.evaluatedPropsToName)(B, L.props);
          let { props: A } = L;
          D();
          function D() {
            for (let E of F) {
              if (q) R(E);
              if (L.allErrors) z(E);
              else (B.var(M, !0), z(E), B.if(M));
            }
          }
          function R(E) {
            for (let O in q)
              if (new RegExp(E).test(O))
                (0, G.checkStrictMode)(
                  L,
                  `property ${O} matches pattern ${E} (use allowMatchingProperties)`
                );
          }
          function z(E) {
            B.forIn("key", V, (O) => {
              B.if(Q._`${(0, Y.usePattern)($, E)}.test(${O})`, () => {
                let Z = N.includes(E);
                if (!Z)
                  $.subschema(
                    {
                      keyword: "patternProperties",
                      schemaProp: E,
                      dataProp: O,
                      dataPropType: J.Type.Str,
                    },
                    M
                  );
                if (L.opts.unevaluated && A !== !0)
                  B.assign(Q._`${A}[${O}]`, !0);
                else if (!Z && !L.allErrors)
                  B.if((0, Q.not)(M), () => B.break());
              });
            });
          }
        },
      };
    X.default = U;
  }),
  kf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = l1(),
      Q = {
        keyword: "not",
        schemaType: ["object", "boolean"],
        trackErrors: !0,
        code(G) {
          let { gen: J, schema: U, it: $ } = G;
          if ((0, Y.alwaysValidSchema)($, U)) {
            G.fail();
            return;
          }
          let B = J.name("valid");
          (G.subschema(
            {
              keyword: "not",
              compositeRule: !0,
              createErrors: !1,
              allErrors: !1,
            },
            B
          ),
            G.failResult(
              B,
              () => G.reset(),
              () => G.error()
            ));
        },
        error: { message: "must NOT be valid" },
      };
    X.default = Q;
  }),
  yf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = d8(),
      Q = {
        keyword: "anyOf",
        schemaType: "array",
        trackErrors: !0,
        code: Y.validateUnion,
        error: { message: "must match a schema in anyOf" },
      };
    X.default = Q;
  }),
  _f = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = l1(),
      G = {
        message: "must match exactly one schema in oneOf",
        params: ({ params: U }) => Y._`{passingSchemas: ${U.passing}}`,
      },
      J = {
        keyword: "oneOf",
        schemaType: "array",
        trackErrors: !0,
        error: G,
        code(U) {
          let { gen: $, schema: B, parentSchema: K, it: V } = U;
          if (!Array.isArray(B)) throw Error("ajv implementation error");
          if (V.opts.discriminator && K.discriminator) return;
          let W = B,
            L = $.let("valid", !1),
            H = $.let("passing", null),
            F = $.name("_valid");
          (U.setParams({ passing: H }),
            $.block(N),
            U.result(
              L,
              () => U.reset(),
              () => U.error(!0)
            ));
          function N() {
            W.forEach((q, M) => {
              let A;
              if ((0, Q.alwaysValidSchema)(V, q)) $.var(F, !0);
              else
                A = U.subschema(
                  { keyword: "oneOf", schemaProp: M, compositeRule: !0 },
                  F
                );
              if (M > 0)
                $.if(Y._`${F} && ${L}`)
                  .assign(L, !1)
                  .assign(H, Y._`[${H}, ${M}]`)
                  .else();
              $.if(F, () => {
                if (($.assign(L, !0), $.assign(H, M), A))
                  U.mergeEvaluated(A, Y.Name);
              });
            });
          }
        },
      };
    X.default = J;
  }),
  ff = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = l1(),
      Q = {
        keyword: "allOf",
        schemaType: "array",
        code(G) {
          let { gen: J, schema: U, it: $ } = G;
          if (!Array.isArray(U)) throw Error("ajv implementation error");
          let B = J.name("valid");
          U.forEach((K, V) => {
            if ((0, Y.alwaysValidSchema)($, K)) return;
            let W = G.subschema({ keyword: "allOf", schemaProp: V }, B);
            (G.ok(B), G.mergeEvaluated(W));
          });
        },
      };
    X.default = Q;
  }),
  xf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = l1(),
      G = {
        message: ({ params: $ }) => Y.str`must match "${$.ifClause}" schema`,
        params: ({ params: $ }) => Y._`{failingKeyword: ${$.ifClause}}`,
      },
      J = {
        keyword: "if",
        schemaType: ["object", "boolean"],
        trackErrors: !0,
        error: G,
        code($) {
          let { gen: B, parentSchema: K, it: V } = $;
          if (K.then === void 0 && K.else === void 0)
            (0, Q.checkStrictMode)(
              V,
              '"if" without "then" and "else" is ignored'
            );
          let W = U(V, "then"),
            L = U(V, "else");
          if (!W && !L) return;
          let H = B.let("valid", !0),
            F = B.name("_valid");
          if ((N(), $.reset(), W && L)) {
            let M = B.let("ifClause");
            ($.setParams({ ifClause: M }), B.if(F, q("then", M), q("else", M)));
          } else if (W) B.if(F, q("then"));
          else B.if((0, Y.not)(F), q("else"));
          $.pass(H, () => $.error(!0));
          function N() {
            let M = $.subschema(
              {
                keyword: "if",
                compositeRule: !0,
                createErrors: !1,
                allErrors: !1,
              },
              F
            );
            $.mergeEvaluated(M);
          }
          function q(M, A) {
            return () => {
              let D = $.subschema({ keyword: M }, F);
              if ((B.assign(H, F), $.mergeValidEvaluated(D, H), A))
                B.assign(A, Y._`${M}`);
              else $.setParams({ ifClause: M });
            };
          }
        },
      };
    function U($, B) {
      let K = $.schema[B];
      return K !== void 0 && !(0, Q.alwaysValidSchema)($, K);
    }
    X.default = J;
  }),
  hf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = l1(),
      Q = {
        keyword: ["then", "else"],
        schemaType: ["object", "boolean"],
        code({ keyword: G, parentSchema: J, it: U }) {
          if (J.if === void 0)
            (0, Y.checkStrictMode)(U, `"${G}" without "if" is ignored`);
        },
      };
    X.default = Q;
  }),
  gf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = xE(),
      Q = Cf(),
      G = hE(),
      J = If(),
      U = Pf(),
      $ = Sf(),
      B = Tf(),
      K = gE(),
      V = bf(),
      W = vf(),
      L = kf(),
      H = yf(),
      F = _f(),
      N = ff(),
      q = xf(),
      M = hf();
    function A(D = !1) {
      let R = [
        L.default,
        H.default,
        F.default,
        N.default,
        q.default,
        M.default,
        B.default,
        K.default,
        $.default,
        V.default,
        W.default,
      ];
      if (D) R.push(Q.default, J.default);
      else R.push(Y.default, G.default);
      return (R.push(U.default), R);
    }
    X.default = A;
  }),
  uf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = {
        message: ({ schemaCode: J }) => Y.str`must match format "${J}"`,
        params: ({ schemaCode: J }) => Y._`{format: ${J}}`,
      },
      G = {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: !0,
        error: Q,
        code(J, U) {
          let {
              gen: $,
              data: B,
              $data: K,
              schema: V,
              schemaCode: W,
              it: L,
            } = J,
            { opts: H, errSchemaPath: F, schemaEnv: N, self: q } = L;
          if (!H.validateFormats) return;
          if (K) M();
          else A();
          function M() {
            let D = $.scopeValue("formats", {
                ref: q.formats,
                code: H.code.formats,
              }),
              R = $.const("fDef", Y._`${D}[${W}]`),
              z = $.let("fType"),
              E = $.let("format");
            ($.if(
              Y._`typeof ${R} == "object" && !(${R} instanceof RegExp)`,
              () =>
                $.assign(z, Y._`${R}.type || "string"`).assign(
                  E,
                  Y._`${R}.validate`
                ),
              () => $.assign(z, Y._`"string"`).assign(E, R)
            ),
              J.fail$data((0, Y.or)(O(), Z())));
            function O() {
              if (H.strictSchema === !1) return Y.nil;
              return Y._`${W} && !${E}`;
            }
            function Z() {
              let j = N.$async
                  ? Y._`(${R}.async ? await ${E}(${B}) : ${E}(${B}))`
                  : Y._`${E}(${B})`,
                w = Y._`(typeof ${E} == "function" ? ${j} : ${E}.test(${B}))`;
              return Y._`${E} && ${E} !== true && ${z} === ${U} && !${w}`;
            }
          }
          function A() {
            let D = q.formats[V];
            if (!D) {
              O();
              return;
            }
            if (D === !0) return;
            let [R, z, E] = Z(D);
            if (R === U) J.pass(j());
            function O() {
              if (H.strictSchema === !1) {
                q.logger.warn(w());
                return;
              }
              throw Error(w());
              function w() {
                return `unknown format "${V}" ignored in schema at path "${F}"`;
              }
            }
            function Z(w) {
              let I =
                  w instanceof RegExp
                    ? (0, Y.regexpCode)(w)
                    : H.code.formats
                      ? Y._`${H.code.formats}${(0, Y.getProperty)(V)}`
                      : void 0,
                T = $.scopeValue("formats", { key: V, ref: w, code: I });
              if (typeof w == "object" && !(w instanceof RegExp))
                return [w.type || "string", w.validate, Y._`${T}.validate`];
              return ["string", w, T];
            }
            function j() {
              if (typeof D == "object" && !(D instanceof RegExp) && D.async) {
                if (!N.$async) throw Error("async format in sync schema");
                return Y._`await ${E}(${B})`;
              }
              return typeof z == "function"
                ? Y._`${E}(${B})`
                : Y._`${E}.test(${B})`;
            }
          }
        },
      };
    X.default = G;
  }),
  lf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = uf(),
      Q = [Y.default];
    X.default = Q;
  }),
  mf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.contentVocabulary = X.metadataVocabulary = void 0),
      (X.metadataVocabulary = [
        "title",
        "description",
        "default",
        "deprecated",
        "readOnly",
        "writeOnly",
        "examples",
      ]),
      (X.contentVocabulary = [
        "contentMediaType",
        "contentEncoding",
        "contentSchema",
      ]));
  }),
  cf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = Ff(),
      Q = wf(),
      G = gf(),
      J = lf(),
      U = mf(),
      $ = [
        Y.default,
        Q.default,
        (0, G.default)(),
        J.default,
        U.metadataVocabulary,
        U.contentVocabulary,
      ];
    X.default = $;
  }),
  df = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.DiscrError = void 0));
    var Y;
    (function (Q) {
      ((Q.Tag = "tag"), (Q.Mapping = "mapping"));
    })(Y || (X.DiscrError = Y = {}));
  }),
  pf = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = I1(),
      Q = df(),
      G = xU(),
      J = HJ(),
      U = l1(),
      $ = {
        message: ({ params: { discrError: K, tagName: V } }) =>
          K === Q.DiscrError.Tag
            ? `tag "${V}" must be string`
            : `value of tag "${V}" must be in oneOf`,
        params: ({ params: { discrError: K, tag: V, tagName: W } }) =>
          Y._`{error: ${K}, tag: ${W}, tagValue: ${V}}`,
      },
      B = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error: $,
        code(K) {
          let { gen: V, data: W, schema: L, parentSchema: H, it: F } = K,
            { oneOf: N } = H;
          if (!F.opts.discriminator)
            throw Error("discriminator: requires discriminator option");
          let q = L.propertyName;
          if (typeof q != "string")
            throw Error("discriminator: requires propertyName");
          if (L.mapping) throw Error("discriminator: mapping is not supported");
          if (!N) throw Error("discriminator: requires oneOf keyword");
          let M = V.let("valid", !1),
            A = V.const("tag", Y._`${W}${(0, Y.getProperty)(q)}`);
          (V.if(
            Y._`typeof ${A} == "string"`,
            () => D(),
            () =>
              K.error(!1, { discrError: Q.DiscrError.Tag, tag: A, tagName: q })
          ),
            K.ok(M));
          function D() {
            let E = z();
            V.if(!1);
            for (let O in E)
              (V.elseIf(Y._`${A} === ${O}`), V.assign(M, R(E[O])));
            (V.else(),
              K.error(!1, {
                discrError: Q.DiscrError.Mapping,
                tag: A,
                tagName: q,
              }),
              V.endIf());
          }
          function R(E) {
            let O = V.name("valid"),
              Z = K.subschema({ keyword: "oneOf", schemaProp: E }, O);
            return (K.mergeEvaluated(Z, Y.Name), O);
          }
          function z() {
            var E;
            let O = {},
              Z = w(H),
              j = !0;
            for (let y = 0; y < N.length; y++) {
              let _ = N[y];
              if (
                (_ === null || _ === void 0 ? void 0 : _.$ref) &&
                !(0, U.schemaHasRulesButRef)(_, F.self.RULES)
              ) {
                let l = _.$ref;
                if (
                  ((_ = G.resolveRef.call(
                    F.self,
                    F.schemaEnv.root,
                    F.baseId,
                    l
                  )),
                  _ instanceof G.SchemaEnv)
                )
                  _ = _.schema;
                if (_ === void 0)
                  throw new J.default(F.opts.uriResolver, F.baseId, l);
              }
              let f =
                (E = _ === null || _ === void 0 ? void 0 : _.properties) ===
                  null || E === void 0
                  ? void 0
                  : E[q];
              if (typeof f != "object")
                throw Error(
                  `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${q}"`
                );
              ((j = j && (Z || w(_))), I(f, y));
            }
            if (!j) throw Error(`discriminator: "${q}" must be required`);
            return O;
            function w({ required: y }) {
              return Array.isArray(y) && y.includes(q);
            }
            function I(y, _) {
              if (y.const) T(y.const, _);
              else if (y.enum) for (let f of y.enum) T(f, _);
              else
                throw Error(
                  `discriminator: "properties/${q}" must have "const" or "enum"`
                );
            }
            function T(y, _) {
              if (typeof y != "string" || y in O)
                throw Error(
                  `discriminator: "${q}" values must be unique strings`
                );
              O[y] = _;
            }
          }
        },
      };
    X.default = B;
  }),
  nf = L0((X, Y) => {
    Y.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
        nonNegativeInteger: { type: "integer", minimum: 0 },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string",
          ],
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: !0,
          default: [],
        },
      },
      type: ["object", "boolean"],
      properties: {
        $id: { type: "string", format: "uri-reference" },
        $schema: { type: "string", format: "uri" },
        $ref: { type: "string", format: "uri-reference" },
        $comment: { type: "string" },
        title: { type: "string" },
        description: { type: "string" },
        default: !0,
        readOnly: { type: "boolean", default: !1 },
        examples: { type: "array", items: !0 },
        multipleOf: { type: "number", exclusiveMinimum: 0 },
        maximum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: { type: "string", format: "regex" },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: !0,
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: { type: "boolean", default: !1 },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {},
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {},
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {},
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
          },
        },
        propertyNames: { $ref: "#" },
        const: !0,
        enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: !0,
            },
          ],
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" },
      },
      default: !0,
    };
  }),
  af = L0((X, Y) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.MissingRefError =
        X.ValidationError =
        X.CodeGen =
        X.Name =
        X.nil =
        X.stringify =
        X.str =
        X._ =
        X.KeywordCxt =
        X.Ajv =
          void 0));
    var Q = Bf(),
      G = cf(),
      J = pf(),
      U = nf(),
      $ = ["/properties"],
      B = "http://json-schema.org/draft-07/schema";
    class K extends Q.default {
      _addVocabularies() {
        if (
          (super._addVocabularies(),
          G.default.forEach((F) => this.addVocabulary(F)),
          this.opts.discriminator)
        )
          this.addKeyword(J.default);
      }
      _addDefaultMetaSchema() {
        if ((super._addDefaultMetaSchema(), !this.opts.meta)) return;
        let F = this.opts.$data ? this.$dataMetaSchema(U, $) : U;
        (this.addMetaSchema(F, B, !1),
          (this.refs["http://json-schema.org/schema"] = B));
      }
      defaultMeta() {
        return (this.opts.defaultMeta =
          super.defaultMeta() || (this.getSchema(B) ? B : void 0));
      }
    }
    ((X.Ajv = K),
      (Y.exports = X = K),
      (Y.exports.Ajv = K),
      Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.default = K));
    var V = WJ();
    Object.defineProperty(X, "KeywordCxt", {
      enumerable: !0,
      get: function () {
        return V.KeywordCxt;
      },
    });
    var W = I1();
    (Object.defineProperty(X, "_", {
      enumerable: !0,
      get: function () {
        return W._;
      },
    }),
      Object.defineProperty(X, "str", {
        enumerable: !0,
        get: function () {
          return W.str;
        },
      }),
      Object.defineProperty(X, "stringify", {
        enumerable: !0,
        get: function () {
          return W.stringify;
        },
      }),
      Object.defineProperty(X, "nil", {
        enumerable: !0,
        get: function () {
          return W.nil;
        },
      }),
      Object.defineProperty(X, "Name", {
        enumerable: !0,
        get: function () {
          return W.Name;
        },
      }),
      Object.defineProperty(X, "CodeGen", {
        enumerable: !0,
        get: function () {
          return W.CodeGen;
        },
      }));
    var L = fU();
    Object.defineProperty(X, "ValidationError", {
      enumerable: !0,
      get: function () {
        return L.default;
      },
    });
    var H = HJ();
    Object.defineProperty(X, "MissingRefError", {
      enumerable: !0,
      get: function () {
        return H.default;
      },
    });
  }),
  rf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.formatNames = X.fastFormats = X.fullFormats = void 0));
    function Y(T, y) {
      return { validate: T, compare: y };
    }
    ((X.fullFormats = {
      date: Y(U, $),
      time: Y(K(!0), V),
      "date-time": Y(H(!0), F),
      "iso-time": Y(K(), W),
      "iso-date-time": Y(H(), N),
      duration:
        /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri: A,
      "uri-reference":
        /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      "uri-template":
        /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email:
        /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname:
        /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex: I,
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment":
        /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      "relative-json-pointer":
        /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      byte: R,
      int32: { type: "number", validate: O },
      int64: { type: "number", validate: Z },
      float: { type: "number", validate: j },
      double: { type: "number", validate: j },
      password: !0,
      binary: !0,
    }),
      (X.fastFormats = {
        ...X.fullFormats,
        date: Y(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, $),
        time: Y(
          /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
          V
        ),
        "date-time": Y(
          /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
          F
        ),
        "iso-time": Y(
          /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
          W
        ),
        "iso-date-time": Y(
          /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
          N
        ),
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference":
          /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        email:
          /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      }),
      (X.formatNames = Object.keys(X.fullFormats)));
    function Q(T) {
      return T % 4 === 0 && (T % 100 !== 0 || T % 400 === 0);
    }
    var G = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
      J = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function U(T) {
      let y = G.exec(T);
      if (!y) return !1;
      let _ = +y[1],
        f = +y[2],
        l = +y[3];
      return f >= 1 && f <= 12 && l >= 1 && l <= (f === 2 && Q(_) ? 29 : J[f]);
    }
    function $(T, y) {
      if (!(T && y)) return;
      if (T > y) return 1;
      if (T < y) return -1;
      return 0;
    }
    var B = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function K(T) {
      return function (_) {
        let f = B.exec(_);
        if (!f) return !1;
        let l = +f[1],
          h = +f[2],
          p = +f[3],
          N0 = f[4],
          e = f[5] === "-" ? -1 : 1,
          P = +(f[6] || 0),
          x = +(f[7] || 0);
        if (P > 23 || x > 59 || (T && !N0)) return !1;
        if (l <= 23 && h <= 59 && p < 60) return !0;
        let r = h - x * e,
          C = l - P * e - (r < 0 ? 1 : 0);
        return (C === 23 || C === -1) && (r === 59 || r === -1) && p < 61;
      };
    }
    function V(T, y) {
      if (!(T && y)) return;
      let _ = new Date("2020-01-01T" + T).valueOf(),
        f = new Date("2020-01-01T" + y).valueOf();
      if (!(_ && f)) return;
      return _ - f;
    }
    function W(T, y) {
      if (!(T && y)) return;
      let _ = B.exec(T),
        f = B.exec(y);
      if (!(_ && f)) return;
      if (((T = _[1] + _[2] + _[3]), (y = f[1] + f[2] + f[3]), T > y)) return 1;
      if (T < y) return -1;
      return 0;
    }
    var L = /t|\s/i;
    function H(T) {
      let y = K(T);
      return function (f) {
        let l = f.split(L);
        return l.length === 2 && U(l[0]) && y(l[1]);
      };
    }
    function F(T, y) {
      if (!(T && y)) return;
      let _ = new Date(T).valueOf(),
        f = new Date(y).valueOf();
      if (!(_ && f)) return;
      return _ - f;
    }
    function N(T, y) {
      if (!(T && y)) return;
      let [_, f] = T.split(L),
        [l, h] = y.split(L),
        p = $(_, l);
      if (p === void 0) return;
      return p || V(f, h);
    }
    var q = /\/|:/,
      M =
        /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function A(T) {
      return q.test(T) && M.test(T);
    }
    var D =
      /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function R(T) {
      return ((D.lastIndex = 0), D.test(T));
    }
    var z = -2147483648,
      E = 2147483647;
    function O(T) {
      return Number.isInteger(T) && T <= E && T >= z;
    }
    function Z(T) {
      return Number.isInteger(T);
    }
    function j() {
      return !0;
    }
    var w = /[^\\]\\Z/;
    function I(T) {
      if (w.test(T)) return !1;
      try {
        return (new RegExp(T), !0);
      } catch (y) {
        return !1;
      }
    }
  }),
  cG = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.regexpCode =
        X.getEsmExportName =
        X.getProperty =
        X.safeStringify =
        X.stringify =
        X.strConcat =
        X.addCodeArg =
        X.str =
        X._ =
        X.nil =
        X._Code =
        X.Name =
        X.IDENTIFIER =
        X._CodeOrName =
          void 0));
    class Y {}
    ((X._CodeOrName = Y), (X.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i));
    class Q extends Y {
      constructor(A) {
        super();
        if (!X.IDENTIFIER.test(A))
          throw Error("CodeGen: name must be a valid identifier");
        this.str = A;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    X.Name = Q;
    class G extends Y {
      constructor(A) {
        super();
        this._items = typeof A === "string" ? [A] : A;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1) return !1;
        let A = this._items[0];
        return A === "" || A === '""';
      }
      get str() {
        var A;
        return (A = this._str) !== null && A !== void 0
          ? A
          : (this._str = this._items.reduce((D, R) => `${D}${R}`, ""));
      }
      get names() {
        var A;
        return (A = this._names) !== null && A !== void 0
          ? A
          : (this._names = this._items.reduce((D, R) => {
              if (R instanceof Q) D[R.str] = (D[R.str] || 0) + 1;
              return D;
            }, {}));
      }
    }
    ((X._Code = G), (X.nil = new G("")));
    function J(A, ...D) {
      let R = [A[0]],
        z = 0;
      while (z < D.length) (B(R, D[z]), R.push(A[++z]));
      return new G(R);
    }
    X._ = J;
    var U = new G("+");
    function $(A, ...D) {
      let R = [F(A[0])],
        z = 0;
      while (z < D.length) (R.push(U), B(R, D[z]), R.push(U, F(A[++z])));
      return (K(R), new G(R));
    }
    X.str = $;
    function B(A, D) {
      if (D instanceof G) A.push(...D._items);
      else if (D instanceof Q) A.push(D);
      else A.push(L(D));
    }
    X.addCodeArg = B;
    function K(A) {
      let D = 1;
      while (D < A.length - 1) {
        if (A[D] === U) {
          let R = V(A[D - 1], A[D + 1]);
          if (R !== void 0) {
            A.splice(D - 1, 3, R);
            continue;
          }
          A[D++] = "+";
        }
        D++;
      }
    }
    function V(A, D) {
      if (D === '""') return A;
      if (A === '""') return D;
      if (typeof A == "string") {
        if (D instanceof Q || A[A.length - 1] !== '"') return;
        if (typeof D != "string") return `${A.slice(0, -1)}${D}"`;
        if (D[0] === '"') return A.slice(0, -1) + D.slice(1);
        return;
      }
      if (typeof D == "string" && D[0] === '"' && !(A instanceof Q))
        return `"${A}${D.slice(1)}`;
      return;
    }
    function W(A, D) {
      return D.emptyStr() ? A : A.emptyStr() ? D : $`${A}${D}`;
    }
    X.strConcat = W;
    function L(A) {
      return typeof A == "number" || typeof A == "boolean" || A === null
        ? A
        : F(Array.isArray(A) ? A.join(",") : A);
    }
    function H(A) {
      return new G(F(A));
    }
    X.stringify = H;
    function F(A) {
      return JSON.stringify(A)
        .replace(/\u2028/g, "\\u2028")
        .replace(/\u2029/g, "\\u2029");
    }
    X.safeStringify = F;
    function N(A) {
      return typeof A == "string" && X.IDENTIFIER.test(A)
        ? new G(`.${A}`)
        : J`[${A}]`;
    }
    X.getProperty = N;
    function q(A) {
      if (typeof A == "string" && X.IDENTIFIER.test(A)) return new G(`${A}`);
      throw Error(
        `CodeGen: invalid export name: ${A}, use explicit $id name mapping`
      );
    }
    X.getEsmExportName = q;
    function M(A) {
      return new G(A.toString());
    }
    X.regexpCode = M;
  }),
  ez = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.ValueScope =
        X.ValueScopeName =
        X.Scope =
        X.varKinds =
        X.UsedValueState =
          void 0));
    var Y = cG();
    class Q extends Error {
      constructor(K) {
        super(`CodeGen: "code" for ${K} not defined`);
        this.value = K.value;
      }
    }
    var G;
    ((function (K) {
      ((K[(K.Started = 0)] = "Started"), (K[(K.Completed = 1)] = "Completed"));
    })(G || (X.UsedValueState = G = {})),
      (X.varKinds = {
        const: new Y.Name("const"),
        let: new Y.Name("let"),
        var: new Y.Name("var"),
      }));
    class J {
      constructor({ prefixes: K, parent: V } = {}) {
        ((this._names = {}), (this._prefixes = K), (this._parent = V));
      }
      toName(K) {
        return K instanceof Y.Name ? K : this.name(K);
      }
      name(K) {
        return new Y.Name(this._newName(K));
      }
      _newName(K) {
        let V = this._names[K] || this._nameGroup(K);
        return `${K}${V.index++}`;
      }
      _nameGroup(K) {
        var V, W;
        if (
          ((W =
            (V = this._parent) === null || V === void 0
              ? void 0
              : V._prefixes) === null || W === void 0
            ? void 0
            : W.has(K)) ||
          (this._prefixes && !this._prefixes.has(K))
        )
          throw Error(`CodeGen: prefix "${K}" is not allowed in this scope`);
        return (this._names[K] = { prefix: K, index: 0 });
      }
    }
    X.Scope = J;
    class U extends Y.Name {
      constructor(K, V) {
        super(V);
        this.prefix = K;
      }
      setValue(K, { property: V, itemIndex: W }) {
        ((this.value = K), (this.scopePath = Y._`.${new Y.Name(V)}[${W}]`));
      }
    }
    X.ValueScopeName = U;
    var $ = Y._`\n`;
    class B extends J {
      constructor(K) {
        super(K);
        ((this._values = {}),
          (this._scope = K.scope),
          (this.opts = { ...K, _n: K.lines ? $ : Y.nil }));
      }
      get() {
        return this._scope;
      }
      name(K) {
        return new U(K, this._newName(K));
      }
      value(K, V) {
        var W;
        if (V.ref === void 0)
          throw Error("CodeGen: ref must be passed in value");
        let L = this.toName(K),
          { prefix: H } = L,
          F = (W = V.key) !== null && W !== void 0 ? W : V.ref,
          N = this._values[H];
        if (N) {
          let A = N.get(F);
          if (A) return A;
        } else N = this._values[H] = new Map();
        N.set(F, L);
        let q = this._scope[H] || (this._scope[H] = []),
          M = q.length;
        return (
          (q[M] = V.ref),
          L.setValue(V, { property: H, itemIndex: M }),
          L
        );
      }
      getValue(K, V) {
        let W = this._values[K];
        if (!W) return;
        return W.get(V);
      }
      scopeRefs(K, V = this._values) {
        return this._reduceValues(V, (W) => {
          if (W.scopePath === void 0)
            throw Error(`CodeGen: name "${W}" has no value`);
          return Y._`${K}${W.scopePath}`;
        });
      }
      scopeCode(K = this._values, V, W) {
        return this._reduceValues(
          K,
          (L) => {
            if (L.value === void 0)
              throw Error(`CodeGen: name "${L}" has no value`);
            return L.value.code;
          },
          V,
          W
        );
      }
      _reduceValues(K, V, W = {}, L) {
        let H = Y.nil;
        for (let F in K) {
          let N = K[F];
          if (!N) continue;
          let q = (W[F] = W[F] || new Map());
          N.forEach((M) => {
            if (q.has(M)) return;
            q.set(M, G.Started);
            let A = V(M);
            if (A) {
              let D = this.opts.es5 ? X.varKinds.var : X.varKinds.const;
              H = Y._`${H}${D} ${M} = ${A};${this.opts._n}`;
            } else if ((A = L === null || L === void 0 ? void 0 : L(M)))
              H = Y._`${H}${A}${this.opts._n}`;
            else throw new Q(M);
            q.set(M, G.Completed);
          });
        }
        return H;
      }
    }
    X.ValueScope = B;
  }),
  D1 = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.or =
        X.and =
        X.not =
        X.CodeGen =
        X.operators =
        X.varKinds =
        X.ValueScopeName =
        X.ValueScope =
        X.Scope =
        X.Name =
        X.regexpCode =
        X.stringify =
        X.getProperty =
        X.nil =
        X.strConcat =
        X.str =
        X._ =
          void 0));
    var Y = cG(),
      Q = ez(),
      G = cG();
    (Object.defineProperty(X, "_", {
      enumerable: !0,
      get: function () {
        return G._;
      },
    }),
      Object.defineProperty(X, "str", {
        enumerable: !0,
        get: function () {
          return G.str;
        },
      }),
      Object.defineProperty(X, "strConcat", {
        enumerable: !0,
        get: function () {
          return G.strConcat;
        },
      }),
      Object.defineProperty(X, "nil", {
        enumerable: !0,
        get: function () {
          return G.nil;
        },
      }),
      Object.defineProperty(X, "getProperty", {
        enumerable: !0,
        get: function () {
          return G.getProperty;
        },
      }),
      Object.defineProperty(X, "stringify", {
        enumerable: !0,
        get: function () {
          return G.stringify;
        },
      }),
      Object.defineProperty(X, "regexpCode", {
        enumerable: !0,
        get: function () {
          return G.regexpCode;
        },
      }),
      Object.defineProperty(X, "Name", {
        enumerable: !0,
        get: function () {
          return G.Name;
        },
      }));
    var J = ez();
    (Object.defineProperty(X, "Scope", {
      enumerable: !0,
      get: function () {
        return J.Scope;
      },
    }),
      Object.defineProperty(X, "ValueScope", {
        enumerable: !0,
        get: function () {
          return J.ValueScope;
        },
      }),
      Object.defineProperty(X, "ValueScopeName", {
        enumerable: !0,
        get: function () {
          return J.ValueScopeName;
        },
      }),
      Object.defineProperty(X, "varKinds", {
        enumerable: !0,
        get: function () {
          return J.varKinds;
        },
      }),
      (X.operators = {
        GT: new Y._Code(">"),
        GTE: new Y._Code(">="),
        LT: new Y._Code("<"),
        LTE: new Y._Code("<="),
        EQ: new Y._Code("==="),
        NEQ: new Y._Code("!=="),
        NOT: new Y._Code("!"),
        OR: new Y._Code("||"),
        AND: new Y._Code("&&"),
        ADD: new Y._Code("+"),
      }));
    class U {
      optimizeNodes() {
        return this;
      }
      optimizeNames(C, v) {
        return this;
      }
    }
    class $ extends U {
      constructor(C, v, k) {
        super();
        ((this.varKind = C), (this.name = v), (this.rhs = k));
      }
      render({ es5: C, _n: v }) {
        let k = C ? Q.varKinds.var : this.varKind,
          o = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${k} ${this.name}${o};` + v;
      }
      optimizeNames(C, v) {
        if (!C[this.name.str]) return;
        if (this.rhs) this.rhs = f(this.rhs, C, v);
        return this;
      }
      get names() {
        return this.rhs instanceof Y._CodeOrName ? this.rhs.names : {};
      }
    }
    class B extends U {
      constructor(C, v, k) {
        super();
        ((this.lhs = C), (this.rhs = v), (this.sideEffects = k));
      }
      render({ _n: C }) {
        return `${this.lhs} = ${this.rhs};` + C;
      }
      optimizeNames(C, v) {
        if (this.lhs instanceof Y.Name && !C[this.lhs.str] && !this.sideEffects)
          return;
        return ((this.rhs = f(this.rhs, C, v)), this);
      }
      get names() {
        let C = this.lhs instanceof Y.Name ? {} : { ...this.lhs.names };
        return _(C, this.rhs);
      }
    }
    class K extends B {
      constructor(C, v, k, o) {
        super(C, k, o);
        this.op = v;
      }
      render({ _n: C }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + C;
      }
    }
    class V extends U {
      constructor(C) {
        super();
        ((this.label = C), (this.names = {}));
      }
      render({ _n: C }) {
        return `${this.label}:` + C;
      }
    }
    class W extends U {
      constructor(C) {
        super();
        ((this.label = C), (this.names = {}));
      }
      render({ _n: C }) {
        return `break${this.label ? ` ${this.label}` : ""};` + C;
      }
    }
    class L extends U {
      constructor(C) {
        super();
        this.error = C;
      }
      render({ _n: C }) {
        return `throw ${this.error};` + C;
      }
      get names() {
        return this.error.names;
      }
    }
    class H extends U {
      constructor(C) {
        super();
        this.code = C;
      }
      render({ _n: C }) {
        return `${this.code};` + C;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(C, v) {
        return ((this.code = f(this.code, C, v)), this);
      }
      get names() {
        return this.code instanceof Y._CodeOrName ? this.code.names : {};
      }
    }
    class F extends U {
      constructor(C = []) {
        super();
        this.nodes = C;
      }
      render(C) {
        return this.nodes.reduce((v, k) => v + k.render(C), "");
      }
      optimizeNodes() {
        let { nodes: C } = this,
          v = C.length;
        while (v--) {
          let k = C[v].optimizeNodes();
          if (Array.isArray(k)) C.splice(v, 1, ...k);
          else if (k) C[v] = k;
          else C.splice(v, 1);
        }
        return C.length > 0 ? this : void 0;
      }
      optimizeNames(C, v) {
        let { nodes: k } = this,
          o = k.length;
        while (o--) {
          let J0 = k[o];
          if (J0.optimizeNames(C, v)) continue;
          (l(C, J0.names), k.splice(o, 1));
        }
        return k.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((C, v) => y(C, v.names), {});
      }
    }
    class N extends F {
      render(C) {
        return "{" + C._n + super.render(C) + "}" + C._n;
      }
    }
    class q extends F {}
    class M extends N {}
    M.kind = "else";
    class A extends N {
      constructor(C, v) {
        super(v);
        this.condition = C;
      }
      render(C) {
        let v = `if(${this.condition})` + super.render(C);
        if (this.else) v += "else " + this.else.render(C);
        return v;
      }
      optimizeNodes() {
        super.optimizeNodes();
        let C = this.condition;
        if (C === !0) return this.nodes;
        let v = this.else;
        if (v) {
          let k = v.optimizeNodes();
          v = this.else = Array.isArray(k) ? new M(k) : k;
        }
        if (v) {
          if (C === !1) return v instanceof A ? v : v.nodes;
          if (this.nodes.length) return this;
          return new A(h(C), v instanceof A ? [v] : v.nodes);
        }
        if (C === !1 || !this.nodes.length) return;
        return this;
      }
      optimizeNames(C, v) {
        var k;
        if (
          ((this.else =
            (k = this.else) === null || k === void 0
              ? void 0
              : k.optimizeNames(C, v)),
          !(super.optimizeNames(C, v) || this.else))
        )
          return;
        return ((this.condition = f(this.condition, C, v)), this);
      }
      get names() {
        let C = super.names;
        if ((_(C, this.condition), this.else)) y(C, this.else.names);
        return C;
      }
    }
    A.kind = "if";
    class D extends N {}
    D.kind = "for";
    class R extends D {
      constructor(C) {
        super();
        this.iteration = C;
      }
      render(C) {
        return `for(${this.iteration})` + super.render(C);
      }
      optimizeNames(C, v) {
        if (!super.optimizeNames(C, v)) return;
        return ((this.iteration = f(this.iteration, C, v)), this);
      }
      get names() {
        return y(super.names, this.iteration.names);
      }
    }
    class z extends D {
      constructor(C, v, k, o) {
        super();
        ((this.varKind = C), (this.name = v), (this.from = k), (this.to = o));
      }
      render(C) {
        let v = C.es5 ? Q.varKinds.var : this.varKind,
          { name: k, from: o, to: J0 } = this;
        return `for(${v} ${k}=${o}; ${k}<${J0}; ${k}++)` + super.render(C);
      }
      get names() {
        let C = _(super.names, this.from);
        return _(C, this.to);
      }
    }
    class E extends D {
      constructor(C, v, k, o) {
        super();
        ((this.loop = C),
          (this.varKind = v),
          (this.name = k),
          (this.iterable = o));
      }
      render(C) {
        return (
          `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
          super.render(C)
        );
      }
      optimizeNames(C, v) {
        if (!super.optimizeNames(C, v)) return;
        return ((this.iterable = f(this.iterable, C, v)), this);
      }
      get names() {
        return y(super.names, this.iterable.names);
      }
    }
    class O extends N {
      constructor(C, v, k) {
        super();
        ((this.name = C), (this.args = v), (this.async = k));
      }
      render(C) {
        return (
          `${this.async ? "async " : ""}function ${this.name}(${this.args})` +
          super.render(C)
        );
      }
    }
    O.kind = "func";
    class Z extends F {
      render(C) {
        return "return " + super.render(C);
      }
    }
    Z.kind = "return";
    class j extends N {
      render(C) {
        let v = "try" + super.render(C);
        if (this.catch) v += this.catch.render(C);
        if (this.finally) v += this.finally.render(C);
        return v;
      }
      optimizeNodes() {
        var C, v;
        return (
          super.optimizeNodes(),
          (C = this.catch) === null || C === void 0 || C.optimizeNodes(),
          (v = this.finally) === null || v === void 0 || v.optimizeNodes(),
          this
        );
      }
      optimizeNames(C, v) {
        var k, o;
        return (
          super.optimizeNames(C, v),
          (k = this.catch) === null || k === void 0 || k.optimizeNames(C, v),
          (o = this.finally) === null || o === void 0 || o.optimizeNames(C, v),
          this
        );
      }
      get names() {
        let C = super.names;
        if (this.catch) y(C, this.catch.names);
        if (this.finally) y(C, this.finally.names);
        return C;
      }
    }
    class w extends N {
      constructor(C) {
        super();
        this.error = C;
      }
      render(C) {
        return `catch(${this.error})` + super.render(C);
      }
    }
    w.kind = "catch";
    class I extends N {
      render(C) {
        return "finally" + super.render(C);
      }
    }
    I.kind = "finally";
    class T {
      constructor(C, v = {}) {
        ((this._values = {}),
          (this._blockStarts = []),
          (this._constants = {}),
          (this.opts = {
            ...v,
            _n: v.lines
              ? `
`
              : "",
          }),
          (this._extScope = C),
          (this._scope = new Q.Scope({ parent: C })),
          (this._nodes = [new q()]));
      }
      toString() {
        return this._root.render(this.opts);
      }
      name(C) {
        return this._scope.name(C);
      }
      scopeName(C) {
        return this._extScope.name(C);
      }
      scopeValue(C, v) {
        let k = this._extScope.value(C, v);
        return (
          (this._values[k.prefix] || (this._values[k.prefix] = new Set())).add(
            k
          ),
          k
        );
      }
      getScopeValue(C, v) {
        return this._extScope.getValue(C, v);
      }
      scopeRefs(C) {
        return this._extScope.scopeRefs(C, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(C, v, k, o) {
        let J0 = this._scope.toName(v);
        if (k !== void 0 && o) this._constants[J0.str] = k;
        return (this._leafNode(new $(C, J0, k)), J0);
      }
      const(C, v, k) {
        return this._def(Q.varKinds.const, C, v, k);
      }
      let(C, v, k) {
        return this._def(Q.varKinds.let, C, v, k);
      }
      var(C, v, k) {
        return this._def(Q.varKinds.var, C, v, k);
      }
      assign(C, v, k) {
        return this._leafNode(new B(C, v, k));
      }
      add(C, v) {
        return this._leafNode(new K(C, X.operators.ADD, v));
      }
      code(C) {
        if (typeof C == "function") C();
        else if (C !== Y.nil) this._leafNode(new H(C));
        return this;
      }
      object(...C) {
        let v = ["{"];
        for (let [k, o] of C) {
          if (v.length > 1) v.push(",");
          if ((v.push(k), k !== o || this.opts.es5))
            (v.push(":"), (0, Y.addCodeArg)(v, o));
        }
        return (v.push("}"), new Y._Code(v));
      }
      if(C, v, k) {
        if ((this._blockNode(new A(C)), v && k))
          this.code(v).else().code(k).endIf();
        else if (v) this.code(v).endIf();
        else if (k) throw Error('CodeGen: "else" body without "then" body');
        return this;
      }
      elseIf(C) {
        return this._elseNode(new A(C));
      }
      else() {
        return this._elseNode(new M());
      }
      endIf() {
        return this._endBlockNode(A, M);
      }
      _for(C, v) {
        if ((this._blockNode(C), v)) this.code(v).endFor();
        return this;
      }
      for(C, v) {
        return this._for(new R(C), v);
      }
      forRange(
        C,
        v,
        k,
        o,
        J0 = this.opts.es5 ? Q.varKinds.var : Q.varKinds.let
      ) {
        let z0 = this._scope.toName(C);
        return this._for(new z(J0, z0, v, k), () => o(z0));
      }
      forOf(C, v, k, o = Q.varKinds.const) {
        let J0 = this._scope.toName(C);
        if (this.opts.es5) {
          let z0 = v instanceof Y.Name ? v : this.var("_arr", v);
          return this.forRange("_i", 0, Y._`${z0}.length`, (A0) => {
            (this.var(J0, Y._`${z0}[${A0}]`), k(J0));
          });
        }
        return this._for(new E("of", o, J0, v), () => k(J0));
      }
      forIn(C, v, k, o = this.opts.es5 ? Q.varKinds.var : Q.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(C, Y._`Object.keys(${v})`, k);
        let J0 = this._scope.toName(C);
        return this._for(new E("in", o, J0, v), () => k(J0));
      }
      endFor() {
        return this._endBlockNode(D);
      }
      label(C) {
        return this._leafNode(new V(C));
      }
      break(C) {
        return this._leafNode(new W(C));
      }
      return(C) {
        let v = new Z();
        if ((this._blockNode(v), this.code(C), v.nodes.length !== 1))
          throw Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Z);
      }
      try(C, v, k) {
        if (!v && !k)
          throw Error('CodeGen: "try" without "catch" and "finally"');
        let o = new j();
        if ((this._blockNode(o), this.code(C), v)) {
          let J0 = this.name("e");
          ((this._currNode = o.catch = new w(J0)), v(J0));
        }
        if (k) ((this._currNode = o.finally = new I()), this.code(k));
        return this._endBlockNode(w, I);
      }
      throw(C) {
        return this._leafNode(new L(C));
      }
      block(C, v) {
        if ((this._blockStarts.push(this._nodes.length), C))
          this.code(C).endBlock(v);
        return this;
      }
      endBlock(C) {
        let v = this._blockStarts.pop();
        if (v === void 0) throw Error("CodeGen: not in self-balancing block");
        let k = this._nodes.length - v;
        if (k < 0 || (C !== void 0 && k !== C))
          throw Error(`CodeGen: wrong number of nodes: ${k} vs ${C} expected`);
        return ((this._nodes.length = v), this);
      }
      func(C, v = Y.nil, k, o) {
        if ((this._blockNode(new O(C, v, k)), o)) this.code(o).endFunc();
        return this;
      }
      endFunc() {
        return this._endBlockNode(O);
      }
      optimize(C = 1) {
        while (C-- > 0)
          (this._root.optimizeNodes(),
            this._root.optimizeNames(this._root.names, this._constants));
      }
      _leafNode(C) {
        return (this._currNode.nodes.push(C), this);
      }
      _blockNode(C) {
        (this._currNode.nodes.push(C), this._nodes.push(C));
      }
      _endBlockNode(C, v) {
        let k = this._currNode;
        if (k instanceof C || (v && k instanceof v))
          return (this._nodes.pop(), this);
        throw Error(
          `CodeGen: not in block "${v ? `${C.kind}/${v.kind}` : C.kind}"`
        );
      }
      _elseNode(C) {
        let v = this._currNode;
        if (!(v instanceof A)) throw Error('CodeGen: "else" without "if"');
        return ((this._currNode = v.else = C), this);
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        let C = this._nodes;
        return C[C.length - 1];
      }
      set _currNode(C) {
        let v = this._nodes;
        v[v.length - 1] = C;
      }
    }
    X.CodeGen = T;
    function y(C, v) {
      for (let k in v) C[k] = (C[k] || 0) + (v[k] || 0);
      return C;
    }
    function _(C, v) {
      return v instanceof Y._CodeOrName ? y(C, v.names) : C;
    }
    function f(C, v, k) {
      if (C instanceof Y.Name) return o(C);
      if (!J0(C)) return C;
      return new Y._Code(
        C._items.reduce((z0, A0) => {
          if (A0 instanceof Y.Name) A0 = o(A0);
          if (A0 instanceof Y._Code) z0.push(...A0._items);
          else z0.push(A0);
          return z0;
        }, [])
      );
      function o(z0) {
        let A0 = k[z0.str];
        if (A0 === void 0 || v[z0.str] !== 1) return z0;
        return (delete v[z0.str], A0);
      }
      function J0(z0) {
        return (
          z0 instanceof Y._Code &&
          z0._items.some(
            (A0) =>
              A0 instanceof Y.Name && v[A0.str] === 1 && k[A0.str] !== void 0
          )
        );
      }
    }
    function l(C, v) {
      for (let k in v) C[k] = (C[k] || 0) - (v[k] || 0);
    }
    function h(C) {
      return typeof C == "boolean" || typeof C == "number" || C === null
        ? !C
        : Y._`!${r(C)}`;
    }
    X.not = h;
    var p = x(X.operators.AND);
    function N0(...C) {
      return C.reduce(p);
    }
    X.and = N0;
    var e = x(X.operators.OR);
    function P(...C) {
      return C.reduce(e);
    }
    X.or = P;
    function x(C) {
      return (v, k) =>
        v === Y.nil ? k : k === Y.nil ? v : Y._`${r(v)} ${C} ${r(k)}`;
    }
    function r(C) {
      return C instanceof Y.Name ? C : Y._`(${C})`;
    }
  }),
  m1 = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.checkStrictMode =
        X.getErrorPath =
        X.Type =
        X.useFunc =
        X.setEvaluated =
        X.evaluatedPropsToName =
        X.mergeEvaluated =
        X.eachItem =
        X.unescapeJsonPointer =
        X.escapeJsonPointer =
        X.escapeFragment =
        X.unescapeFragment =
        X.schemaRefOrVal =
        X.schemaHasRulesButRef =
        X.schemaHasRules =
        X.checkUnknownRules =
        X.alwaysValidSchema =
        X.toHash =
          void 0));
    var Y = D1(),
      Q = cG();
    function G(O) {
      let Z = {};
      for (let j of O) Z[j] = !0;
      return Z;
    }
    X.toHash = G;
    function J(O, Z) {
      if (typeof Z == "boolean") return Z;
      if (Object.keys(Z).length === 0) return !0;
      return (U(O, Z), !$(Z, O.self.RULES.all));
    }
    X.alwaysValidSchema = J;
    function U(O, Z = O.schema) {
      let { opts: j, self: w } = O;
      if (!j.strictSchema) return;
      if (typeof Z === "boolean") return;
      let I = w.RULES.keywords;
      for (let T in Z) if (!I[T]) E(O, `unknown keyword: "${T}"`);
    }
    X.checkUnknownRules = U;
    function $(O, Z) {
      if (typeof O == "boolean") return !O;
      for (let j in O) if (Z[j]) return !0;
      return !1;
    }
    X.schemaHasRules = $;
    function B(O, Z) {
      if (typeof O == "boolean") return !O;
      for (let j in O) if (j !== "$ref" && Z.all[j]) return !0;
      return !1;
    }
    X.schemaHasRulesButRef = B;
    function K({ topSchemaRef: O, schemaPath: Z }, j, w, I) {
      if (!I) {
        if (typeof j == "number" || typeof j == "boolean") return j;
        if (typeof j == "string") return Y._`${j}`;
      }
      return Y._`${O}${Z}${(0, Y.getProperty)(w)}`;
    }
    X.schemaRefOrVal = K;
    function V(O) {
      return H(decodeURIComponent(O));
    }
    X.unescapeFragment = V;
    function W(O) {
      return encodeURIComponent(L(O));
    }
    X.escapeFragment = W;
    function L(O) {
      if (typeof O == "number") return `${O}`;
      return O.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    X.escapeJsonPointer = L;
    function H(O) {
      return O.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    X.unescapeJsonPointer = H;
    function F(O, Z) {
      if (Array.isArray(O)) for (let j of O) Z(j);
      else Z(O);
    }
    X.eachItem = F;
    function N({
      mergeNames: O,
      mergeToName: Z,
      mergeValues: j,
      resultToName: w,
    }) {
      return (I, T, y, _) => {
        let f =
          y === void 0
            ? T
            : y instanceof Y.Name
              ? (T instanceof Y.Name ? O(I, T, y) : Z(I, T, y), y)
              : T instanceof Y.Name
                ? (Z(I, y, T), T)
                : j(T, y);
        return _ === Y.Name && !(f instanceof Y.Name) ? w(I, f) : f;
      };
    }
    X.mergeEvaluated = {
      props: N({
        mergeNames: (O, Z, j) =>
          O.if(Y._`${j} !== true && ${Z} !== undefined`, () => {
            O.if(
              Y._`${Z} === true`,
              () => O.assign(j, !0),
              () =>
                O.assign(j, Y._`${j} || {}`).code(
                  Y._`Object.assign(${j}, ${Z})`
                )
            );
          }),
        mergeToName: (O, Z, j) =>
          O.if(Y._`${j} !== true`, () => {
            if (Z === !0) O.assign(j, !0);
            else (O.assign(j, Y._`${j} || {}`), M(O, j, Z));
          }),
        mergeValues: (O, Z) => (O === !0 ? !0 : { ...O, ...Z }),
        resultToName: q,
      }),
      items: N({
        mergeNames: (O, Z, j) =>
          O.if(Y._`${j} !== true && ${Z} !== undefined`, () =>
            O.assign(j, Y._`${Z} === true ? true : ${j} > ${Z} ? ${j} : ${Z}`)
          ),
        mergeToName: (O, Z, j) =>
          O.if(Y._`${j} !== true`, () =>
            O.assign(j, Z === !0 ? !0 : Y._`${j} > ${Z} ? ${j} : ${Z}`)
          ),
        mergeValues: (O, Z) => (O === !0 ? !0 : Math.max(O, Z)),
        resultToName: (O, Z) => O.var("items", Z),
      }),
    };
    function q(O, Z) {
      if (Z === !0) return O.var("props", !0);
      let j = O.var("props", Y._`{}`);
      if (Z !== void 0) M(O, j, Z);
      return j;
    }
    X.evaluatedPropsToName = q;
    function M(O, Z, j) {
      Object.keys(j).forEach((w) =>
        O.assign(Y._`${Z}${(0, Y.getProperty)(w)}`, !0)
      );
    }
    X.setEvaluated = M;
    var A = {};
    function D(O, Z) {
      return O.scopeValue("func", {
        ref: Z,
        code: A[Z.code] || (A[Z.code] = new Q._Code(Z.code)),
      });
    }
    X.useFunc = D;
    var R;
    (function (O) {
      ((O[(O.Num = 0)] = "Num"), (O[(O.Str = 1)] = "Str"));
    })(R || (X.Type = R = {}));
    function z(O, Z, j) {
      if (O instanceof Y.Name) {
        let w = Z === R.Num;
        return j
          ? w
            ? Y._`"[" + ${O} + "]"`
            : Y._`"['" + ${O} + "']"`
          : w
            ? Y._`"/" + ${O}`
            : Y._`"/" + ${O}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return j ? (0, Y.getProperty)(O).toString() : "/" + L(O);
    }
    X.getErrorPath = z;
    function E(O, Z, j = O.opts.strictSchema) {
      if (!j) return;
      if (((Z = `strict mode: ${Z}`), j === !0)) throw Error(Z);
      O.self.logger.warn(Z);
    }
    X.checkStrictMode = E;
  }),
  u4 = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = {
        data: new Y.Name("data"),
        valCxt: new Y.Name("valCxt"),
        instancePath: new Y.Name("instancePath"),
        parentData: new Y.Name("parentData"),
        parentDataProperty: new Y.Name("parentDataProperty"),
        rootData: new Y.Name("rootData"),
        dynamicAnchors: new Y.Name("dynamicAnchors"),
        vErrors: new Y.Name("vErrors"),
        errors: new Y.Name("errors"),
        this: new Y.Name("this"),
        self: new Y.Name("self"),
        scope: new Y.Name("scope"),
        json: new Y.Name("json"),
        jsonPos: new Y.Name("jsonPos"),
        jsonLen: new Y.Name("jsonLen"),
        jsonPart: new Y.Name("jsonPart"),
      };
    X.default = Q;
  }),
  $J = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.extendErrors =
        X.resetErrorsCount =
        X.reportExtraError =
        X.reportError =
        X.keyword$DataError =
        X.keywordError =
          void 0));
    var Y = D1(),
      Q = m1(),
      G = u4();
    ((X.keywordError = {
      message: ({ keyword: M }) => Y.str`must pass "${M}" keyword validation`,
    }),
      (X.keyword$DataError = {
        message: ({ keyword: M, schemaType: A }) =>
          A
            ? Y.str`"${M}" keyword must be ${A} ($data)`
            : Y.str`"${M}" keyword is invalid ($data)`,
      }));
    function J(M, A = X.keywordError, D, R) {
      let { it: z } = M,
        { gen: E, compositeRule: O, allErrors: Z } = z,
        j = L(M, A, D);
      if (R !== null && R !== void 0 ? R : O || Z) K(E, j);
      else V(z, Y._`[${j}]`);
    }
    X.reportError = J;
    function U(M, A = X.keywordError, D) {
      let { it: R } = M,
        { gen: z, compositeRule: E, allErrors: O } = R,
        Z = L(M, A, D);
      if ((K(z, Z), !(E || O))) V(R, G.default.vErrors);
    }
    X.reportExtraError = U;
    function $(M, A) {
      (M.assign(G.default.errors, A),
        M.if(Y._`${G.default.vErrors} !== null`, () =>
          M.if(
            A,
            () => M.assign(Y._`${G.default.vErrors}.length`, A),
            () => M.assign(G.default.vErrors, null)
          )
        ));
    }
    X.resetErrorsCount = $;
    function B({
      gen: M,
      keyword: A,
      schemaValue: D,
      data: R,
      errsCount: z,
      it: E,
    }) {
      if (z === void 0) throw Error("ajv implementation error");
      let O = M.name("err");
      M.forRange("i", z, G.default.errors, (Z) => {
        if (
          (M.const(O, Y._`${G.default.vErrors}[${Z}]`),
          M.if(Y._`${O}.instancePath === undefined`, () =>
            M.assign(
              Y._`${O}.instancePath`,
              (0, Y.strConcat)(G.default.instancePath, E.errorPath)
            )
          ),
          M.assign(Y._`${O}.schemaPath`, Y.str`${E.errSchemaPath}/${A}`),
          E.opts.verbose)
        )
          (M.assign(Y._`${O}.schema`, D), M.assign(Y._`${O}.data`, R));
      });
    }
    X.extendErrors = B;
    function K(M, A) {
      let D = M.const("err", A);
      (M.if(
        Y._`${G.default.vErrors} === null`,
        () => M.assign(G.default.vErrors, Y._`[${D}]`),
        Y._`${G.default.vErrors}.push(${D})`
      ),
        M.code(Y._`${G.default.errors}++`));
    }
    function V(M, A) {
      let { gen: D, validateName: R, schemaEnv: z } = M;
      if (z.$async) D.throw(Y._`new ${M.ValidationError}(${A})`);
      else (D.assign(Y._`${R}.errors`, A), D.return(!1));
    }
    var W = {
      keyword: new Y.Name("keyword"),
      schemaPath: new Y.Name("schemaPath"),
      params: new Y.Name("params"),
      propertyName: new Y.Name("propertyName"),
      message: new Y.Name("message"),
      schema: new Y.Name("schema"),
      parentSchema: new Y.Name("parentSchema"),
    };
    function L(M, A, D) {
      let { createErrors: R } = M.it;
      if (R === !1) return Y._`{}`;
      return H(M, A, D);
    }
    function H(M, A, D = {}) {
      let { gen: R, it: z } = M,
        E = [F(z, D), N(M, D)];
      return (q(M, A, E), R.object(...E));
    }
    function F({ errorPath: M }, { instancePath: A }) {
      let D = A ? Y.str`${M}${(0, Q.getErrorPath)(A, Q.Type.Str)}` : M;
      return [
        G.default.instancePath,
        (0, Y.strConcat)(G.default.instancePath, D),
      ];
    }
    function N(
      { keyword: M, it: { errSchemaPath: A } },
      { schemaPath: D, parentSchema: R }
    ) {
      let z = R ? A : Y.str`${A}/${M}`;
      if (D) z = Y.str`${z}${(0, Q.getErrorPath)(D, Q.Type.Str)}`;
      return [W.schemaPath, z];
    }
    function q(M, { params: A, message: D }, R) {
      let { keyword: z, data: E, schemaValue: O, it: Z } = M,
        { opts: j, propertyName: w, topSchemaRef: I, schemaPath: T } = Z;
      if (
        (R.push(
          [W.keyword, z],
          [W.params, typeof A == "function" ? A(M) : A || Y._`{}`]
        ),
        j.messages)
      )
        R.push([W.message, typeof D == "function" ? D(M) : D]);
      if (j.verbose)
        R.push(
          [W.schema, O],
          [W.parentSchema, Y._`${I}${T}`],
          [G.default.data, E]
        );
      if (w) R.push([W.propertyName, w]);
    }
  }),
  of = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.boolOrEmptySchema = X.topBoolOrEmptySchema = void 0));
    var Y = $J(),
      Q = D1(),
      G = u4(),
      J = { message: "boolean schema is false" };
    function U(K) {
      let { gen: V, schema: W, validateName: L } = K;
      if (W === !1) B(K, !1);
      else if (typeof W == "object" && W.$async === !0)
        V.return(G.default.data);
      else (V.assign(Q._`${L}.errors`, null), V.return(!0));
    }
    X.topBoolOrEmptySchema = U;
    function $(K, V) {
      let { gen: W, schema: L } = K;
      if (L === !1) (W.var(V, !1), B(K));
      else W.var(V, !0);
    }
    X.boolOrEmptySchema = $;
    function B(K, V) {
      let { gen: W, data: L } = K,
        H = {
          gen: W,
          keyword: "false schema",
          data: L,
          schema: !1,
          schemaCode: !1,
          schemaValue: !1,
          params: {},
          it: K,
        };
      (0, Y.reportError)(H, J, void 0, V);
    }
  }),
  uE = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.getRules = X.isJSONType = void 0));
    var Y = [
        "string",
        "number",
        "integer",
        "boolean",
        "null",
        "object",
        "array",
      ],
      Q = new Set(Y);
    function G(U) {
      return typeof U == "string" && Q.has(U);
    }
    X.isJSONType = G;
    function J() {
      let U = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] },
      };
      return {
        types: { ...U, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, U.number, U.string, U.array, U.object],
        post: { rules: [] },
        all: {},
        keywords: {},
      };
    }
    X.getRules = J;
  }),
  lE = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.shouldUseRule = X.shouldUseGroup = X.schemaHasRulesForType = void 0));
    function Y({ schema: J, self: U }, $) {
      let B = U.RULES.types[$];
      return B && B !== !0 && Q(J, B);
    }
    X.schemaHasRulesForType = Y;
    function Q(J, U) {
      return U.rules.some(($) => G(J, $));
    }
    X.shouldUseGroup = Q;
    function G(J, U) {
      var $;
      return (
        J[U.keyword] !== void 0 ||
        (($ = U.definition.implements) === null || $ === void 0
          ? void 0
          : $.some((B) => J[B] !== void 0))
      );
    }
    X.shouldUseRule = G;
  }),
  dG = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.reportTypeError =
        X.checkDataTypes =
        X.checkDataType =
        X.coerceAndCheckDataType =
        X.getJSONTypes =
        X.getSchemaTypes =
        X.DataType =
          void 0));
    var Y = uE(),
      Q = lE(),
      G = $J(),
      J = D1(),
      U = m1(),
      $;
    (function (R) {
      ((R[(R.Correct = 0)] = "Correct"), (R[(R.Wrong = 1)] = "Wrong"));
    })($ || (X.DataType = $ = {}));
    function B(R) {
      let z = K(R.type);
      if (z.includes("null")) {
        if (R.nullable === !1)
          throw Error("type: null contradicts nullable: false");
      } else {
        if (!z.length && R.nullable !== void 0)
          throw Error('"nullable" cannot be used without "type"');
        if (R.nullable === !0) z.push("null");
      }
      return z;
    }
    X.getSchemaTypes = B;
    function K(R) {
      let z = Array.isArray(R) ? R : R ? [R] : [];
      if (z.every(Y.isJSONType)) return z;
      throw Error("type must be JSONType or JSONType[]: " + z.join(","));
    }
    X.getJSONTypes = K;
    function V(R, z) {
      let { gen: E, data: O, opts: Z } = R,
        j = L(z, Z.coerceTypes),
        w =
          z.length > 0 &&
          !(
            j.length === 0 &&
            z.length === 1 &&
            (0, Q.schemaHasRulesForType)(R, z[0])
          );
      if (w) {
        let I = q(z, O, Z.strictNumbers, $.Wrong);
        E.if(I, () => {
          if (j.length) H(R, z, j);
          else A(R);
        });
      }
      return w;
    }
    X.coerceAndCheckDataType = V;
    var W = new Set(["string", "number", "integer", "boolean", "null"]);
    function L(R, z) {
      return z
        ? R.filter((E) => W.has(E) || (z === "array" && E === "array"))
        : [];
    }
    function H(R, z, E) {
      let { gen: O, data: Z, opts: j } = R,
        w = O.let("dataType", J._`typeof ${Z}`),
        I = O.let("coerced", J._`undefined`);
      if (j.coerceTypes === "array")
        O.if(
          J._`${w} == 'object' && Array.isArray(${Z}) && ${Z}.length == 1`,
          () =>
            O.assign(Z, J._`${Z}[0]`)
              .assign(w, J._`typeof ${Z}`)
              .if(q(z, Z, j.strictNumbers), () => O.assign(I, Z))
        );
      O.if(J._`${I} !== undefined`);
      for (let y of E)
        if (W.has(y) || (y === "array" && j.coerceTypes === "array")) T(y);
      (O.else(),
        A(R),
        O.endIf(),
        O.if(J._`${I} !== undefined`, () => {
          (O.assign(Z, I), F(R, I));
        }));
      function T(y) {
        switch (y) {
          case "string":
            O.elseIf(J._`${w} == "number" || ${w} == "boolean"`)
              .assign(I, J._`"" + ${Z}`)
              .elseIf(J._`${Z} === null`)
              .assign(I, J._`""`);
            return;
          case "number":
            O.elseIf(
              J._`${w} == "boolean" || ${Z} === null
              || (${w} == "string" && ${Z} && ${Z} == +${Z})`
            ).assign(I, J._`+${Z}`);
            return;
          case "integer":
            O.elseIf(
              J._`${w} === "boolean" || ${Z} === null
              || (${w} === "string" && ${Z} && ${Z} == +${Z} && !(${Z} % 1))`
            ).assign(I, J._`+${Z}`);
            return;
          case "boolean":
            O.elseIf(J._`${Z} === "false" || ${Z} === 0 || ${Z} === null`)
              .assign(I, !1)
              .elseIf(J._`${Z} === "true" || ${Z} === 1`)
              .assign(I, !0);
            return;
          case "null":
            (O.elseIf(J._`${Z} === "" || ${Z} === 0 || ${Z} === false`),
              O.assign(I, null));
            return;
          case "array":
            O.elseIf(
              J._`${w} === "string" || ${w} === "number"
              || ${w} === "boolean" || ${Z} === null`
            ).assign(I, J._`[${Z}]`);
        }
      }
    }
    function F({ gen: R, parentData: z, parentDataProperty: E }, O) {
      R.if(J._`${z} !== undefined`, () => R.assign(J._`${z}[${E}]`, O));
    }
    function N(R, z, E, O = $.Correct) {
      let Z = O === $.Correct ? J.operators.EQ : J.operators.NEQ,
        j;
      switch (R) {
        case "null":
          return J._`${z} ${Z} null`;
        case "array":
          j = J._`Array.isArray(${z})`;
          break;
        case "object":
          j = J._`${z} && typeof ${z} == "object" && !Array.isArray(${z})`;
          break;
        case "integer":
          j = w(J._`!(${z} % 1) && !isNaN(${z})`);
          break;
        case "number":
          j = w();
          break;
        default:
          return J._`typeof ${z} ${Z} ${R}`;
      }
      return O === $.Correct ? j : (0, J.not)(j);
      function w(I = J.nil) {
        return (0, J.and)(
          J._`typeof ${z} == "number"`,
          I,
          E ? J._`isFinite(${z})` : J.nil
        );
      }
    }
    X.checkDataType = N;
    function q(R, z, E, O) {
      if (R.length === 1) return N(R[0], z, E, O);
      let Z,
        j = (0, U.toHash)(R);
      if (j.array && j.object) {
        let w = J._`typeof ${z} != "object"`;
        ((Z = j.null ? w : J._`!${z} || ${w}`),
          delete j.null,
          delete j.array,
          delete j.object);
      } else Z = J.nil;
      if (j.number) delete j.integer;
      for (let w in j) Z = (0, J.and)(Z, N(w, z, E, O));
      return Z;
    }
    X.checkDataTypes = q;
    var M = {
      message: ({ schema: R }) => `must be ${R}`,
      params: ({ schema: R, schemaValue: z }) =>
        typeof R == "string" ? J._`{type: ${R}}` : J._`{type: ${z}}`,
    };
    function A(R) {
      let z = D(R);
      (0, G.reportError)(z, M);
    }
    X.reportTypeError = A;
    function D(R) {
      let { gen: z, data: E, schema: O } = R,
        Z = (0, U.schemaRefOrVal)(R, O, "type");
      return {
        gen: z,
        keyword: "type",
        data: E,
        schema: O.type,
        schemaCode: Z,
        schemaValue: Z,
        parentSchema: O,
        params: {},
        it: R,
      };
    }
  }),
  sf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.assignDefaults = void 0));
    var Y = D1(),
      Q = m1();
    function G(U, $) {
      let { properties: B, items: K } = U.schema;
      if ($ === "object" && B) for (let V in B) J(U, V, B[V].default);
      else if ($ === "array" && Array.isArray(K))
        K.forEach((V, W) => J(U, W, V.default));
    }
    X.assignDefaults = G;
    function J(U, $, B) {
      let { gen: K, compositeRule: V, data: W, opts: L } = U;
      if (B === void 0) return;
      let H = Y._`${W}${(0, Y.getProperty)($)}`;
      if (V) {
        (0, Q.checkStrictMode)(U, `default is ignored for: ${H}`);
        return;
      }
      let F = Y._`${H} === undefined`;
      if (L.useDefaults === "empty")
        F = Y._`${F} || ${H} === null || ${H} === ""`;
      K.if(F, Y._`${H} = ${(0, Y.stringify)(B)}`);
    }
  }),
  p8 = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.validateUnion =
        X.validateArray =
        X.usePattern =
        X.callValidateCode =
        X.schemaProperties =
        X.allSchemaProperties =
        X.noPropertyInData =
        X.propertyInData =
        X.isOwnProperty =
        X.hasPropFunc =
        X.reportMissingProp =
        X.checkMissingProp =
        X.checkReportMissingProp =
          void 0));
    var Y = D1(),
      Q = m1(),
      G = u4(),
      J = m1();
    function U(R, z) {
      let { gen: E, data: O, it: Z } = R;
      E.if(L(E, O, z, Z.opts.ownProperties), () => {
        (R.setParams({ missingProperty: Y._`${z}` }, !0), R.error());
      });
    }
    X.checkReportMissingProp = U;
    function $({ gen: R, data: z, it: { opts: E } }, O, Z) {
      return (0, Y.or)(
        ...O.map((j) =>
          (0, Y.and)(L(R, z, j, E.ownProperties), Y._`${Z} = ${j}`)
        )
      );
    }
    X.checkMissingProp = $;
    function B(R, z) {
      (R.setParams({ missingProperty: z }, !0), R.error());
    }
    X.reportMissingProp = B;
    function K(R) {
      return R.scopeValue("func", {
        ref: Object.prototype.hasOwnProperty,
        code: Y._`Object.prototype.hasOwnProperty`,
      });
    }
    X.hasPropFunc = K;
    function V(R, z, E) {
      return Y._`${K(R)}.call(${z}, ${E})`;
    }
    X.isOwnProperty = V;
    function W(R, z, E, O) {
      let Z = Y._`${z}${(0, Y.getProperty)(E)} !== undefined`;
      return O ? Y._`${Z} && ${V(R, z, E)}` : Z;
    }
    X.propertyInData = W;
    function L(R, z, E, O) {
      let Z = Y._`${z}${(0, Y.getProperty)(E)} === undefined`;
      return O ? (0, Y.or)(Z, (0, Y.not)(V(R, z, E))) : Z;
    }
    X.noPropertyInData = L;
    function H(R) {
      return R ? Object.keys(R).filter((z) => z !== "__proto__") : [];
    }
    X.allSchemaProperties = H;
    function F(R, z) {
      return H(z).filter((E) => !(0, Q.alwaysValidSchema)(R, z[E]));
    }
    X.schemaProperties = F;
    function N(
      {
        schemaCode: R,
        data: z,
        it: { gen: E, topSchemaRef: O, schemaPath: Z, errorPath: j },
        it: w,
      },
      I,
      T,
      y
    ) {
      let _ = y ? Y._`${R}, ${z}, ${O}${Z}` : z,
        f = [
          [G.default.instancePath, (0, Y.strConcat)(G.default.instancePath, j)],
          [G.default.parentData, w.parentData],
          [G.default.parentDataProperty, w.parentDataProperty],
          [G.default.rootData, G.default.rootData],
        ];
      if (w.opts.dynamicRef)
        f.push([G.default.dynamicAnchors, G.default.dynamicAnchors]);
      let l = Y._`${_}, ${E.object(...f)}`;
      return T !== Y.nil ? Y._`${I}.call(${T}, ${l})` : Y._`${I}(${l})`;
    }
    X.callValidateCode = N;
    var q = Y._`new RegExp`;
    function M({ gen: R, it: { opts: z } }, E) {
      let O = z.unicodeRegExp ? "u" : "",
        { regExp: Z } = z.code,
        j = Z(E, O);
      return R.scopeValue("pattern", {
        key: j.toString(),
        ref: j,
        code: Y._`${Z.code === "new RegExp" ? q : (0, J.useFunc)(R, Z)}(${E}, ${O})`,
      });
    }
    X.usePattern = M;
    function A(R) {
      let { gen: z, data: E, keyword: O, it: Z } = R,
        j = z.name("valid");
      if (Z.allErrors) {
        let I = z.let("valid", !0);
        return (w(() => z.assign(I, !1)), I);
      }
      return (z.var(j, !0), w(() => z.break()), j);
      function w(I) {
        let T = z.const("len", Y._`${E}.length`);
        z.forRange("i", 0, T, (y) => {
          (R.subschema(
            { keyword: O, dataProp: y, dataPropType: Q.Type.Num },
            j
          ),
            z.if((0, Y.not)(j), I));
        });
      }
    }
    X.validateArray = A;
    function D(R) {
      let { gen: z, schema: E, keyword: O, it: Z } = R;
      if (!Array.isArray(E)) throw Error("ajv implementation error");
      if (E.some((T) => (0, Q.alwaysValidSchema)(Z, T)) && !Z.opts.unevaluated)
        return;
      let w = z.let("valid", !1),
        I = z.name("_valid");
      (z.block(() =>
        E.forEach((T, y) => {
          let _ = R.subschema(
            { keyword: O, schemaProp: y, compositeRule: !0 },
            I
          );
          if ((z.assign(w, Y._`${w} || ${I}`), !R.mergeValidEvaluated(_, I)))
            z.if((0, Y.not)(w));
        })
      ),
        R.result(
          w,
          () => R.reset(),
          () => R.error(!0)
        ));
    }
    X.validateUnion = D;
  }),
  tf = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.validateKeywordUsage =
        X.validSchemaType =
        X.funcKeywordCode =
        X.macroKeywordCode =
          void 0));
    var Y = D1(),
      Q = u4(),
      G = p8(),
      J = $J();
    function U(F, N) {
      let { gen: q, keyword: M, schema: A, parentSchema: D, it: R } = F,
        z = N.macro.call(R.self, A, D, R),
        E = W(q, M, z);
      if (R.opts.validateSchema !== !1) R.self.validateSchema(z, !0);
      let O = q.name("valid");
      (F.subschema(
        {
          schema: z,
          schemaPath: Y.nil,
          errSchemaPath: `${R.errSchemaPath}/${M}`,
          topSchemaRef: E,
          compositeRule: !0,
        },
        O
      ),
        F.pass(O, () => F.error(!0)));
    }
    X.macroKeywordCode = U;
    function $(F, N) {
      var q;
      let {
        gen: M,
        keyword: A,
        schema: D,
        parentSchema: R,
        $data: z,
        it: E,
      } = F;
      V(E, N);
      let O = !z && N.compile ? N.compile.call(E.self, D, R, E) : N.validate,
        Z = W(M, A, O),
        j = M.let("valid");
      (F.block$data(j, w),
        F.ok((q = N.valid) !== null && q !== void 0 ? q : j));
      function w() {
        if (N.errors === !1) {
          if ((y(), N.modifying)) B(F);
          _(() => F.error());
        } else {
          let f = N.async ? I() : T();
          if (N.modifying) B(F);
          _(() => K(F, f));
        }
      }
      function I() {
        let f = M.let("ruleErrs", null);
        return (
          M.try(
            () => y(Y._`await `),
            (l) =>
              M.assign(j, !1).if(
                Y._`${l} instanceof ${E.ValidationError}`,
                () => M.assign(f, Y._`${l}.errors`),
                () => M.throw(l)
              )
          ),
          f
        );
      }
      function T() {
        let f = Y._`${Z}.errors`;
        return (M.assign(f, null), y(Y.nil), f);
      }
      function y(f = N.async ? Y._`await ` : Y.nil) {
        let l = E.opts.passContext ? Q.default.this : Q.default.self,
          h = !(("compile" in N && !z) || N.schema === !1);
        M.assign(
          j,
          Y._`${f}${(0, G.callValidateCode)(F, Z, l, h)}`,
          N.modifying
        );
      }
      function _(f) {
        var l;
        M.if((0, Y.not)((l = N.valid) !== null && l !== void 0 ? l : j), f);
      }
    }
    X.funcKeywordCode = $;
    function B(F) {
      let { gen: N, data: q, it: M } = F;
      N.if(M.parentData, () =>
        N.assign(q, Y._`${M.parentData}[${M.parentDataProperty}]`)
      );
    }
    function K(F, N) {
      let { gen: q } = F;
      q.if(
        Y._`Array.isArray(${N})`,
        () => {
          (q
            .assign(
              Q.default.vErrors,
              Y._`${Q.default.vErrors} === null ? ${N} : ${Q.default.vErrors}.concat(${N})`
            )
            .assign(Q.default.errors, Y._`${Q.default.vErrors}.length`),
            (0, J.extendErrors)(F));
        },
        () => F.error()
      );
    }
    function V({ schemaEnv: F }, N) {
      if (N.async && !F.$async) throw Error("async keyword in sync schema");
    }
    function W(F, N, q) {
      if (q === void 0) throw Error(`keyword "${N}" failed to compile`);
      return F.scopeValue(
        "keyword",
        typeof q == "function"
          ? { ref: q }
          : { ref: q, code: (0, Y.stringify)(q) }
      );
    }
    function L(F, N, q = !1) {
      return (
        !N.length ||
        N.some((M) =>
          M === "array"
            ? Array.isArray(F)
            : M === "object"
              ? F && typeof F == "object" && !Array.isArray(F)
              : typeof F == M || (q && typeof F > "u")
        )
      );
    }
    X.validSchemaType = L;
    function H({ schema: F, opts: N, self: q, errSchemaPath: M }, A, D) {
      if (Array.isArray(A.keyword) ? !A.keyword.includes(D) : A.keyword !== D)
        throw Error("ajv implementation error");
      let R = A.dependencies;
      if (
        R === null || R === void 0
          ? void 0
          : R.some((z) => !Object.prototype.hasOwnProperty.call(F, z))
      )
        throw Error(
          `parent schema must have dependencies of ${D}: ${R.join(",")}`
        );
      if (A.validateSchema) {
        if (!A.validateSchema(F[D])) {
          let E =
            `keyword "${D}" value is invalid at path "${M}": ` +
            q.errorsText(A.validateSchema.errors);
          if (N.validateSchema === "log") q.logger.error(E);
          else throw Error(E);
        }
      }
    }
    X.validateKeywordUsage = H;
  }),
  ef = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.extendSubschemaMode =
        X.extendSubschemaData =
        X.getSubschema =
          void 0));
    var Y = D1(),
      Q = m1();
    function G(
      $,
      {
        keyword: B,
        schemaProp: K,
        schema: V,
        schemaPath: W,
        errSchemaPath: L,
        topSchemaRef: H,
      }
    ) {
      if (B !== void 0 && V !== void 0)
        throw Error('both "keyword" and "schema" passed, only one allowed');
      if (B !== void 0) {
        let F = $.schema[B];
        return K === void 0
          ? {
              schema: F,
              schemaPath: Y._`${$.schemaPath}${(0, Y.getProperty)(B)}`,
              errSchemaPath: `${$.errSchemaPath}/${B}`,
            }
          : {
              schema: F[K],
              schemaPath: Y._`${$.schemaPath}${(0, Y.getProperty)(B)}${(0, Y.getProperty)(K)}`,
              errSchemaPath: `${$.errSchemaPath}/${B}/${(0, Q.escapeFragment)(K)}`,
            };
      }
      if (V !== void 0) {
        if (W === void 0 || L === void 0 || H === void 0)
          throw Error(
            '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"'
          );
        return { schema: V, schemaPath: W, topSchemaRef: H, errSchemaPath: L };
      }
      throw Error('either "keyword" or "schema" must be passed');
    }
    X.getSubschema = G;
    function J(
      $,
      B,
      { dataProp: K, dataPropType: V, data: W, dataTypes: L, propertyName: H }
    ) {
      if (W !== void 0 && K !== void 0)
        throw Error('both "data" and "dataProp" passed, only one allowed');
      let { gen: F } = B;
      if (K !== void 0) {
        let { errorPath: q, dataPathArr: M, opts: A } = B,
          D = F.let("data", Y._`${B.data}${(0, Y.getProperty)(K)}`, !0);
        (N(D),
          ($.errorPath = Y.str`${q}${(0, Q.getErrorPath)(K, V, A.jsPropertySyntax)}`),
          ($.parentDataProperty = Y._`${K}`),
          ($.dataPathArr = [...M, $.parentDataProperty]));
      }
      if (W !== void 0) {
        let q = W instanceof Y.Name ? W : F.let("data", W, !0);
        if ((N(q), H !== void 0)) $.propertyName = H;
      }
      if (L) $.dataTypes = L;
      function N(q) {
        (($.data = q),
          ($.dataLevel = B.dataLevel + 1),
          ($.dataTypes = []),
          (B.definedProperties = new Set()),
          ($.parentData = B.data),
          ($.dataNames = [...B.dataNames, q]));
      }
    }
    X.extendSubschemaData = J;
    function U(
      $,
      {
        jtdDiscriminator: B,
        jtdMetadata: K,
        compositeRule: V,
        createErrors: W,
        allErrors: L,
      }
    ) {
      if (V !== void 0) $.compositeRule = V;
      if (W !== void 0) $.createErrors = W;
      if (L !== void 0) $.allErrors = L;
      (($.jtdDiscriminator = B), ($.jtdMetadata = K));
    }
    X.extendSubschemaMode = U;
  }),
  Xx = L0((X, Y) => {
    var Q = (Y.exports = function (U, $, B) {
      if (typeof $ == "function") ((B = $), ($ = {}));
      B = $.cb || B;
      var K = typeof B == "function" ? B : B.pre || function () {},
        V = B.post || function () {};
      G($, K, V, U, "", U);
    });
    ((Q.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0,
    }),
      (Q.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 }),
      (Q.propsKeywords = {
        $defs: !0,
        definitions: !0,
        properties: !0,
        patternProperties: !0,
        dependencies: !0,
      }),
      (Q.skipKeywords = {
        default: !0,
        enum: !0,
        const: !0,
        required: !0,
        maximum: !0,
        minimum: !0,
        exclusiveMaximum: !0,
        exclusiveMinimum: !0,
        multipleOf: !0,
        maxLength: !0,
        minLength: !0,
        pattern: !0,
        format: !0,
        maxItems: !0,
        minItems: !0,
        uniqueItems: !0,
        maxProperties: !0,
        minProperties: !0,
      }));
    function G(U, $, B, K, V, W, L, H, F, N) {
      if (K && typeof K == "object" && !Array.isArray(K)) {
        $(K, V, W, L, H, F, N);
        for (var q in K) {
          var M = K[q];
          if (Array.isArray(M)) {
            if (q in Q.arrayKeywords)
              for (var A = 0; A < M.length; A++)
                G(U, $, B, M[A], V + "/" + q + "/" + A, W, V, q, K, A);
          } else if (q in Q.propsKeywords) {
            if (M && typeof M == "object")
              for (var D in M)
                G(U, $, B, M[D], V + "/" + q + "/" + J(D), W, V, q, K, D);
          } else if (q in Q.keywords || (U.allKeys && !(q in Q.skipKeywords)))
            G(U, $, B, M, V + "/" + q, W, V, q, K);
        }
        B(K, V, W, L, H, F, N);
      }
    }
    function J(U) {
      return U.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }),
  UJ = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.getSchemaRefs =
        X.resolveUrl =
        X.normalizeId =
        X._getFullPath =
        X.getFullPath =
        X.inlineRef =
          void 0));
    var Y = m1(),
      Q = GJ(),
      G = Xx(),
      J = new Set([
        "type",
        "format",
        "pattern",
        "maxLength",
        "minLength",
        "maxProperties",
        "minProperties",
        "maxItems",
        "minItems",
        "maximum",
        "minimum",
        "uniqueItems",
        "multipleOf",
        "required",
        "enum",
        "const",
      ]);
    function U(M, A = !0) {
      if (typeof M == "boolean") return !0;
      if (A === !0) return !B(M);
      if (!A) return !1;
      return K(M) <= A;
    }
    X.inlineRef = U;
    var $ = new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor",
    ]);
    function B(M) {
      for (let A in M) {
        if ($.has(A)) return !0;
        let D = M[A];
        if (Array.isArray(D) && D.some(B)) return !0;
        if (typeof D == "object" && B(D)) return !0;
      }
      return !1;
    }
    function K(M) {
      let A = 0;
      for (let D in M) {
        if (D === "$ref") return 1 / 0;
        if ((A++, J.has(D))) continue;
        if (typeof M[D] == "object") (0, Y.eachItem)(M[D], (R) => (A += K(R)));
        if (A === 1 / 0) return 1 / 0;
      }
      return A;
    }
    function V(M, A = "", D) {
      if (D !== !1) A = H(A);
      let R = M.parse(A);
      return W(M, R);
    }
    X.getFullPath = V;
    function W(M, A) {
      return M.serialize(A).split("#")[0] + "#";
    }
    X._getFullPath = W;
    var L = /#\/?$/;
    function H(M) {
      return M ? M.replace(L, "") : "";
    }
    X.normalizeId = H;
    function F(M, A, D) {
      return ((D = H(D)), M.resolve(A, D));
    }
    X.resolveUrl = F;
    var N = /^[a-z_][-a-z0-9._]*$/i;
    function q(M, A) {
      if (typeof M == "boolean") return {};
      let { schemaId: D, uriResolver: R } = this.opts,
        z = H(M[D] || A),
        E = { "": z },
        O = V(R, z, !1),
        Z = {},
        j = new Set();
      return (
        G(M, { allKeys: !0 }, (T, y, _, f) => {
          if (f === void 0) return;
          let l = O + y,
            h = E[f];
          if (typeof T[D] == "string") h = p.call(this, T[D]);
          (N0.call(this, T.$anchor),
            N0.call(this, T.$dynamicAnchor),
            (E[y] = h));
          function p(e) {
            let P = this.opts.uriResolver.resolve;
            if (((e = H(h ? P(h, e) : e)), j.has(e))) throw I(e);
            j.add(e);
            let x = this.refs[e];
            if (typeof x == "string") x = this.refs[x];
            if (typeof x == "object") w(T, x.schema, e);
            else if (e !== H(l))
              if (e[0] === "#") (w(T, Z[e], e), (Z[e] = T));
              else this.refs[e] = l;
            return e;
          }
          function N0(e) {
            if (typeof e == "string") {
              if (!N.test(e)) throw Error(`invalid anchor "${e}"`);
              p.call(this, `#${e}`);
            }
          }
        }),
        Z
      );
      function w(T, y, _) {
        if (y !== void 0 && !Q(T, y)) throw I(_);
      }
      function I(T) {
        return Error(`reference "${T}" resolves to more than one schema`);
      }
    }
    X.getSchemaRefs = q;
  }),
  LJ = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.getData = X.KeywordCxt = X.validateFunctionCode = void 0));
    var Y = of(),
      Q = dG(),
      G = lE(),
      J = dG(),
      U = sf(),
      $ = tf(),
      B = ef(),
      K = D1(),
      V = u4(),
      W = UJ(),
      L = m1(),
      H = $J();
    function F(b) {
      if (O(b)) {
        if ((j(b), E(b))) {
          A(b);
          return;
        }
      }
      N(b, () => (0, Y.topBoolOrEmptySchema)(b));
    }
    X.validateFunctionCode = F;
    function N(
      { gen: b, validateName: m, schema: n, schemaEnv: M0, opts: D0 },
      Z0
    ) {
      if (D0.code.es5)
        b.func(
          m,
          K._`${V.default.data}, ${V.default.valCxt}`,
          M0.$async,
          () => {
            (b.code(K._`"use strict"; ${R(n, D0)}`), M(b, D0), b.code(Z0));
          }
        );
      else
        b.func(m, K._`${V.default.data}, ${q(D0)}`, M0.$async, () =>
          b.code(R(n, D0)).code(Z0)
        );
    }
    function q(b) {
      return K._`{${V.default.instancePath}="", ${V.default.parentData}, ${V.default.parentDataProperty}, ${V.default.rootData}=${V.default.data}${b.dynamicRef ? K._`, ${V.default.dynamicAnchors}={}` : K.nil}}={}`;
    }
    function M(b, m) {
      b.if(
        V.default.valCxt,
        () => {
          if (
            (b.var(
              V.default.instancePath,
              K._`${V.default.valCxt}.${V.default.instancePath}`
            ),
            b.var(
              V.default.parentData,
              K._`${V.default.valCxt}.${V.default.parentData}`
            ),
            b.var(
              V.default.parentDataProperty,
              K._`${V.default.valCxt}.${V.default.parentDataProperty}`
            ),
            b.var(
              V.default.rootData,
              K._`${V.default.valCxt}.${V.default.rootData}`
            ),
            m.dynamicRef)
          )
            b.var(
              V.default.dynamicAnchors,
              K._`${V.default.valCxt}.${V.default.dynamicAnchors}`
            );
        },
        () => {
          if (
            (b.var(V.default.instancePath, K._`""`),
            b.var(V.default.parentData, K._`undefined`),
            b.var(V.default.parentDataProperty, K._`undefined`),
            b.var(V.default.rootData, V.default.data),
            m.dynamicRef)
          )
            b.var(V.default.dynamicAnchors, K._`{}`);
        }
      );
    }
    function A(b) {
      let { schema: m, opts: n, gen: M0 } = b;
      N(b, () => {
        if (n.$comment && m.$comment) f(b);
        if (
          (T(b),
          M0.let(V.default.vErrors, null),
          M0.let(V.default.errors, 0),
          n.unevaluated)
        )
          D(b);
        (w(b), l(b));
      });
      return;
    }
    function D(b) {
      let { gen: m, validateName: n } = b;
      ((b.evaluated = m.const("evaluated", K._`${n}.evaluated`)),
        m.if(K._`${b.evaluated}.dynamicProps`, () =>
          m.assign(K._`${b.evaluated}.props`, K._`undefined`)
        ),
        m.if(K._`${b.evaluated}.dynamicItems`, () =>
          m.assign(K._`${b.evaluated}.items`, K._`undefined`)
        ));
    }
    function R(b, m) {
      let n = typeof b == "object" && b[m.schemaId];
      return n && (m.code.source || m.code.process)
        ? K._`/*# sourceURL=${n} */`
        : K.nil;
    }
    function z(b, m) {
      if (O(b)) {
        if ((j(b), E(b))) {
          Z(b, m);
          return;
        }
      }
      (0, Y.boolOrEmptySchema)(b, m);
    }
    function E({ schema: b, self: m }) {
      if (typeof b == "boolean") return !b;
      for (let n in b) if (m.RULES.all[n]) return !0;
      return !1;
    }
    function O(b) {
      return typeof b.schema != "boolean";
    }
    function Z(b, m) {
      let { schema: n, gen: M0, opts: D0 } = b;
      if (D0.$comment && n.$comment) f(b);
      (y(b), _(b));
      let Z0 = M0.const("_errs", V.default.errors);
      (w(b, Z0), M0.var(m, K._`${Z0} === ${V.default.errors}`));
    }
    function j(b) {
      ((0, L.checkUnknownRules)(b), I(b));
    }
    function w(b, m) {
      if (b.opts.jtd) return p(b, [], !1, m);
      let n = (0, Q.getSchemaTypes)(b.schema),
        M0 = (0, Q.coerceAndCheckDataType)(b, n);
      p(b, n, !M0, m);
    }
    function I(b) {
      let { schema: m, errSchemaPath: n, opts: M0, self: D0 } = b;
      if (
        m.$ref &&
        M0.ignoreKeywordsWithRef &&
        (0, L.schemaHasRulesButRef)(m, D0.RULES)
      )
        D0.logger.warn(`$ref: keywords ignored in schema at path "${n}"`);
    }
    function T(b) {
      let { schema: m, opts: n } = b;
      if (m.default !== void 0 && n.useDefaults && n.strictSchema)
        (0, L.checkStrictMode)(b, "default is ignored in the schema root");
    }
    function y(b) {
      let m = b.schema[b.opts.schemaId];
      if (m) b.baseId = (0, W.resolveUrl)(b.opts.uriResolver, b.baseId, m);
    }
    function _(b) {
      if (b.schema.$async && !b.schemaEnv.$async)
        throw Error("async schema in sync schema");
    }
    function f({
      gen: b,
      schemaEnv: m,
      schema: n,
      errSchemaPath: M0,
      opts: D0,
    }) {
      let Z0 = n.$comment;
      if (D0.$comment === !0) b.code(K._`${V.default.self}.logger.log(${Z0})`);
      else if (typeof D0.$comment == "function") {
        let B1 = K.str`${M0}/$comment`,
          j1 = b.scopeValue("root", { ref: m.root });
        b.code(
          K._`${V.default.self}.opts.$comment(${Z0}, ${B1}, ${j1}.schema)`
        );
      }
    }
    function l(b) {
      let {
        gen: m,
        schemaEnv: n,
        validateName: M0,
        ValidationError: D0,
        opts: Z0,
      } = b;
      if (n.$async)
        m.if(
          K._`${V.default.errors} === 0`,
          () => m.return(V.default.data),
          () => m.throw(K._`new ${D0}(${V.default.vErrors})`)
        );
      else {
        if ((m.assign(K._`${M0}.errors`, V.default.vErrors), Z0.unevaluated))
          h(b);
        m.return(K._`${V.default.errors} === 0`);
      }
    }
    function h({ gen: b, evaluated: m, props: n, items: M0 }) {
      if (n instanceof K.Name) b.assign(K._`${m}.props`, n);
      if (M0 instanceof K.Name) b.assign(K._`${m}.items`, M0);
    }
    function p(b, m, n, M0) {
      let {
          gen: D0,
          schema: Z0,
          data: B1,
          allErrors: j1,
          opts: v1,
          self: M1,
        } = b,
        { RULES: x0 } = M1;
      if (
        Z0.$ref &&
        (v1.ignoreKeywordsWithRef || !(0, L.schemaHasRulesButRef)(Z0, x0))
      ) {
        D0.block(() => z0(b, "$ref", x0.all.$ref.definition));
        return;
      }
      if (!v1.jtd) e(b, m);
      D0.block(() => {
        for (let g1 of x0.rules) h1(g1);
        h1(x0.post);
      });
      function h1(g1) {
        if (!(0, G.shouldUseGroup)(Z0, g1)) return;
        if (g1.type) {
          if (
            (D0.if((0, J.checkDataType)(g1.type, B1, v1.strictNumbers)),
            N0(b, g1),
            m.length === 1 && m[0] === g1.type && n)
          )
            (D0.else(), (0, J.reportTypeError)(b));
          D0.endIf();
        } else N0(b, g1);
        if (!j1) D0.if(K._`${V.default.errors} === ${M0 || 0}`);
      }
    }
    function N0(b, m) {
      let {
        gen: n,
        schema: M0,
        opts: { useDefaults: D0 },
      } = b;
      if (D0) (0, U.assignDefaults)(b, m.type);
      n.block(() => {
        for (let Z0 of m.rules)
          if ((0, G.shouldUseRule)(M0, Z0))
            z0(b, Z0.keyword, Z0.definition, m.type);
      });
    }
    function e(b, m) {
      if (b.schemaEnv.meta || !b.opts.strictTypes) return;
      if ((P(b, m), !b.opts.allowUnionTypes)) x(b, m);
      r(b, b.dataTypes);
    }
    function P(b, m) {
      if (!m.length) return;
      if (!b.dataTypes.length) {
        b.dataTypes = m;
        return;
      }
      (m.forEach((n) => {
        if (!v(b.dataTypes, n))
          o(b, `type "${n}" not allowed by context "${b.dataTypes.join(",")}"`);
      }),
        k(b, m));
    }
    function x(b, m) {
      if (m.length > 1 && !(m.length === 2 && m.includes("null")))
        o(b, "use allowUnionTypes to allow union type keyword");
    }
    function r(b, m) {
      let n = b.self.RULES.all;
      for (let M0 in n) {
        let D0 = n[M0];
        if (typeof D0 == "object" && (0, G.shouldUseRule)(b.schema, D0)) {
          let { type: Z0 } = D0.definition;
          if (Z0.length && !Z0.some((B1) => C(m, B1)))
            o(b, `missing type "${Z0.join(",")}" for keyword "${M0}"`);
        }
      }
    }
    function C(b, m) {
      return b.includes(m) || (m === "number" && b.includes("integer"));
    }
    function v(b, m) {
      return b.includes(m) || (m === "integer" && b.includes("number"));
    }
    function k(b, m) {
      let n = [];
      for (let M0 of b.dataTypes)
        if (v(m, M0)) n.push(M0);
        else if (m.includes("integer") && M0 === "number") n.push("integer");
      b.dataTypes = n;
    }
    function o(b, m) {
      let n = b.schemaEnv.baseId + b.errSchemaPath;
      ((m += ` at "${n}" (strictTypes)`),
        (0, L.checkStrictMode)(b, m, b.opts.strictTypes));
    }
    class J0 {
      constructor(b, m, n) {
        if (
          ((0, $.validateKeywordUsage)(b, m, n),
          (this.gen = b.gen),
          (this.allErrors = b.allErrors),
          (this.keyword = n),
          (this.data = b.data),
          (this.schema = b.schema[n]),
          (this.$data =
            m.$data && b.opts.$data && this.schema && this.schema.$data),
          (this.schemaValue = (0, L.schemaRefOrVal)(
            b,
            this.schema,
            n,
            this.$data
          )),
          (this.schemaType = m.schemaType),
          (this.parentSchema = b.schema),
          (this.params = {}),
          (this.it = b),
          (this.def = m),
          this.$data)
        )
          this.schemaCode = b.gen.const("vSchema", Y1(this.$data, b));
        else if (
          ((this.schemaCode = this.schemaValue),
          !(0, $.validSchemaType)(this.schema, m.schemaType, m.allowUndefined))
        )
          throw Error(`${n} value must be ${JSON.stringify(m.schemaType)}`);
        if ("code" in m ? m.trackErrors : m.errors !== !1)
          this.errsCount = b.gen.const("_errs", V.default.errors);
      }
      result(b, m, n) {
        this.failResult((0, K.not)(b), m, n);
      }
      failResult(b, m, n) {
        if ((this.gen.if(b), n)) n();
        else this.error();
        if (m) {
          if ((this.gen.else(), m(), this.allErrors)) this.gen.endIf();
        } else if (this.allErrors) this.gen.endIf();
        else this.gen.else();
      }
      pass(b, m) {
        this.failResult((0, K.not)(b), void 0, m);
      }
      fail(b) {
        if (b === void 0) {
          if ((this.error(), !this.allErrors)) this.gen.if(!1);
          return;
        }
        if ((this.gen.if(b), this.error(), this.allErrors)) this.gen.endIf();
        else this.gen.else();
      }
      fail$data(b) {
        if (!this.$data) return this.fail(b);
        let { schemaCode: m } = this;
        this.fail(
          K._`${m} !== undefined && (${(0, K.or)(this.invalid$data(), b)})`
        );
      }
      error(b, m, n) {
        if (m) {
          (this.setParams(m), this._error(b, n), this.setParams({}));
          return;
        }
        this._error(b, n);
      }
      _error(b, m) {
        (b ? H.reportExtraError : H.reportError)(this, this.def.error, m);
      }
      $dataError() {
        (0, H.reportError)(this, this.def.$dataError || H.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw Error('add "trackErrors" to keyword definition');
        (0, H.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(b) {
        if (!this.allErrors) this.gen.if(b);
      }
      setParams(b, m) {
        if (m) Object.assign(this.params, b);
        else this.params = b;
      }
      block$data(b, m, n = K.nil) {
        this.gen.block(() => {
          (this.check$data(b, n), m());
        });
      }
      check$data(b = K.nil, m = K.nil) {
        if (!this.$data) return;
        let { gen: n, schemaCode: M0, schemaType: D0, def: Z0 } = this;
        if ((n.if((0, K.or)(K._`${M0} === undefined`, m)), b !== K.nil))
          n.assign(b, !0);
        if (D0.length || Z0.validateSchema) {
          if ((n.elseIf(this.invalid$data()), this.$dataError(), b !== K.nil))
            n.assign(b, !1);
        }
        n.else();
      }
      invalid$data() {
        let { gen: b, schemaCode: m, schemaType: n, def: M0, it: D0 } = this;
        return (0, K.or)(Z0(), B1());
        function Z0() {
          if (n.length) {
            if (!(m instanceof K.Name)) throw Error("ajv implementation error");
            let j1 = Array.isArray(n) ? n : [n];
            return K._`${(0, J.checkDataTypes)(j1, m, D0.opts.strictNumbers, J.DataType.Wrong)}`;
          }
          return K.nil;
        }
        function B1() {
          if (M0.validateSchema) {
            let j1 = b.scopeValue("validate$data", { ref: M0.validateSchema });
            return K._`!${j1}(${m})`;
          }
          return K.nil;
        }
      }
      subschema(b, m) {
        let n = (0, B.getSubschema)(this.it, b);
        ((0, B.extendSubschemaData)(n, this.it, b),
          (0, B.extendSubschemaMode)(n, b));
        let M0 = { ...this.it, ...n, items: void 0, props: void 0 };
        return (z(M0, m), M0);
      }
      mergeEvaluated(b, m) {
        let { it: n, gen: M0 } = this;
        if (!n.opts.unevaluated) return;
        if (n.props !== !0 && b.props !== void 0)
          n.props = L.mergeEvaluated.props(M0, b.props, n.props, m);
        if (n.items !== !0 && b.items !== void 0)
          n.items = L.mergeEvaluated.items(M0, b.items, n.items, m);
      }
      mergeValidEvaluated(b, m) {
        let { it: n, gen: M0 } = this;
        if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
          return (M0.if(m, () => this.mergeEvaluated(b, K.Name)), !0);
      }
    }
    X.KeywordCxt = J0;
    function z0(b, m, n, M0) {
      let D0 = new J0(b, n, m);
      if ("code" in n) n.code(D0, M0);
      else if (D0.$data && n.validate) (0, $.funcKeywordCode)(D0, n);
      else if ("macro" in n) (0, $.macroKeywordCode)(D0, n);
      else if (n.compile || n.validate) (0, $.funcKeywordCode)(D0, n);
    }
    var A0 = /^\/(?:[^~]|~0|~1)*$/,
      w0 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function Y1(b, { dataLevel: m, dataNames: n, dataPathArr: M0 }) {
      let D0, Z0;
      if (b === "") return V.default.rootData;
      if (b[0] === "/") {
        if (!A0.test(b)) throw Error(`Invalid JSON-pointer: ${b}`);
        ((D0 = b), (Z0 = V.default.rootData));
      } else {
        let M1 = w0.exec(b);
        if (!M1) throw Error(`Invalid JSON-pointer: ${b}`);
        let x0 = +M1[1];
        if (((D0 = M1[2]), D0 === "#")) {
          if (x0 >= m) throw Error(v1("property/index", x0));
          return M0[m - x0];
        }
        if (x0 > m) throw Error(v1("data", x0));
        if (((Z0 = n[m - x0]), !D0)) return Z0;
      }
      let B1 = Z0,
        j1 = D0.split("/");
      for (let M1 of j1)
        if (M1)
          ((Z0 = K._`${Z0}${(0, K.getProperty)((0, L.unescapeJsonPointer)(M1))}`),
            (B1 = K._`${B1} && ${Z0}`));
      return B1;
      function v1(M1, x0) {
        return `Cannot access ${M1} ${x0} levels up, current level is ${m}`;
      }
    }
    X.getData = Y1;
  }),
  gU = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    class Y extends Error {
      constructor(Q) {
        super("validation failed");
        ((this.errors = Q), (this.ajv = this.validation = !0));
      }
    }
    X.default = Y;
  }),
  BJ = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = UJ();
    class Q extends Error {
      constructor(G, J, U, $) {
        super($ || `can't resolve reference ${U} from id ${J}`);
        ((this.missingRef = (0, Y.resolveUrl)(G, J, U)),
          (this.missingSchema = (0, Y.normalizeId)(
            (0, Y.getFullPath)(G, this.missingRef)
          )));
      }
    }
    X.default = Q;
  }),
  uU = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.resolveSchema =
        X.getCompilingSchema =
        X.resolveRef =
        X.compileSchema =
        X.SchemaEnv =
          void 0));
    var Y = D1(),
      Q = gU(),
      G = u4(),
      J = UJ(),
      U = m1(),
      $ = LJ();
    class B {
      constructor(A) {
        var D;
        ((this.refs = {}), (this.dynamicAnchors = {}));
        let R;
        if (typeof A.schema == "object") R = A.schema;
        ((this.schema = A.schema),
          (this.schemaId = A.schemaId),
          (this.root = A.root || this),
          (this.baseId =
            (D = A.baseId) !== null && D !== void 0
              ? D
              : (0, J.normalizeId)(
                  R === null || R === void 0 ? void 0 : R[A.schemaId || "$id"]
                )),
          (this.schemaPath = A.schemaPath),
          (this.localRefs = A.localRefs),
          (this.meta = A.meta),
          (this.$async = R === null || R === void 0 ? void 0 : R.$async),
          (this.refs = {}));
      }
    }
    X.SchemaEnv = B;
    function K(A) {
      let D = L.call(this, A);
      if (D) return D;
      let R = (0, J.getFullPath)(this.opts.uriResolver, A.root.baseId),
        { es5: z, lines: E } = this.opts.code,
        { ownProperties: O } = this.opts,
        Z = new Y.CodeGen(this.scope, { es5: z, lines: E, ownProperties: O }),
        j;
      if (A.$async)
        j = Z.scopeValue("Error", {
          ref: Q.default,
          code: Y._`require("ajv/dist/runtime/validation_error").default`,
        });
      let w = Z.scopeName("validate");
      A.validateName = w;
      let I = {
          gen: Z,
          allErrors: this.opts.allErrors,
          data: G.default.data,
          parentData: G.default.parentData,
          parentDataProperty: G.default.parentDataProperty,
          dataNames: [G.default.data],
          dataPathArr: [Y.nil],
          dataLevel: 0,
          dataTypes: [],
          definedProperties: new Set(),
          topSchemaRef: Z.scopeValue(
            "schema",
            this.opts.code.source === !0
              ? { ref: A.schema, code: (0, Y.stringify)(A.schema) }
              : { ref: A.schema }
          ),
          validateName: w,
          ValidationError: j,
          schema: A.schema,
          schemaEnv: A,
          rootId: R,
          baseId: A.baseId || R,
          schemaPath: Y.nil,
          errSchemaPath: A.schemaPath || (this.opts.jtd ? "" : "#"),
          errorPath: Y._`""`,
          opts: this.opts,
          self: this,
        },
        T;
      try {
        (this._compilations.add(A),
          (0, $.validateFunctionCode)(I),
          Z.optimize(this.opts.code.optimize));
        let y = Z.toString();
        if (
          ((T = `${Z.scopeRefs(G.default.scope)}return ${y}`),
          this.opts.code.process)
        )
          T = this.opts.code.process(T, A);
        let f = Function(
          `${G.default.self}`,
          `${G.default.scope}`,
          T
        )(this, this.scope.get());
        if (
          (this.scope.value(w, { ref: f }),
          (f.errors = null),
          (f.schema = A.schema),
          (f.schemaEnv = A),
          A.$async)
        )
          f.$async = !0;
        if (this.opts.code.source === !0)
          f.source = {
            validateName: w,
            validateCode: y,
            scopeValues: Z._values,
          };
        if (this.opts.unevaluated) {
          let { props: l, items: h } = I;
          if (
            ((f.evaluated = {
              props: l instanceof Y.Name ? void 0 : l,
              items: h instanceof Y.Name ? void 0 : h,
              dynamicProps: l instanceof Y.Name,
              dynamicItems: h instanceof Y.Name,
            }),
            f.source)
          )
            f.source.evaluated = (0, Y.stringify)(f.evaluated);
        }
        return ((A.validate = f), A);
      } catch (y) {
        if ((delete A.validate, delete A.validateName, T))
          this.logger.error("Error compiling schema, function code:", T);
        throw y;
      } finally {
        this._compilations.delete(A);
      }
    }
    X.compileSchema = K;
    function V(A, D, R) {
      var z;
      R = (0, J.resolveUrl)(this.opts.uriResolver, D, R);
      let E = A.refs[R];
      if (E) return E;
      let O = F.call(this, A, R);
      if (O === void 0) {
        let Z = (z = A.localRefs) === null || z === void 0 ? void 0 : z[R],
          { schemaId: j } = this.opts;
        if (Z) O = new B({ schema: Z, schemaId: j, root: A, baseId: D });
      }
      if (O === void 0) return;
      return (A.refs[R] = W.call(this, O));
    }
    X.resolveRef = V;
    function W(A) {
      if ((0, J.inlineRef)(A.schema, this.opts.inlineRefs)) return A.schema;
      return A.validate ? A : K.call(this, A);
    }
    function L(A) {
      for (let D of this._compilations) if (H(D, A)) return D;
    }
    X.getCompilingSchema = L;
    function H(A, D) {
      return (
        A.schema === D.schema && A.root === D.root && A.baseId === D.baseId
      );
    }
    function F(A, D) {
      let R;
      while (typeof (R = this.refs[D]) == "string") D = R;
      return R || this.schemas[D] || N.call(this, A, D);
    }
    function N(A, D) {
      let R = this.opts.uriResolver.parse(D),
        z = (0, J._getFullPath)(this.opts.uriResolver, R),
        E = (0, J.getFullPath)(this.opts.uriResolver, A.baseId, void 0);
      if (Object.keys(A.schema).length > 0 && z === E)
        return M.call(this, R, A);
      let O = (0, J.normalizeId)(z),
        Z = this.refs[O] || this.schemas[O];
      if (typeof Z == "string") {
        let j = N.call(this, A, Z);
        if (
          typeof (j === null || j === void 0 ? void 0 : j.schema) !== "object"
        )
          return;
        return M.call(this, R, j);
      }
      if (typeof (Z === null || Z === void 0 ? void 0 : Z.schema) !== "object")
        return;
      if (!Z.validate) K.call(this, Z);
      if (O === (0, J.normalizeId)(D)) {
        let { schema: j } = Z,
          { schemaId: w } = this.opts,
          I = j[w];
        if (I) E = (0, J.resolveUrl)(this.opts.uriResolver, E, I);
        return new B({ schema: j, schemaId: w, root: A, baseId: E });
      }
      return M.call(this, R, Z);
    }
    X.resolveSchema = N;
    var q = new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions",
    ]);
    function M(A, { baseId: D, schema: R, root: z }) {
      var E;
      if (((E = A.fragment) === null || E === void 0 ? void 0 : E[0]) !== "/")
        return;
      for (let j of A.fragment.slice(1).split("/")) {
        if (typeof R === "boolean") return;
        let w = R[(0, U.unescapeFragment)(j)];
        if (w === void 0) return;
        R = w;
        let I = typeof R === "object" && R[this.opts.schemaId];
        if (!q.has(j) && I) D = (0, J.resolveUrl)(this.opts.uriResolver, D, I);
      }
      let O;
      if (
        typeof R != "boolean" &&
        R.$ref &&
        !(0, U.schemaHasRulesButRef)(R, this.RULES)
      ) {
        let j = (0, J.resolveUrl)(this.opts.uriResolver, D, R.$ref);
        O = N.call(this, z, j);
      }
      let { schemaId: Z } = this.opts;
      if (
        ((O = O || new B({ schema: R, schemaId: Z, root: z, baseId: D })),
        O.schema !== O.root.schema)
      )
        return O;
      return;
    }
  }),
  Yx = L0((X, Y) => {
    Y.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description:
        "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" },
          ],
        },
      },
      additionalProperties: !1,
    };
  }),
  Qx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = fE();
    ((Y.code = 'require("ajv/dist/runtime/uri").default'), (X.default = Y));
  }),
  Gx = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.CodeGen =
        X.Name =
        X.nil =
        X.stringify =
        X.str =
        X._ =
        X.KeywordCxt =
          void 0));
    var Y = LJ();
    Object.defineProperty(X, "KeywordCxt", {
      enumerable: !0,
      get: function () {
        return Y.KeywordCxt;
      },
    });
    var Q = D1();
    (Object.defineProperty(X, "_", {
      enumerable: !0,
      get: function () {
        return Q._;
      },
    }),
      Object.defineProperty(X, "str", {
        enumerable: !0,
        get: function () {
          return Q.str;
        },
      }),
      Object.defineProperty(X, "stringify", {
        enumerable: !0,
        get: function () {
          return Q.stringify;
        },
      }),
      Object.defineProperty(X, "nil", {
        enumerable: !0,
        get: function () {
          return Q.nil;
        },
      }),
      Object.defineProperty(X, "Name", {
        enumerable: !0,
        get: function () {
          return Q.Name;
        },
      }),
      Object.defineProperty(X, "CodeGen", {
        enumerable: !0,
        get: function () {
          return Q.CodeGen;
        },
      }));
    var G = gU(),
      J = BJ(),
      U = uE(),
      $ = uU(),
      B = D1(),
      K = UJ(),
      V = dG(),
      W = m1(),
      L = Yx(),
      H = Qx(),
      F = (P, x) => new RegExp(P, x);
    F.code = "new RegExp";
    var N = ["removeAdditional", "useDefaults", "coerceTypes"],
      q = new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error",
      ]),
      M = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs:
          "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode:
          "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats:
          "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now.",
      },
      A = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode:
          '"minLength"/"maxLength" account for unicode characters by default.',
      },
      D = 200;
    function R(P) {
      var x,
        r,
        C,
        v,
        k,
        o,
        J0,
        z0,
        A0,
        w0,
        Y1,
        b,
        m,
        n,
        M0,
        D0,
        Z0,
        B1,
        j1,
        v1,
        M1,
        x0,
        h1,
        g1,
        b5;
      let r0 = P.strict,
        q8 = (x = P.code) === null || x === void 0 ? void 0 : x.optimize,
        w8 = q8 === !0 || q8 === void 0 ? 1 : q8 || 0,
        Y6 =
          (C = (r = P.code) === null || r === void 0 ? void 0 : r.regExp) !==
            null && C !== void 0
            ? C
            : F,
        R8 = (v = P.uriResolver) !== null && v !== void 0 ? v : H.default;
      return {
        strictSchema:
          (o = (k = P.strictSchema) !== null && k !== void 0 ? k : r0) !==
            null && o !== void 0
            ? o
            : !0,
        strictNumbers:
          (z0 = (J0 = P.strictNumbers) !== null && J0 !== void 0 ? J0 : r0) !==
            null && z0 !== void 0
            ? z0
            : !0,
        strictTypes:
          (w0 = (A0 = P.strictTypes) !== null && A0 !== void 0 ? A0 : r0) !==
            null && w0 !== void 0
            ? w0
            : "log",
        strictTuples:
          (b = (Y1 = P.strictTuples) !== null && Y1 !== void 0 ? Y1 : r0) !==
            null && b !== void 0
            ? b
            : "log",
        strictRequired:
          (n = (m = P.strictRequired) !== null && m !== void 0 ? m : r0) !==
            null && n !== void 0
            ? n
            : !1,
        code: P.code
          ? { ...P.code, optimize: w8, regExp: Y6 }
          : { optimize: w8, regExp: Y6 },
        loopRequired: (M0 = P.loopRequired) !== null && M0 !== void 0 ? M0 : D,
        loopEnum: (D0 = P.loopEnum) !== null && D0 !== void 0 ? D0 : D,
        meta: (Z0 = P.meta) !== null && Z0 !== void 0 ? Z0 : !0,
        messages: (B1 = P.messages) !== null && B1 !== void 0 ? B1 : !0,
        inlineRefs: (j1 = P.inlineRefs) !== null && j1 !== void 0 ? j1 : !0,
        schemaId: (v1 = P.schemaId) !== null && v1 !== void 0 ? v1 : "$id",
        addUsedSchema:
          (M1 = P.addUsedSchema) !== null && M1 !== void 0 ? M1 : !0,
        validateSchema:
          (x0 = P.validateSchema) !== null && x0 !== void 0 ? x0 : !0,
        validateFormats:
          (h1 = P.validateFormats) !== null && h1 !== void 0 ? h1 : !0,
        unicodeRegExp:
          (g1 = P.unicodeRegExp) !== null && g1 !== void 0 ? g1 : !0,
        int32range: (b5 = P.int32range) !== null && b5 !== void 0 ? b5 : !0,
        uriResolver: R8,
      };
    }
    class z {
      constructor(P = {}) {
        ((this.schemas = {}),
          (this.refs = {}),
          (this.formats = {}),
          (this._compilations = new Set()),
          (this._loading = {}),
          (this._cache = new Map()),
          (P = this.opts = { ...P, ...R(P) }));
        let { es5: x, lines: r } = this.opts.code;
        ((this.scope = new B.ValueScope({
          scope: {},
          prefixes: q,
          es5: x,
          lines: r,
        })),
          (this.logger = y(P.logger)));
        let C = P.validateFormats;
        if (
          ((P.validateFormats = !1),
          (this.RULES = (0, U.getRules)()),
          E.call(this, M, P, "NOT SUPPORTED"),
          E.call(this, A, P, "DEPRECATED", "warn"),
          (this._metaOpts = I.call(this)),
          P.formats)
        )
          j.call(this);
        if ((this._addVocabularies(), this._addDefaultMetaSchema(), P.keywords))
          w.call(this, P.keywords);
        if (typeof P.meta == "object") this.addMetaSchema(P.meta);
        (Z.call(this), (P.validateFormats = C));
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        let { $data: P, meta: x, schemaId: r } = this.opts,
          C = L;
        if (r === "id") ((C = { ...L }), (C.id = C.$id), delete C.$id);
        if (x && P) this.addMetaSchema(C, C[r], !1);
      }
      defaultMeta() {
        let { meta: P, schemaId: x } = this.opts;
        return (this.opts.defaultMeta =
          typeof P == "object" ? P[x] || P : void 0);
      }
      validate(P, x) {
        let r;
        if (typeof P == "string") {
          if (((r = this.getSchema(P)), !r))
            throw Error(`no schema with key or ref "${P}"`);
        } else r = this.compile(P);
        let C = r(x);
        if (!("$async" in r)) this.errors = r.errors;
        return C;
      }
      compile(P, x) {
        let r = this._addSchema(P, x);
        return r.validate || this._compileSchemaEnv(r);
      }
      compileAsync(P, x) {
        if (typeof this.opts.loadSchema != "function")
          throw Error("options.loadSchema should be a function");
        let { loadSchema: r } = this.opts;
        return C.call(this, P, x);
        async function C(A0, w0) {
          await v.call(this, A0.$schema);
          let Y1 = this._addSchema(A0, w0);
          return Y1.validate || k.call(this, Y1);
        }
        async function v(A0) {
          if (A0 && !this.getSchema(A0)) await C.call(this, { $ref: A0 }, !0);
        }
        async function k(A0) {
          try {
            return this._compileSchemaEnv(A0);
          } catch (w0) {
            if (!(w0 instanceof J.default)) throw w0;
            return (
              o.call(this, w0),
              await J0.call(this, w0.missingSchema),
              k.call(this, A0)
            );
          }
        }
        function o({ missingSchema: A0, missingRef: w0 }) {
          if (this.refs[A0])
            throw Error(
              `AnySchema ${A0} is loaded but ${w0} cannot be resolved`
            );
        }
        async function J0(A0) {
          let w0 = await z0.call(this, A0);
          if (!this.refs[A0]) await v.call(this, w0.$schema);
          if (!this.refs[A0]) this.addSchema(w0, A0, x);
        }
        async function z0(A0) {
          let w0 = this._loading[A0];
          if (w0) return w0;
          try {
            return await (this._loading[A0] = r(A0));
          } finally {
            delete this._loading[A0];
          }
        }
      }
      addSchema(P, x, r, C = this.opts.validateSchema) {
        if (Array.isArray(P)) {
          for (let k of P) this.addSchema(k, void 0, r, C);
          return this;
        }
        let v;
        if (typeof P === "object") {
          let { schemaId: k } = this.opts;
          if (((v = P[k]), v !== void 0 && typeof v != "string"))
            throw Error(`schema ${k} must be string`);
        }
        return (
          (x = (0, K.normalizeId)(x || v)),
          this._checkUnique(x),
          (this.schemas[x] = this._addSchema(P, r, x, C, !0)),
          this
        );
      }
      addMetaSchema(P, x, r = this.opts.validateSchema) {
        return (this.addSchema(P, x, !0, r), this);
      }
      validateSchema(P, x) {
        if (typeof P == "boolean") return !0;
        let r;
        if (((r = P.$schema), r !== void 0 && typeof r != "string"))
          throw Error("$schema must be a string");
        if (((r = r || this.opts.defaultMeta || this.defaultMeta()), !r))
          return (
            this.logger.warn("meta-schema not available"),
            (this.errors = null),
            !0
          );
        let C = this.validate(r, P);
        if (!C && x) {
          let v = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log") this.logger.error(v);
          else throw Error(v);
        }
        return C;
      }
      getSchema(P) {
        let x;
        while (typeof (x = O.call(this, P)) == "string") P = x;
        if (x === void 0) {
          let { schemaId: r } = this.opts,
            C = new $.SchemaEnv({ schema: {}, schemaId: r });
          if (((x = $.resolveSchema.call(this, C, P)), !x)) return;
          this.refs[P] = x;
        }
        return x.validate || this._compileSchemaEnv(x);
      }
      removeSchema(P) {
        if (P instanceof RegExp)
          return (
            this._removeAllSchemas(this.schemas, P),
            this._removeAllSchemas(this.refs, P),
            this
          );
        switch (typeof P) {
          case "undefined":
            return (
              this._removeAllSchemas(this.schemas),
              this._removeAllSchemas(this.refs),
              this._cache.clear(),
              this
            );
          case "string": {
            let x = O.call(this, P);
            if (typeof x == "object") this._cache.delete(x.schema);
            return (delete this.schemas[P], delete this.refs[P], this);
          }
          case "object": {
            let x = P;
            this._cache.delete(x);
            let r = P[this.opts.schemaId];
            if (r)
              ((r = (0, K.normalizeId)(r)),
                delete this.schemas[r],
                delete this.refs[r]);
            return this;
          }
          default:
            throw Error("ajv.removeSchema: invalid parameter");
        }
      }
      addVocabulary(P) {
        for (let x of P) this.addKeyword(x);
        return this;
      }
      addKeyword(P, x) {
        let r;
        if (typeof P == "string") {
          if (((r = P), typeof x == "object"))
            (this.logger.warn(
              "these parameters are deprecated, see docs for addKeyword"
            ),
              (x.keyword = r));
        } else if (typeof P == "object" && x === void 0) {
          if (((x = P), (r = x.keyword), Array.isArray(r) && !r.length))
            throw Error(
              "addKeywords: keyword must be string or non-empty array"
            );
        } else throw Error("invalid addKeywords parameters");
        if ((f.call(this, r, x), !x))
          return ((0, W.eachItem)(r, (v) => l.call(this, v)), this);
        p.call(this, x);
        let C = {
          ...x,
          type: (0, V.getJSONTypes)(x.type),
          schemaType: (0, V.getJSONTypes)(x.schemaType),
        };
        return (
          (0, W.eachItem)(
            r,
            C.type.length === 0
              ? (v) => l.call(this, v, C)
              : (v) => C.type.forEach((k) => l.call(this, v, C, k))
          ),
          this
        );
      }
      getKeyword(P) {
        let x = this.RULES.all[P];
        return typeof x == "object" ? x.definition : !!x;
      }
      removeKeyword(P) {
        let { RULES: x } = this;
        (delete x.keywords[P], delete x.all[P]);
        for (let r of x.rules) {
          let C = r.rules.findIndex((v) => v.keyword === P);
          if (C >= 0) r.rules.splice(C, 1);
        }
        return this;
      }
      addFormat(P, x) {
        if (typeof x == "string") x = new RegExp(x);
        return ((this.formats[P] = x), this);
      }
      errorsText(
        P = this.errors,
        { separator: x = ", ", dataVar: r = "data" } = {}
      ) {
        if (!P || P.length === 0) return "No errors";
        return P.map((C) => `${r}${C.instancePath} ${C.message}`).reduce(
          (C, v) => C + x + v
        );
      }
      $dataMetaSchema(P, x) {
        let r = this.RULES.all;
        P = JSON.parse(JSON.stringify(P));
        for (let C of x) {
          let v = C.split("/").slice(1),
            k = P;
          for (let o of v) k = k[o];
          for (let o in r) {
            let J0 = r[o];
            if (typeof J0 != "object") continue;
            let { $data: z0 } = J0.definition,
              A0 = k[o];
            if (z0 && A0) k[o] = e(A0);
          }
        }
        return P;
      }
      _removeAllSchemas(P, x) {
        for (let r in P) {
          let C = P[r];
          if (!x || x.test(r)) {
            if (typeof C == "string") delete P[r];
            else if (C && !C.meta) (this._cache.delete(C.schema), delete P[r]);
          }
        }
      }
      _addSchema(
        P,
        x,
        r,
        C = this.opts.validateSchema,
        v = this.opts.addUsedSchema
      ) {
        let k,
          { schemaId: o } = this.opts;
        if (typeof P == "object") k = P[o];
        else if (this.opts.jtd) throw Error("schema must be object");
        else if (typeof P != "boolean")
          throw Error("schema must be object or boolean");
        let J0 = this._cache.get(P);
        if (J0 !== void 0) return J0;
        r = (0, K.normalizeId)(k || r);
        let z0 = K.getSchemaRefs.call(this, P, r);
        if (
          ((J0 = new $.SchemaEnv({
            schema: P,
            schemaId: o,
            meta: x,
            baseId: r,
            localRefs: z0,
          })),
          this._cache.set(J0.schema, J0),
          v && !r.startsWith("#"))
        ) {
          if (r) this._checkUnique(r);
          this.refs[r] = J0;
        }
        if (C) this.validateSchema(P, !0);
        return J0;
      }
      _checkUnique(P) {
        if (this.schemas[P] || this.refs[P])
          throw Error(`schema with key or id "${P}" already exists`);
      }
      _compileSchemaEnv(P) {
        if (P.meta) this._compileMetaSchema(P);
        else $.compileSchema.call(this, P);
        if (!P.validate) throw Error("ajv implementation error");
        return P.validate;
      }
      _compileMetaSchema(P) {
        let x = this.opts;
        this.opts = this._metaOpts;
        try {
          $.compileSchema.call(this, P);
        } finally {
          this.opts = x;
        }
      }
    }
    ((z.ValidationError = G.default),
      (z.MissingRefError = J.default),
      (X.default = z));
    function E(P, x, r, C = "error") {
      for (let v in P) {
        let k = v;
        if (k in x) this.logger[C](`${r}: option ${v}. ${P[k]}`);
      }
    }
    function O(P) {
      return ((P = (0, K.normalizeId)(P)), this.schemas[P] || this.refs[P]);
    }
    function Z() {
      let P = this.opts.schemas;
      if (!P) return;
      if (Array.isArray(P)) this.addSchema(P);
      else for (let x in P) this.addSchema(P[x], x);
    }
    function j() {
      for (let P in this.opts.formats) {
        let x = this.opts.formats[P];
        if (x) this.addFormat(P, x);
      }
    }
    function w(P) {
      if (Array.isArray(P)) {
        this.addVocabulary(P);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (let x in P) {
        let r = P[x];
        if (!r.keyword) r.keyword = x;
        this.addKeyword(r);
      }
    }
    function I() {
      let P = { ...this.opts };
      for (let x of N) delete P[x];
      return P;
    }
    var T = { log() {}, warn() {}, error() {} };
    function y(P) {
      if (P === !1) return T;
      if (P === void 0) return console;
      if (P.log && P.warn && P.error) return P;
      throw Error("logger must implement log, warn and error methods");
    }
    var _ = /^[a-z_$][a-z0-9_$:-]*$/i;
    function f(P, x) {
      let { RULES: r } = this;
      if (
        ((0, W.eachItem)(P, (C) => {
          if (r.keywords[C]) throw Error(`Keyword ${C} is already defined`);
          if (!_.test(C)) throw Error(`Keyword ${C} has invalid name`);
        }),
        !x)
      )
        return;
      if (x.$data && !("code" in x || "validate" in x))
        throw Error('$data keyword must have "code" or "validate" function');
    }
    function l(P, x, r) {
      var C;
      let v = x === null || x === void 0 ? void 0 : x.post;
      if (r && v) throw Error('keyword with "post" flag cannot have "type"');
      let { RULES: k } = this,
        o = v ? k.post : k.rules.find(({ type: z0 }) => z0 === r);
      if (!o) ((o = { type: r, rules: [] }), k.rules.push(o));
      if (((k.keywords[P] = !0), !x)) return;
      let J0 = {
        keyword: P,
        definition: {
          ...x,
          type: (0, V.getJSONTypes)(x.type),
          schemaType: (0, V.getJSONTypes)(x.schemaType),
        },
      };
      if (x.before) h.call(this, o, J0, x.before);
      else o.rules.push(J0);
      ((k.all[P] = J0),
        (C = x.implements) === null ||
          C === void 0 ||
          C.forEach((z0) => this.addKeyword(z0)));
    }
    function h(P, x, r) {
      let C = P.rules.findIndex((v) => v.keyword === r);
      if (C >= 0) P.rules.splice(C, 0, x);
      else (P.rules.push(x), this.logger.warn(`rule ${r} is not defined`));
    }
    function p(P) {
      let { metaSchema: x } = P;
      if (x === void 0) return;
      if (P.$data && this.opts.$data) x = e(x);
      P.validateSchema = this.compile(x, !0);
    }
    var N0 = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    };
    function e(P) {
      return { anyOf: [P, N0] };
    }
  }),
  Jx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = {
      keyword: "id",
      code() {
        throw Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      },
    };
    X.default = Y;
  }),
  Wx = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.callRef = X.getValidate = void 0));
    var Y = BJ(),
      Q = p8(),
      G = D1(),
      J = u4(),
      U = uU(),
      $ = m1(),
      B = {
        keyword: "$ref",
        schemaType: "string",
        code(W) {
          let { gen: L, schema: H, it: F } = W,
            { baseId: N, schemaEnv: q, validateName: M, opts: A, self: D } = F,
            { root: R } = q;
          if ((H === "#" || H === "#/") && N === R.baseId) return E();
          let z = U.resolveRef.call(D, R, N, H);
          if (z === void 0) throw new Y.default(F.opts.uriResolver, N, H);
          if (z instanceof U.SchemaEnv) return O(z);
          return Z(z);
          function E() {
            if (q === R) return V(W, M, q, q.$async);
            let j = L.scopeValue("root", { ref: R });
            return V(W, G._`${j}.validate`, R, R.$async);
          }
          function O(j) {
            let w = K(W, j);
            V(W, w, j, j.$async);
          }
          function Z(j) {
            let w = L.scopeValue(
                "schema",
                A.code.source === !0
                  ? { ref: j, code: (0, G.stringify)(j) }
                  : { ref: j }
              ),
              I = L.name("valid"),
              T = W.subschema(
                {
                  schema: j,
                  dataTypes: [],
                  schemaPath: G.nil,
                  topSchemaRef: w,
                  errSchemaPath: H,
                },
                I
              );
            (W.mergeEvaluated(T), W.ok(I));
          }
        },
      };
    function K(W, L) {
      let { gen: H } = W;
      return L.validate
        ? H.scopeValue("validate", { ref: L.validate })
        : G._`${H.scopeValue("wrapper", { ref: L })}.validate`;
    }
    X.getValidate = K;
    function V(W, L, H, F) {
      let { gen: N, it: q } = W,
        { allErrors: M, schemaEnv: A, opts: D } = q,
        R = D.passContext ? J.default.this : G.nil;
      if (F) z();
      else E();
      function z() {
        if (!A.$async) throw Error("async schema referenced by sync schema");
        let j = N.let("valid");
        (N.try(
          () => {
            if (
              (N.code(G._`await ${(0, Q.callValidateCode)(W, L, R)}`), Z(L), !M)
            )
              N.assign(j, !0);
          },
          (w) => {
            if (
              (N.if(G._`!(${w} instanceof ${q.ValidationError})`, () =>
                N.throw(w)
              ),
              O(w),
              !M)
            )
              N.assign(j, !1);
          }
        ),
          W.ok(j));
      }
      function E() {
        W.result(
          (0, Q.callValidateCode)(W, L, R),
          () => Z(L),
          () => O(L)
        );
      }
      function O(j) {
        let w = G._`${j}.errors`;
        (N.assign(
          J.default.vErrors,
          G._`${J.default.vErrors} === null ? ${w} : ${J.default.vErrors}.concat(${w})`
        ),
          N.assign(J.default.errors, G._`${J.default.vErrors}.length`));
      }
      function Z(j) {
        var w;
        if (!q.opts.unevaluated) return;
        let I =
          (w = H === null || H === void 0 ? void 0 : H.validate) === null ||
          w === void 0
            ? void 0
            : w.evaluated;
        if (q.props !== !0)
          if (I && !I.dynamicProps) {
            if (I.props !== void 0)
              q.props = $.mergeEvaluated.props(N, I.props, q.props);
          } else {
            let T = N.var("props", G._`${j}.evaluated.props`);
            q.props = $.mergeEvaluated.props(N, T, q.props, G.Name);
          }
        if (q.items !== !0)
          if (I && !I.dynamicItems) {
            if (I.items !== void 0)
              q.items = $.mergeEvaluated.items(N, I.items, q.items);
          } else {
            let T = N.var("items", G._`${j}.evaluated.items`);
            q.items = $.mergeEvaluated.items(N, T, q.items, G.Name);
          }
      }
    }
    ((X.callRef = V), (X.default = B));
  }),
  Hx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = Jx(),
      Q = Wx(),
      G = [
        "$schema",
        "$id",
        "$defs",
        "$vocabulary",
        { keyword: "$comment" },
        "definitions",
        Y.default,
        Q.default,
      ];
    X.default = G;
  }),
  $x = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = Y.operators,
      G = {
        maximum: { okStr: "<=", ok: Q.LTE, fail: Q.GT },
        minimum: { okStr: ">=", ok: Q.GTE, fail: Q.LT },
        exclusiveMaximum: { okStr: "<", ok: Q.LT, fail: Q.GTE },
        exclusiveMinimum: { okStr: ">", ok: Q.GT, fail: Q.LTE },
      },
      J = {
        message: ({ keyword: $, schemaCode: B }) =>
          Y.str`must be ${G[$].okStr} ${B}`,
        params: ({ keyword: $, schemaCode: B }) =>
          Y._`{comparison: ${G[$].okStr}, limit: ${B}}`,
      },
      U = {
        keyword: Object.keys(G),
        type: "number",
        schemaType: "number",
        $data: !0,
        error: J,
        code($) {
          let { keyword: B, data: K, schemaCode: V } = $;
          $.fail$data(Y._`${K} ${G[B].fail} ${V} || isNaN(${K})`);
        },
      };
    X.default = U;
  }),
  Ux = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = {
        message: ({ schemaCode: J }) => Y.str`must be multiple of ${J}`,
        params: ({ schemaCode: J }) => Y._`{multipleOf: ${J}}`,
      },
      G = {
        keyword: "multipleOf",
        type: "number",
        schemaType: "number",
        $data: !0,
        error: Q,
        code(J) {
          let { gen: U, data: $, schemaCode: B, it: K } = J,
            V = K.opts.multipleOfPrecision,
            W = U.let("res"),
            L = V
              ? Y._`Math.abs(Math.round(${W}) - ${W}) > 1e-${V}`
              : Y._`${W} !== parseInt(${W})`;
          J.fail$data(Y._`(${B} === 0 || (${W} = ${$}/${B}, ${L}))`);
        },
      };
    X.default = G;
  }),
  Lx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    function Y(Q) {
      let G = Q.length,
        J = 0,
        U = 0,
        $;
      while (U < G)
        if ((J++, ($ = Q.charCodeAt(U++)), $ >= 55296 && $ <= 56319 && U < G)) {
          if ((($ = Q.charCodeAt(U)), ($ & 64512) === 56320)) U++;
        }
      return J;
    }
    ((X.default = Y),
      (Y.code = 'require("ajv/dist/runtime/ucs2length").default'));
  }),
  Bx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = m1(),
      G = Lx(),
      J = {
        message({ keyword: $, schemaCode: B }) {
          let K = $ === "maxLength" ? "more" : "fewer";
          return Y.str`must NOT have ${K} than ${B} characters`;
        },
        params: ({ schemaCode: $ }) => Y._`{limit: ${$}}`,
      },
      U = {
        keyword: ["maxLength", "minLength"],
        type: "string",
        schemaType: "number",
        $data: !0,
        error: J,
        code($) {
          let { keyword: B, data: K, schemaCode: V, it: W } = $,
            L = B === "maxLength" ? Y.operators.GT : Y.operators.LT,
            H =
              W.opts.unicode === !1
                ? Y._`${K}.length`
                : Y._`${(0, Q.useFunc)($.gen, G.default)}(${K})`;
          $.fail$data(Y._`${H} ${L} ${V}`);
        },
      };
    X.default = U;
  }),
  Kx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = p8(),
      Q = D1(),
      G = {
        message: ({ schemaCode: U }) => Q.str`must match pattern "${U}"`,
        params: ({ schemaCode: U }) => Q._`{pattern: ${U}}`,
      },
      J = {
        keyword: "pattern",
        type: "string",
        schemaType: "string",
        $data: !0,
        error: G,
        code(U) {
          let { data: $, $data: B, schema: K, schemaCode: V, it: W } = U,
            L = W.opts.unicodeRegExp ? "u" : "",
            H = B ? Q._`(new RegExp(${V}, ${L}))` : (0, Y.usePattern)(U, K);
          U.fail$data(Q._`!${H}.test(${$})`);
        },
      };
    X.default = J;
  }),
  Vx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = {
        message({ keyword: J, schemaCode: U }) {
          let $ = J === "maxProperties" ? "more" : "fewer";
          return Y.str`must NOT have ${$} than ${U} properties`;
        },
        params: ({ schemaCode: J }) => Y._`{limit: ${J}}`,
      },
      G = {
        keyword: ["maxProperties", "minProperties"],
        type: "object",
        schemaType: "number",
        $data: !0,
        error: Q,
        code(J) {
          let { keyword: U, data: $, schemaCode: B } = J,
            K = U === "maxProperties" ? Y.operators.GT : Y.operators.LT;
          J.fail$data(Y._`Object.keys(${$}).length ${K} ${B}`);
        },
      };
    X.default = G;
  }),
  Fx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = p8(),
      Q = D1(),
      G = m1(),
      J = {
        message: ({ params: { missingProperty: $ } }) =>
          Q.str`must have required property '${$}'`,
        params: ({ params: { missingProperty: $ } }) =>
          Q._`{missingProperty: ${$}}`,
      },
      U = {
        keyword: "required",
        type: "object",
        schemaType: "array",
        $data: !0,
        error: J,
        code($) {
          let {
              gen: B,
              schema: K,
              schemaCode: V,
              data: W,
              $data: L,
              it: H,
            } = $,
            { opts: F } = H;
          if (!L && K.length === 0) return;
          let N = K.length >= F.loopRequired;
          if (H.allErrors) q();
          else M();
          if (F.strictRequired) {
            let R = $.parentSchema.properties,
              { definedProperties: z } = $.it;
            for (let E of K)
              if (
                (R === null || R === void 0 ? void 0 : R[E]) === void 0 &&
                !z.has(E)
              ) {
                let O = H.schemaEnv.baseId + H.errSchemaPath,
                  Z = `required property "${E}" is not defined at "${O}" (strictRequired)`;
                (0, G.checkStrictMode)(H, Z, H.opts.strictRequired);
              }
          }
          function q() {
            if (N || L) $.block$data(Q.nil, A);
            else for (let R of K) (0, Y.checkReportMissingProp)($, R);
          }
          function M() {
            let R = B.let("missing");
            if (N || L) {
              let z = B.let("valid", !0);
              ($.block$data(z, () => D(R, z)), $.ok(z));
            } else
              (B.if((0, Y.checkMissingProp)($, K, R)),
                (0, Y.reportMissingProp)($, R),
                B.else());
          }
          function A() {
            B.forOf("prop", V, (R) => {
              ($.setParams({ missingProperty: R }),
                B.if((0, Y.noPropertyInData)(B, W, R, F.ownProperties), () =>
                  $.error()
                ));
            });
          }
          function D(R, z) {
            ($.setParams({ missingProperty: R }),
              B.forOf(
                R,
                V,
                () => {
                  (B.assign(z, (0, Y.propertyInData)(B, W, R, F.ownProperties)),
                    B.if((0, Q.not)(z), () => {
                      ($.error(), B.break());
                    }));
                },
                Q.nil
              ));
          }
        },
      };
    X.default = U;
  }),
  Nx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = {
        message({ keyword: J, schemaCode: U }) {
          let $ = J === "maxItems" ? "more" : "fewer";
          return Y.str`must NOT have ${$} than ${U} items`;
        },
        params: ({ schemaCode: J }) => Y._`{limit: ${J}}`,
      },
      G = {
        keyword: ["maxItems", "minItems"],
        type: "array",
        schemaType: "number",
        $data: !0,
        error: Q,
        code(J) {
          let { keyword: U, data: $, schemaCode: B } = J,
            K = U === "maxItems" ? Y.operators.GT : Y.operators.LT;
          J.fail$data(Y._`${$}.length ${K} ${B}`);
        },
      };
    X.default = G;
  }),
  lU = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = GJ();
    ((Y.code = 'require("ajv/dist/runtime/equal").default'), (X.default = Y));
  }),
  Mx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = dG(),
      Q = D1(),
      G = m1(),
      J = lU(),
      U = {
        message: ({ params: { i: B, j: K } }) =>
          Q.str`must NOT have duplicate items (items ## ${K} and ${B} are identical)`,
        params: ({ params: { i: B, j: K } }) => Q._`{i: ${B}, j: ${K}}`,
      },
      $ = {
        keyword: "uniqueItems",
        type: "array",
        schemaType: "boolean",
        $data: !0,
        error: U,
        code(B) {
          let {
            gen: K,
            data: V,
            $data: W,
            schema: L,
            parentSchema: H,
            schemaCode: F,
            it: N,
          } = B;
          if (!W && !L) return;
          let q = K.let("valid"),
            M = H.items ? (0, Y.getSchemaTypes)(H.items) : [];
          (B.block$data(q, A, Q._`${F} === false`), B.ok(q));
          function A() {
            let E = K.let("i", Q._`${V}.length`),
              O = K.let("j");
            (B.setParams({ i: E, j: O }),
              K.assign(q, !0),
              K.if(Q._`${E} > 1`, () => (D() ? R : z)(E, O)));
          }
          function D() {
            return (
              M.length > 0 && !M.some((E) => E === "object" || E === "array")
            );
          }
          function R(E, O) {
            let Z = K.name("item"),
              j = (0, Y.checkDataTypes)(
                M,
                Z,
                N.opts.strictNumbers,
                Y.DataType.Wrong
              ),
              w = K.const("indices", Q._`{}`);
            K.for(Q._`;${E}--;`, () => {
              if (
                (K.let(Z, Q._`${V}[${E}]`),
                K.if(j, Q._`continue`),
                M.length > 1)
              )
                K.if(Q._`typeof ${Z} == "string"`, Q._`${Z} += "_"`);
              K.if(Q._`typeof ${w}[${Z}] == "number"`, () => {
                (K.assign(O, Q._`${w}[${Z}]`),
                  B.error(),
                  K.assign(q, !1).break());
              }).code(Q._`${w}[${Z}] = ${E}`);
            });
          }
          function z(E, O) {
            let Z = (0, G.useFunc)(K, J.default),
              j = K.name("outer");
            K.label(j).for(Q._`;${E}--;`, () =>
              K.for(Q._`${O} = ${E}; ${O}--;`, () =>
                K.if(Q._`${Z}(${V}[${E}], ${V}[${O}])`, () => {
                  (B.error(), K.assign(q, !1).break(j));
                })
              )
            );
          }
        },
      };
    X.default = $;
  }),
  Ax = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = m1(),
      G = lU(),
      J = {
        message: "must be equal to constant",
        params: ({ schemaCode: $ }) => Y._`{allowedValue: ${$}}`,
      },
      U = {
        keyword: "const",
        $data: !0,
        error: J,
        code($) {
          let { gen: B, data: K, $data: V, schemaCode: W, schema: L } = $;
          if (V || (L && typeof L == "object"))
            $.fail$data(Y._`!${(0, Q.useFunc)(B, G.default)}(${K}, ${W})`);
          else $.fail(Y._`${L} !== ${K}`);
        },
      };
    X.default = U;
  }),
  qx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = m1(),
      G = lU(),
      J = {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode: $ }) => Y._`{allowedValues: ${$}}`,
      },
      U = {
        keyword: "enum",
        schemaType: "array",
        $data: !0,
        error: J,
        code($) {
          let {
            gen: B,
            data: K,
            $data: V,
            schema: W,
            schemaCode: L,
            it: H,
          } = $;
          if (!V && W.length === 0)
            throw Error("enum must have non-empty array");
          let F = W.length >= H.opts.loopEnum,
            N,
            q = () =>
              N !== null && N !== void 0
                ? N
                : (N = (0, Q.useFunc)(B, G.default)),
            M;
          if (F || V) ((M = B.let("valid")), $.block$data(M, A));
          else {
            if (!Array.isArray(W)) throw Error("ajv implementation error");
            let R = B.const("vSchema", L);
            M = (0, Y.or)(...W.map((z, E) => D(R, E)));
          }
          $.pass(M);
          function A() {
            (B.assign(M, !1),
              B.forOf("v", L, (R) =>
                B.if(Y._`${q()}(${K}, ${R})`, () => B.assign(M, !0).break())
              ));
          }
          function D(R, z) {
            let E = W[z];
            return typeof E === "object" && E !== null
              ? Y._`${q()}(${K}, ${R}[${z}])`
              : Y._`${K} === ${E}`;
          }
        },
      };
    X.default = U;
  }),
  Rx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = $x(),
      Q = Ux(),
      G = Bx(),
      J = Kx(),
      U = Vx(),
      $ = Fx(),
      B = Nx(),
      K = Mx(),
      V = Ax(),
      W = qx(),
      L = [
        Y.default,
        Q.default,
        G.default,
        J.default,
        U.default,
        $.default,
        B.default,
        K.default,
        { keyword: "type", schemaType: ["string", "array"] },
        { keyword: "nullable", schemaType: "boolean" },
        V.default,
        W.default,
      ];
    X.default = L;
  }),
  mE = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.validateAdditionalItems = void 0));
    var Y = D1(),
      Q = m1(),
      G = {
        message: ({ params: { len: $ } }) =>
          Y.str`must NOT have more than ${$} items`,
        params: ({ params: { len: $ } }) => Y._`{limit: ${$}}`,
      },
      J = {
        keyword: "additionalItems",
        type: "array",
        schemaType: ["boolean", "object"],
        before: "uniqueItems",
        error: G,
        code($) {
          let { parentSchema: B, it: K } = $,
            { items: V } = B;
          if (!Array.isArray(V)) {
            (0, Q.checkStrictMode)(
              K,
              '"additionalItems" is ignored when "items" is not an array of schemas'
            );
            return;
          }
          U($, V);
        },
      };
    function U($, B) {
      let { gen: K, schema: V, data: W, keyword: L, it: H } = $;
      H.items = !0;
      let F = K.const("len", Y._`${W}.length`);
      if (V === !1)
        ($.setParams({ len: B.length }), $.pass(Y._`${F} <= ${B.length}`));
      else if (typeof V == "object" && !(0, Q.alwaysValidSchema)(H, V)) {
        let q = K.var("valid", Y._`${F} <= ${B.length}`);
        (K.if((0, Y.not)(q), () => N(q)), $.ok(q));
      }
      function N(q) {
        K.forRange("i", B.length, F, (M) => {
          if (
            ($.subschema(
              { keyword: L, dataProp: M, dataPropType: Q.Type.Num },
              q
            ),
            !H.allErrors)
          )
            K.if((0, Y.not)(q), () => K.break());
        });
      }
    }
    ((X.validateAdditionalItems = U), (X.default = J));
  }),
  cE = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.validateTuple = void 0));
    var Y = D1(),
      Q = m1(),
      G = p8(),
      J = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "array", "boolean"],
        before: "uniqueItems",
        code($) {
          let { schema: B, it: K } = $;
          if (Array.isArray(B)) return U($, "additionalItems", B);
          if (((K.items = !0), (0, Q.alwaysValidSchema)(K, B))) return;
          $.ok((0, G.validateArray)($));
        },
      };
    function U($, B, K = $.schema) {
      let { gen: V, parentSchema: W, data: L, keyword: H, it: F } = $;
      if ((M(W), F.opts.unevaluated && K.length && F.items !== !0))
        F.items = Q.mergeEvaluated.items(V, K.length, F.items);
      let N = V.name("valid"),
        q = V.const("len", Y._`${L}.length`);
      K.forEach((A, D) => {
        if ((0, Q.alwaysValidSchema)(F, A)) return;
        (V.if(Y._`${q} > ${D}`, () =>
          $.subschema({ keyword: H, schemaProp: D, dataProp: D }, N)
        ),
          $.ok(N));
      });
      function M(A) {
        let { opts: D, errSchemaPath: R } = F,
          z = K.length,
          E = z === A.minItems && (z === A.maxItems || A[B] === !1);
        if (D.strictTuples && !E) {
          let O = `"${H}" is ${z}-tuple, but minItems or maxItems/${B} are not specified or different at path "${R}"`;
          (0, Q.checkStrictMode)(F, O, D.strictTuples);
        }
      }
    }
    ((X.validateTuple = U), (X.default = J));
  }),
  Dx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = cE(),
      Q = {
        keyword: "prefixItems",
        type: "array",
        schemaType: ["array"],
        before: "uniqueItems",
        code: (G) => (0, Y.validateTuple)(G, "items"),
      };
    X.default = Q;
  }),
  zx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = m1(),
      G = p8(),
      J = mE(),
      U = {
        message: ({ params: { len: B } }) =>
          Y.str`must NOT have more than ${B} items`,
        params: ({ params: { len: B } }) => Y._`{limit: ${B}}`,
      },
      $ = {
        keyword: "items",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        error: U,
        code(B) {
          let { schema: K, parentSchema: V, it: W } = B,
            { prefixItems: L } = V;
          if (((W.items = !0), (0, Q.alwaysValidSchema)(W, K))) return;
          if (L) (0, J.validateAdditionalItems)(B, L);
          else B.ok((0, G.validateArray)(B));
        },
      };
    X.default = $;
  }),
  Ex = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = m1(),
      G = {
        message: ({ params: { min: U, max: $ } }) =>
          $ === void 0
            ? Y.str`must contain at least ${U} valid item(s)`
            : Y.str`must contain at least ${U} and no more than ${$} valid item(s)`,
        params: ({ params: { min: U, max: $ } }) =>
          $ === void 0
            ? Y._`{minContains: ${U}}`
            : Y._`{minContains: ${U}, maxContains: ${$}}`,
      },
      J = {
        keyword: "contains",
        type: "array",
        schemaType: ["object", "boolean"],
        before: "uniqueItems",
        trackErrors: !0,
        error: G,
        code(U) {
          let { gen: $, schema: B, parentSchema: K, data: V, it: W } = U,
            L,
            H,
            { minContains: F, maxContains: N } = K;
          if (W.opts.next) ((L = F === void 0 ? 1 : F), (H = N));
          else L = 1;
          let q = $.const("len", Y._`${V}.length`);
          if ((U.setParams({ min: L, max: H }), H === void 0 && L === 0)) {
            (0, Q.checkStrictMode)(
              W,
              '"minContains" == 0 without "maxContains": "contains" keyword ignored'
            );
            return;
          }
          if (H !== void 0 && L > H) {
            ((0, Q.checkStrictMode)(
              W,
              '"minContains" > "maxContains" is always invalid'
            ),
              U.fail());
            return;
          }
          if ((0, Q.alwaysValidSchema)(W, B)) {
            let z = Y._`${q} >= ${L}`;
            if (H !== void 0) z = Y._`${z} && ${q} <= ${H}`;
            U.pass(z);
            return;
          }
          W.items = !0;
          let M = $.name("valid");
          if (H === void 0 && L === 1) D(M, () => $.if(M, () => $.break()));
          else if (L === 0) {
            if (($.let(M, !0), H !== void 0)) $.if(Y._`${V}.length > 0`, A);
          } else ($.let(M, !1), A());
          U.result(M, () => U.reset());
          function A() {
            let z = $.name("_valid"),
              E = $.let("count", 0);
            D(z, () => $.if(z, () => R(E)));
          }
          function D(z, E) {
            $.forRange("i", 0, q, (O) => {
              (U.subschema(
                {
                  keyword: "contains",
                  dataProp: O,
                  dataPropType: Q.Type.Num,
                  compositeRule: !0,
                },
                z
              ),
                E());
            });
          }
          function R(z) {
            if (($.code(Y._`${z}++`), H === void 0))
              $.if(Y._`${z} >= ${L}`, () => $.assign(M, !0).break());
            else if (
              ($.if(Y._`${z} > ${H}`, () => $.assign(M, !1).break()), L === 1)
            )
              $.assign(M, !0);
            else $.if(Y._`${z} >= ${L}`, () => $.assign(M, !0));
          }
        },
      };
    X.default = J;
  }),
  Ox = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.validateSchemaDeps = X.validatePropertyDeps = X.error = void 0));
    var Y = D1(),
      Q = m1(),
      G = p8();
    X.error = {
      message: ({ params: { property: K, depsCount: V, deps: W } }) => {
        let L = V === 1 ? "property" : "properties";
        return Y.str`must have ${L} ${W} when property ${K} is present`;
      },
      params: ({
        params: { property: K, depsCount: V, deps: W, missingProperty: L },
      }) => Y._`{property: ${K},
    missingProperty: ${L},
    depsCount: ${V},
    deps: ${W}}`,
    };
    var J = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: X.error,
      code(K) {
        let [V, W] = U(K);
        ($(K, V), B(K, W));
      },
    };
    function U({ schema: K }) {
      let V = {},
        W = {};
      for (let L in K) {
        if (L === "__proto__") continue;
        let H = Array.isArray(K[L]) ? V : W;
        H[L] = K[L];
      }
      return [V, W];
    }
    function $(K, V = K.schema) {
      let { gen: W, data: L, it: H } = K;
      if (Object.keys(V).length === 0) return;
      let F = W.let("missing");
      for (let N in V) {
        let q = V[N];
        if (q.length === 0) continue;
        let M = (0, G.propertyInData)(W, L, N, H.opts.ownProperties);
        if (
          (K.setParams({
            property: N,
            depsCount: q.length,
            deps: q.join(", "),
          }),
          H.allErrors)
        )
          W.if(M, () => {
            for (let A of q) (0, G.checkReportMissingProp)(K, A);
          });
        else
          (W.if(Y._`${M} && (${(0, G.checkMissingProp)(K, q, F)})`),
            (0, G.reportMissingProp)(K, F),
            W.else());
      }
    }
    X.validatePropertyDeps = $;
    function B(K, V = K.schema) {
      let { gen: W, data: L, keyword: H, it: F } = K,
        N = W.name("valid");
      for (let q in V) {
        if ((0, Q.alwaysValidSchema)(F, V[q])) continue;
        (W.if(
          (0, G.propertyInData)(W, L, q, F.opts.ownProperties),
          () => {
            let M = K.subschema({ keyword: H, schemaProp: q }, N);
            K.mergeValidEvaluated(M, N);
          },
          () => W.var(N, !0)
        ),
          K.ok(N));
      }
    }
    ((X.validateSchemaDeps = B), (X.default = J));
  }),
  Zx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = m1(),
      G = {
        message: "property name must be valid",
        params: ({ params: U }) => Y._`{propertyName: ${U.propertyName}}`,
      },
      J = {
        keyword: "propertyNames",
        type: "object",
        schemaType: ["object", "boolean"],
        error: G,
        code(U) {
          let { gen: $, schema: B, data: K, it: V } = U;
          if ((0, Q.alwaysValidSchema)(V, B)) return;
          let W = $.name("valid");
          ($.forIn("key", K, (L) => {
            (U.setParams({ propertyName: L }),
              U.subschema(
                {
                  keyword: "propertyNames",
                  data: L,
                  dataTypes: ["string"],
                  propertyName: L,
                  compositeRule: !0,
                },
                W
              ),
              $.if((0, Y.not)(W), () => {
                if ((U.error(!0), !V.allErrors)) $.break();
              }));
          }),
            U.ok(W));
        },
      };
    X.default = J;
  }),
  dE = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = p8(),
      Q = D1(),
      G = u4(),
      J = m1(),
      U = {
        message: "must NOT have additional properties",
        params: ({ params: B }) =>
          Q._`{additionalProperty: ${B.additionalProperty}}`,
      },
      $ = {
        keyword: "additionalProperties",
        type: ["object"],
        schemaType: ["boolean", "object"],
        allowUndefined: !0,
        trackErrors: !0,
        error: U,
        code(B) {
          let {
            gen: K,
            schema: V,
            parentSchema: W,
            data: L,
            errsCount: H,
            it: F,
          } = B;
          if (!H) throw Error("ajv implementation error");
          let { allErrors: N, opts: q } = F;
          if (
            ((F.props = !0),
            q.removeAdditional !== "all" && (0, J.alwaysValidSchema)(F, V))
          )
            return;
          let M = (0, Y.allSchemaProperties)(W.properties),
            A = (0, Y.allSchemaProperties)(W.patternProperties);
          (D(), B.ok(Q._`${H} === ${G.default.errors}`));
          function D() {
            K.forIn("key", L, (Z) => {
              if (!M.length && !A.length) E(Z);
              else K.if(R(Z), () => E(Z));
            });
          }
          function R(Z) {
            let j;
            if (M.length > 8) {
              let w = (0, J.schemaRefOrVal)(F, W.properties, "properties");
              j = (0, Y.isOwnProperty)(K, w, Z);
            } else if (M.length)
              j = (0, Q.or)(...M.map((w) => Q._`${Z} === ${w}`));
            else j = Q.nil;
            if (A.length)
              j = (0, Q.or)(
                j,
                ...A.map((w) => Q._`${(0, Y.usePattern)(B, w)}.test(${Z})`)
              );
            return (0, Q.not)(j);
          }
          function z(Z) {
            K.code(Q._`delete ${L}[${Z}]`);
          }
          function E(Z) {
            if (
              q.removeAdditional === "all" ||
              (q.removeAdditional && V === !1)
            ) {
              z(Z);
              return;
            }
            if (V === !1) {
              if ((B.setParams({ additionalProperty: Z }), B.error(), !N))
                K.break();
              return;
            }
            if (typeof V == "object" && !(0, J.alwaysValidSchema)(F, V)) {
              let j = K.name("valid");
              if (q.removeAdditional === "failing")
                (O(Z, j, !1),
                  K.if((0, Q.not)(j), () => {
                    (B.reset(), z(Z));
                  }));
              else if ((O(Z, j), !N)) K.if((0, Q.not)(j), () => K.break());
            }
          }
          function O(Z, j, w) {
            let I = {
              keyword: "additionalProperties",
              dataProp: Z,
              dataPropType: J.Type.Str,
            };
            if (w === !1)
              Object.assign(I, {
                compositeRule: !0,
                createErrors: !1,
                allErrors: !1,
              });
            B.subschema(I, j);
          }
        },
      };
    X.default = $;
  }),
  jx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = LJ(),
      Q = p8(),
      G = m1(),
      J = dE(),
      U = {
        keyword: "properties",
        type: "object",
        schemaType: "object",
        code($) {
          let { gen: B, schema: K, parentSchema: V, data: W, it: L } = $;
          if (
            L.opts.removeAdditional === "all" &&
            V.additionalProperties === void 0
          )
            J.default.code(
              new Y.KeywordCxt(L, J.default, "additionalProperties")
            );
          let H = (0, Q.allSchemaProperties)(K);
          for (let A of H) L.definedProperties.add(A);
          if (L.opts.unevaluated && H.length && L.props !== !0)
            L.props = G.mergeEvaluated.props(B, (0, G.toHash)(H), L.props);
          let F = H.filter((A) => !(0, G.alwaysValidSchema)(L, K[A]));
          if (F.length === 0) return;
          let N = B.name("valid");
          for (let A of F) {
            if (q(A)) M(A);
            else {
              if (
                (B.if((0, Q.propertyInData)(B, W, A, L.opts.ownProperties)),
                M(A),
                !L.allErrors)
              )
                B.else().var(N, !0);
              B.endIf();
            }
            ($.it.definedProperties.add(A), $.ok(N));
          }
          function q(A) {
            return (
              L.opts.useDefaults && !L.compositeRule && K[A].default !== void 0
            );
          }
          function M(A) {
            $.subschema(
              { keyword: "properties", schemaProp: A, dataProp: A },
              N
            );
          }
        },
      };
    X.default = U;
  }),
  wx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = p8(),
      Q = D1(),
      G = m1(),
      J = m1(),
      U = {
        keyword: "patternProperties",
        type: "object",
        schemaType: "object",
        code($) {
          let { gen: B, schema: K, data: V, parentSchema: W, it: L } = $,
            { opts: H } = L,
            F = (0, Y.allSchemaProperties)(K),
            N = F.filter((E) => (0, G.alwaysValidSchema)(L, K[E]));
          if (
            F.length === 0 ||
            (N.length === F.length && (!L.opts.unevaluated || L.props === !0))
          )
            return;
          let q = H.strictSchema && !H.allowMatchingProperties && W.properties,
            M = B.name("valid");
          if (L.props !== !0 && !(L.props instanceof Q.Name))
            L.props = (0, J.evaluatedPropsToName)(B, L.props);
          let { props: A } = L;
          D();
          function D() {
            for (let E of F) {
              if (q) R(E);
              if (L.allErrors) z(E);
              else (B.var(M, !0), z(E), B.if(M));
            }
          }
          function R(E) {
            for (let O in q)
              if (new RegExp(E).test(O))
                (0, G.checkStrictMode)(
                  L,
                  `property ${O} matches pattern ${E} (use allowMatchingProperties)`
                );
          }
          function z(E) {
            B.forIn("key", V, (O) => {
              B.if(Q._`${(0, Y.usePattern)($, E)}.test(${O})`, () => {
                let Z = N.includes(E);
                if (!Z)
                  $.subschema(
                    {
                      keyword: "patternProperties",
                      schemaProp: E,
                      dataProp: O,
                      dataPropType: J.Type.Str,
                    },
                    M
                  );
                if (L.opts.unevaluated && A !== !0)
                  B.assign(Q._`${A}[${O}]`, !0);
                else if (!Z && !L.allErrors)
                  B.if((0, Q.not)(M), () => B.break());
              });
            });
          }
        },
      };
    X.default = U;
  }),
  Cx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = m1(),
      Q = {
        keyword: "not",
        schemaType: ["object", "boolean"],
        trackErrors: !0,
        code(G) {
          let { gen: J, schema: U, it: $ } = G;
          if ((0, Y.alwaysValidSchema)($, U)) {
            G.fail();
            return;
          }
          let B = J.name("valid");
          (G.subschema(
            {
              keyword: "not",
              compositeRule: !0,
              createErrors: !1,
              allErrors: !1,
            },
            B
          ),
            G.failResult(
              B,
              () => G.reset(),
              () => G.error()
            ));
        },
        error: { message: "must NOT be valid" },
      };
    X.default = Q;
  }),
  Ix = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = p8(),
      Q = {
        keyword: "anyOf",
        schemaType: "array",
        trackErrors: !0,
        code: Y.validateUnion,
        error: { message: "must match a schema in anyOf" },
      };
    X.default = Q;
  }),
  Px = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = m1(),
      G = {
        message: "must match exactly one schema in oneOf",
        params: ({ params: U }) => Y._`{passingSchemas: ${U.passing}}`,
      },
      J = {
        keyword: "oneOf",
        schemaType: "array",
        trackErrors: !0,
        error: G,
        code(U) {
          let { gen: $, schema: B, parentSchema: K, it: V } = U;
          if (!Array.isArray(B)) throw Error("ajv implementation error");
          if (V.opts.discriminator && K.discriminator) return;
          let W = B,
            L = $.let("valid", !1),
            H = $.let("passing", null),
            F = $.name("_valid");
          (U.setParams({ passing: H }),
            $.block(N),
            U.result(
              L,
              () => U.reset(),
              () => U.error(!0)
            ));
          function N() {
            W.forEach((q, M) => {
              let A;
              if ((0, Q.alwaysValidSchema)(V, q)) $.var(F, !0);
              else
                A = U.subschema(
                  { keyword: "oneOf", schemaProp: M, compositeRule: !0 },
                  F
                );
              if (M > 0)
                $.if(Y._`${F} && ${L}`)
                  .assign(L, !1)
                  .assign(H, Y._`[${H}, ${M}]`)
                  .else();
              $.if(F, () => {
                if (($.assign(L, !0), $.assign(H, M), A))
                  U.mergeEvaluated(A, Y.Name);
              });
            });
          }
        },
      };
    X.default = J;
  }),
  Sx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = m1(),
      Q = {
        keyword: "allOf",
        schemaType: "array",
        code(G) {
          let { gen: J, schema: U, it: $ } = G;
          if (!Array.isArray(U)) throw Error("ajv implementation error");
          let B = J.name("valid");
          U.forEach((K, V) => {
            if ((0, Y.alwaysValidSchema)($, K)) return;
            let W = G.subschema({ keyword: "allOf", schemaProp: V }, B);
            (G.ok(B), G.mergeEvaluated(W));
          });
        },
      };
    X.default = Q;
  }),
  Tx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = m1(),
      G = {
        message: ({ params: $ }) => Y.str`must match "${$.ifClause}" schema`,
        params: ({ params: $ }) => Y._`{failingKeyword: ${$.ifClause}}`,
      },
      J = {
        keyword: "if",
        schemaType: ["object", "boolean"],
        trackErrors: !0,
        error: G,
        code($) {
          let { gen: B, parentSchema: K, it: V } = $;
          if (K.then === void 0 && K.else === void 0)
            (0, Q.checkStrictMode)(
              V,
              '"if" without "then" and "else" is ignored'
            );
          let W = U(V, "then"),
            L = U(V, "else");
          if (!W && !L) return;
          let H = B.let("valid", !0),
            F = B.name("_valid");
          if ((N(), $.reset(), W && L)) {
            let M = B.let("ifClause");
            ($.setParams({ ifClause: M }), B.if(F, q("then", M), q("else", M)));
          } else if (W) B.if(F, q("then"));
          else B.if((0, Y.not)(F), q("else"));
          $.pass(H, () => $.error(!0));
          function N() {
            let M = $.subschema(
              {
                keyword: "if",
                compositeRule: !0,
                createErrors: !1,
                allErrors: !1,
              },
              F
            );
            $.mergeEvaluated(M);
          }
          function q(M, A) {
            return () => {
              let D = $.subschema({ keyword: M }, F);
              if ((B.assign(H, F), $.mergeValidEvaluated(D, H), A))
                B.assign(A, Y._`${M}`);
              else $.setParams({ ifClause: M });
            };
          }
        },
      };
    function U($, B) {
      let K = $.schema[B];
      return K !== void 0 && !(0, Q.alwaysValidSchema)($, K);
    }
    X.default = J;
  }),
  bx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = m1(),
      Q = {
        keyword: ["then", "else"],
        schemaType: ["object", "boolean"],
        code({ keyword: G, parentSchema: J, it: U }) {
          if (J.if === void 0)
            (0, Y.checkStrictMode)(U, `"${G}" without "if" is ignored`);
        },
      };
    X.default = Q;
  }),
  vx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = mE(),
      Q = Dx(),
      G = cE(),
      J = zx(),
      U = Ex(),
      $ = Ox(),
      B = Zx(),
      K = dE(),
      V = jx(),
      W = wx(),
      L = Cx(),
      H = Ix(),
      F = Px(),
      N = Sx(),
      q = Tx(),
      M = bx();
    function A(D = !1) {
      let R = [
        L.default,
        H.default,
        F.default,
        N.default,
        q.default,
        M.default,
        B.default,
        K.default,
        $.default,
        V.default,
        W.default,
      ];
      if (D) R.push(Q.default, J.default);
      else R.push(Y.default, G.default);
      return (R.push(U.default), R);
    }
    X.default = A;
  }),
  kx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = {
        message: ({ schemaCode: J }) => Y.str`must match format "${J}"`,
        params: ({ schemaCode: J }) => Y._`{format: ${J}}`,
      },
      G = {
        keyword: "format",
        type: ["number", "string"],
        schemaType: "string",
        $data: !0,
        error: Q,
        code(J, U) {
          let {
              gen: $,
              data: B,
              $data: K,
              schema: V,
              schemaCode: W,
              it: L,
            } = J,
            { opts: H, errSchemaPath: F, schemaEnv: N, self: q } = L;
          if (!H.validateFormats) return;
          if (K) M();
          else A();
          function M() {
            let D = $.scopeValue("formats", {
                ref: q.formats,
                code: H.code.formats,
              }),
              R = $.const("fDef", Y._`${D}[${W}]`),
              z = $.let("fType"),
              E = $.let("format");
            ($.if(
              Y._`typeof ${R} == "object" && !(${R} instanceof RegExp)`,
              () =>
                $.assign(z, Y._`${R}.type || "string"`).assign(
                  E,
                  Y._`${R}.validate`
                ),
              () => $.assign(z, Y._`"string"`).assign(E, R)
            ),
              J.fail$data((0, Y.or)(O(), Z())));
            function O() {
              if (H.strictSchema === !1) return Y.nil;
              return Y._`${W} && !${E}`;
            }
            function Z() {
              let j = N.$async
                  ? Y._`(${R}.async ? await ${E}(${B}) : ${E}(${B}))`
                  : Y._`${E}(${B})`,
                w = Y._`(typeof ${E} == "function" ? ${j} : ${E}.test(${B}))`;
              return Y._`${E} && ${E} !== true && ${z} === ${U} && !${w}`;
            }
          }
          function A() {
            let D = q.formats[V];
            if (!D) {
              O();
              return;
            }
            if (D === !0) return;
            let [R, z, E] = Z(D);
            if (R === U) J.pass(j());
            function O() {
              if (H.strictSchema === !1) {
                q.logger.warn(w());
                return;
              }
              throw Error(w());
              function w() {
                return `unknown format "${V}" ignored in schema at path "${F}"`;
              }
            }
            function Z(w) {
              let I =
                  w instanceof RegExp
                    ? (0, Y.regexpCode)(w)
                    : H.code.formats
                      ? Y._`${H.code.formats}${(0, Y.getProperty)(V)}`
                      : void 0,
                T = $.scopeValue("formats", { key: V, ref: w, code: I });
              if (typeof w == "object" && !(w instanceof RegExp))
                return [w.type || "string", w.validate, Y._`${T}.validate`];
              return ["string", w, T];
            }
            function j() {
              if (typeof D == "object" && !(D instanceof RegExp) && D.async) {
                if (!N.$async) throw Error("async format in sync schema");
                return Y._`await ${E}(${B})`;
              }
              return typeof z == "function"
                ? Y._`${E}(${B})`
                : Y._`${E}.test(${B})`;
            }
          }
        },
      };
    X.default = G;
  }),
  yx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = kx(),
      Q = [Y.default];
    X.default = Q;
  }),
  _x = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.contentVocabulary = X.metadataVocabulary = void 0),
      (X.metadataVocabulary = [
        "title",
        "description",
        "default",
        "deprecated",
        "readOnly",
        "writeOnly",
        "examples",
      ]),
      (X.contentVocabulary = [
        "contentMediaType",
        "contentEncoding",
        "contentSchema",
      ]));
  }),
  fx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = Hx(),
      Q = Rx(),
      G = vx(),
      J = yx(),
      U = _x(),
      $ = [
        Y.default,
        Q.default,
        (0, G.default)(),
        J.default,
        U.metadataVocabulary,
        U.contentVocabulary,
      ];
    X.default = $;
  }),
  xx = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.DiscrError = void 0));
    var Y;
    (function (Q) {
      ((Q.Tag = "tag"), (Q.Mapping = "mapping"));
    })(Y || (X.DiscrError = Y = {}));
  }),
  hx = L0((X) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Y = D1(),
      Q = xx(),
      G = uU(),
      J = BJ(),
      U = m1(),
      $ = {
        message: ({ params: { discrError: K, tagName: V } }) =>
          K === Q.DiscrError.Tag
            ? `tag "${V}" must be string`
            : `value of tag "${V}" must be in oneOf`,
        params: ({ params: { discrError: K, tag: V, tagName: W } }) =>
          Y._`{error: ${K}, tag: ${W}, tagValue: ${V}}`,
      },
      B = {
        keyword: "discriminator",
        type: "object",
        schemaType: "object",
        error: $,
        code(K) {
          let { gen: V, data: W, schema: L, parentSchema: H, it: F } = K,
            { oneOf: N } = H;
          if (!F.opts.discriminator)
            throw Error("discriminator: requires discriminator option");
          let q = L.propertyName;
          if (typeof q != "string")
            throw Error("discriminator: requires propertyName");
          if (L.mapping) throw Error("discriminator: mapping is not supported");
          if (!N) throw Error("discriminator: requires oneOf keyword");
          let M = V.let("valid", !1),
            A = V.const("tag", Y._`${W}${(0, Y.getProperty)(q)}`);
          (V.if(
            Y._`typeof ${A} == "string"`,
            () => D(),
            () =>
              K.error(!1, { discrError: Q.DiscrError.Tag, tag: A, tagName: q })
          ),
            K.ok(M));
          function D() {
            let E = z();
            V.if(!1);
            for (let O in E)
              (V.elseIf(Y._`${A} === ${O}`), V.assign(M, R(E[O])));
            (V.else(),
              K.error(!1, {
                discrError: Q.DiscrError.Mapping,
                tag: A,
                tagName: q,
              }),
              V.endIf());
          }
          function R(E) {
            let O = V.name("valid"),
              Z = K.subschema({ keyword: "oneOf", schemaProp: E }, O);
            return (K.mergeEvaluated(Z, Y.Name), O);
          }
          function z() {
            var E;
            let O = {},
              Z = w(H),
              j = !0;
            for (let y = 0; y < N.length; y++) {
              let _ = N[y];
              if (
                (_ === null || _ === void 0 ? void 0 : _.$ref) &&
                !(0, U.schemaHasRulesButRef)(_, F.self.RULES)
              ) {
                let l = _.$ref;
                if (
                  ((_ = G.resolveRef.call(
                    F.self,
                    F.schemaEnv.root,
                    F.baseId,
                    l
                  )),
                  _ instanceof G.SchemaEnv)
                )
                  _ = _.schema;
                if (_ === void 0)
                  throw new J.default(F.opts.uriResolver, F.baseId, l);
              }
              let f =
                (E = _ === null || _ === void 0 ? void 0 : _.properties) ===
                  null || E === void 0
                  ? void 0
                  : E[q];
              if (typeof f != "object")
                throw Error(
                  `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${q}"`
                );
              ((j = j && (Z || w(_))), I(f, y));
            }
            if (!j) throw Error(`discriminator: "${q}" must be required`);
            return O;
            function w({ required: y }) {
              return Array.isArray(y) && y.includes(q);
            }
            function I(y, _) {
              if (y.const) T(y.const, _);
              else if (y.enum) for (let f of y.enum) T(f, _);
              else
                throw Error(
                  `discriminator: "properties/${q}" must have "const" or "enum"`
                );
            }
            function T(y, _) {
              if (typeof y != "string" || y in O)
                throw Error(
                  `discriminator: "${q}" values must be unique strings`
                );
              O[y] = _;
            }
          }
        },
      };
    X.default = B;
  }),
  gx = L0((X, Y) => {
    Y.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
        nonNegativeInteger: { type: "integer", minimum: 0 },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string",
          ],
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: !0,
          default: [],
        },
      },
      type: ["object", "boolean"],
      properties: {
        $id: { type: "string", format: "uri-reference" },
        $schema: { type: "string", format: "uri" },
        $ref: { type: "string", format: "uri-reference" },
        $comment: { type: "string" },
        title: { type: "string" },
        description: { type: "string" },
        default: !0,
        readOnly: { type: "boolean", default: !1 },
        examples: { type: "array", items: !0 },
        multipleOf: { type: "number", exclusiveMinimum: 0 },
        maximum: { type: "number" },
        exclusiveMaximum: { type: "number" },
        minimum: { type: "number" },
        exclusiveMinimum: { type: "number" },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: { type: "string", format: "regex" },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: !0,
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: { type: "boolean", default: !1 },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {},
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {},
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {},
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
          },
        },
        propertyNames: { $ref: "#" },
        const: !0,
        enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: !0,
            },
          ],
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" },
      },
      default: !0,
    };
  }),
  ux = L0((X, Y) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.MissingRefError =
        X.ValidationError =
        X.CodeGen =
        X.Name =
        X.nil =
        X.stringify =
        X.str =
        X._ =
        X.KeywordCxt =
        X.Ajv =
          void 0));
    var Q = Gx(),
      G = fx(),
      J = hx(),
      U = gx(),
      $ = ["/properties"],
      B = "http://json-schema.org/draft-07/schema";
    class K extends Q.default {
      _addVocabularies() {
        if (
          (super._addVocabularies(),
          G.default.forEach((F) => this.addVocabulary(F)),
          this.opts.discriminator)
        )
          this.addKeyword(J.default);
      }
      _addDefaultMetaSchema() {
        if ((super._addDefaultMetaSchema(), !this.opts.meta)) return;
        let F = this.opts.$data ? this.$dataMetaSchema(U, $) : U;
        (this.addMetaSchema(F, B, !1),
          (this.refs["http://json-schema.org/schema"] = B));
      }
      defaultMeta() {
        return (this.opts.defaultMeta =
          super.defaultMeta() || (this.getSchema(B) ? B : void 0));
      }
    }
    ((X.Ajv = K),
      (Y.exports = X = K),
      (Y.exports.Ajv = K),
      Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.default = K));
    var V = LJ();
    Object.defineProperty(X, "KeywordCxt", {
      enumerable: !0,
      get: function () {
        return V.KeywordCxt;
      },
    });
    var W = D1();
    (Object.defineProperty(X, "_", {
      enumerable: !0,
      get: function () {
        return W._;
      },
    }),
      Object.defineProperty(X, "str", {
        enumerable: !0,
        get: function () {
          return W.str;
        },
      }),
      Object.defineProperty(X, "stringify", {
        enumerable: !0,
        get: function () {
          return W.stringify;
        },
      }),
      Object.defineProperty(X, "nil", {
        enumerable: !0,
        get: function () {
          return W.nil;
        },
      }),
      Object.defineProperty(X, "Name", {
        enumerable: !0,
        get: function () {
          return W.Name;
        },
      }),
      Object.defineProperty(X, "CodeGen", {
        enumerable: !0,
        get: function () {
          return W.CodeGen;
        },
      }));
    var L = gU();
    Object.defineProperty(X, "ValidationError", {
      enumerable: !0,
      get: function () {
        return L.default;
      },
    });
    var H = BJ();
    Object.defineProperty(X, "MissingRefError", {
      enumerable: !0,
      get: function () {
        return H.default;
      },
    });
  }),
  lx = L0((X) => {
    (Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.formatLimitDefinition = void 0));
    var Y = ux(),
      Q = D1(),
      G = Q.operators,
      J = {
        formatMaximum: { okStr: "<=", ok: G.LTE, fail: G.GT },
        formatMinimum: { okStr: ">=", ok: G.GTE, fail: G.LT },
        formatExclusiveMaximum: { okStr: "<", ok: G.LT, fail: G.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: G.GT, fail: G.LTE },
      },
      U = {
        message: ({ keyword: B, schemaCode: K }) =>
          Q.str`should be ${J[B].okStr} ${K}`,
        params: ({ keyword: B, schemaCode: K }) =>
          Q._`{comparison: ${J[B].okStr}, limit: ${K}}`,
      };
    X.formatLimitDefinition = {
      keyword: Object.keys(J),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: U,
      code(B) {
        let { gen: K, data: V, schemaCode: W, keyword: L, it: H } = B,
          { opts: F, self: N } = H;
        if (!F.validateFormats) return;
        let q = new Y.KeywordCxt(H, N.RULES.all.format.definition, "format");
        if (q.$data) M();
        else A();
        function M() {
          let R = K.scopeValue("formats", {
              ref: N.formats,
              code: F.code.formats,
            }),
            z = K.const("fmt", Q._`${R}[${q.schemaCode}]`);
          B.fail$data(
            (0, Q.or)(
              Q._`typeof ${z} != "object"`,
              Q._`${z} instanceof RegExp`,
              Q._`typeof ${z}.compare != "function"`,
              D(z)
            )
          );
        }
        function A() {
          let R = q.schema,
            z = N.formats[R];
          if (!z || z === !0) return;
          if (
            typeof z != "object" ||
            z instanceof RegExp ||
            typeof z.compare != "function"
          )
            throw Error(
              `"${L}": format "${R}" does not define "compare" function`
            );
          let E = K.scopeValue("formats", {
            key: R,
            ref: z,
            code: F.code.formats
              ? Q._`${F.code.formats}${(0, Q.getProperty)(R)}`
              : void 0,
          });
          B.fail$data(D(E));
        }
        function D(R) {
          return Q._`${R}.compare(${V}, ${W}) ${J[L].fail} 0`;
        }
      },
      dependencies: ["format"],
    };
    var $ = (B) => {
      return (B.addKeyword(X.formatLimitDefinition), B);
    };
    X.default = $;
  }),
  mx = L0((X, Y) => {
    Object.defineProperty(X, "__esModule", { value: !0 });
    var Q = rf(),
      G = lx(),
      J = D1(),
      U = new J.Name("fullFormats"),
      $ = new J.Name("fastFormats"),
      B = (V, W = { keywords: !0 }) => {
        if (Array.isArray(W)) return (K(V, W, Q.fullFormats, U), V);
        let [L, H] =
            W.mode === "fast" ? [Q.fastFormats, $] : [Q.fullFormats, U],
          F = W.formats || Q.formatNames;
        if ((K(V, F, L, H), W.keywords)) (0, G.default)(V);
        return V;
      };
    B.get = (V, W = "full") => {
      let H = (W === "fast" ? Q.fastFormats : Q.fullFormats)[V];
      if (!H) throw Error(`Unknown format "${V}"`);
      return H;
    };
    function K(V, W, L, H) {
      var F, N;
      ((F = (N = V.opts.code).formats) !== null && F !== void 0) ||
        (N.formats = J._`require("ajv-formats/dist/formats").${H}`);
      for (let q of W) V.addFormat(q, L[q]);
    }
    ((Y.exports = X = B),
      Object.defineProperty(X, "__esModule", { value: !0 }),
      (X.default = B));
  }),
  px = 50;
function pE(X = px) {
  let Y = new AbortController();
  return (dx(X, Y.signal), Y);
}
var rx =
    typeof global == "object" && global && global.Object === Object && global,
  ox = rx,
  sx = typeof self == "object" && self && self.Object === Object && self,
  tx = ox || sx || Function("return this")(),
  mU = tx,
  ex = mU.Symbol,
  pG = ex,
  iE = Object.prototype,
  Xh = iE.hasOwnProperty,
  Yh = iE.toString,
  TY = pG ? pG.toStringTag : void 0;
function Qh(X) {
  var Y = Xh.call(X, TY),
    Q = X[TY];
  try {
    X[TY] = void 0;
    var G = !0;
  } catch (U) {}
  var J = Yh.call(X);
  if (G)
    if (Y) X[TY] = Q;
    else delete X[TY];
  return J;
}
var Gh = Qh,
  Jh = Object.prototype,
  Wh = Jh.toString;
function Hh(X) {
  return Wh.call(X);
}
var $h = Hh,
  Uh = "[object Null]",
  Lh = "[object Undefined]",
  YE = pG ? pG.toStringTag : void 0;
function Bh(X) {
  if (X == null) return X === void 0 ? Lh : Uh;
  return YE && YE in Object(X) ? Gh(X) : $h(X);
}
var Kh = Bh;
function Vh(X) {
  var Y = typeof X;
  return X != null && (Y == "object" || Y == "function");
}
var nE = Vh,
  Fh = "[object AsyncFunction]",
  Nh = "[object Function]",
  Mh = "[object GeneratorFunction]",
  Ah = "[object Proxy]";
function qh(X) {
  if (!nE(X)) return !1;
  var Y = Kh(X);
  return Y == Nh || Y == Mh || Y == Fh || Y == Ah;
}
var Rh = qh,
  Dh = mU["__core-js_shared__"],
  OU = Dh,
  QE = (function () {
    var X = /[^.]+$/.exec((OU && OU.keys && OU.keys.IE_PROTO) || "");
    return X ? "Symbol(src)_1." + X : "";
  })();
function zh(X) {
  return !!QE && QE in X;
}
var Eh = zh,
  Oh = Function.prototype,
  Zh = Oh.toString;
function jh(X) {
  if (X != null) {
    try {
      return Zh.call(X);
    } catch (Y) {}
    try {
      return X + "";
    } catch (Y) {}
  }
  return "";
}
var wh = jh,
  Ch = /[\\^$.*+?()[\]{}|]/g,
  Ih = /^\[object .+?Constructor\]$/,
  Ph = Function.prototype,
  Sh = Object.prototype,
  Th = Ph.toString,
  bh = Sh.hasOwnProperty,
  vh = RegExp(
    "^" +
      Th.call(bh)
        .replace(Ch, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?"
        ) +
      "$"
  );
function kh(X) {
  if (!nE(X) || Eh(X)) return !1;
  var Y = Rh(X) ? vh : Ih;
  return Y.test(wh(X));
}
var yh = kh;
function _h(X, Y) {
  return X == null ? void 0 : X[Y];
}
var fh = _h;
function xh(X, Y) {
  var Q = fh(X, Y);
  return yh(Q) ? Q : void 0;
}
var aE = xh,
  hh = aE(Object, "create"),
  yY = hh;
function gh() {
  ((this.__data__ = yY ? yY(null) : {}), (this.size = 0));
}
var uh = gh;
function lh(X) {
  var Y = this.has(X) && delete this.__data__[X];
  return ((this.size -= Y ? 1 : 0), Y);
}
var mh = lh,
  ch = "__lodash_hash_undefined__",
  dh = Object.prototype,
  ph = dh.hasOwnProperty;
function ih(X) {
  var Y = this.__data__;
  if (yY) {
    var Q = Y[X];
    return Q === ch ? void 0 : Q;
  }
  return ph.call(Y, X) ? Y[X] : void 0;
}
var nh = ih,
  ah = Object.prototype,
  rh = ah.hasOwnProperty;
function oh(X) {
  var Y = this.__data__;
  return yY ? Y[X] !== void 0 : rh.call(Y, X);
}
var sh = oh,
  th = "__lodash_hash_undefined__";
function eh(X, Y) {
  var Q = this.__data__;
  return (
    (this.size += this.has(X) ? 0 : 1),
    (Q[X] = yY && Y === void 0 ? th : Y),
    this
  );
}
var Xg = eh;
function U7(X) {
  var Y = -1,
    Q = X == null ? 0 : X.length;
  this.clear();
  while (++Y < Q) {
    var G = X[Y];
    this.set(G[0], G[1]);
  }
}
U7.prototype.clear = uh;
U7.prototype.delete = mh;
U7.prototype.get = nh;
U7.prototype.has = sh;
U7.prototype.set = Xg;
var GE = U7;
function Yg() {
  ((this.__data__ = []), (this.size = 0));
}
var Qg = Yg;
function Gg(X, Y) {
  return X === Y || (X !== X && Y !== Y);
}
var Jg = Gg;
function Wg(X, Y) {
  var Q = X.length;
  while (Q--) if (Jg(X[Q][0], Y)) return Q;
  return -1;
}
var KJ = Wg,
  Hg = Array.prototype,
  $g = Hg.splice;
function Ug(X) {
  var Y = this.__data__,
    Q = KJ(Y, X);
  if (Q < 0) return !1;
  var G = Y.length - 1;
  if (Q == G) Y.pop();
  else $g.call(Y, Q, 1);
  return (--this.size, !0);
}
var Lg = Ug;
function Bg(X) {
  var Y = this.__data__,
    Q = KJ(Y, X);
  return Q < 0 ? void 0 : Y[Q][1];
}
var Kg = Bg;
function Vg(X) {
  return KJ(this.__data__, X) > -1;
}
var Fg = Vg;
function Ng(X, Y) {
  var Q = this.__data__,
    G = KJ(Q, X);
  if (G < 0) (++this.size, Q.push([X, Y]));
  else Q[G][1] = Y;
  return this;
}
var Mg = Ng;
function L7(X) {
  var Y = -1,
    Q = X == null ? 0 : X.length;
  this.clear();
  while (++Y < Q) {
    var G = X[Y];
    this.set(G[0], G[1]);
  }
}
L7.prototype.clear = Qg;
L7.prototype.delete = Lg;
L7.prototype.get = Kg;
L7.prototype.has = Fg;
L7.prototype.set = Mg;
var Ag = L7,
  qg = aE(mU, "Map"),
  Rg = qg;
function Dg() {
  ((this.size = 0),
    (this.__data__ = {
      hash: new GE(),
      map: new (Rg || Ag)(),
      string: new GE(),
    }));
}
var zg = Dg;
function Eg(X) {
  var Y = typeof X;
  return Y == "string" || Y == "number" || Y == "symbol" || Y == "boolean"
    ? X !== "__proto__"
    : X === null;
}
var Og = Eg;
function Zg(X, Y) {
  var Q = X.__data__;
  return Og(Y) ? Q[typeof Y == "string" ? "string" : "hash"] : Q.map;
}
var VJ = Zg;
function jg(X) {
  var Y = VJ(this, X).delete(X);
  return ((this.size -= Y ? 1 : 0), Y);
}
var wg = jg;
function Cg(X) {
  return VJ(this, X).get(X);
}
var Ig = Cg;
function Pg(X) {
  return VJ(this, X).has(X);
}
var Sg = Pg;
function Tg(X, Y) {
  var Q = VJ(this, X),
    G = Q.size;
  return (Q.set(X, Y), (this.size += Q.size == G ? 0 : 1), this);
}
var bg = Tg;
function B7(X) {
  var Y = -1,
    Q = X == null ? 0 : X.length;
  this.clear();
  while (++Y < Q) {
    var G = X[Y];
    this.set(G[0], G[1]);
  }
}
B7.prototype.clear = zg;
B7.prototype.delete = wg;
B7.prototype.get = Ig;
B7.prototype.has = Sg;
B7.prototype.set = bg;
var rE = B7,
  vg = "Expected a function";
function cU(X, Y) {
  if (typeof X != "function" || (Y != null && typeof Y != "function"))
    throw TypeError(vg);
  var Q = function () {
    var G = arguments,
      J = Y ? Y.apply(this, G) : G[0],
      U = Q.cache;
    if (U.has(J)) return U.get(J);
    var $ = X.apply(this, G);
    return ((Q.cache = U.set(J, $) || U), $);
  };
  return ((Q.cache = new (cU.Cache || rE)()), Q);
}
cU.Cache = rE;
var rY = cU,
  JE = 2000;
function kg(X) {
  for (let Y = 0; Y < X.length; Y += JE)
    process.stderr.write(X.substring(Y, Y + JE));
}
var yg = rY((X) => {
  if (!X || X.trim() === "") return null;
  let Y = X.split(",")
    .map((U) => U.trim())
    .filter(Boolean);
  if (Y.length === 0) return null;
  let Q = Y.some((U) => U.startsWith("!")),
    G = Y.some((U) => !U.startsWith("!"));
  if (Q && G) return null;
  let J = Y.map((U) => U.replace(/^!/, "").toLowerCase());
  return { include: Q ? [] : J, exclude: Q ? J : [], isExclusive: Q };
});
function _g(X) {
  let Y = [],
    Q = X.match(/^MCP server ["']([^"']+)["']/);
  if (Q && Q[1]) (Y.push("mcp"), Y.push(Q[1].toLowerCase()));
  else {
    let U = X.match(/^([^:[]+):/);
    if (U && U[1]) Y.push(U[1].trim().toLowerCase());
  }
  let G = X.match(/^\[([^\]]+)]/);
  if (G && G[1]) Y.push(G[1].trim().toLowerCase());
  if (X.toLowerCase().includes("statsig event:")) Y.push("statsig");
  let J = X.match(/:\s*([^:]+?)(?:\s+(?:type|mode|status|event))?:/);
  if (J && J[1]) {
    let U = J[1].trim().toLowerCase();
    if (U.length < 30 && !U.includes(" ")) Y.push(U);
  }
  return Array.from(new Set(Y));
}
function fg(X, Y) {
  if (!Y) return !0;
  if (X.length === 0) return !1;
  if (Y.isExclusive) return !X.some((Q) => Y.exclude.includes(Q));
  else return X.some((Q) => Y.include.includes(Q));
}
function xg(X, Y) {
  if (!Y) return !0;
  let Q = _g(X);
  return fg(Q, Y);
}
function oE() {
  return process.env.CLAUDE_CONFIG_DIR ?? hg(gg(), ".claude");
}
function WE(X) {
  if (!X) return !1;
  if (typeof X === "boolean") return X;
  let Y = X.toLowerCase().trim();
  return ["1", "true", "yes", "on"].includes(Y);
}
var cg = {
    name: "BASH_MAX_OUTPUT_LENGTH",
    default: 30000,
    validate: (X) => {
      if (!X) return { effective: 30000, status: "valid" };
      let G = parseInt(X, 10);
      if (isNaN(G) || G <= 0)
        return {
          effective: 30000,
          status: "invalid",
          message: `Invalid value "${X}" (using default: 30000)`,
        };
      if (G > 150000)
        return {
          effective: 150000,
          status: "capped",
          message: `Capped from ${G} to 150000`,
        };
      return { effective: G, status: "valid" };
    },
  },
  dg = {
    name: "CLAUDE_CODE_MAX_OUTPUT_TOKENS",
    default: 32000,
    validate: (X) => {
      if (!X) return { effective: 32000, status: "valid" };
      let G = parseInt(X, 10);
      if (isNaN(G) || G <= 0)
        return {
          effective: 32000,
          status: "invalid",
          message: `Invalid value "${X}" (using default: 32000)`,
        };
      if (G > 64000)
        return {
          effective: 64000,
          status: "capped",
          message: `Capped from ${G} to 64000`,
        };
      return { effective: G, status: "valid" };
    },
  };
function pg() {
  let X = "";
  if (typeof process < "u" && typeof process.cwd === "function") X = lg(ug());
  return {
    originalCwd: X,
    totalCostUSD: 0,
    totalAPIDuration: 0,
    totalAPIDurationWithoutRetries: 0,
    totalToolDuration: 0,
    startTime: Date.now(),
    lastInteractionTime: Date.now(),
    totalLinesAdded: 0,
    totalLinesRemoved: 0,
    hasUnknownModelCost: !1,
    cwd: X,
    modelUsage: {},
    mainLoopModelOverride: void 0,
    initialMainLoopModel: null,
    modelStrings: null,
    isInteractive: !1,
    clientType: "cli",
    sessionIngressToken: void 0,
    oauthTokenFromFd: void 0,
    apiKeyFromFd: void 0,
    flagSettingsPath: void 0,
    allowedSettingSources: [
      "userSettings",
      "projectSettings",
      "localSettings",
      "flagSettings",
      "policySettings",
    ],
    meter: null,
    sessionCounter: null,
    locCounter: null,
    prCounter: null,
    commitCounter: null,
    costCounter: null,
    tokenCounter: null,
    codeEditToolDecisionCounter: null,
    activeTimeCounter: null,
    sessionId: mg(),
    loggerProvider: null,
    eventLogger: null,
    meterProvider: null,
    tracerProvider: null,
    agentColorMap: new Map(),
    agentColorIndex: 0,
    envVarValidators: [cg, dg],
    lastAPIRequest: null,
    inMemoryErrorLog: [],
    inlinePlugins: [],
    sessionBypassPermissionsMode: !1,
    sessionPersistenceDisabled: !1,
    hasExitedPlanMode: !1,
    needsPlanModeExitAttachment: !1,
    hasExitedDelegateMode: !1,
    needsDelegateModeExitAttachment: !1,
    lspRecommendationShownThisSession: !1,
    initJsonSchema: null,
    registeredHooks: null,
    planSlugCache: new Map(),
    teleportedSessionInfo: null,
    invokedSkills: new Map(),
  };
}
var ig = pg();
function ng() {
  return ig.sessionId;
}
function ag({
  writeFn: X,
  flushIntervalMs: Y = 1000,
  maxBufferSize: Q = 100,
  immediateMode: G = !1,
}) {
  let J = [],
    U = null;
  function $() {
    if (U) (clearTimeout(U), (U = null));
  }
  function B() {
    if (J.length === 0) return;
    (X(J.join("")), (J = []), $());
  }
  function K() {
    if (!U) U = setTimeout(B, Y);
  }
  return {
    write(V) {
      if (G) {
        X(V);
        return;
      }
      if ((J.push(V), K(), J.length >= Q)) B();
    },
    flush: B,
    dispose() {
      B();
    },
  };
}
var HE = new Set();
function rg(X) {
  return (HE.add(X), () => HE.delete(X));
}
var og = rY(() => {
    return (
      WE(process.env.DEBUG) ||
      WE(process.env.DEBUG_SDK) ||
      process.argv.includes("--debug") ||
      process.argv.includes("-d") ||
      tE() ||
      process.argv.some((X) => X.startsWith("--debug="))
    );
  }),
  sg = rY(() => {
    let X = process.argv.find((Q) => Q.startsWith("--debug="));
    if (!X) return null;
    let Y = X.substring(8);
    return yg(Y);
  }),
  tE = rY(() => {
    return (
      process.argv.includes("--debug-to-stderr") ||
      process.argv.includes("-d2e")
    );
  });
function tg(X) {
  if (
    typeof process > "u" ||
    typeof process.versions > "u" ||
    typeof process.versions.node > "u"
  )
    return !1;
  let Y = sg();
  return xg(X, Y);
}
var eg = !1,
  fG = null;
function Xu() {
  if (!fG)
    ((fG = ag({
      writeFn: (X) => {
        let Y = eE();
        if (!J4().existsSync(IU(Y))) J4().mkdirSync(IU(Y));
        (J4().appendFileSync(Y, X), Yu());
      },
      flushIntervalMs: 1000,
      maxBufferSize: 100,
      immediateMode: og(),
    })),
      rg(async () => fG?.dispose()));
  return fG;
}
function _4(X, { level: Y } = { level: "debug" }) {
  if (!tg(X)) return;
  if (
    eg &&
    X.includes(`
`)
  )
    X = JSON.stringify(X);
  let G = `${new Date().toISOString()} [${Y.toUpperCase()}] ${X.trim()}
`;
  if (tE()) {
    kg(G);
    return;
  }
  Xu().write(G);
}
function eE() {
  return (
    process.env.CLAUDE_CODE_DEBUG_LOGS_DIR ?? sE(oE(), "debug", `${ng()}.txt`)
  );
}
var Yu = rY(() => {
    if (process.argv[2] === "--ripgrep") return;
    try {
      let X = eE(),
        Y = IU(X),
        Q = sE(Y, "latest");
      if (!J4().existsSync(Y)) J4().mkdirSync(Y);
      if (J4().existsSync(Q))
        try {
          J4().unlinkSync(Q);
        } catch {}
      J4().symlinkSync(X, Q);
    } catch {}
  }),
  Qu = 5;
function D5(X, Y) {
  let Q = performance.now();
  try {
    return Y();
  } finally {
    let G = performance.now() - Q;
    if (G > Qu) _4(`[SLOW OPERATION DETECTED] fs.${X} (${G.toFixed(1)}ms)`);
  }
}
var Gu = {
    cwd() {
      return process.cwd();
    },
    existsSync(X) {
      return D5("existsSync", () => i0.existsSync(X));
    },
    async stat(X) {
      return ax(X);
    },
    statSync(X) {
      return D5("statSync", () => i0.statSync(X));
    },
    lstatSync(X) {
      return D5("lstatSync", () => i0.lstatSync(X));
    },
    readFileSync(X, Y) {
      return D5("readFileSync", () =>
        i0.readFileSync(X, { encoding: Y.encoding })
      );
    },
    readFileBytesSync(X) {
      return D5("readFileBytesSync", () => i0.readFileSync(X));
    },
    readSync(X, Y) {
      return D5("readSync", () => {
        let Q = void 0;
        try {
          Q = i0.openSync(X, "r");
          let G = Buffer.alloc(Y.length),
            J = i0.readSync(Q, G, 0, Y.length, 0);
          return { buffer: G, bytesRead: J };
        } finally {
          if (Q) i0.closeSync(Q);
        }
      });
    },
    writeFileSync(X, Y, Q) {
      return D5("writeFileSync", () => {
        let G = i0.existsSync(X);
        if (!Q.flush) {
          let U = { encoding: Q.encoding };
          if (!G) U.mode = Q.mode ?? 384;
          else if (Q.mode !== void 0) U.mode = Q.mode;
          i0.writeFileSync(X, Y, U);
          return;
        }
        let J;
        try {
          let U = !G ? (Q.mode ?? 384) : Q.mode;
          ((J = i0.openSync(X, "w", U)),
            i0.writeFileSync(J, Y, { encoding: Q.encoding }),
            i0.fsyncSync(J));
        } finally {
          if (J) i0.closeSync(J);
        }
      });
    },
    appendFileSync(X, Y, Q) {
      return D5("appendFileSync", () => {
        if (!i0.existsSync(X)) {
          let G = Q?.mode ?? 384,
            J = i0.openSync(X, "a", G);
          try {
            i0.appendFileSync(J, Y);
          } finally {
            i0.closeSync(J);
          }
        } else i0.appendFileSync(X, Y);
      });
    },
    copyFileSync(X, Y) {
      return D5("copyFileSync", () => i0.copyFileSync(X, Y));
    },
    unlinkSync(X) {
      return D5("unlinkSync", () => i0.unlinkSync(X));
    },
    renameSync(X, Y) {
      return D5("renameSync", () => i0.renameSync(X, Y));
    },
    linkSync(X, Y) {
      return D5("linkSync", () => i0.linkSync(X, Y));
    },
    symlinkSync(X, Y) {
      return D5("symlinkSync", () => i0.symlinkSync(X, Y));
    },
    readlinkSync(X) {
      return D5("readlinkSync", () => i0.readlinkSync(X));
    },
    realpathSync(X) {
      return D5("realpathSync", () => i0.realpathSync(X));
    },
    mkdirSync(X) {
      return D5("mkdirSync", () => {
        if (!i0.existsSync(X)) i0.mkdirSync(X, { recursive: !0, mode: 448 });
      });
    },
    readdirSync(X) {
      return D5("readdirSync", () => i0.readdirSync(X, { withFileTypes: !0 }));
    },
    readdirStringSync(X) {
      return D5("readdirStringSync", () => i0.readdirSync(X));
    },
    isDirEmptySync(X) {
      return D5("isDirEmptySync", () => {
        return this.readdirSync(X).length === 0;
      });
    },
    rmdirSync(X) {
      return D5("rmdirSync", () => i0.rmdirSync(X));
    },
    rmSync(X, Y) {
      return D5("rmSync", () => i0.rmSync(X, Y));
    },
    createWriteStream(X) {
      return i0.createWriteStream(X);
    },
  },
  Ju = Gu;
function J4() {
  return Ju;
}
class eX extends Error {}
function XO() {
  return process.versions.bun !== void 0;
}
var xG = null,
  UE = !1;
function Lu() {
  if (UE) return xG;
  if (((UE = !0), !process.env.DEBUG_CLAUDE_AGENT_SDK)) return null;
  let X = $E(oE(), "debug");
  if (((xG = $E(X, `sdk-${Wu()}.txt`)), !$u(X))) Uu(X, { recursive: !0 });
  return (
    process.stderr.write(`SDK debug logs: ${xG}
`),
    xG
  );
}
function k9(X) {
  let Y = Lu();
  if (!Y) return;
  let G = `${new Date().toISOString()} ${X}
`;
  Hu(Y, G);
}
function Bu(X, Y) {
  let Q = { ...X };
  if (Y) {
    let G = { sandbox: Y };
    if (Q.settings)
      try {
        G = { ...JSON.parse(Q.settings), sandbox: Y };
      } catch {}
    Q.settings = JSON.stringify(G);
  }
  return Q;
}
class YO {
  options;
  process;
  processStdin;
  processStdout;
  ready = !1;
  abortController;
  exitError;
  exitListeners = [];
  processExitHandler;
  abortHandler;
  constructor(X) {
    ((this.options = X),
      (this.abortController = X.abortController || pE()),
      this.initialize());
  }
  getDefaultExecutable() {
    return XO() ? "bun" : "node";
  }
  spawnLocalProcess(X) {
    let { command: Y, args: Q, cwd: G, env: J, signal: U } = X,
      $ = J.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr ? "pipe" : "ignore",
      B = ix(Y, Q, {
        cwd: G,
        stdio: ["pipe", "pipe", $],
        signal: U,
        env: J,
        windowsHide: !0,
      });
    if (J.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr)
      B.stderr.on("data", (V) => {
        let W = V.toString();
        if ((k9(W), this.options.stderr)) this.options.stderr(W);
      });
    return {
      stdin: B.stdin,
      stdout: B.stdout,
      get killed() {
        return B.killed;
      },
      get exitCode() {
        return B.exitCode;
      },
      kill: B.kill.bind(B),
      on: B.on.bind(B),
      once: B.once.bind(B),
      off: B.off.bind(B),
    };
  }
  initialize() {
    try {
      let {
          additionalDirectories: X = [],
          betas: Y,
          cwd: Q,
          executable: G = this.getDefaultExecutable(),
          executableArgs: J = [],
          extraArgs: U = {},
          pathToClaudeCodeExecutable: $,
          env: B = { ...process.env },
          maxThinkingTokens: K,
          maxTurns: V,
          maxBudgetUsd: W,
          model: L,
          fallbackModel: H,
          jsonSchema: F,
          permissionMode: N,
          allowDangerouslySkipPermissions: q,
          permissionPromptToolName: M,
          continueConversation: A,
          resume: D,
          settingSources: R,
          allowedTools: z = [],
          disallowedTools: E = [],
          tools: O,
          mcpServers: Z,
          strictMcpConfig: j,
          canUseTool: w,
          includePartialMessages: I,
          plugins: T,
          sandbox: y,
        } = this.options,
        _ = [
          "--output-format",
          "stream-json",
          "--verbose",
          "--input-format",
          "stream-json",
        ];
      if (K !== void 0) _.push("--max-thinking-tokens", K.toString());
      if (V) _.push("--max-turns", V.toString());
      if (W !== void 0) _.push("--max-budget-usd", W.toString());
      if (L) _.push("--model", L);
      if (Y && Y.length > 0) _.push("--betas", Y.join(","));
      if (F) _.push("--json-schema", JSON.stringify(F));
      if (B.DEBUG_CLAUDE_AGENT_SDK) _.push("--debug-to-stderr");
      if (w) {
        if (M)
          throw Error(
            "canUseTool callback cannot be used with permissionPromptToolName. Please use one or the other."
          );
        _.push("--permission-prompt-tool", "stdio");
      } else if (M) _.push("--permission-prompt-tool", M);
      if (A) _.push("--continue");
      if (D) _.push("--resume", D);
      if (z.length > 0) _.push("--allowedTools", z.join(","));
      if (E.length > 0) _.push("--disallowedTools", E.join(","));
      if (O !== void 0)
        if (Array.isArray(O))
          if (O.length === 0) _.push("--tools", "");
          else _.push("--tools", O.join(","));
        else _.push("--tools", "default");
      if (Z && Object.keys(Z).length > 0)
        _.push("--mcp-config", JSON.stringify({ mcpServers: Z }));
      if (R) _.push("--setting-sources", R.join(","));
      if (j) _.push("--strict-mcp-config");
      if (N) _.push("--permission-mode", N);
      if (q) _.push("--allow-dangerously-skip-permissions");
      if (H) {
        if (L && H === L)
          throw Error(
            "Fallback model cannot be the same as the main model. Please specify a different model for fallbackModel option."
          );
        _.push("--fallback-model", H);
      }
      if (I) _.push("--include-partial-messages");
      for (let P of X) _.push("--add-dir", P);
      if (T && T.length > 0)
        for (let P of T)
          if (P.type === "local") _.push("--plugin-dir", P.path);
          else throw Error(`Unsupported plugin type: ${P.type}`);
      if (this.options.forkSession) _.push("--fork-session");
      if (this.options.resumeSessionAt)
        _.push("--resume-session-at", this.options.resumeSessionAt);
      if (this.options.persistSession === !1)
        _.push("--no-session-persistence");
      let f = Bu(U ?? {}, y);
      for (let [P, x] of Object.entries(f))
        if (x === null) _.push(`--${P}`);
        else _.push(`--${P}`, x);
      if (!B.CLAUDE_CODE_ENTRYPOINT) B.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
      if ((delete B.NODE_OPTIONS, B.DEBUG_CLAUDE_AGENT_SDK)) B.DEBUG = "1";
      else delete B.DEBUG;
      let l = Ku($),
        h = l ? $ : G,
        p = l ? [...J, ..._] : [...J, $, ..._],
        N0 = {
          command: h,
          args: p,
          cwd: Q,
          env: B,
          signal: this.abortController.signal,
        };
      if (this.options.spawnClaudeCodeProcess)
        (k9(`Spawning Claude Code (custom): ${h} ${p.join(" ")}`),
          (this.process = this.options.spawnClaudeCodeProcess(N0)));
      else {
        if (!J4().existsSync($)) {
          let x = l
            ? `Claude Code native binary not found at ${$}. Please ensure Claude Code is installed via native installer or specify a valid path with options.pathToClaudeCodeExecutable.`
            : `Claude Code executable not found at ${$}. Is options.pathToClaudeCodeExecutable set?`;
          throw ReferenceError(x);
        }
        (k9(`Spawning Claude Code: ${h} ${p.join(" ")}`),
          (this.process = this.spawnLocalProcess(N0)));
      }
      ((this.processStdin = this.process.stdin),
        (this.processStdout = this.process.stdout));
      let e = () => {
        if (this.process && !this.process.killed) this.process.kill("SIGTERM");
      };
      ((this.processExitHandler = e),
        (this.abortHandler = e),
        process.on("exit", this.processExitHandler),
        this.abortController.signal.addEventListener(
          "abort",
          this.abortHandler
        ),
        this.process.on("error", (P) => {
          if (((this.ready = !1), this.abortController.signal.aborted))
            this.exitError = new eX("Claude Code process aborted by user");
          else
            ((this.exitError = Error(
              `Failed to spawn Claude Code process: ${P.message}`
            )),
              k9(this.exitError.message));
        }),
        this.process.on("exit", (P, x) => {
          if (((this.ready = !1), this.abortController.signal.aborted))
            this.exitError = new eX("Claude Code process aborted by user");
          else {
            let r = this.getProcessExitError(P, x);
            if (r) ((this.exitError = r), k9(r.message));
          }
        }),
        (this.ready = !0));
    } catch (X) {
      throw ((this.ready = !1), X);
    }
  }
  getProcessExitError(X, Y) {
    if (X !== 0 && X !== null)
      return Error(`Claude Code process exited with code ${X}`);
    else if (Y) return Error(`Claude Code process terminated by signal ${Y}`);
    return;
  }
  write(X) {
    if (this.abortController.signal.aborted) throw new eX("Operation aborted");
    if (!this.ready || !this.processStdin)
      throw Error("ProcessTransport is not ready for writing");
    if (this.process?.killed || this.process?.exitCode !== null)
      throw Error("Cannot write to terminated process");
    if (this.exitError)
      throw Error(
        `Cannot write to process that exited with error: ${this.exitError.message}`
      );
    k9(`[ProcessTransport] Writing to stdin: ${X.substring(0, 100)}`);
    try {
      if (!this.processStdin.write(X))
        k9("[ProcessTransport] Write buffer full, data queued");
    } catch (Y) {
      throw (
        (this.ready = !1),
        Error(`Failed to write to process stdin: ${Y.message}`)
      );
    }
  }
  close() {
    if (this.processStdin)
      (this.processStdin.end(), (this.processStdin = void 0));
    if (this.abortHandler)
      (this.abortController.signal.removeEventListener(
        "abort",
        this.abortHandler
      ),
        (this.abortHandler = void 0));
    for (let { handler: X } of this.exitListeners) this.process?.off("exit", X);
    if (((this.exitListeners = []), this.process && !this.process.killed))
      (this.process.kill("SIGTERM"),
        setTimeout(() => {
          if (this.process && !this.process.killed)
            this.process.kill("SIGKILL");
        }, 5000));
    if (((this.ready = !1), this.processExitHandler))
      (process.off("exit", this.processExitHandler),
        (this.processExitHandler = void 0));
  }
  isReady() {
    return this.ready;
  }
  async *readMessages() {
    if (!this.processStdout)
      throw Error("ProcessTransport output stream not available");
    let X = nx({ input: this.processStdout });
    try {
      for await (let Y of X) if (Y.trim()) yield JSON.parse(Y);
      await this.waitForExit();
    } catch (Y) {
      throw Y;
    } finally {
      X.close();
    }
  }
  endInput() {
    if (this.processStdin) this.processStdin.end();
  }
  getInputStream() {
    return this.processStdin;
  }
  onExit(X) {
    if (!this.process) return () => {};
    let Y = (Q, G) => {
      let J = this.getProcessExitError(Q, G);
      X(J);
    };
    return (
      this.process.on("exit", Y),
      this.exitListeners.push({ callback: X, handler: Y }),
      () => {
        if (this.process) this.process.off("exit", Y);
        let Q = this.exitListeners.findIndex((G) => G.handler === Y);
        if (Q !== -1) this.exitListeners.splice(Q, 1);
      }
    );
  }
  async waitForExit() {
    if (!this.process) {
      if (this.exitError) throw this.exitError;
      return;
    }
    if (this.process.exitCode !== null || this.process.killed) {
      if (this.exitError) throw this.exitError;
      return;
    }
    return new Promise((X, Y) => {
      let Q = (J, U) => {
        if (this.abortController.signal.aborted) {
          Y(new eX("Operation aborted"));
          return;
        }
        let $ = this.getProcessExitError(J, U);
        if ($) Y($);
        else X();
      };
      this.process.once("exit", Q);
      let G = (J) => {
        (this.process.off("exit", Q), Y(J));
      };
      (this.process.once("error", G),
        this.process.once("exit", () => {
          this.process.off("error", G);
        }));
    });
  }
}
function Ku(X) {
  return ![".js", ".mjs", ".tsx", ".ts", ".jsx"].some((Q) => X.endsWith(Q));
}
class QO {
  returned;
  queue = [];
  readResolve;
  readReject;
  isDone = !1;
  hasError;
  started = !1;
  constructor(X) {
    this.returned = X;
  }
  [Symbol.asyncIterator]() {
    if (this.started) throw Error("Stream can only be iterated once");
    return ((this.started = !0), this);
  }
  next() {
    if (this.queue.length > 0)
      return Promise.resolve({ done: !1, value: this.queue.shift() });
    if (this.isDone) return Promise.resolve({ done: !0, value: void 0 });
    if (this.hasError) return Promise.reject(this.hasError);
    return new Promise((X, Y) => {
      ((this.readResolve = X), (this.readReject = Y));
    });
  }
  enqueue(X) {
    if (this.readResolve) {
      let Y = this.readResolve;
      ((this.readResolve = void 0),
        (this.readReject = void 0),
        Y({ done: !1, value: X }));
    } else this.queue.push(X);
  }
  done() {
    if (((this.isDone = !0), this.readResolve)) {
      let X = this.readResolve;
      ((this.readResolve = void 0),
        (this.readReject = void 0),
        X({ done: !0, value: void 0 }));
    }
  }
  error(X) {
    if (((this.hasError = X), this.readReject)) {
      let Y = this.readReject;
      ((this.readResolve = void 0), (this.readReject = void 0), Y(X));
    }
  }
  return() {
    if (((this.isDone = !0), this.returned)) this.returned();
    return Promise.resolve({ done: !0, value: void 0 });
  }
}
class GO {
  sendMcpMessage;
  isClosed = !1;
  constructor(X) {
    this.sendMcpMessage = X;
  }
  onclose;
  onerror;
  onmessage;
  async start() {}
  async send(X) {
    if (this.isClosed) throw Error("Transport is closed");
    this.sendMcpMessage(X);
  }
  async close() {
    if (this.isClosed) return;
    ((this.isClosed = !0), this.onclose?.());
  }
}
class JO {
  transport;
  isSingleUserTurn;
  canUseTool;
  hooks;
  abortController;
  jsonSchema;
  initConfig;
  pendingControlResponses = new Map();
  cleanupPerformed = !1;
  sdkMessages;
  inputStream = new QO();
  initialization;
  cancelControllers = new Map();
  hookCallbacks = new Map();
  nextCallbackId = 0;
  sdkMcpTransports = new Map();
  sdkMcpServerInstances = new Map();
  pendingMcpResponses = new Map();
  firstResultReceivedResolve;
  firstResultReceived = !1;
  hasBidirectionalNeeds() {
    return (
      this.sdkMcpTransports.size > 0 ||
      (this.hooks !== void 0 && Object.keys(this.hooks).length > 0) ||
      this.canUseTool !== void 0
    );
  }
  constructor(X, Y, Q, G, J, U = new Map(), $, B) {
    ((this.transport = X),
      (this.isSingleUserTurn = Y),
      (this.canUseTool = Q),
      (this.hooks = G),
      (this.abortController = J),
      (this.jsonSchema = $),
      (this.initConfig = B));
    for (let [K, V] of U) this.connectSdkMcpServer(K, V);
    ((this.sdkMessages = this.readSdkMessages()),
      this.readMessages(),
      (this.initialization = this.initialize()),
      this.initialization.catch(() => {}));
  }
  setError(X) {
    this.inputStream.error(X);
  }
  cleanup(X) {
    if (this.cleanupPerformed) return;
    this.cleanupPerformed = !0;
    try {
      (this.transport.close(),
        this.pendingControlResponses.clear(),
        this.pendingMcpResponses.clear(),
        this.cancelControllers.clear(),
        this.hookCallbacks.clear());
      for (let Y of this.sdkMcpTransports.values())
        try {
          Y.close();
        } catch {}
      if ((this.sdkMcpTransports.clear(), X)) this.inputStream.error(X);
      else this.inputStream.done();
    } catch (Y) {}
  }
  next(...[X]) {
    return this.sdkMessages.next(...[X]);
  }
  return(X) {
    return this.sdkMessages.return(X);
  }
  throw(X) {
    return this.sdkMessages.throw(X);
  }
  [Symbol.asyncIterator]() {
    return this.sdkMessages;
  }
  [Symbol.asyncDispose]() {
    return this.sdkMessages[Symbol.asyncDispose]();
  }
  async readMessages() {
    try {
      for await (let X of this.transport.readMessages()) {
        if (X.type === "control_response") {
          let Y = this.pendingControlResponses.get(X.response.request_id);
          if (Y) Y(X.response);
          continue;
        } else if (X.type === "control_request") {
          this.handleControlRequest(X);
          continue;
        } else if (X.type === "control_cancel_request") {
          this.handleControlCancelRequest(X);
          continue;
        } else if (X.type === "keep_alive") continue;
        if (X.type === "result") {
          if (
            ((this.firstResultReceived = !0), this.firstResultReceivedResolve)
          )
            this.firstResultReceivedResolve();
          if (this.isSingleUserTurn)
            (_4(
              "[Query.readMessages] First result received for single-turn query, closing stdin"
            ),
              this.transport.endInput());
        }
        this.inputStream.enqueue(X);
      }
      if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
      (this.inputStream.done(), this.cleanup());
    } catch (X) {
      if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
      (this.inputStream.error(X), this.cleanup(X));
    }
  }
  async handleControlRequest(X) {
    let Y = new AbortController();
    this.cancelControllers.set(X.request_id, Y);
    try {
      let Q = await this.processControlRequest(X, Y.signal),
        G = {
          type: "control_response",
          response: {
            subtype: "success",
            request_id: X.request_id,
            response: Q,
          },
        };
      await Promise.resolve(
        this.transport.write(
          JSON.stringify(G) +
            `
`
        )
      );
    } catch (Q) {
      let G = {
        type: "control_response",
        response: {
          subtype: "error",
          request_id: X.request_id,
          error: Q.message || String(Q),
        },
      };
      await Promise.resolve(
        this.transport.write(
          JSON.stringify(G) +
            `
`
        )
      );
    } finally {
      this.cancelControllers.delete(X.request_id);
    }
  }
  handleControlCancelRequest(X) {
    let Y = this.cancelControllers.get(X.request_id);
    if (Y) (Y.abort(), this.cancelControllers.delete(X.request_id));
  }
  async processControlRequest(X, Y) {
    if (X.request.subtype === "can_use_tool") {
      if (!this.canUseTool) throw Error("canUseTool callback is not provided.");
      return {
        ...(await this.canUseTool(X.request.tool_name, X.request.input, {
          signal: Y,
          suggestions: X.request.permission_suggestions,
          blockedPath: X.request.blocked_path,
          decisionReason: X.request.decision_reason,
          toolUseID: X.request.tool_use_id,
          agentID: X.request.agent_id,
        })),
        toolUseID: X.request.tool_use_id,
      };
    } else if (X.request.subtype === "hook_callback")
      return await this.handleHookCallbacks(
        X.request.callback_id,
        X.request.input,
        X.request.tool_use_id,
        Y
      );
    else if (X.request.subtype === "mcp_message") {
      let Q = X.request,
        G = this.sdkMcpTransports.get(Q.server_name);
      if (!G) throw Error(`SDK MCP server not found: ${Q.server_name}`);
      if ("method" in Q.message && "id" in Q.message && Q.message.id !== null)
        return {
          mcp_response: await this.handleMcpControlRequest(Q.server_name, Q, G),
        };
      else {
        if (G.onmessage) G.onmessage(Q.message);
        return { mcp_response: { jsonrpc: "2.0", result: {}, id: 0 } };
      }
    }
    throw Error("Unsupported control request subtype: " + X.request.subtype);
  }
  async *readSdkMessages() {
    for await (let X of this.inputStream) yield X;
  }
  async initialize() {
    let X;
    if (this.hooks) {
      X = {};
      for (let [J, U] of Object.entries(this.hooks))
        if (U.length > 0)
          X[J] = U.map(($) => {
            let B = [];
            for (let K of $.hooks) {
              let V = `hook_${this.nextCallbackId++}`;
              (this.hookCallbacks.set(V, K), B.push(V));
            }
            return {
              matcher: $.matcher,
              hookCallbackIds: B,
              timeout: $.timeout,
            };
          });
    }
    let Y =
        this.sdkMcpTransports.size > 0
          ? Array.from(this.sdkMcpTransports.keys())
          : void 0,
      Q = {
        subtype: "initialize",
        hooks: X,
        sdkMcpServers: Y,
        jsonSchema: this.jsonSchema,
        systemPrompt: this.initConfig?.systemPrompt,
        appendSystemPrompt: this.initConfig?.appendSystemPrompt,
        agents: this.initConfig?.agents,
      };
    return (await this.request(Q)).response;
  }
  async interrupt() {
    await this.request({ subtype: "interrupt" });
  }
  async setPermissionMode(X) {
    await this.request({ subtype: "set_permission_mode", mode: X });
  }
  async setModel(X) {
    await this.request({ subtype: "set_model", model: X });
  }
  async setMaxThinkingTokens(X) {
    await this.request({
      subtype: "set_max_thinking_tokens",
      max_thinking_tokens: X,
    });
  }
  async rewindFiles(X) {
    await this.request({ subtype: "rewind_files", user_message_id: X });
  }
  async processPendingPermissionRequests(X) {
    for (let Y of X)
      if (Y.request.subtype === "can_use_tool")
        this.handleControlRequest(Y).catch(() => {});
  }
  request(X) {
    let Y = Math.random().toString(36).substring(2, 15),
      Q = { request_id: Y, type: "control_request", request: X };
    return new Promise((G, J) => {
      (this.pendingControlResponses.set(Y, (U) => {
        if (U.subtype === "success") G(U);
        else if ((J(Error(U.error)), U.pending_permission_requests))
          this.processPendingPermissionRequests(U.pending_permission_requests);
      }),
        Promise.resolve(
          this.transport.write(
            JSON.stringify(Q) +
              `
`
          )
        ));
    });
  }
  async supportedCommands() {
    return (await this.initialization).commands;
  }
  async supportedModels() {
    return (await this.initialization).models;
  }
  async mcpServerStatus() {
    return (await this.request({ subtype: "mcp_status" })).response.mcpServers;
  }
  async setMcpServers(X) {
    let Y = {},
      Q = {};
    for (let [B, K] of Object.entries(X))
      if (K.type === "sdk" && "instance" in K) Y[B] = K.instance;
      else Q[B] = K;
    let G = new Set(this.sdkMcpServerInstances.keys()),
      J = new Set(Object.keys(Y));
    for (let B of G) if (!J.has(B)) await this.disconnectSdkMcpServer(B);
    for (let [B, K] of Object.entries(Y))
      if (!G.has(B)) this.connectSdkMcpServer(B, K);
    let U = {};
    for (let B of Object.keys(Y)) U[B] = { type: "sdk", name: B };
    return (
      await this.request({
        subtype: "mcp_set_servers",
        servers: { ...Q, ...U },
      })
    ).response;
  }
  async accountInfo() {
    return (await this.initialization).account;
  }
  async streamInput(X) {
    _4("[Query.streamInput] Starting to process input stream");
    try {
      let Y = 0;
      for await (let Q of X) {
        if (
          (Y++,
          _4(`[Query.streamInput] Processing message ${Y}: ${Q.type}`),
          this.abortController?.signal.aborted)
        )
          break;
        await Promise.resolve(
          this.transport.write(
            JSON.stringify(Q) +
              `
`
          )
        );
      }
      if (
        (_4(
          `[Query.streamInput] Finished processing ${Y} messages from input stream`
        ),
        this.hasBidirectionalNeeds())
      )
        (_4(
          "[Query.streamInput] Has bidirectional needs, waiting for first result"
        ),
          await this.waitForFirstResult());
      (_4("[Query] Calling transport.endInput() to close stdin to CLI process"),
        this.transport.endInput());
    } catch (Y) {
      if (!(Y instanceof eX)) throw Y;
    }
  }
  waitForFirstResult() {
    if (this.firstResultReceived)
      return (
        _4(
          "[Query.waitForFirstResult] Result already received, returning immediately"
        ),
        Promise.resolve()
      );
    return new Promise((X) => {
      if (this.abortController?.signal.aborted) {
        X();
        return;
      }
      (this.abortController?.signal.addEventListener("abort", () => X(), {
        once: !0,
      }),
        (this.firstResultReceivedResolve = X));
    });
  }
  handleHookCallbacks(X, Y, Q, G) {
    let J = this.hookCallbacks.get(X);
    if (!J) throw Error(`No hook callback found for ID: ${X}`);
    return J(Y, Q, { signal: G });
  }
  connectSdkMcpServer(X, Y) {
    let Q = new GO((G) => this.sendMcpServerMessageToCli(X, G));
    (this.sdkMcpTransports.set(X, Q),
      this.sdkMcpServerInstances.set(X, Y),
      Y.connect(Q));
  }
  async disconnectSdkMcpServer(X) {
    let Y = this.sdkMcpTransports.get(X);
    if (Y) (await Y.close(), this.sdkMcpTransports.delete(X));
    this.sdkMcpServerInstances.delete(X);
  }
  sendMcpServerMessageToCli(X, Y) {
    if ("id" in Y && Y.id !== null && Y.id !== void 0) {
      let G = `${X}:${Y.id}`,
        J = this.pendingMcpResponses.get(G);
      if (J) {
        (J.resolve(Y), this.pendingMcpResponses.delete(G));
        return;
      }
    }
    let Q = {
      type: "control_request",
      request_id: Vu(),
      request: { subtype: "mcp_message", server_name: X, message: Y },
    };
    this.transport.write(
      JSON.stringify(Q) +
        `
`
    );
  }
  handleMcpControlRequest(X, Y, Q) {
    let G = "id" in Y.message ? Y.message.id : null,
      J = `${X}:${G}`;
    return new Promise((U, $) => {
      let B = () => {
          this.pendingMcpResponses.delete(J);
        },
        K = (W) => {
          (B(), U(W));
        },
        V = (W) => {
          (B(), $(W));
        };
      if (
        (this.pendingMcpResponses.set(J, { resolve: K, reject: V }),
        Q.onmessage)
      )
        Q.onmessage(Y.message);
      else {
        (B(), $(Error("No message handler registered")));
        return;
      }
    });
  }
}
var x1;
(function (X) {
  X.assertEqual = (J) => {};
  function Y(J) {}
  X.assertIs = Y;
  function Q(J) {
    throw Error();
  }
  ((X.assertNever = Q),
    (X.arrayToEnum = (J) => {
      let U = {};
      for (let $ of J) U[$] = $;
      return U;
    }),
    (X.getValidEnumValues = (J) => {
      let U = X.objectKeys(J).filter((B) => typeof J[J[B]] !== "number"),
        $ = {};
      for (let B of U) $[B] = J[B];
      return X.objectValues($);
    }),
    (X.objectValues = (J) => {
      return X.objectKeys(J).map(function (U) {
        return J[U];
      });
    }),
    (X.objectKeys =
      typeof Object.keys === "function"
        ? (J) => Object.keys(J)
        : (J) => {
            let U = [];
            for (let $ in J)
              if (Object.prototype.hasOwnProperty.call(J, $)) U.push($);
            return U;
          }),
    (X.find = (J, U) => {
      for (let $ of J) if (U($)) return $;
      return;
    }),
    (X.isInteger =
      typeof Number.isInteger === "function"
        ? (J) => Number.isInteger(J)
        : (J) =>
            typeof J === "number" &&
            Number.isFinite(J) &&
            Math.floor(J) === J));
  function G(J, U = " | ") {
    return J.map(($) => (typeof $ === "string" ? `'${$}'` : $)).join(U);
  }
  ((X.joinValues = G),
    (X.jsonStringifyReplacer = (J, U) => {
      if (typeof U === "bigint") return U.toString();
      return U;
    }));
})(x1 || (x1 = {}));
var LE;
(function (X) {
  X.mergeShapes = (Y, Q) => {
    return { ...Y, ...Q };
  };
})(LE || (LE = {}));
var y0 = x1.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  f4 = (X) => {
    switch (typeof X) {
      case "undefined":
        return y0.undefined;
      case "string":
        return y0.string;
      case "number":
        return Number.isNaN(X) ? y0.nan : y0.number;
      case "boolean":
        return y0.boolean;
      case "function":
        return y0.function;
      case "bigint":
        return y0.bigint;
      case "symbol":
        return y0.symbol;
      case "object":
        if (Array.isArray(X)) return y0.array;
        if (X === null) return y0.null;
        if (
          X.then &&
          typeof X.then === "function" &&
          X.catch &&
          typeof X.catch === "function"
        )
          return y0.promise;
        if (typeof Map < "u" && X instanceof Map) return y0.map;
        if (typeof Set < "u" && X instanceof Set) return y0.set;
        if (typeof Date < "u" && X instanceof Date) return y0.date;
        return y0.object;
      default:
        return y0.unknown;
    }
  },
  O0 = x1.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]);
class S8 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(X) {
    super();
    ((this.issues = []),
      (this.addIssue = (Q) => {
        this.issues = [...this.issues, Q];
      }),
      (this.addIssues = (Q = []) => {
        this.issues = [...this.issues, ...Q];
      }));
    let Y = new.target.prototype;
    if (Object.setPrototypeOf) Object.setPrototypeOf(this, Y);
    else this.__proto__ = Y;
    ((this.name = "ZodError"), (this.issues = X));
  }
  format(X) {
    let Y =
        X ||
        function (J) {
          return J.message;
        },
      Q = { _errors: [] },
      G = (J) => {
        for (let U of J.issues)
          if (U.code === "invalid_union") U.unionErrors.map(G);
          else if (U.code === "invalid_return_type") G(U.returnTypeError);
          else if (U.code === "invalid_arguments") G(U.argumentsError);
          else if (U.path.length === 0) Q._errors.push(Y(U));
          else {
            let $ = Q,
              B = 0;
            while (B < U.path.length) {
              let K = U.path[B];
              if (B !== U.path.length - 1) $[K] = $[K] || { _errors: [] };
              else (($[K] = $[K] || { _errors: [] }), $[K]._errors.push(Y(U)));
              (($ = $[K]), B++);
            }
          }
      };
    return (G(this), Q);
  }
  static assert(X) {
    if (!(X instanceof S8)) throw Error(`Not a ZodError: ${X}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, x1.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(X = (Y) => Y.message) {
    let Y = {},
      Q = [];
    for (let G of this.issues)
      if (G.path.length > 0) {
        let J = G.path[0];
        ((Y[J] = Y[J] || []), Y[J].push(X(G)));
      } else Q.push(X(G));
    return { formErrors: Q, fieldErrors: Y };
  }
  get formErrors() {
    return this.flatten();
  }
}
S8.create = (X) => {
  return new S8(X);
};
var Fu = (X, Y) => {
    let Q;
    switch (X.code) {
      case O0.invalid_type:
        if (X.received === y0.undefined) Q = "Required";
        else Q = `Expected ${X.expected}, received ${X.received}`;
        break;
      case O0.invalid_literal:
        Q = `Invalid literal value, expected ${JSON.stringify(X.expected, x1.jsonStringifyReplacer)}`;
        break;
      case O0.unrecognized_keys:
        Q = `Unrecognized key(s) in object: ${x1.joinValues(X.keys, ", ")}`;
        break;
      case O0.invalid_union:
        Q = "Invalid input";
        break;
      case O0.invalid_union_discriminator:
        Q = `Invalid discriminator value. Expected ${x1.joinValues(X.options)}`;
        break;
      case O0.invalid_enum_value:
        Q = `Invalid enum value. Expected ${x1.joinValues(X.options)}, received '${X.received}'`;
        break;
      case O0.invalid_arguments:
        Q = "Invalid function arguments";
        break;
      case O0.invalid_return_type:
        Q = "Invalid function return type";
        break;
      case O0.invalid_date:
        Q = "Invalid date";
        break;
      case O0.invalid_string:
        if (typeof X.validation === "object")
          if ("includes" in X.validation) {
            if (
              ((Q = `Invalid input: must include "${X.validation.includes}"`),
              typeof X.validation.position === "number")
            )
              Q = `${Q} at one or more positions greater than or equal to ${X.validation.position}`;
          } else if ("startsWith" in X.validation)
            Q = `Invalid input: must start with "${X.validation.startsWith}"`;
          else if ("endsWith" in X.validation)
            Q = `Invalid input: must end with "${X.validation.endsWith}"`;
          else x1.assertNever(X.validation);
        else if (X.validation !== "regex") Q = `Invalid ${X.validation}`;
        else Q = "Invalid";
        break;
      case O0.too_small:
        if (X.type === "array")
          Q = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "more than"} ${X.minimum} element(s)`;
        else if (X.type === "string")
          Q = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "over"} ${X.minimum} character(s)`;
        else if (X.type === "number")
          Q = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
        else if (X.type === "bigint")
          Q = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
        else if (X.type === "date")
          Q = `Date must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(X.minimum))}`;
        else Q = "Invalid input";
        break;
      case O0.too_big:
        if (X.type === "array")
          Q = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "less than"} ${X.maximum} element(s)`;
        else if (X.type === "string")
          Q = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "under"} ${X.maximum} character(s)`;
        else if (X.type === "number")
          Q = `Number must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
        else if (X.type === "bigint")
          Q = `BigInt must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
        else if (X.type === "date")
          Q = `Date must be ${X.exact ? "exactly" : X.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(X.maximum))}`;
        else Q = "Invalid input";
        break;
      case O0.custom:
        Q = "Invalid input";
        break;
      case O0.invalid_intersection_types:
        Q = "Intersection results could not be merged";
        break;
      case O0.not_multiple_of:
        Q = `Number must be a multiple of ${X.multipleOf}`;
        break;
      case O0.not_finite:
        Q = "Number must be finite";
        break;
      default:
        ((Q = Y.defaultError), x1.assertNever(X));
    }
    return { message: Q };
  },
  _Y = Fu,
  Nu = _Y;
function PU() {
  return Nu;
}
var SU = (X) => {
  let { data: Y, path: Q, errorMaps: G, issueData: J } = X,
    U = [...Q, ...(J.path || [])],
    $ = { ...J, path: U };
  if (J.message !== void 0) return { ...J, path: U, message: J.message };
  let B = "",
    K = G.filter((V) => !!V)
      .slice()
      .reverse();
  for (let V of K) B = V($, { data: Y, defaultError: B }).message;
  return { ...J, path: U, message: B };
};
function v0(X, Y) {
  let Q = PU(),
    G = SU({
      issueData: Y,
      data: X.data,
      path: X.path,
      errorMaps: [
        X.common.contextualErrorMap,
        X.schemaErrorMap,
        Q,
        Q === _Y ? void 0 : _Y,
      ].filter((J) => !!J),
    });
  X.common.issues.push(G);
}
class J8 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray(X, Y) {
    let Q = [];
    for (let G of Y) {
      if (G.status === "aborted") return e0;
      if (G.status === "dirty") X.dirty();
      Q.push(G.value);
    }
    return { status: X.value, value: Q };
  }
  static async mergeObjectAsync(X, Y) {
    let Q = [];
    for (let G of Y) {
      let J = await G.key,
        U = await G.value;
      Q.push({ key: J, value: U });
    }
    return J8.mergeObjectSync(X, Q);
  }
  static mergeObjectSync(X, Y) {
    let Q = {};
    for (let G of Y) {
      let { key: J, value: U } = G;
      if (J.status === "aborted") return e0;
      if (U.status === "aborted") return e0;
      if (J.status === "dirty") X.dirty();
      if (U.status === "dirty") X.dirty();
      if (J.value !== "__proto__" && (typeof U.value < "u" || G.alwaysSet))
        Q[J.value] = U.value;
    }
    return { status: X.value, value: Q };
  }
}
var e0 = Object.freeze({ status: "aborted" }),
  bY = (X) => ({ status: "dirty", value: X }),
  L8 = (X) => ({ status: "valid", value: X }),
  BE = (X) => X.status === "aborted",
  KE = (X) => X.status === "dirty",
  Y7 = (X) => X.status === "valid",
  iG = (X) => typeof Promise < "u" && X instanceof Promise,
  u0;
(function (X) {
  ((X.errToObj = (Y) => (typeof Y === "string" ? { message: Y } : Y || {})),
    (X.toString = (Y) => (typeof Y === "string" ? Y : Y?.message)));
})(u0 || (u0 = {}));
class m8 {
  constructor(X, Y, Q, G) {
    ((this._cachedPath = []),
      (this.parent = X),
      (this.data = Y),
      (this._path = Q),
      (this._key = G));
  }
  get path() {
    if (!this._cachedPath.length)
      if (Array.isArray(this._key))
        this._cachedPath.push(...this._path, ...this._key);
      else this._cachedPath.push(...this._path, this._key);
    return this._cachedPath;
  }
}
var VE = (X, Y) => {
  if (Y7(Y)) return { success: !0, data: Y.value };
  else {
    if (!X.common.issues.length)
      throw Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error) return this._error;
        let Q = new S8(X.common.issues);
        return ((this._error = Q), this._error);
      },
    };
  }
};
function L1(X) {
  if (!X) return {};
  let {
    errorMap: Y,
    invalid_type_error: Q,
    required_error: G,
    description: J,
  } = X;
  if (Y && (Q || G))
    throw Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    );
  if (Y) return { errorMap: Y, description: J };
  return {
    errorMap: ($, B) => {
      let { message: K } = X;
      if ($.code === "invalid_enum_value")
        return { message: K ?? B.defaultError };
      if (typeof B.data > "u") return { message: K ?? G ?? B.defaultError };
      if ($.code !== "invalid_type") return { message: B.defaultError };
      return { message: K ?? Q ?? B.defaultError };
    },
    description: J,
  };
}
class O1 {
  get description() {
    return this._def.description;
  }
  _getType(X) {
    return f4(X.data);
  }
  _getOrReturnCtx(X, Y) {
    return (
      Y || {
        common: X.parent.common,
        data: X.data,
        parsedType: f4(X.data),
        schemaErrorMap: this._def.errorMap,
        path: X.path,
        parent: X.parent,
      }
    );
  }
  _processInputParams(X) {
    return {
      status: new J8(),
      ctx: {
        common: X.parent.common,
        data: X.data,
        parsedType: f4(X.data),
        schemaErrorMap: this._def.errorMap,
        path: X.path,
        parent: X.parent,
      },
    };
  }
  _parseSync(X) {
    let Y = this._parse(X);
    if (iG(Y)) throw Error("Synchronous parse encountered promise.");
    return Y;
  }
  _parseAsync(X) {
    let Y = this._parse(X);
    return Promise.resolve(Y);
  }
  parse(X, Y) {
    let Q = this.safeParse(X, Y);
    if (Q.success) return Q.data;
    throw Q.error;
  }
  safeParse(X, Y) {
    let Q = {
        common: {
          issues: [],
          async: Y?.async ?? !1,
          contextualErrorMap: Y?.errorMap,
        },
        path: Y?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: X,
        parsedType: f4(X),
      },
      G = this._parseSync({ data: X, path: Q.path, parent: Q });
    return VE(Q, G);
  }
  "~validate"(X) {
    let Y = {
      common: { issues: [], async: !!this["~standard"].async },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: X,
      parsedType: f4(X),
    };
    if (!this["~standard"].async)
      try {
        let Q = this._parseSync({ data: X, path: [], parent: Y });
        return Y7(Q) ? { value: Q.value } : { issues: Y.common.issues };
      } catch (Q) {
        if (Q?.message?.toLowerCase()?.includes("encountered"))
          this["~standard"].async = !0;
        Y.common = { issues: [], async: !0 };
      }
    return this._parseAsync({ data: X, path: [], parent: Y }).then((Q) =>
      Y7(Q) ? { value: Q.value } : { issues: Y.common.issues }
    );
  }
  async parseAsync(X, Y) {
    let Q = await this.safeParseAsync(X, Y);
    if (Q.success) return Q.data;
    throw Q.error;
  }
  async safeParseAsync(X, Y) {
    let Q = {
        common: { issues: [], contextualErrorMap: Y?.errorMap, async: !0 },
        path: Y?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: X,
        parsedType: f4(X),
      },
      G = this._parse({ data: X, path: Q.path, parent: Q }),
      J = await (iG(G) ? G : Promise.resolve(G));
    return VE(Q, J);
  }
  refine(X, Y) {
    let Q = (G) => {
      if (typeof Y === "string" || typeof Y > "u") return { message: Y };
      else if (typeof Y === "function") return Y(G);
      else return Y;
    };
    return this._refinement((G, J) => {
      let U = X(G),
        $ = () => J.addIssue({ code: O0.custom, ...Q(G) });
      if (typeof Promise < "u" && U instanceof Promise)
        return U.then((B) => {
          if (!B) return ($(), !1);
          else return !0;
        });
      if (!U) return ($(), !1);
      else return !0;
    });
  }
  refinement(X, Y) {
    return this._refinement((Q, G) => {
      if (!X(Q)) return (G.addIssue(typeof Y === "function" ? Y(Q, G) : Y), !1);
      else return !0;
    });
  }
  _refinement(X) {
    return new B6({
      schema: this,
      typeName: X1.ZodEffects,
      effect: { type: "refinement", refinement: X },
    });
  }
  superRefine(X) {
    return this._refinement(X);
  }
  constructor(X) {
    ((this.spa = this.safeParseAsync),
      (this._def = X),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this)),
      (this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (Y) => this["~validate"](Y),
      }));
  }
  optional() {
    return U6.create(this, this._def);
  }
  nullable() {
    return h4.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return $6.create(this);
  }
  promise() {
    return W7.create(this, this._def);
  }
  or(X) {
    return gY.create([this, X], this._def);
  }
  and(X) {
    return uY.create(this, X, this._def);
  }
  transform(X) {
    return new B6({
      ...L1(this._def),
      schema: this,
      typeName: X1.ZodEffects,
      effect: { type: "transform", transform: X },
    });
  }
  default(X) {
    let Y = typeof X === "function" ? X : () => X;
    return new dY({
      ...L1(this._def),
      innerType: this,
      defaultValue: Y,
      typeName: X1.ZodDefault,
    });
  }
  brand() {
    return new pU({ typeName: X1.ZodBranded, type: this, ...L1(this._def) });
  }
  catch(X) {
    let Y = typeof X === "function" ? X : () => X;
    return new pY({
      ...L1(this._def),
      innerType: this,
      catchValue: Y,
      typeName: X1.ZodCatch,
    });
  }
  describe(X) {
    return new this.constructor({ ...this._def, description: X });
  }
  pipe(X) {
    return FJ.create(this, X);
  }
  readonly() {
    return iY.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var Mu = /^c[^\s-]{8,}$/i,
  Au = /^[0-9a-z]+$/,
  qu = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
  Ru =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  Du = /^[a-z0-9_-]{21}$/i,
  zu = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  Eu =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  Ou =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  Zu = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  ZU,
  ju =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  wu =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  Cu =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  Iu =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  Pu = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  Su = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  WO =
    "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  Tu = new RegExp(`^${WO}$`);
function HO(X) {
  let Y = "[0-5]\\d";
  if (X.precision) Y = `${Y}\\.\\d{${X.precision}}`;
  else if (X.precision == null) Y = `${Y}(\\.\\d+)?`;
  let Q = X.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${Y})${Q}`;
}
function bu(X) {
  return new RegExp(`^${HO(X)}$`);
}
function vu(X) {
  let Y = `${WO}T${HO(X)}`,
    Q = [];
  if ((Q.push(X.local ? "Z?" : "Z"), X.offset)) Q.push("([+-]\\d{2}:?\\d{2})");
  return ((Y = `${Y}(${Q.join("|")})`), new RegExp(`^${Y}$`));
}
function ku(X, Y) {
  if ((Y === "v4" || !Y) && ju.test(X)) return !0;
  if ((Y === "v6" || !Y) && Cu.test(X)) return !0;
  return !1;
}
function yu(X, Y) {
  if (!zu.test(X)) return !1;
  try {
    let [Q] = X.split(".");
    if (!Q) return !1;
    let G = Q.replace(/-/g, "+")
        .replace(/_/g, "/")
        .padEnd(Q.length + ((4 - (Q.length % 4)) % 4), "="),
      J = JSON.parse(atob(G));
    if (typeof J !== "object" || J === null) return !1;
    if ("typ" in J && J?.typ !== "JWT") return !1;
    if (!J.alg) return !1;
    if (Y && J.alg !== Y) return !1;
    return !0;
  } catch {
    return !1;
  }
}
function _u(X, Y) {
  if ((Y === "v4" || !Y) && wu.test(X)) return !0;
  if ((Y === "v6" || !Y) && Iu.test(X)) return !0;
  return !1;
}
class W4 extends O1 {
  _parse(X) {
    if (this._def.coerce) X.data = String(X.data);
    if (this._getType(X) !== y0.string) {
      let J = this._getOrReturnCtx(X);
      return (
        v0(J, {
          code: O0.invalid_type,
          expected: y0.string,
          received: J.parsedType,
        }),
        e0
      );
    }
    let Q = new J8(),
      G = void 0;
    for (let J of this._def.checks)
      if (J.kind === "min") {
        if (X.data.length < J.value)
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              code: O0.too_small,
              minimum: J.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "max") {
        if (X.data.length > J.value)
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              code: O0.too_big,
              maximum: J.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "length") {
        let U = X.data.length > J.value,
          $ = X.data.length < J.value;
        if (U || $) {
          if (((G = this._getOrReturnCtx(X, G)), U))
            v0(G, {
              code: O0.too_big,
              maximum: J.value,
              type: "string",
              inclusive: !0,
              exact: !0,
              message: J.message,
            });
          else if ($)
            v0(G, {
              code: O0.too_small,
              minimum: J.value,
              type: "string",
              inclusive: !0,
              exact: !0,
              message: J.message,
            });
          Q.dirty();
        }
      } else if (J.kind === "email") {
        if (!Ou.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "email",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "emoji") {
        if (!ZU) ZU = new RegExp(Zu, "u");
        if (!ZU.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "emoji",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "uuid") {
        if (!Ru.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "uuid",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "nanoid") {
        if (!Du.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "nanoid",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "cuid") {
        if (!Mu.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "cuid",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "cuid2") {
        if (!Au.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "cuid2",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "ulid") {
        if (!qu.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "ulid",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "url")
        try {
          new URL(X.data);
        } catch {
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "url",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
        }
      else if (J.kind === "regex") {
        if (((J.regex.lastIndex = 0), !J.regex.test(X.data)))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "regex",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "trim") X.data = X.data.trim();
      else if (J.kind === "includes") {
        if (!X.data.includes(J.value, J.position))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              code: O0.invalid_string,
              validation: { includes: J.value, position: J.position },
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "toLowerCase") X.data = X.data.toLowerCase();
      else if (J.kind === "toUpperCase") X.data = X.data.toUpperCase();
      else if (J.kind === "startsWith") {
        if (!X.data.startsWith(J.value))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              code: O0.invalid_string,
              validation: { startsWith: J.value },
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "endsWith") {
        if (!X.data.endsWith(J.value))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              code: O0.invalid_string,
              validation: { endsWith: J.value },
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "datetime") {
        if (!vu(J).test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              code: O0.invalid_string,
              validation: "datetime",
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "date") {
        if (!Tu.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              code: O0.invalid_string,
              validation: "date",
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "time") {
        if (!bu(J).test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              code: O0.invalid_string,
              validation: "time",
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "duration") {
        if (!Eu.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "duration",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "ip") {
        if (!ku(X.data, J.version))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "ip",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "jwt") {
        if (!yu(X.data, J.alg))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "jwt",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "cidr") {
        if (!_u(X.data, J.version))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "cidr",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "base64") {
        if (!Pu.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "base64",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else if (J.kind === "base64url") {
        if (!Su.test(X.data))
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              validation: "base64url",
              code: O0.invalid_string,
              message: J.message,
            }),
            Q.dirty());
      } else x1.assertNever(J);
    return { status: Q.value, value: X.data };
  }
  _regex(X, Y, Q) {
    return this.refinement((G) => X.test(G), {
      validation: Y,
      code: O0.invalid_string,
      ...u0.errToObj(Q),
    });
  }
  _addCheck(X) {
    return new W4({ ...this._def, checks: [...this._def.checks, X] });
  }
  email(X) {
    return this._addCheck({ kind: "email", ...u0.errToObj(X) });
  }
  url(X) {
    return this._addCheck({ kind: "url", ...u0.errToObj(X) });
  }
  emoji(X) {
    return this._addCheck({ kind: "emoji", ...u0.errToObj(X) });
  }
  uuid(X) {
    return this._addCheck({ kind: "uuid", ...u0.errToObj(X) });
  }
  nanoid(X) {
    return this._addCheck({ kind: "nanoid", ...u0.errToObj(X) });
  }
  cuid(X) {
    return this._addCheck({ kind: "cuid", ...u0.errToObj(X) });
  }
  cuid2(X) {
    return this._addCheck({ kind: "cuid2", ...u0.errToObj(X) });
  }
  ulid(X) {
    return this._addCheck({ kind: "ulid", ...u0.errToObj(X) });
  }
  base64(X) {
    return this._addCheck({ kind: "base64", ...u0.errToObj(X) });
  }
  base64url(X) {
    return this._addCheck({ kind: "base64url", ...u0.errToObj(X) });
  }
  jwt(X) {
    return this._addCheck({ kind: "jwt", ...u0.errToObj(X) });
  }
  ip(X) {
    return this._addCheck({ kind: "ip", ...u0.errToObj(X) });
  }
  cidr(X) {
    return this._addCheck({ kind: "cidr", ...u0.errToObj(X) });
  }
  datetime(X) {
    if (typeof X === "string")
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: X,
      });
    return this._addCheck({
      kind: "datetime",
      precision: typeof X?.precision > "u" ? null : X?.precision,
      offset: X?.offset ?? !1,
      local: X?.local ?? !1,
      ...u0.errToObj(X?.message),
    });
  }
  date(X) {
    return this._addCheck({ kind: "date", message: X });
  }
  time(X) {
    if (typeof X === "string")
      return this._addCheck({ kind: "time", precision: null, message: X });
    return this._addCheck({
      kind: "time",
      precision: typeof X?.precision > "u" ? null : X?.precision,
      ...u0.errToObj(X?.message),
    });
  }
  duration(X) {
    return this._addCheck({ kind: "duration", ...u0.errToObj(X) });
  }
  regex(X, Y) {
    return this._addCheck({ kind: "regex", regex: X, ...u0.errToObj(Y) });
  }
  includes(X, Y) {
    return this._addCheck({
      kind: "includes",
      value: X,
      position: Y?.position,
      ...u0.errToObj(Y?.message),
    });
  }
  startsWith(X, Y) {
    return this._addCheck({ kind: "startsWith", value: X, ...u0.errToObj(Y) });
  }
  endsWith(X, Y) {
    return this._addCheck({ kind: "endsWith", value: X, ...u0.errToObj(Y) });
  }
  min(X, Y) {
    return this._addCheck({ kind: "min", value: X, ...u0.errToObj(Y) });
  }
  max(X, Y) {
    return this._addCheck({ kind: "max", value: X, ...u0.errToObj(Y) });
  }
  length(X, Y) {
    return this._addCheck({ kind: "length", value: X, ...u0.errToObj(Y) });
  }
  nonempty(X) {
    return this.min(1, u0.errToObj(X));
  }
  trim() {
    return new W4({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    });
  }
  toLowerCase() {
    return new W4({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    });
  }
  toUpperCase() {
    return new W4({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((X) => X.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((X) => X.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((X) => X.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((X) => X.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((X) => X.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((X) => X.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((X) => X.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((X) => X.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((X) => X.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((X) => X.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((X) => X.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((X) => X.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((X) => X.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((X) => X.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((X) => X.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((X) => X.kind === "base64url");
  }
  get minLength() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "min") {
        if (X === null || Y.value > X) X = Y.value;
      }
    return X;
  }
  get maxLength() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "max") {
        if (X === null || Y.value < X) X = Y.value;
      }
    return X;
  }
}
W4.create = (X) => {
  return new W4({
    checks: [],
    typeName: X1.ZodString,
    coerce: X?.coerce ?? !1,
    ...L1(X),
  });
};
function fu(X, Y) {
  let Q = (X.toString().split(".")[1] || "").length,
    G = (Y.toString().split(".")[1] || "").length,
    J = Q > G ? Q : G,
    U = Number.parseInt(X.toFixed(J).replace(".", "")),
    $ = Number.parseInt(Y.toFixed(J).replace(".", ""));
  return (U % $) / 10 ** J;
}
class Q7 extends O1 {
  constructor() {
    super(...arguments);
    ((this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf));
  }
  _parse(X) {
    if (this._def.coerce) X.data = Number(X.data);
    if (this._getType(X) !== y0.number) {
      let J = this._getOrReturnCtx(X);
      return (
        v0(J, {
          code: O0.invalid_type,
          expected: y0.number,
          received: J.parsedType,
        }),
        e0
      );
    }
    let Q = void 0,
      G = new J8();
    for (let J of this._def.checks)
      if (J.kind === "int") {
        if (!x1.isInteger(X.data))
          ((Q = this._getOrReturnCtx(X, Q)),
            v0(Q, {
              code: O0.invalid_type,
              expected: "integer",
              received: "float",
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "min") {
        if (J.inclusive ? X.data < J.value : X.data <= J.value)
          ((Q = this._getOrReturnCtx(X, Q)),
            v0(Q, {
              code: O0.too_small,
              minimum: J.value,
              type: "number",
              inclusive: J.inclusive,
              exact: !1,
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "max") {
        if (J.inclusive ? X.data > J.value : X.data >= J.value)
          ((Q = this._getOrReturnCtx(X, Q)),
            v0(Q, {
              code: O0.too_big,
              maximum: J.value,
              type: "number",
              inclusive: J.inclusive,
              exact: !1,
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "multipleOf") {
        if (fu(X.data, J.value) !== 0)
          ((Q = this._getOrReturnCtx(X, Q)),
            v0(Q, {
              code: O0.not_multiple_of,
              multipleOf: J.value,
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "finite") {
        if (!Number.isFinite(X.data))
          ((Q = this._getOrReturnCtx(X, Q)),
            v0(Q, { code: O0.not_finite, message: J.message }),
            G.dirty());
      } else x1.assertNever(J);
    return { status: G.value, value: X.data };
  }
  gte(X, Y) {
    return this.setLimit("min", X, !0, u0.toString(Y));
  }
  gt(X, Y) {
    return this.setLimit("min", X, !1, u0.toString(Y));
  }
  lte(X, Y) {
    return this.setLimit("max", X, !0, u0.toString(Y));
  }
  lt(X, Y) {
    return this.setLimit("max", X, !1, u0.toString(Y));
  }
  setLimit(X, Y, Q, G) {
    return new Q7({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: X, value: Y, inclusive: Q, message: u0.toString(G) },
      ],
    });
  }
  _addCheck(X) {
    return new Q7({ ...this._def, checks: [...this._def.checks, X] });
  }
  int(X) {
    return this._addCheck({ kind: "int", message: u0.toString(X) });
  }
  positive(X) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: u0.toString(X),
    });
  }
  negative(X) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: u0.toString(X),
    });
  }
  nonpositive(X) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: u0.toString(X),
    });
  }
  nonnegative(X) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: u0.toString(X),
    });
  }
  multipleOf(X, Y) {
    return this._addCheck({
      kind: "multipleOf",
      value: X,
      message: u0.toString(Y),
    });
  }
  finite(X) {
    return this._addCheck({ kind: "finite", message: u0.toString(X) });
  }
  safe(X) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: u0.toString(X),
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: u0.toString(X),
    });
  }
  get minValue() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "min") {
        if (X === null || Y.value > X) X = Y.value;
      }
    return X;
  }
  get maxValue() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "max") {
        if (X === null || Y.value < X) X = Y.value;
      }
    return X;
  }
  get isInt() {
    return !!this._def.checks.find(
      (X) =>
        X.kind === "int" || (X.kind === "multipleOf" && x1.isInteger(X.value))
    );
  }
  get isFinite() {
    let X = null,
      Y = null;
    for (let Q of this._def.checks)
      if (Q.kind === "finite" || Q.kind === "int" || Q.kind === "multipleOf")
        return !0;
      else if (Q.kind === "min") {
        if (Y === null || Q.value > Y) Y = Q.value;
      } else if (Q.kind === "max") {
        if (X === null || Q.value < X) X = Q.value;
      }
    return Number.isFinite(Y) && Number.isFinite(X);
  }
}
Q7.create = (X) => {
  return new Q7({
    checks: [],
    typeName: X1.ZodNumber,
    coerce: X?.coerce || !1,
    ...L1(X),
  });
};
class G7 extends O1 {
  constructor() {
    super(...arguments);
    ((this.min = this.gte), (this.max = this.lte));
  }
  _parse(X) {
    if (this._def.coerce)
      try {
        X.data = BigInt(X.data);
      } catch {
        return this._getInvalidInput(X);
      }
    if (this._getType(X) !== y0.bigint) return this._getInvalidInput(X);
    let Q = void 0,
      G = new J8();
    for (let J of this._def.checks)
      if (J.kind === "min") {
        if (J.inclusive ? X.data < J.value : X.data <= J.value)
          ((Q = this._getOrReturnCtx(X, Q)),
            v0(Q, {
              code: O0.too_small,
              type: "bigint",
              minimum: J.value,
              inclusive: J.inclusive,
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "max") {
        if (J.inclusive ? X.data > J.value : X.data >= J.value)
          ((Q = this._getOrReturnCtx(X, Q)),
            v0(Q, {
              code: O0.too_big,
              type: "bigint",
              maximum: J.value,
              inclusive: J.inclusive,
              message: J.message,
            }),
            G.dirty());
      } else if (J.kind === "multipleOf") {
        if (X.data % J.value !== BigInt(0))
          ((Q = this._getOrReturnCtx(X, Q)),
            v0(Q, {
              code: O0.not_multiple_of,
              multipleOf: J.value,
              message: J.message,
            }),
            G.dirty());
      } else x1.assertNever(J);
    return { status: G.value, value: X.data };
  }
  _getInvalidInput(X) {
    let Y = this._getOrReturnCtx(X);
    return (
      v0(Y, {
        code: O0.invalid_type,
        expected: y0.bigint,
        received: Y.parsedType,
      }),
      e0
    );
  }
  gte(X, Y) {
    return this.setLimit("min", X, !0, u0.toString(Y));
  }
  gt(X, Y) {
    return this.setLimit("min", X, !1, u0.toString(Y));
  }
  lte(X, Y) {
    return this.setLimit("max", X, !0, u0.toString(Y));
  }
  lt(X, Y) {
    return this.setLimit("max", X, !1, u0.toString(Y));
  }
  setLimit(X, Y, Q, G) {
    return new G7({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: X, value: Y, inclusive: Q, message: u0.toString(G) },
      ],
    });
  }
  _addCheck(X) {
    return new G7({ ...this._def, checks: [...this._def.checks, X] });
  }
  positive(X) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: u0.toString(X),
    });
  }
  negative(X) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: u0.toString(X),
    });
  }
  nonpositive(X) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: u0.toString(X),
    });
  }
  nonnegative(X) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: u0.toString(X),
    });
  }
  multipleOf(X, Y) {
    return this._addCheck({
      kind: "multipleOf",
      value: X,
      message: u0.toString(Y),
    });
  }
  get minValue() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "min") {
        if (X === null || Y.value > X) X = Y.value;
      }
    return X;
  }
  get maxValue() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "max") {
        if (X === null || Y.value < X) X = Y.value;
      }
    return X;
  }
}
G7.create = (X) => {
  return new G7({
    checks: [],
    typeName: X1.ZodBigInt,
    coerce: X?.coerce ?? !1,
    ...L1(X),
  });
};
class nG extends O1 {
  _parse(X) {
    if (this._def.coerce) X.data = Boolean(X.data);
    if (this._getType(X) !== y0.boolean) {
      let Q = this._getOrReturnCtx(X);
      return (
        v0(Q, {
          code: O0.invalid_type,
          expected: y0.boolean,
          received: Q.parsedType,
        }),
        e0
      );
    }
    return L8(X.data);
  }
}
nG.create = (X) => {
  return new nG({ typeName: X1.ZodBoolean, coerce: X?.coerce || !1, ...L1(X) });
};
class fY extends O1 {
  _parse(X) {
    if (this._def.coerce) X.data = new Date(X.data);
    if (this._getType(X) !== y0.date) {
      let J = this._getOrReturnCtx(X);
      return (
        v0(J, {
          code: O0.invalid_type,
          expected: y0.date,
          received: J.parsedType,
        }),
        e0
      );
    }
    if (Number.isNaN(X.data.getTime())) {
      let J = this._getOrReturnCtx(X);
      return (v0(J, { code: O0.invalid_date }), e0);
    }
    let Q = new J8(),
      G = void 0;
    for (let J of this._def.checks)
      if (J.kind === "min") {
        if (X.data.getTime() < J.value)
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              code: O0.too_small,
              message: J.message,
              inclusive: !0,
              exact: !1,
              minimum: J.value,
              type: "date",
            }),
            Q.dirty());
      } else if (J.kind === "max") {
        if (X.data.getTime() > J.value)
          ((G = this._getOrReturnCtx(X, G)),
            v0(G, {
              code: O0.too_big,
              message: J.message,
              inclusive: !0,
              exact: !1,
              maximum: J.value,
              type: "date",
            }),
            Q.dirty());
      } else x1.assertNever(J);
    return { status: Q.value, value: new Date(X.data.getTime()) };
  }
  _addCheck(X) {
    return new fY({ ...this._def, checks: [...this._def.checks, X] });
  }
  min(X, Y) {
    return this._addCheck({
      kind: "min",
      value: X.getTime(),
      message: u0.toString(Y),
    });
  }
  max(X, Y) {
    return this._addCheck({
      kind: "max",
      value: X.getTime(),
      message: u0.toString(Y),
    });
  }
  get minDate() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "min") {
        if (X === null || Y.value > X) X = Y.value;
      }
    return X != null ? new Date(X) : null;
  }
  get maxDate() {
    let X = null;
    for (let Y of this._def.checks)
      if (Y.kind === "max") {
        if (X === null || Y.value < X) X = Y.value;
      }
    return X != null ? new Date(X) : null;
  }
}
fY.create = (X) => {
  return new fY({
    checks: [],
    coerce: X?.coerce || !1,
    typeName: X1.ZodDate,
    ...L1(X),
  });
};
class aG extends O1 {
  _parse(X) {
    if (this._getType(X) !== y0.symbol) {
      let Q = this._getOrReturnCtx(X);
      return (
        v0(Q, {
          code: O0.invalid_type,
          expected: y0.symbol,
          received: Q.parsedType,
        }),
        e0
      );
    }
    return L8(X.data);
  }
}
aG.create = (X) => {
  return new aG({ typeName: X1.ZodSymbol, ...L1(X) });
};
class xY extends O1 {
  _parse(X) {
    if (this._getType(X) !== y0.undefined) {
      let Q = this._getOrReturnCtx(X);
      return (
        v0(Q, {
          code: O0.invalid_type,
          expected: y0.undefined,
          received: Q.parsedType,
        }),
        e0
      );
    }
    return L8(X.data);
  }
}
xY.create = (X) => {
  return new xY({ typeName: X1.ZodUndefined, ...L1(X) });
};
class hY extends O1 {
  _parse(X) {
    if (this._getType(X) !== y0.null) {
      let Q = this._getOrReturnCtx(X);
      return (
        v0(Q, {
          code: O0.invalid_type,
          expected: y0.null,
          received: Q.parsedType,
        }),
        e0
      );
    }
    return L8(X.data);
  }
}
hY.create = (X) => {
  return new hY({ typeName: X1.ZodNull, ...L1(X) });
};
class rG extends O1 {
  constructor() {
    super(...arguments);
    this._any = !0;
  }
  _parse(X) {
    return L8(X.data);
  }
}
rG.create = (X) => {
  return new rG({ typeName: X1.ZodAny, ...L1(X) });
};
class y9 extends O1 {
  constructor() {
    super(...arguments);
    this._unknown = !0;
  }
  _parse(X) {
    return L8(X.data);
  }
}
y9.create = (X) => {
  return new y9({ typeName: X1.ZodUnknown, ...L1(X) });
};
class H4 extends O1 {
  _parse(X) {
    let Y = this._getOrReturnCtx(X);
    return (
      v0(Y, {
        code: O0.invalid_type,
        expected: y0.never,
        received: Y.parsedType,
      }),
      e0
    );
  }
}
H4.create = (X) => {
  return new H4({ typeName: X1.ZodNever, ...L1(X) });
};
class oG extends O1 {
  _parse(X) {
    if (this._getType(X) !== y0.undefined) {
      let Q = this._getOrReturnCtx(X);
      return (
        v0(Q, {
          code: O0.invalid_type,
          expected: y0.void,
          received: Q.parsedType,
        }),
        e0
      );
    }
    return L8(X.data);
  }
}
oG.create = (X) => {
  return new oG({ typeName: X1.ZodVoid, ...L1(X) });
};
class $6 extends O1 {
  _parse(X) {
    let { ctx: Y, status: Q } = this._processInputParams(X),
      G = this._def;
    if (Y.parsedType !== y0.array)
      return (
        v0(Y, {
          code: O0.invalid_type,
          expected: y0.array,
          received: Y.parsedType,
        }),
        e0
      );
    if (G.exactLength !== null) {
      let U = Y.data.length > G.exactLength.value,
        $ = Y.data.length < G.exactLength.value;
      if (U || $)
        (v0(Y, {
          code: U ? O0.too_big : O0.too_small,
          minimum: $ ? G.exactLength.value : void 0,
          maximum: U ? G.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: G.exactLength.message,
        }),
          Q.dirty());
    }
    if (G.minLength !== null) {
      if (Y.data.length < G.minLength.value)
        (v0(Y, {
          code: O0.too_small,
          minimum: G.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: G.minLength.message,
        }),
          Q.dirty());
    }
    if (G.maxLength !== null) {
      if (Y.data.length > G.maxLength.value)
        (v0(Y, {
          code: O0.too_big,
          maximum: G.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: G.maxLength.message,
        }),
          Q.dirty());
    }
    if (Y.common.async)
      return Promise.all(
        [...Y.data].map((U, $) => {
          return G.type._parseAsync(new m8(Y, U, Y.path, $));
        })
      ).then((U) => {
        return J8.mergeArray(Q, U);
      });
    let J = [...Y.data].map((U, $) => {
      return G.type._parseSync(new m8(Y, U, Y.path, $));
    });
    return J8.mergeArray(Q, J);
  }
  get element() {
    return this._def.type;
  }
  min(X, Y) {
    return new $6({
      ...this._def,
      minLength: { value: X, message: u0.toString(Y) },
    });
  }
  max(X, Y) {
    return new $6({
      ...this._def,
      maxLength: { value: X, message: u0.toString(Y) },
    });
  }
  length(X, Y) {
    return new $6({
      ...this._def,
      exactLength: { value: X, message: u0.toString(Y) },
    });
  }
  nonempty(X) {
    return this.min(1, X);
  }
}
$6.create = (X, Y) => {
  return new $6({
    type: X,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: X1.ZodArray,
    ...L1(Y),
  });
};
function sX(X) {
  if (X instanceof M5) {
    let Y = {};
    for (let Q in X.shape) {
      let G = X.shape[Q];
      Y[Q] = U6.create(sX(G));
    }
    return new M5({ ...X._def, shape: () => Y });
  } else if (X instanceof $6) return new $6({ ...X._def, type: sX(X.element) });
  else if (X instanceof U6) return U6.create(sX(X.unwrap()));
  else if (X instanceof h4) return h4.create(sX(X.unwrap()));
  else if (X instanceof $4) return $4.create(X.items.map((Y) => sX(Y)));
  else return X;
}
class M5 extends O1 {
  constructor() {
    super(...arguments);
    ((this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend));
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    let X = this._def.shape(),
      Y = x1.objectKeys(X);
    return ((this._cached = { shape: X, keys: Y }), this._cached);
  }
  _parse(X) {
    if (this._getType(X) !== y0.object) {
      let K = this._getOrReturnCtx(X);
      return (
        v0(K, {
          code: O0.invalid_type,
          expected: y0.object,
          received: K.parsedType,
        }),
        e0
      );
    }
    let { status: Q, ctx: G } = this._processInputParams(X),
      { shape: J, keys: U } = this._getCached(),
      $ = [];
    if (
      !(this._def.catchall instanceof H4 && this._def.unknownKeys === "strip")
    ) {
      for (let K in G.data) if (!U.includes(K)) $.push(K);
    }
    let B = [];
    for (let K of U) {
      let V = J[K],
        W = G.data[K];
      B.push({
        key: { status: "valid", value: K },
        value: V._parse(new m8(G, W, G.path, K)),
        alwaysSet: K in G.data,
      });
    }
    if (this._def.catchall instanceof H4) {
      let K = this._def.unknownKeys;
      if (K === "passthrough")
        for (let V of $)
          B.push({
            key: { status: "valid", value: V },
            value: { status: "valid", value: G.data[V] },
          });
      else if (K === "strict") {
        if ($.length > 0)
          (v0(G, { code: O0.unrecognized_keys, keys: $ }), Q.dirty());
      } else if (K === "strip");
      else throw Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let K = this._def.catchall;
      for (let V of $) {
        let W = G.data[V];
        B.push({
          key: { status: "valid", value: V },
          value: K._parse(new m8(G, W, G.path, V)),
          alwaysSet: V in G.data,
        });
      }
    }
    if (G.common.async)
      return Promise.resolve()
        .then(async () => {
          let K = [];
          for (let V of B) {
            let W = await V.key,
              L = await V.value;
            K.push({ key: W, value: L, alwaysSet: V.alwaysSet });
          }
          return K;
        })
        .then((K) => {
          return J8.mergeObjectSync(Q, K);
        });
    else return J8.mergeObjectSync(Q, B);
  }
  get shape() {
    return this._def.shape();
  }
  strict(X) {
    return (
      u0.errToObj,
      new M5({
        ...this._def,
        unknownKeys: "strict",
        ...(X !== void 0
          ? {
              errorMap: (Y, Q) => {
                let G = this._def.errorMap?.(Y, Q).message ?? Q.defaultError;
                if (Y.code === "unrecognized_keys")
                  return { message: u0.errToObj(X).message ?? G };
                return { message: G };
              },
            }
          : {}),
      })
    );
  }
  strip() {
    return new M5({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new M5({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(X) {
    return new M5({
      ...this._def,
      shape: () => ({ ...this._def.shape(), ...X }),
    });
  }
  merge(X) {
    return new M5({
      unknownKeys: X._def.unknownKeys,
      catchall: X._def.catchall,
      shape: () => ({ ...this._def.shape(), ...X._def.shape() }),
      typeName: X1.ZodObject,
    });
  }
  setKey(X, Y) {
    return this.augment({ [X]: Y });
  }
  catchall(X) {
    return new M5({ ...this._def, catchall: X });
  }
  pick(X) {
    let Y = {};
    for (let Q of x1.objectKeys(X))
      if (X[Q] && this.shape[Q]) Y[Q] = this.shape[Q];
    return new M5({ ...this._def, shape: () => Y });
  }
  omit(X) {
    let Y = {};
    for (let Q of x1.objectKeys(this.shape)) if (!X[Q]) Y[Q] = this.shape[Q];
    return new M5({ ...this._def, shape: () => Y });
  }
  deepPartial() {
    return sX(this);
  }
  partial(X) {
    let Y = {};
    for (let Q of x1.objectKeys(this.shape)) {
      let G = this.shape[Q];
      if (X && !X[Q]) Y[Q] = G;
      else Y[Q] = G.optional();
    }
    return new M5({ ...this._def, shape: () => Y });
  }
  required(X) {
    let Y = {};
    for (let Q of x1.objectKeys(this.shape))
      if (X && !X[Q]) Y[Q] = this.shape[Q];
      else {
        let J = this.shape[Q];
        while (J instanceof U6) J = J._def.innerType;
        Y[Q] = J;
      }
    return new M5({ ...this._def, shape: () => Y });
  }
  keyof() {
    return $O(x1.objectKeys(this.shape));
  }
}
M5.create = (X, Y) => {
  return new M5({
    shape: () => X,
    unknownKeys: "strip",
    catchall: H4.create(),
    typeName: X1.ZodObject,
    ...L1(Y),
  });
};
M5.strictCreate = (X, Y) => {
  return new M5({
    shape: () => X,
    unknownKeys: "strict",
    catchall: H4.create(),
    typeName: X1.ZodObject,
    ...L1(Y),
  });
};
M5.lazycreate = (X, Y) => {
  return new M5({
    shape: X,
    unknownKeys: "strip",
    catchall: H4.create(),
    typeName: X1.ZodObject,
    ...L1(Y),
  });
};
class gY extends O1 {
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X),
      Q = this._def.options;
    function G(J) {
      for (let $ of J) if ($.result.status === "valid") return $.result;
      for (let $ of J)
        if ($.result.status === "dirty")
          return (Y.common.issues.push(...$.ctx.common.issues), $.result);
      let U = J.map(($) => new S8($.ctx.common.issues));
      return (v0(Y, { code: O0.invalid_union, unionErrors: U }), e0);
    }
    if (Y.common.async)
      return Promise.all(
        Q.map(async (J) => {
          let U = { ...Y, common: { ...Y.common, issues: [] }, parent: null };
          return {
            result: await J._parseAsync({
              data: Y.data,
              path: Y.path,
              parent: U,
            }),
            ctx: U,
          };
        })
      ).then(G);
    else {
      let J = void 0,
        U = [];
      for (let B of Q) {
        let K = { ...Y, common: { ...Y.common, issues: [] }, parent: null },
          V = B._parseSync({ data: Y.data, path: Y.path, parent: K });
        if (V.status === "valid") return V;
        else if (V.status === "dirty" && !J) J = { result: V, ctx: K };
        if (K.common.issues.length) U.push(K.common.issues);
      }
      if (J) return (Y.common.issues.push(...J.ctx.common.issues), J.result);
      let $ = U.map((B) => new S8(B));
      return (v0(Y, { code: O0.invalid_union, unionErrors: $ }), e0);
    }
  }
  get options() {
    return this._def.options;
  }
}
gY.create = (X, Y) => {
  return new gY({ options: X, typeName: X1.ZodUnion, ...L1(Y) });
};
var G4 = (X) => {
  if (X instanceof lY) return G4(X.schema);
  else if (X instanceof B6) return G4(X.innerType());
  else if (X instanceof mY) return [X.value];
  else if (X instanceof _9) return X.options;
  else if (X instanceof cY) return x1.objectValues(X.enum);
  else if (X instanceof dY) return G4(X._def.innerType);
  else if (X instanceof xY) return [void 0];
  else if (X instanceof hY) return [null];
  else if (X instanceof U6) return [void 0, ...G4(X.unwrap())];
  else if (X instanceof h4) return [null, ...G4(X.unwrap())];
  else if (X instanceof pU) return G4(X.unwrap());
  else if (X instanceof iY) return G4(X.unwrap());
  else if (X instanceof pY) return G4(X._def.innerType);
  else return [];
};
class dU extends O1 {
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X);
    if (Y.parsedType !== y0.object)
      return (
        v0(Y, {
          code: O0.invalid_type,
          expected: y0.object,
          received: Y.parsedType,
        }),
        e0
      );
    let Q = this.discriminator,
      G = Y.data[Q],
      J = this.optionsMap.get(G);
    if (!J)
      return (
        v0(Y, {
          code: O0.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [Q],
        }),
        e0
      );
    if (Y.common.async)
      return J._parseAsync({ data: Y.data, path: Y.path, parent: Y });
    else return J._parseSync({ data: Y.data, path: Y.path, parent: Y });
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(X, Y, Q) {
    let G = new Map();
    for (let J of Y) {
      let U = G4(J.shape[X]);
      if (!U.length)
        throw Error(
          `A discriminator value for key \`${X}\` could not be extracted from all schema options`
        );
      for (let $ of U) {
        if (G.has($))
          throw Error(
            `Discriminator property ${String(X)} has duplicate value ${String($)}`
          );
        G.set($, J);
      }
    }
    return new dU({
      typeName: X1.ZodDiscriminatedUnion,
      discriminator: X,
      options: Y,
      optionsMap: G,
      ...L1(Q),
    });
  }
}
function TU(X, Y) {
  let Q = f4(X),
    G = f4(Y);
  if (X === Y) return { valid: !0, data: X };
  else if (Q === y0.object && G === y0.object) {
    let J = x1.objectKeys(Y),
      U = x1.objectKeys(X).filter((B) => J.indexOf(B) !== -1),
      $ = { ...X, ...Y };
    for (let B of U) {
      let K = TU(X[B], Y[B]);
      if (!K.valid) return { valid: !1 };
      $[B] = K.data;
    }
    return { valid: !0, data: $ };
  } else if (Q === y0.array && G === y0.array) {
    if (X.length !== Y.length) return { valid: !1 };
    let J = [];
    for (let U = 0; U < X.length; U++) {
      let $ = X[U],
        B = Y[U],
        K = TU($, B);
      if (!K.valid) return { valid: !1 };
      J.push(K.data);
    }
    return { valid: !0, data: J };
  } else if (Q === y0.date && G === y0.date && +X === +Y)
    return { valid: !0, data: X };
  else return { valid: !1 };
}
class uY extends O1 {
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X),
      G = (J, U) => {
        if (BE(J) || BE(U)) return e0;
        let $ = TU(J.value, U.value);
        if (!$.valid)
          return (v0(Q, { code: O0.invalid_intersection_types }), e0);
        if (KE(J) || KE(U)) Y.dirty();
        return { status: Y.value, value: $.data };
      };
    if (Q.common.async)
      return Promise.all([
        this._def.left._parseAsync({ data: Q.data, path: Q.path, parent: Q }),
        this._def.right._parseAsync({ data: Q.data, path: Q.path, parent: Q }),
      ]).then(([J, U]) => G(J, U));
    else
      return G(
        this._def.left._parseSync({ data: Q.data, path: Q.path, parent: Q }),
        this._def.right._parseSync({ data: Q.data, path: Q.path, parent: Q })
      );
  }
}
uY.create = (X, Y, Q) => {
  return new uY({ left: X, right: Y, typeName: X1.ZodIntersection, ...L1(Q) });
};
class $4 extends O1 {
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== y0.array)
      return (
        v0(Q, {
          code: O0.invalid_type,
          expected: y0.array,
          received: Q.parsedType,
        }),
        e0
      );
    if (Q.data.length < this._def.items.length)
      return (
        v0(Q, {
          code: O0.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        e0
      );
    if (!this._def.rest && Q.data.length > this._def.items.length)
      (v0(Q, {
        code: O0.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array",
      }),
        Y.dirty());
    let J = [...Q.data]
      .map((U, $) => {
        let B = this._def.items[$] || this._def.rest;
        if (!B) return null;
        return B._parse(new m8(Q, U, Q.path, $));
      })
      .filter((U) => !!U);
    if (Q.common.async)
      return Promise.all(J).then((U) => {
        return J8.mergeArray(Y, U);
      });
    else return J8.mergeArray(Y, J);
  }
  get items() {
    return this._def.items;
  }
  rest(X) {
    return new $4({ ...this._def, rest: X });
  }
}
$4.create = (X, Y) => {
  if (!Array.isArray(X))
    throw Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new $4({ items: X, typeName: X1.ZodTuple, rest: null, ...L1(Y) });
};
class sG extends O1 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== y0.object)
      return (
        v0(Q, {
          code: O0.invalid_type,
          expected: y0.object,
          received: Q.parsedType,
        }),
        e0
      );
    let G = [],
      J = this._def.keyType,
      U = this._def.valueType;
    for (let $ in Q.data)
      G.push({
        key: J._parse(new m8(Q, $, Q.path, $)),
        value: U._parse(new m8(Q, Q.data[$], Q.path, $)),
        alwaysSet: $ in Q.data,
      });
    if (Q.common.async) return J8.mergeObjectAsync(Y, G);
    else return J8.mergeObjectSync(Y, G);
  }
  get element() {
    return this._def.valueType;
  }
  static create(X, Y, Q) {
    if (Y instanceof O1)
      return new sG({
        keyType: X,
        valueType: Y,
        typeName: X1.ZodRecord,
        ...L1(Q),
      });
    return new sG({
      keyType: W4.create(),
      valueType: X,
      typeName: X1.ZodRecord,
      ...L1(Y),
    });
  }
}
class tG extends O1 {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== y0.map)
      return (
        v0(Q, {
          code: O0.invalid_type,
          expected: y0.map,
          received: Q.parsedType,
        }),
        e0
      );
    let G = this._def.keyType,
      J = this._def.valueType,
      U = [...Q.data.entries()].map(([$, B], K) => {
        return {
          key: G._parse(new m8(Q, $, Q.path, [K, "key"])),
          value: J._parse(new m8(Q, B, Q.path, [K, "value"])),
        };
      });
    if (Q.common.async) {
      let $ = new Map();
      return Promise.resolve().then(async () => {
        for (let B of U) {
          let K = await B.key,
            V = await B.value;
          if (K.status === "aborted" || V.status === "aborted") return e0;
          if (K.status === "dirty" || V.status === "dirty") Y.dirty();
          $.set(K.value, V.value);
        }
        return { status: Y.value, value: $ };
      });
    } else {
      let $ = new Map();
      for (let B of U) {
        let { key: K, value: V } = B;
        if (K.status === "aborted" || V.status === "aborted") return e0;
        if (K.status === "dirty" || V.status === "dirty") Y.dirty();
        $.set(K.value, V.value);
      }
      return { status: Y.value, value: $ };
    }
  }
}
tG.create = (X, Y, Q) => {
  return new tG({ valueType: Y, keyType: X, typeName: X1.ZodMap, ...L1(Q) });
};
class J7 extends O1 {
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== y0.set)
      return (
        v0(Q, {
          code: O0.invalid_type,
          expected: y0.set,
          received: Q.parsedType,
        }),
        e0
      );
    let G = this._def;
    if (G.minSize !== null) {
      if (Q.data.size < G.minSize.value)
        (v0(Q, {
          code: O0.too_small,
          minimum: G.minSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: G.minSize.message,
        }),
          Y.dirty());
    }
    if (G.maxSize !== null) {
      if (Q.data.size > G.maxSize.value)
        (v0(Q, {
          code: O0.too_big,
          maximum: G.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: G.maxSize.message,
        }),
          Y.dirty());
    }
    let J = this._def.valueType;
    function U(B) {
      let K = new Set();
      for (let V of B) {
        if (V.status === "aborted") return e0;
        if (V.status === "dirty") Y.dirty();
        K.add(V.value);
      }
      return { status: Y.value, value: K };
    }
    let $ = [...Q.data.values()].map((B, K) =>
      J._parse(new m8(Q, B, Q.path, K))
    );
    if (Q.common.async) return Promise.all($).then((B) => U(B));
    else return U($);
  }
  min(X, Y) {
    return new J7({
      ...this._def,
      minSize: { value: X, message: u0.toString(Y) },
    });
  }
  max(X, Y) {
    return new J7({
      ...this._def,
      maxSize: { value: X, message: u0.toString(Y) },
    });
  }
  size(X, Y) {
    return this.min(X, Y).max(X, Y);
  }
  nonempty(X) {
    return this.min(1, X);
  }
}
J7.create = (X, Y) => {
  return new J7({
    valueType: X,
    minSize: null,
    maxSize: null,
    typeName: X1.ZodSet,
    ...L1(Y),
  });
};
class kY extends O1 {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X);
    if (Y.parsedType !== y0.function)
      return (
        v0(Y, {
          code: O0.invalid_type,
          expected: y0.function,
          received: Y.parsedType,
        }),
        e0
      );
    function Q($, B) {
      return SU({
        data: $,
        path: Y.path,
        errorMaps: [
          Y.common.contextualErrorMap,
          Y.schemaErrorMap,
          PU(),
          _Y,
        ].filter((K) => !!K),
        issueData: { code: O0.invalid_arguments, argumentsError: B },
      });
    }
    function G($, B) {
      return SU({
        data: $,
        path: Y.path,
        errorMaps: [
          Y.common.contextualErrorMap,
          Y.schemaErrorMap,
          PU(),
          _Y,
        ].filter((K) => !!K),
        issueData: { code: O0.invalid_return_type, returnTypeError: B },
      });
    }
    let J = { errorMap: Y.common.contextualErrorMap },
      U = Y.data;
    if (this._def.returns instanceof W7) {
      let $ = this;
      return L8(async function (...B) {
        let K = new S8([]),
          V = await $._def.args.parseAsync(B, J).catch((H) => {
            throw (K.addIssue(Q(B, H)), K);
          }),
          W = await Reflect.apply(U, this, V);
        return await $._def.returns._def.type.parseAsync(W, J).catch((H) => {
          throw (K.addIssue(G(W, H)), K);
        });
      });
    } else {
      let $ = this;
      return L8(function (...B) {
        let K = $._def.args.safeParse(B, J);
        if (!K.success) throw new S8([Q(B, K.error)]);
        let V = Reflect.apply(U, this, K.data),
          W = $._def.returns.safeParse(V, J);
        if (!W.success) throw new S8([G(V, W.error)]);
        return W.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...X) {
    return new kY({ ...this._def, args: $4.create(X).rest(y9.create()) });
  }
  returns(X) {
    return new kY({ ...this._def, returns: X });
  }
  implement(X) {
    return this.parse(X);
  }
  strictImplement(X) {
    return this.parse(X);
  }
  static create(X, Y, Q) {
    return new kY({
      args: X ? X : $4.create([]).rest(y9.create()),
      returns: Y || y9.create(),
      typeName: X1.ZodFunction,
      ...L1(Q),
    });
  }
}
class lY extends O1 {
  get schema() {
    return this._def.getter();
  }
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X);
    return this._def.getter()._parse({ data: Y.data, path: Y.path, parent: Y });
  }
}
lY.create = (X, Y) => {
  return new lY({ getter: X, typeName: X1.ZodLazy, ...L1(Y) });
};
class mY extends O1 {
  _parse(X) {
    if (X.data !== this._def.value) {
      let Y = this._getOrReturnCtx(X);
      return (
        v0(Y, {
          received: Y.data,
          code: O0.invalid_literal,
          expected: this._def.value,
        }),
        e0
      );
    }
    return { status: "valid", value: X.data };
  }
  get value() {
    return this._def.value;
  }
}
mY.create = (X, Y) => {
  return new mY({ value: X, typeName: X1.ZodLiteral, ...L1(Y) });
};
function $O(X, Y) {
  return new _9({ values: X, typeName: X1.ZodEnum, ...L1(Y) });
}
class _9 extends O1 {
  _parse(X) {
    if (typeof X.data !== "string") {
      let Y = this._getOrReturnCtx(X),
        Q = this._def.values;
      return (
        v0(Y, {
          expected: x1.joinValues(Q),
          received: Y.parsedType,
          code: O0.invalid_type,
        }),
        e0
      );
    }
    if (!this._cache) this._cache = new Set(this._def.values);
    if (!this._cache.has(X.data)) {
      let Y = this._getOrReturnCtx(X),
        Q = this._def.values;
      return (
        v0(Y, { received: Y.data, code: O0.invalid_enum_value, options: Q }),
        e0
      );
    }
    return L8(X.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let X = {};
    for (let Y of this._def.values) X[Y] = Y;
    return X;
  }
  get Values() {
    let X = {};
    for (let Y of this._def.values) X[Y] = Y;
    return X;
  }
  get Enum() {
    let X = {};
    for (let Y of this._def.values) X[Y] = Y;
    return X;
  }
  extract(X, Y = this._def) {
    return _9.create(X, { ...this._def, ...Y });
  }
  exclude(X, Y = this._def) {
    return _9.create(
      this.options.filter((Q) => !X.includes(Q)),
      { ...this._def, ...Y }
    );
  }
}
_9.create = $O;
class cY extends O1 {
  _parse(X) {
    let Y = x1.getValidEnumValues(this._def.values),
      Q = this._getOrReturnCtx(X);
    if (Q.parsedType !== y0.string && Q.parsedType !== y0.number) {
      let G = x1.objectValues(Y);
      return (
        v0(Q, {
          expected: x1.joinValues(G),
          received: Q.parsedType,
          code: O0.invalid_type,
        }),
        e0
      );
    }
    if (!this._cache)
      this._cache = new Set(x1.getValidEnumValues(this._def.values));
    if (!this._cache.has(X.data)) {
      let G = x1.objectValues(Y);
      return (
        v0(Q, { received: Q.data, code: O0.invalid_enum_value, options: G }),
        e0
      );
    }
    return L8(X.data);
  }
  get enum() {
    return this._def.values;
  }
}
cY.create = (X, Y) => {
  return new cY({ values: X, typeName: X1.ZodNativeEnum, ...L1(Y) });
};
class W7 extends O1 {
  unwrap() {
    return this._def.type;
  }
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X);
    if (Y.parsedType !== y0.promise && Y.common.async === !1)
      return (
        v0(Y, {
          code: O0.invalid_type,
          expected: y0.promise,
          received: Y.parsedType,
        }),
        e0
      );
    let Q = Y.parsedType === y0.promise ? Y.data : Promise.resolve(Y.data);
    return L8(
      Q.then((G) => {
        return this._def.type.parseAsync(G, {
          path: Y.path,
          errorMap: Y.common.contextualErrorMap,
        });
      })
    );
  }
}
W7.create = (X, Y) => {
  return new W7({ type: X, typeName: X1.ZodPromise, ...L1(Y) });
};
class B6 extends O1 {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === X1.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X),
      G = this._def.effect || null,
      J = {
        addIssue: (U) => {
          if ((v0(Q, U), U.fatal)) Y.abort();
          else Y.dirty();
        },
        get path() {
          return Q.path;
        },
      };
    if (((J.addIssue = J.addIssue.bind(J)), G.type === "preprocess")) {
      let U = G.transform(Q.data, J);
      if (Q.common.async)
        return Promise.resolve(U).then(async ($) => {
          if (Y.value === "aborted") return e0;
          let B = await this._def.schema._parseAsync({
            data: $,
            path: Q.path,
            parent: Q,
          });
          if (B.status === "aborted") return e0;
          if (B.status === "dirty") return bY(B.value);
          if (Y.value === "dirty") return bY(B.value);
          return B;
        });
      else {
        if (Y.value === "aborted") return e0;
        let $ = this._def.schema._parseSync({
          data: U,
          path: Q.path,
          parent: Q,
        });
        if ($.status === "aborted") return e0;
        if ($.status === "dirty") return bY($.value);
        if (Y.value === "dirty") return bY($.value);
        return $;
      }
    }
    if (G.type === "refinement") {
      let U = ($) => {
        let B = G.refinement($, J);
        if (Q.common.async) return Promise.resolve(B);
        if (B instanceof Promise)
          throw Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return $;
      };
      if (Q.common.async === !1) {
        let $ = this._def.schema._parseSync({
          data: Q.data,
          path: Q.path,
          parent: Q,
        });
        if ($.status === "aborted") return e0;
        if ($.status === "dirty") Y.dirty();
        return (U($.value), { status: Y.value, value: $.value });
      } else
        return this._def.schema
          ._parseAsync({ data: Q.data, path: Q.path, parent: Q })
          .then(($) => {
            if ($.status === "aborted") return e0;
            if ($.status === "dirty") Y.dirty();
            return U($.value).then(() => {
              return { status: Y.value, value: $.value };
            });
          });
    }
    if (G.type === "transform")
      if (Q.common.async === !1) {
        let U = this._def.schema._parseSync({
          data: Q.data,
          path: Q.path,
          parent: Q,
        });
        if (!Y7(U)) return e0;
        let $ = G.transform(U.value, J);
        if ($ instanceof Promise)
          throw Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return { status: Y.value, value: $ };
      } else
        return this._def.schema
          ._parseAsync({ data: Q.data, path: Q.path, parent: Q })
          .then((U) => {
            if (!Y7(U)) return e0;
            return Promise.resolve(G.transform(U.value, J)).then(($) => ({
              status: Y.value,
              value: $,
            }));
          });
    x1.assertNever(G);
  }
}
B6.create = (X, Y, Q) => {
  return new B6({ schema: X, typeName: X1.ZodEffects, effect: Y, ...L1(Q) });
};
B6.createWithPreprocess = (X, Y, Q) => {
  return new B6({
    schema: Y,
    effect: { type: "preprocess", transform: X },
    typeName: X1.ZodEffects,
    ...L1(Q),
  });
};
class U6 extends O1 {
  _parse(X) {
    if (this._getType(X) === y0.undefined) return L8(void 0);
    return this._def.innerType._parse(X);
  }
  unwrap() {
    return this._def.innerType;
  }
}
U6.create = (X, Y) => {
  return new U6({ innerType: X, typeName: X1.ZodOptional, ...L1(Y) });
};
class h4 extends O1 {
  _parse(X) {
    if (this._getType(X) === y0.null) return L8(null);
    return this._def.innerType._parse(X);
  }
  unwrap() {
    return this._def.innerType;
  }
}
h4.create = (X, Y) => {
  return new h4({ innerType: X, typeName: X1.ZodNullable, ...L1(Y) });
};
class dY extends O1 {
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X),
      Q = Y.data;
    if (Y.parsedType === y0.undefined) Q = this._def.defaultValue();
    return this._def.innerType._parse({ data: Q, path: Y.path, parent: Y });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
dY.create = (X, Y) => {
  return new dY({
    innerType: X,
    typeName: X1.ZodDefault,
    defaultValue: typeof Y.default === "function" ? Y.default : () => Y.default,
    ...L1(Y),
  });
};
class pY extends O1 {
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X),
      Q = { ...Y, common: { ...Y.common, issues: [] } },
      G = this._def.innerType._parse({
        data: Q.data,
        path: Q.path,
        parent: { ...Q },
      });
    if (iG(G))
      return G.then((J) => {
        return {
          status: "valid",
          value:
            J.status === "valid"
              ? J.value
              : this._def.catchValue({
                  get error() {
                    return new S8(Q.common.issues);
                  },
                  input: Q.data,
                }),
        };
      });
    else
      return {
        status: "valid",
        value:
          G.status === "valid"
            ? G.value
            : this._def.catchValue({
                get error() {
                  return new S8(Q.common.issues);
                },
                input: Q.data,
              }),
      };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
pY.create = (X, Y) => {
  return new pY({
    innerType: X,
    typeName: X1.ZodCatch,
    catchValue: typeof Y.catch === "function" ? Y.catch : () => Y.catch,
    ...L1(Y),
  });
};
class eG extends O1 {
  _parse(X) {
    if (this._getType(X) !== y0.nan) {
      let Q = this._getOrReturnCtx(X);
      return (
        v0(Q, {
          code: O0.invalid_type,
          expected: y0.nan,
          received: Q.parsedType,
        }),
        e0
      );
    }
    return { status: "valid", value: X.data };
  }
}
eG.create = (X) => {
  return new eG({ typeName: X1.ZodNaN, ...L1(X) });
};
var AJ0 = Symbol("zod_brand");
class pU extends O1 {
  _parse(X) {
    let { ctx: Y } = this._processInputParams(X),
      Q = Y.data;
    return this._def.type._parse({ data: Q, path: Y.path, parent: Y });
  }
  unwrap() {
    return this._def.type;
  }
}
class FJ extends O1 {
  _parse(X) {
    let { status: Y, ctx: Q } = this._processInputParams(X);
    if (Q.common.async)
      return (async () => {
        let J = await this._def.in._parseAsync({
          data: Q.data,
          path: Q.path,
          parent: Q,
        });
        if (J.status === "aborted") return e0;
        if (J.status === "dirty") return (Y.dirty(), bY(J.value));
        else
          return this._def.out._parseAsync({
            data: J.value,
            path: Q.path,
            parent: Q,
          });
      })();
    else {
      let G = this._def.in._parseSync({
        data: Q.data,
        path: Q.path,
        parent: Q,
      });
      if (G.status === "aborted") return e0;
      if (G.status === "dirty")
        return (Y.dirty(), { status: "dirty", value: G.value });
      else
        return this._def.out._parseSync({
          data: G.value,
          path: Q.path,
          parent: Q,
        });
    }
  }
  static create(X, Y) {
    return new FJ({ in: X, out: Y, typeName: X1.ZodPipeline });
  }
}
class iY extends O1 {
  _parse(X) {
    let Y = this._def.innerType._parse(X),
      Q = (G) => {
        if (Y7(G)) G.value = Object.freeze(G.value);
        return G;
      };
    return iG(Y) ? Y.then((G) => Q(G)) : Q(Y);
  }
  unwrap() {
    return this._def.innerType;
  }
}
iY.create = (X, Y) => {
  return new iY({ innerType: X, typeName: X1.ZodReadonly, ...L1(Y) });
};
var qJ0 = { object: M5.lazycreate },
  X1;
(function (X) {
  ((X.ZodString = "ZodString"),
    (X.ZodNumber = "ZodNumber"),
    (X.ZodNaN = "ZodNaN"),
    (X.ZodBigInt = "ZodBigInt"),
    (X.ZodBoolean = "ZodBoolean"),
    (X.ZodDate = "ZodDate"),
    (X.ZodSymbol = "ZodSymbol"),
    (X.ZodUndefined = "ZodUndefined"),
    (X.ZodNull = "ZodNull"),
    (X.ZodAny = "ZodAny"),
    (X.ZodUnknown = "ZodUnknown"),
    (X.ZodNever = "ZodNever"),
    (X.ZodVoid = "ZodVoid"),
    (X.ZodArray = "ZodArray"),
    (X.ZodObject = "ZodObject"),
    (X.ZodUnion = "ZodUnion"),
    (X.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (X.ZodIntersection = "ZodIntersection"),
    (X.ZodTuple = "ZodTuple"),
    (X.ZodRecord = "ZodRecord"),
    (X.ZodMap = "ZodMap"),
    (X.ZodSet = "ZodSet"),
    (X.ZodFunction = "ZodFunction"),
    (X.ZodLazy = "ZodLazy"),
    (X.ZodLiteral = "ZodLiteral"),
    (X.ZodEnum = "ZodEnum"),
    (X.ZodEffects = "ZodEffects"),
    (X.ZodNativeEnum = "ZodNativeEnum"),
    (X.ZodOptional = "ZodOptional"),
    (X.ZodNullable = "ZodNullable"),
    (X.ZodDefault = "ZodDefault"),
    (X.ZodCatch = "ZodCatch"),
    (X.ZodPromise = "ZodPromise"),
    (X.ZodBranded = "ZodBranded"),
    (X.ZodPipeline = "ZodPipeline"),
    (X.ZodReadonly = "ZodReadonly"));
})(X1 || (X1 = {}));
var RJ0 = W4.create,
  DJ0 = Q7.create,
  zJ0 = eG.create,
  EJ0 = G7.create,
  OJ0 = nG.create,
  ZJ0 = fY.create,
  jJ0 = aG.create,
  wJ0 = xY.create,
  CJ0 = hY.create,
  IJ0 = rG.create,
  PJ0 = y9.create,
  SJ0 = H4.create,
  TJ0 = oG.create,
  bJ0 = $6.create,
  vJ0 = M5.create,
  kJ0 = M5.strictCreate,
  yJ0 = gY.create,
  _J0 = dU.create,
  fJ0 = uY.create,
  xJ0 = $4.create,
  hJ0 = sG.create,
  gJ0 = tG.create,
  uJ0 = J7.create,
  lJ0 = kY.create,
  mJ0 = lY.create,
  cJ0 = mY.create,
  dJ0 = _9.create,
  pJ0 = cY.create,
  iJ0 = W7.create,
  nJ0 = B6.create,
  aJ0 = U6.create,
  rJ0 = h4.create,
  oJ0 = B6.createWithPreprocess,
  sJ0 = FJ.create,
  tJ0 = Object.freeze({ status: "aborted" });
function R0(X, Y, Q) {
  function G(B, K) {
    var V;
    (Object.defineProperty(B, "_zod", { value: B._zod ?? {}, enumerable: !1 }),
      (V = B._zod).traits ?? (V.traits = new Set()),
      B._zod.traits.add(X),
      Y(B, K));
    for (let W in $.prototype)
      if (!(W in B))
        Object.defineProperty(B, W, { value: $.prototype[W].bind(B) });
    ((B._zod.constr = $), (B._zod.def = K));
  }
  let J = Q?.Parent ?? Object;
  class U extends J {}
  Object.defineProperty(U, "name", { value: X });
  function $(B) {
    var K;
    let V = Q?.Parent ? new U() : this;
    (G(V, B), (K = V._zod).deferred ?? (K.deferred = []));
    for (let W of V._zod.deferred) W();
    return V;
  }
  return (
    Object.defineProperty($, "init", { value: G }),
    Object.defineProperty($, Symbol.hasInstance, {
      value: (B) => {
        if (Q?.Parent && B instanceof Q.Parent) return !0;
        return B?._zod?.traits?.has(X);
      },
    }),
    Object.defineProperty($, "name", { value: X }),
    $
  );
}
var eJ0 = Symbol("zod_brand");
class H7 extends Error {
  constructor() {
    super(
      "Encountered Promise during synchronous parse. Use .parseAsync() instead."
    );
  }
}
var bU = {};
function U4(X) {
  if (X) Object.assign(bU, X);
  return bU;
}
var Y5 = {};
kE(Y5, {
  unwrapMessage: () => vY,
  stringifyPrimitive: () => aU,
  required: () => Yl,
  randomString: () => du,
  propertyKeyTypes: () => VO,
  promiseAllObject: () => cu,
  primitiveTypes: () => nu,
  prefixIssues: () => x4,
  pick: () => ou,
  partial: () => Xl,
  optionalKeys: () => FO,
  omit: () => su,
  numKeys: () => pu,
  nullish: () => MJ,
  normalizeParams: () => a0,
  merge: () => eu,
  jsonStringifyReplacer: () => LO,
  joinValues: () => vU,
  issue: () => MO,
  isPlainObject: () => aY,
  isObject: () => nY,
  getSizableOrigin: () => Ql,
  getParsedType: () => iu,
  getLengthableOrigin: () => qJ,
  getEnumValues: () => UO,
  getElementAtPath: () => mu,
  floatSafeRemainder: () => BO,
  finalizeIssue: () => L4,
  extend: () => tu,
  escapeRegex: () => K7,
  esc: () => tX,
  defineLazy: () => Q5,
  createTransparentProxy: () => au,
  clone: () => l4,
  cleanRegex: () => AJ,
  cleanEnum: () => Gl,
  captureStackTrace: () => nU,
  cached: () => NJ,
  assignProp: () => iU,
  assertNotEqual: () => hu,
  assertNever: () => uu,
  assertIs: () => gu,
  assertEqual: () => xu,
  assert: () => lu,
  allowsEval: () => KO,
  aborted: () => X7,
  NUMBER_FORMAT_RANGES: () => NO,
  Class: () => AO,
  BIGINT_FORMAT_RANGES: () => ru,
});
function xu(X) {
  return X;
}
function hu(X) {
  return X;
}
function gu(X) {}
function uu(X) {
  throw Error();
}
function lu(X) {}
function UO(X) {
  let Y = Object.values(X).filter((G) => typeof G === "number");
  return Object.entries(X)
    .filter(([G, J]) => Y.indexOf(+G) === -1)
    .map(([G, J]) => J);
}
function vU(X, Y = "|") {
  return X.map((Q) => aU(Q)).join(Y);
}
function LO(X, Y) {
  if (typeof Y === "bigint") return Y.toString();
  return Y;
}
function NJ(X) {
  return {
    get value() {
      {
        let Q = X();
        return (Object.defineProperty(this, "value", { value: Q }), Q);
      }
      throw Error("cached value already set");
    },
  };
}
function MJ(X) {
  return X === null || X === void 0;
}
function AJ(X) {
  let Y = X.startsWith("^") ? 1 : 0,
    Q = X.endsWith("$") ? X.length - 1 : X.length;
  return X.slice(Y, Q);
}
function BO(X, Y) {
  let Q = (X.toString().split(".")[1] || "").length,
    G = (Y.toString().split(".")[1] || "").length,
    J = Q > G ? Q : G,
    U = Number.parseInt(X.toFixed(J).replace(".", "")),
    $ = Number.parseInt(Y.toFixed(J).replace(".", ""));
  return (U % $) / 10 ** J;
}
function Q5(X, Y, Q) {
  Object.defineProperty(X, Y, {
    get() {
      {
        let J = Q();
        return ((X[Y] = J), J);
      }
      throw Error("cached value already set");
    },
    set(J) {
      Object.defineProperty(X, Y, { value: J });
    },
    configurable: !0,
  });
}
function iU(X, Y, Q) {
  Object.defineProperty(X, Y, {
    value: Q,
    writable: !0,
    enumerable: !0,
    configurable: !0,
  });
}
function mu(X, Y) {
  if (!Y) return X;
  return Y.reduce((Q, G) => Q?.[G], X);
}
function cu(X) {
  let Y = Object.keys(X),
    Q = Y.map((G) => X[G]);
  return Promise.all(Q).then((G) => {
    let J = {};
    for (let U = 0; U < Y.length; U++) J[Y[U]] = G[U];
    return J;
  });
}
function du(X = 10) {
  let Q = "";
  for (let G = 0; G < X; G++)
    Q += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return Q;
}
function tX(X) {
  return JSON.stringify(X);
}
var nU = Error.captureStackTrace ? Error.captureStackTrace : (...X) => {};
function nY(X) {
  return typeof X === "object" && X !== null && !Array.isArray(X);
}
var KO = NJ(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    return (new Function(""), !0);
  } catch (X) {
    return !1;
  }
});
function aY(X) {
  if (nY(X) === !1) return !1;
  let Y = X.constructor;
  if (Y === void 0) return !0;
  let Q = Y.prototype;
  if (nY(Q) === !1) return !1;
  if (Object.prototype.hasOwnProperty.call(Q, "isPrototypeOf") === !1)
    return !1;
  return !0;
}
function pu(X) {
  let Y = 0;
  for (let Q in X) if (Object.prototype.hasOwnProperty.call(X, Q)) Y++;
  return Y;
}
var iu = (X) => {
    let Y = typeof X;
    switch (Y) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return Number.isNaN(X) ? "nan" : "number";
      case "boolean":
        return "boolean";
      case "function":
        return "function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      case "object":
        if (Array.isArray(X)) return "array";
        if (X === null) return "null";
        if (
          X.then &&
          typeof X.then === "function" &&
          X.catch &&
          typeof X.catch === "function"
        )
          return "promise";
        if (typeof Map < "u" && X instanceof Map) return "map";
        if (typeof Set < "u" && X instanceof Set) return "set";
        if (typeof Date < "u" && X instanceof Date) return "date";
        if (typeof File < "u" && X instanceof File) return "file";
        return "object";
      default:
        throw Error(`Unknown data type: ${Y}`);
    }
  },
  VO = new Set(["string", "number", "symbol"]),
  nu = new Set([
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol",
    "undefined",
  ]);
function K7(X) {
  return X.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function l4(X, Y, Q) {
  let G = new X._zod.constr(Y ?? X._zod.def);
  if (!Y || Q?.parent) G._zod.parent = X;
  return G;
}
function a0(X) {
  let Y = X;
  if (!Y) return {};
  if (typeof Y === "string") return { error: () => Y };
  if (Y?.message !== void 0) {
    if (Y?.error !== void 0)
      throw Error("Cannot specify both `message` and `error` params");
    Y.error = Y.message;
  }
  if ((delete Y.message, typeof Y.error === "string"))
    return { ...Y, error: () => Y.error };
  return Y;
}
function au(X) {
  let Y;
  return new Proxy(
    {},
    {
      get(Q, G, J) {
        return (Y ?? (Y = X()), Reflect.get(Y, G, J));
      },
      set(Q, G, J, U) {
        return (Y ?? (Y = X()), Reflect.set(Y, G, J, U));
      },
      has(Q, G) {
        return (Y ?? (Y = X()), Reflect.has(Y, G));
      },
      deleteProperty(Q, G) {
        return (Y ?? (Y = X()), Reflect.deleteProperty(Y, G));
      },
      ownKeys(Q) {
        return (Y ?? (Y = X()), Reflect.ownKeys(Y));
      },
      getOwnPropertyDescriptor(Q, G) {
        return (Y ?? (Y = X()), Reflect.getOwnPropertyDescriptor(Y, G));
      },
      defineProperty(Q, G, J) {
        return (Y ?? (Y = X()), Reflect.defineProperty(Y, G, J));
      },
    }
  );
}
function aU(X) {
  if (typeof X === "bigint") return X.toString() + "n";
  if (typeof X === "string") return `"${X}"`;
  return `${X}`;
}
function FO(X) {
  return Object.keys(X).filter((Y) => {
    return X[Y]._zod.optin === "optional" && X[Y]._zod.optout === "optional";
  });
}
var NO = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [
      -340282346638528860000000000000000000000,
      340282346638528860000000000000000000000,
    ],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
  },
  ru = {
    int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
    uint64: [BigInt(0), BigInt("18446744073709551615")],
  };
function ou(X, Y) {
  let Q = {},
    G = X._zod.def;
  for (let J in Y) {
    if (!(J in G.shape)) throw Error(`Unrecognized key: "${J}"`);
    if (!Y[J]) continue;
    Q[J] = G.shape[J];
  }
  return l4(X, { ...X._zod.def, shape: Q, checks: [] });
}
function su(X, Y) {
  let Q = { ...X._zod.def.shape },
    G = X._zod.def;
  for (let J in Y) {
    if (!(J in G.shape)) throw Error(`Unrecognized key: "${J}"`);
    if (!Y[J]) continue;
    delete Q[J];
  }
  return l4(X, { ...X._zod.def, shape: Q, checks: [] });
}
function tu(X, Y) {
  if (!aY(Y)) throw Error("Invalid input to extend: expected a plain object");
  let Q = {
    ...X._zod.def,
    get shape() {
      let G = { ...X._zod.def.shape, ...Y };
      return (iU(this, "shape", G), G);
    },
    checks: [],
  };
  return l4(X, Q);
}
function eu(X, Y) {
  return l4(X, {
    ...X._zod.def,
    get shape() {
      let Q = { ...X._zod.def.shape, ...Y._zod.def.shape };
      return (iU(this, "shape", Q), Q);
    },
    catchall: Y._zod.def.catchall,
    checks: [],
  });
}
function Xl(X, Y, Q) {
  let G = Y._zod.def.shape,
    J = { ...G };
  if (Q)
    for (let U in Q) {
      if (!(U in G)) throw Error(`Unrecognized key: "${U}"`);
      if (!Q[U]) continue;
      J[U] = X ? new X({ type: "optional", innerType: G[U] }) : G[U];
    }
  else
    for (let U in G)
      J[U] = X ? new X({ type: "optional", innerType: G[U] }) : G[U];
  return l4(Y, { ...Y._zod.def, shape: J, checks: [] });
}
function Yl(X, Y, Q) {
  let G = Y._zod.def.shape,
    J = { ...G };
  if (Q)
    for (let U in Q) {
      if (!(U in J)) throw Error(`Unrecognized key: "${U}"`);
      if (!Q[U]) continue;
      J[U] = new X({ type: "nonoptional", innerType: G[U] });
    }
  else for (let U in G) J[U] = new X({ type: "nonoptional", innerType: G[U] });
  return l4(Y, { ...Y._zod.def, shape: J, checks: [] });
}
function X7(X, Y = 0) {
  for (let Q = Y; Q < X.issues.length; Q++)
    if (X.issues[Q]?.continue !== !0) return !0;
  return !1;
}
function x4(X, Y) {
  return Y.map((Q) => {
    var G;
    return ((G = Q).path ?? (G.path = []), Q.path.unshift(X), Q);
  });
}
function vY(X) {
  return typeof X === "string" ? X : X?.message;
}
function L4(X, Y, Q) {
  let G = { ...X, path: X.path ?? [] };
  if (!X.message) {
    let J =
      vY(X.inst?._zod.def?.error?.(X)) ??
      vY(Y?.error?.(X)) ??
      vY(Q.customError?.(X)) ??
      vY(Q.localeError?.(X)) ??
      "Invalid input";
    G.message = J;
  }
  if ((delete G.inst, delete G.continue, !Y?.reportInput)) delete G.input;
  return G;
}
function Ql(X) {
  if (X instanceof Set) return "set";
  if (X instanceof Map) return "map";
  if (X instanceof File) return "file";
  return "unknown";
}
function qJ(X) {
  if (Array.isArray(X)) return "array";
  if (typeof X === "string") return "string";
  return "unknown";
}
function MO(...X) {
  let [Y, Q, G] = X;
  if (typeof Y === "string")
    return { message: Y, code: "custom", input: Q, inst: G };
  return { ...Y };
}
function Gl(X) {
  return Object.entries(X)
    .filter(([Y, Q]) => {
      return Number.isNaN(Number.parseInt(Y, 10));
    })
    .map((Y) => Y[1]);
}
class AO {
  constructor(...X) {}
}
var qO = (X, Y) => {
    ((X.name = "$ZodError"),
      Object.defineProperty(X, "_zod", { value: X._zod, enumerable: !1 }),
      Object.defineProperty(X, "issues", { value: Y, enumerable: !1 }),
      Object.defineProperty(X, "message", {
        get() {
          return JSON.stringify(Y, LO, 2);
        },
        enumerable: !0,
      }));
  },
  RO = R0("$ZodError", qO),
  DO = R0("$ZodError", qO, { Parent: Error });
function Jl(X, Y = (Q) => Q.message) {
  let Q = {},
    G = [];
  for (let J of X.issues)
    if (J.path.length > 0)
      ((Q[J.path[0]] = Q[J.path[0]] || []), Q[J.path[0]].push(Y(J)));
    else G.push(Y(J));
  return { formErrors: G, fieldErrors: Q };
}
function Wl(X, Y) {
  let Q =
      Y ||
      function (U) {
        return U.message;
      },
    G = { _errors: [] },
    J = (U) => {
      for (let $ of U.issues)
        if ($.code === "invalid_union" && $.errors.length)
          $.errors.map((B) => J({ issues: B }));
        else if ($.code === "invalid_key") J({ issues: $.issues });
        else if ($.code === "invalid_element") J({ issues: $.issues });
        else if ($.path.length === 0) G._errors.push(Q($));
        else {
          let B = G,
            K = 0;
          while (K < $.path.length) {
            let V = $.path[K];
            if (K !== $.path.length - 1) B[V] = B[V] || { _errors: [] };
            else ((B[V] = B[V] || { _errors: [] }), B[V]._errors.push(Q($)));
            ((B = B[V]), K++);
          }
        }
    };
  return (J(X), G);
}
var Hl = (X) => (Y, Q, G, J) => {
  let U = G ? Object.assign(G, { async: !1 }) : { async: !1 },
    $ = Y._zod.run({ value: Q, issues: [] }, U);
  if ($ instanceof Promise) throw new H7();
  if ($.issues.length) {
    let B = new (J?.Err ?? X)($.issues.map((K) => L4(K, U, U4())));
    throw (nU(B, J?.callee), B);
  }
  return $.value;
};
var $l = (X) => async (Y, Q, G, J) => {
  let U = G ? Object.assign(G, { async: !0 }) : { async: !0 },
    $ = Y._zod.run({ value: Q, issues: [] }, U);
  if ($ instanceof Promise) $ = await $;
  if ($.issues.length) {
    let B = new (J?.Err ?? X)($.issues.map((K) => L4(K, U, U4())));
    throw (nU(B, J?.callee), B);
  }
  return $.value;
};
var zO = (X) => (Y, Q, G) => {
    let J = G ? { ...G, async: !1 } : { async: !1 },
      U = Y._zod.run({ value: Q, issues: [] }, J);
    if (U instanceof Promise) throw new H7();
    return U.issues.length
      ? {
          success: !1,
          error: new (X ?? RO)(U.issues.map(($) => L4($, J, U4()))),
        }
      : { success: !0, data: U.value };
  },
  Ul = zO(DO),
  EO = (X) => async (Y, Q, G) => {
    let J = G ? Object.assign(G, { async: !0 }) : { async: !0 },
      U = Y._zod.run({ value: Q, issues: [] }, J);
    if (U instanceof Promise) U = await U;
    return U.issues.length
      ? { success: !1, error: new X(U.issues.map(($) => L4($, J, U4()))) }
      : { success: !0, data: U.value };
  },
  Ll = EO(DO),
  Bl = /^[cC][^\s-]{8,}$/,
  Kl = /^[0-9a-z]+$/,
  Vl = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,
  Fl = /^[0-9a-vA-V]{20}$/,
  Nl = /^[A-Za-z0-9]{27}$/,
  Ml = /^[a-zA-Z0-9_-]{21}$/,
  Al =
    /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,
  ql =
    /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,
  FE = (X) => {
    if (!X)
      return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
    return new RegExp(
      `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${X}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`
    );
  },
  Rl =
    /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
  Dl = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function zl() {
  return new RegExp(Dl, "u");
}
var El =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  Ol =
    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/,
  Zl =
    /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
  jl =
    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  wl =
    /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
  OO = /^[A-Za-z0-9_-]*$/,
  Cl = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/,
  Il = /^\+(?:[0-9]){6,14}[0-9]$/,
  ZO =
    "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))",
  Pl = new RegExp(`^${ZO}$`);
function jO(X) {
  return typeof X.precision === "number"
    ? X.precision === -1
      ? "(?:[01]\\d|2[0-3]):[0-5]\\d"
      : X.precision === 0
        ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"
        : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${X.precision}}`
    : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function Sl(X) {
  return new RegExp(`^${jO(X)}$`);
}
function Tl(X) {
  let Y = jO({ precision: X.precision }),
    Q = ["Z"];
  if (X.local) Q.push("");
  if (X.offset) Q.push("([+-]\\d{2}:\\d{2})");
  let G = `${Y}(?:${Q.join("|")})`;
  return new RegExp(`^${ZO}T(?:${G})$`);
}
var bl = (X) => {
    let Y = X
      ? `[\\s\\S]{${X?.minimum ?? 0},${X?.maximum ?? ""}}`
      : "[\\s\\S]*";
    return new RegExp(`^${Y}$`);
  },
  vl = /^\d+$/,
  kl = /^-?\d+(?:\.\d+)?/i,
  yl = /true|false/i,
  _l = /null/i,
  fl = /^[^A-Z]*$/,
  xl = /^[^a-z]*$/,
  B8 = R0("$ZodCheck", (X, Y) => {
    var Q;
    (X._zod ?? (X._zod = {}),
      (X._zod.def = Y),
      (Q = X._zod).onattach ?? (Q.onattach = []));
  }),
  wO = { number: "number", bigint: "bigint", object: "date" },
  CO = R0("$ZodCheckLessThan", (X, Y) => {
    B8.init(X, Y);
    let Q = wO[typeof Y.value];
    (X._zod.onattach.push((G) => {
      let J = G._zod.bag,
        U =
          (Y.inclusive ? J.maximum : J.exclusiveMaximum) ??
          Number.POSITIVE_INFINITY;
      if (Y.value < U)
        if (Y.inclusive) J.maximum = Y.value;
        else J.exclusiveMaximum = Y.value;
    }),
      (X._zod.check = (G) => {
        if (Y.inclusive ? G.value <= Y.value : G.value < Y.value) return;
        G.issues.push({
          origin: Q,
          code: "too_big",
          maximum: Y.value,
          input: G.value,
          inclusive: Y.inclusive,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  IO = R0("$ZodCheckGreaterThan", (X, Y) => {
    B8.init(X, Y);
    let Q = wO[typeof Y.value];
    (X._zod.onattach.push((G) => {
      let J = G._zod.bag,
        U =
          (Y.inclusive ? J.minimum : J.exclusiveMinimum) ??
          Number.NEGATIVE_INFINITY;
      if (Y.value > U)
        if (Y.inclusive) J.minimum = Y.value;
        else J.exclusiveMinimum = Y.value;
    }),
      (X._zod.check = (G) => {
        if (Y.inclusive ? G.value >= Y.value : G.value > Y.value) return;
        G.issues.push({
          origin: Q,
          code: "too_small",
          minimum: Y.value,
          input: G.value,
          inclusive: Y.inclusive,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  hl = R0("$ZodCheckMultipleOf", (X, Y) => {
    (B8.init(X, Y),
      X._zod.onattach.push((Q) => {
        var G;
        (G = Q._zod.bag).multipleOf ?? (G.multipleOf = Y.value);
      }),
      (X._zod.check = (Q) => {
        if (typeof Q.value !== typeof Y.value)
          throw Error("Cannot mix number and bigint in multiple_of check.");
        if (
          typeof Q.value === "bigint"
            ? Q.value % Y.value === BigInt(0)
            : BO(Q.value, Y.value) === 0
        )
          return;
        Q.issues.push({
          origin: typeof Q.value,
          code: "not_multiple_of",
          divisor: Y.value,
          input: Q.value,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  gl = R0("$ZodCheckNumberFormat", (X, Y) => {
    (B8.init(X, Y), (Y.format = Y.format || "float64"));
    let Q = Y.format?.includes("int"),
      G = Q ? "int" : "number",
      [J, U] = NO[Y.format];
    (X._zod.onattach.push(($) => {
      let B = $._zod.bag;
      if (((B.format = Y.format), (B.minimum = J), (B.maximum = U), Q))
        B.pattern = vl;
    }),
      (X._zod.check = ($) => {
        let B = $.value;
        if (Q) {
          if (!Number.isInteger(B)) {
            $.issues.push({
              expected: G,
              format: Y.format,
              code: "invalid_type",
              input: B,
              inst: X,
            });
            return;
          }
          if (!Number.isSafeInteger(B)) {
            if (B > 0)
              $.issues.push({
                input: B,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst: X,
                origin: G,
                continue: !Y.abort,
              });
            else
              $.issues.push({
                input: B,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst: X,
                origin: G,
                continue: !Y.abort,
              });
            return;
          }
        }
        if (B < J)
          $.issues.push({
            origin: "number",
            input: B,
            code: "too_small",
            minimum: J,
            inclusive: !0,
            inst: X,
            continue: !Y.abort,
          });
        if (B > U)
          $.issues.push({
            origin: "number",
            input: B,
            code: "too_big",
            maximum: U,
            inst: X,
          });
      }));
  }),
  ul = R0("$ZodCheckMaxLength", (X, Y) => {
    (B8.init(X, Y),
      (X._zod.when = (Q) => {
        let G = Q.value;
        return !MJ(G) && G.length !== void 0;
      }),
      X._zod.onattach.push((Q) => {
        let G = Q._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (Y.maximum < G) Q._zod.bag.maximum = Y.maximum;
      }),
      (X._zod.check = (Q) => {
        let G = Q.value;
        if (G.length <= Y.maximum) return;
        let U = qJ(G);
        Q.issues.push({
          origin: U,
          code: "too_big",
          maximum: Y.maximum,
          inclusive: !0,
          input: G,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  ll = R0("$ZodCheckMinLength", (X, Y) => {
    (B8.init(X, Y),
      (X._zod.when = (Q) => {
        let G = Q.value;
        return !MJ(G) && G.length !== void 0;
      }),
      X._zod.onattach.push((Q) => {
        let G = Q._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (Y.minimum > G) Q._zod.bag.minimum = Y.minimum;
      }),
      (X._zod.check = (Q) => {
        let G = Q.value;
        if (G.length >= Y.minimum) return;
        let U = qJ(G);
        Q.issues.push({
          origin: U,
          code: "too_small",
          minimum: Y.minimum,
          inclusive: !0,
          input: G,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  ml = R0("$ZodCheckLengthEquals", (X, Y) => {
    (B8.init(X, Y),
      (X._zod.when = (Q) => {
        let G = Q.value;
        return !MJ(G) && G.length !== void 0;
      }),
      X._zod.onattach.push((Q) => {
        let G = Q._zod.bag;
        ((G.minimum = Y.length), (G.maximum = Y.length), (G.length = Y.length));
      }),
      (X._zod.check = (Q) => {
        let G = Q.value,
          J = G.length;
        if (J === Y.length) return;
        let U = qJ(G),
          $ = J > Y.length;
        Q.issues.push({
          origin: U,
          ...($
            ? { code: "too_big", maximum: Y.length }
            : { code: "too_small", minimum: Y.length }),
          inclusive: !0,
          exact: !0,
          input: Q.value,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  RJ = R0("$ZodCheckStringFormat", (X, Y) => {
    var Q, G;
    if (
      (B8.init(X, Y),
      X._zod.onattach.push((J) => {
        let U = J._zod.bag;
        if (((U.format = Y.format), Y.pattern))
          (U.patterns ?? (U.patterns = new Set()), U.patterns.add(Y.pattern));
      }),
      Y.pattern)
    )
      (Q = X._zod).check ??
        (Q.check = (J) => {
          if (((Y.pattern.lastIndex = 0), Y.pattern.test(J.value))) return;
          J.issues.push({
            origin: "string",
            code: "invalid_format",
            format: Y.format,
            input: J.value,
            ...(Y.pattern ? { pattern: Y.pattern.toString() } : {}),
            inst: X,
            continue: !Y.abort,
          });
        });
    else (G = X._zod).check ?? (G.check = () => {});
  }),
  cl = R0("$ZodCheckRegex", (X, Y) => {
    (RJ.init(X, Y),
      (X._zod.check = (Q) => {
        if (((Y.pattern.lastIndex = 0), Y.pattern.test(Q.value))) return;
        Q.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: Q.value,
          pattern: Y.pattern.toString(),
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  dl = R0("$ZodCheckLowerCase", (X, Y) => {
    (Y.pattern ?? (Y.pattern = fl), RJ.init(X, Y));
  }),
  pl = R0("$ZodCheckUpperCase", (X, Y) => {
    (Y.pattern ?? (Y.pattern = xl), RJ.init(X, Y));
  }),
  il = R0("$ZodCheckIncludes", (X, Y) => {
    B8.init(X, Y);
    let Q = K7(Y.includes),
      G = new RegExp(
        typeof Y.position === "number" ? `^.{${Y.position}}${Q}` : Q
      );
    ((Y.pattern = G),
      X._zod.onattach.push((J) => {
        let U = J._zod.bag;
        (U.patterns ?? (U.patterns = new Set()), U.patterns.add(G));
      }),
      (X._zod.check = (J) => {
        if (J.value.includes(Y.includes, Y.position)) return;
        J.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: Y.includes,
          input: J.value,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  nl = R0("$ZodCheckStartsWith", (X, Y) => {
    B8.init(X, Y);
    let Q = new RegExp(`^${K7(Y.prefix)}.*`);
    (Y.pattern ?? (Y.pattern = Q),
      X._zod.onattach.push((G) => {
        let J = G._zod.bag;
        (J.patterns ?? (J.patterns = new Set()), J.patterns.add(Q));
      }),
      (X._zod.check = (G) => {
        if (G.value.startsWith(Y.prefix)) return;
        G.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: Y.prefix,
          input: G.value,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  al = R0("$ZodCheckEndsWith", (X, Y) => {
    B8.init(X, Y);
    let Q = new RegExp(`.*${K7(Y.suffix)}$`);
    (Y.pattern ?? (Y.pattern = Q),
      X._zod.onattach.push((G) => {
        let J = G._zod.bag;
        (J.patterns ?? (J.patterns = new Set()), J.patterns.add(Q));
      }),
      (X._zod.check = (G) => {
        if (G.value.endsWith(Y.suffix)) return;
        G.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: Y.suffix,
          input: G.value,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  rl = R0("$ZodCheckOverwrite", (X, Y) => {
    (B8.init(X, Y),
      (X._zod.check = (Q) => {
        Q.value = Y.tx(Q.value);
      }));
  });
class PO {
  constructor(X = []) {
    if (((this.content = []), (this.indent = 0), this)) this.args = X;
  }
  indented(X) {
    ((this.indent += 1), X(this), (this.indent -= 1));
  }
  write(X) {
    if (typeof X === "function") {
      (X(this, { execution: "sync" }), X(this, { execution: "async" }));
      return;
    }
    let Q = X.split(
        `
`
      ).filter((U) => U),
      G = Math.min(...Q.map((U) => U.length - U.trimStart().length)),
      J = Q.map((U) => U.slice(G)).map((U) => " ".repeat(this.indent * 2) + U);
    for (let U of J) this.content.push(U);
  }
  compile() {
    let X = Function,
      Y = this?.args,
      G = [...(this?.content ?? [""]).map((J) => `  ${J}`)];
    return new X(
      ...Y,
      G.join(`
`)
    );
  }
}
var ol = { major: 4, minor: 0, patch: 0 },
  G5 = R0("$ZodType", (X, Y) => {
    var Q;
    (X ?? (X = {}),
      (X._zod.def = Y),
      (X._zod.bag = X._zod.bag || {}),
      (X._zod.version = ol));
    let G = [...(X._zod.def.checks ?? [])];
    if (X._zod.traits.has("$ZodCheck")) G.unshift(X);
    for (let J of G) for (let U of J._zod.onattach) U(X);
    if (G.length === 0)
      ((Q = X._zod).deferred ?? (Q.deferred = []),
        X._zod.deferred?.push(() => {
          X._zod.run = X._zod.parse;
        }));
    else {
      let J = (U, $, B) => {
        let K = X7(U),
          V;
        for (let W of $) {
          if (W._zod.when) {
            if (!W._zod.when(U)) continue;
          } else if (K) continue;
          let L = U.issues.length,
            H = W._zod.check(U);
          if (H instanceof Promise && B?.async === !1) throw new H7();
          if (V || H instanceof Promise)
            V = (V ?? Promise.resolve()).then(async () => {
              if ((await H, U.issues.length === L)) return;
              if (!K) K = X7(U, L);
            });
          else {
            if (U.issues.length === L) continue;
            if (!K) K = X7(U, L);
          }
        }
        if (V)
          return V.then(() => {
            return U;
          });
        return U;
      };
      X._zod.run = (U, $) => {
        let B = X._zod.parse(U, $);
        if (B instanceof Promise) {
          if ($.async === !1) throw new H7();
          return B.then((K) => J(K, G, $));
        }
        return J(B, G, $);
      };
    }
    X["~standard"] = {
      validate: (J) => {
        try {
          let U = Ul(X, J);
          return U.success ? { value: U.data } : { issues: U.error?.issues };
        } catch (U) {
          return Ll(X, J).then(($) =>
            $.success ? { value: $.data } : { issues: $.error?.issues }
          );
        }
      },
      vendor: "zod",
      version: 1,
    };
  }),
  rU = R0("$ZodString", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.pattern =
        [...(X?._zod.bag?.patterns ?? [])].pop() ?? bl(X._zod.bag)),
      (X._zod.parse = (Q, G) => {
        if (Y.coerce)
          try {
            Q.value = String(Q.value);
          } catch (J) {}
        if (typeof Q.value === "string") return Q;
        return (
          Q.issues.push({
            expected: "string",
            code: "invalid_type",
            input: Q.value,
            inst: X,
          }),
          Q
        );
      }));
  }),
  H5 = R0("$ZodStringFormat", (X, Y) => {
    (RJ.init(X, Y), rU.init(X, Y));
  }),
  sl = R0("$ZodGUID", (X, Y) => {
    (Y.pattern ?? (Y.pattern = ql), H5.init(X, Y));
  }),
  tl = R0("$ZodUUID", (X, Y) => {
    if (Y.version) {
      let G = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[
        Y.version
      ];
      if (G === void 0) throw Error(`Invalid UUID version: "${Y.version}"`);
      Y.pattern ?? (Y.pattern = FE(G));
    } else Y.pattern ?? (Y.pattern = FE());
    H5.init(X, Y);
  }),
  el = R0("$ZodEmail", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Rl), H5.init(X, Y));
  }),
  Xm = R0("$ZodURL", (X, Y) => {
    (H5.init(X, Y),
      (X._zod.check = (Q) => {
        try {
          let G = Q.value,
            J = new URL(G),
            U = J.href;
          if (Y.hostname) {
            if (((Y.hostname.lastIndex = 0), !Y.hostname.test(J.hostname)))
              Q.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: Cl.source,
                input: Q.value,
                inst: X,
                continue: !Y.abort,
              });
          }
          if (Y.protocol) {
            if (
              ((Y.protocol.lastIndex = 0),
              !Y.protocol.test(
                J.protocol.endsWith(":") ? J.protocol.slice(0, -1) : J.protocol
              ))
            )
              Q.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: Y.protocol.source,
                input: Q.value,
                inst: X,
                continue: !Y.abort,
              });
          }
          if (!G.endsWith("/") && U.endsWith("/")) Q.value = U.slice(0, -1);
          else Q.value = U;
          return;
        } catch (G) {
          Q.issues.push({
            code: "invalid_format",
            format: "url",
            input: Q.value,
            inst: X,
            continue: !Y.abort,
          });
        }
      }));
  }),
  Ym = R0("$ZodEmoji", (X, Y) => {
    (Y.pattern ?? (Y.pattern = zl()), H5.init(X, Y));
  }),
  Qm = R0("$ZodNanoID", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Ml), H5.init(X, Y));
  }),
  Gm = R0("$ZodCUID", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Bl), H5.init(X, Y));
  }),
  Jm = R0("$ZodCUID2", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Kl), H5.init(X, Y));
  }),
  Wm = R0("$ZodULID", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Vl), H5.init(X, Y));
  }),
  Hm = R0("$ZodXID", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Fl), H5.init(X, Y));
  }),
  $m = R0("$ZodKSUID", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Nl), H5.init(X, Y));
  }),
  Um = R0("$ZodISODateTime", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Tl(Y)), H5.init(X, Y));
  }),
  Lm = R0("$ZodISODate", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Pl), H5.init(X, Y));
  }),
  Bm = R0("$ZodISOTime", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Sl(Y)), H5.init(X, Y));
  }),
  Km = R0("$ZodISODuration", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Al), H5.init(X, Y));
  }),
  Vm = R0("$ZodIPv4", (X, Y) => {
    (Y.pattern ?? (Y.pattern = El),
      H5.init(X, Y),
      X._zod.onattach.push((Q) => {
        let G = Q._zod.bag;
        G.format = "ipv4";
      }));
  }),
  Fm = R0("$ZodIPv6", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Ol),
      H5.init(X, Y),
      X._zod.onattach.push((Q) => {
        let G = Q._zod.bag;
        G.format = "ipv6";
      }),
      (X._zod.check = (Q) => {
        try {
          new URL(`http://[${Q.value}]`);
        } catch {
          Q.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: Q.value,
            inst: X,
            continue: !Y.abort,
          });
        }
      }));
  }),
  Nm = R0("$ZodCIDRv4", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Zl), H5.init(X, Y));
  }),
  Mm = R0("$ZodCIDRv6", (X, Y) => {
    (Y.pattern ?? (Y.pattern = jl),
      H5.init(X, Y),
      (X._zod.check = (Q) => {
        let [G, J] = Q.value.split("/");
        try {
          if (!J) throw Error();
          let U = Number(J);
          if (`${U}` !== J) throw Error();
          if (U < 0 || U > 128) throw Error();
          new URL(`http://[${G}]`);
        } catch {
          Q.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: Q.value,
            inst: X,
            continue: !Y.abort,
          });
        }
      }));
  });
function SO(X) {
  if (X === "") return !0;
  if (X.length % 4 !== 0) return !1;
  try {
    return (atob(X), !0);
  } catch {
    return !1;
  }
}
var Am = R0("$ZodBase64", (X, Y) => {
  (Y.pattern ?? (Y.pattern = wl),
    H5.init(X, Y),
    X._zod.onattach.push((Q) => {
      Q._zod.bag.contentEncoding = "base64";
    }),
    (X._zod.check = (Q) => {
      if (SO(Q.value)) return;
      Q.issues.push({
        code: "invalid_format",
        format: "base64",
        input: Q.value,
        inst: X,
        continue: !Y.abort,
      });
    }));
});
function qm(X) {
  if (!OO.test(X)) return !1;
  let Y = X.replace(/[-_]/g, (G) => (G === "-" ? "+" : "/")),
    Q = Y.padEnd(Math.ceil(Y.length / 4) * 4, "=");
  return SO(Q);
}
var Rm = R0("$ZodBase64URL", (X, Y) => {
    (Y.pattern ?? (Y.pattern = OO),
      H5.init(X, Y),
      X._zod.onattach.push((Q) => {
        Q._zod.bag.contentEncoding = "base64url";
      }),
      (X._zod.check = (Q) => {
        if (qm(Q.value)) return;
        Q.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: Q.value,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  Dm = R0("$ZodE164", (X, Y) => {
    (Y.pattern ?? (Y.pattern = Il), H5.init(X, Y));
  });
function zm(X, Y = null) {
  try {
    let Q = X.split(".");
    if (Q.length !== 3) return !1;
    let [G] = Q;
    if (!G) return !1;
    let J = JSON.parse(atob(G));
    if ("typ" in J && J?.typ !== "JWT") return !1;
    if (!J.alg) return !1;
    if (Y && (!("alg" in J) || J.alg !== Y)) return !1;
    return !0;
  } catch {
    return !1;
  }
}
var Em = R0("$ZodJWT", (X, Y) => {
    (H5.init(X, Y),
      (X._zod.check = (Q) => {
        if (zm(Q.value, Y.alg)) return;
        Q.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: Q.value,
          inst: X,
          continue: !Y.abort,
        });
      }));
  }),
  TO = R0("$ZodNumber", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.pattern = X._zod.bag.pattern ?? kl),
      (X._zod.parse = (Q, G) => {
        if (Y.coerce)
          try {
            Q.value = Number(Q.value);
          } catch ($) {}
        let J = Q.value;
        if (typeof J === "number" && !Number.isNaN(J) && Number.isFinite(J))
          return Q;
        let U =
          typeof J === "number"
            ? Number.isNaN(J)
              ? "NaN"
              : !Number.isFinite(J)
                ? "Infinity"
                : void 0
            : void 0;
        return (
          Q.issues.push({
            expected: "number",
            code: "invalid_type",
            input: J,
            inst: X,
            ...(U ? { received: U } : {}),
          }),
          Q
        );
      }));
  }),
  Om = R0("$ZodNumber", (X, Y) => {
    (gl.init(X, Y), TO.init(X, Y));
  }),
  Zm = R0("$ZodBoolean", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.pattern = yl),
      (X._zod.parse = (Q, G) => {
        if (Y.coerce)
          try {
            Q.value = Boolean(Q.value);
          } catch (U) {}
        let J = Q.value;
        if (typeof J === "boolean") return Q;
        return (
          Q.issues.push({
            expected: "boolean",
            code: "invalid_type",
            input: J,
            inst: X,
          }),
          Q
        );
      }));
  }),
  jm = R0("$ZodNull", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.pattern = _l),
      (X._zod.values = new Set([null])),
      (X._zod.parse = (Q, G) => {
        let J = Q.value;
        if (J === null) return Q;
        return (
          Q.issues.push({
            expected: "null",
            code: "invalid_type",
            input: J,
            inst: X,
          }),
          Q
        );
      }));
  }),
  wm = R0("$ZodUnknown", (X, Y) => {
    (G5.init(X, Y), (X._zod.parse = (Q) => Q));
  }),
  Cm = R0("$ZodNever", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.parse = (Q, G) => {
        return (
          Q.issues.push({
            expected: "never",
            code: "invalid_type",
            input: Q.value,
            inst: X,
          }),
          Q
        );
      }));
  });
function NE(X, Y, Q) {
  if (X.issues.length) Y.issues.push(...x4(Q, X.issues));
  Y.value[Q] = X.value;
}
var Im = R0("$ZodArray", (X, Y) => {
  (G5.init(X, Y),
    (X._zod.parse = (Q, G) => {
      let J = Q.value;
      if (!Array.isArray(J))
        return (
          Q.issues.push({
            expected: "array",
            code: "invalid_type",
            input: J,
            inst: X,
          }),
          Q
        );
      Q.value = Array(J.length);
      let U = [];
      for (let $ = 0; $ < J.length; $++) {
        let B = J[$],
          K = Y.element._zod.run({ value: B, issues: [] }, G);
        if (K instanceof Promise) U.push(K.then((V) => NE(V, Q, $)));
        else NE(K, Q, $);
      }
      if (U.length) return Promise.all(U).then(() => Q);
      return Q;
    }));
});
function hG(X, Y, Q) {
  if (X.issues.length) Y.issues.push(...x4(Q, X.issues));
  Y.value[Q] = X.value;
}
function ME(X, Y, Q, G) {
  if (X.issues.length)
    if (G[Q] === void 0)
      if (Q in G) Y.value[Q] = void 0;
      else Y.value[Q] = X.value;
    else Y.issues.push(...x4(Q, X.issues));
  else if (X.value === void 0) {
    if (Q in G) Y.value[Q] = void 0;
  } else Y.value[Q] = X.value;
}
var Pm = R0("$ZodObject", (X, Y) => {
  G5.init(X, Y);
  let Q = NJ(() => {
    let L = Object.keys(Y.shape);
    for (let F of L)
      if (!(Y.shape[F] instanceof G5))
        throw Error(`Invalid element at key "${F}": expected a Zod schema`);
    let H = FO(Y.shape);
    return {
      shape: Y.shape,
      keys: L,
      keySet: new Set(L),
      numKeys: L.length,
      optionalKeys: new Set(H),
    };
  });
  Q5(X._zod, "propValues", () => {
    let L = Y.shape,
      H = {};
    for (let F in L) {
      let N = L[F]._zod;
      if (N.values) {
        H[F] ?? (H[F] = new Set());
        for (let q of N.values) H[F].add(q);
      }
    }
    return H;
  });
  let G = (L) => {
      let H = new PO(["shape", "payload", "ctx"]),
        F = Q.value,
        N = (D) => {
          let R = tX(D);
          return `shape[${R}]._zod.run({ value: input[${R}], issues: [] }, ctx)`;
        };
      H.write("const input = payload.value;");
      let q = Object.create(null),
        M = 0;
      for (let D of F.keys) q[D] = `key_${M++}`;
      H.write("const newResult = {}");
      for (let D of F.keys)
        if (F.optionalKeys.has(D)) {
          let R = q[D];
          H.write(`const ${R} = ${N(D)};`);
          let z = tX(D);
          H.write(`
        if (${R}.issues.length) {
          if (input[${z}] === undefined) {
            if (${z} in input) {
              newResult[${z}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${R}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${z}, ...iss.path] : [${z}],
              }))
            );
          }
        } else if (${R}.value === undefined) {
          if (${z} in input) newResult[${z}] = undefined;
        } else {
          newResult[${z}] = ${R}.value;
        }
        `);
        } else {
          let R = q[D];
          (H.write(`const ${R} = ${N(D)};`),
            H.write(`
          if (${R}.issues.length) payload.issues = payload.issues.concat(${R}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${tX(D)}, ...iss.path] : [${tX(D)}]
          })));`),
            H.write(`newResult[${tX(D)}] = ${R}.value`));
        }
      (H.write("payload.value = newResult;"), H.write("return payload;"));
      let A = H.compile();
      return (D, R) => A(L, D, R);
    },
    J,
    U = nY,
    $ = !bU.jitless,
    K = $ && KO.value,
    V = Y.catchall,
    W;
  X._zod.parse = (L, H) => {
    W ?? (W = Q.value);
    let F = L.value;
    if (!U(F))
      return (
        L.issues.push({
          expected: "object",
          code: "invalid_type",
          input: F,
          inst: X,
        }),
        L
      );
    let N = [];
    if ($ && K && H?.async === !1 && H.jitless !== !0) {
      if (!J) J = G(Y.shape);
      L = J(L, H);
    } else {
      L.value = {};
      let R = W.shape;
      for (let z of W.keys) {
        let E = R[z],
          O = E._zod.run({ value: F[z], issues: [] }, H),
          Z = E._zod.optin === "optional" && E._zod.optout === "optional";
        if (O instanceof Promise)
          N.push(O.then((j) => (Z ? ME(j, L, z, F) : hG(j, L, z))));
        else if (Z) ME(O, L, z, F);
        else hG(O, L, z);
      }
    }
    if (!V) return N.length ? Promise.all(N).then(() => L) : L;
    let q = [],
      M = W.keySet,
      A = V._zod,
      D = A.def.type;
    for (let R of Object.keys(F)) {
      if (M.has(R)) continue;
      if (D === "never") {
        q.push(R);
        continue;
      }
      let z = A.run({ value: F[R], issues: [] }, H);
      if (z instanceof Promise) N.push(z.then((E) => hG(E, L, R)));
      else hG(z, L, R);
    }
    if (q.length)
      L.issues.push({ code: "unrecognized_keys", keys: q, input: F, inst: X });
    if (!N.length) return L;
    return Promise.all(N).then(() => {
      return L;
    });
  };
});
function AE(X, Y, Q, G) {
  for (let J of X) if (J.issues.length === 0) return ((Y.value = J.value), Y);
  return (
    Y.issues.push({
      code: "invalid_union",
      input: Y.value,
      inst: Q,
      errors: X.map((J) => J.issues.map((U) => L4(U, G, U4()))),
    }),
    Y
  );
}
var bO = R0("$ZodUnion", (X, Y) => {
    (G5.init(X, Y),
      Q5(X._zod, "optin", () =>
        Y.options.some((Q) => Q._zod.optin === "optional") ? "optional" : void 0
      ),
      Q5(X._zod, "optout", () =>
        Y.options.some((Q) => Q._zod.optout === "optional")
          ? "optional"
          : void 0
      ),
      Q5(X._zod, "values", () => {
        if (Y.options.every((Q) => Q._zod.values))
          return new Set(Y.options.flatMap((Q) => Array.from(Q._zod.values)));
        return;
      }),
      Q5(X._zod, "pattern", () => {
        if (Y.options.every((Q) => Q._zod.pattern)) {
          let Q = Y.options.map((G) => G._zod.pattern);
          return new RegExp(`^(${Q.map((G) => AJ(G.source)).join("|")})$`);
        }
        return;
      }),
      (X._zod.parse = (Q, G) => {
        let J = !1,
          U = [];
        for (let $ of Y.options) {
          let B = $._zod.run({ value: Q.value, issues: [] }, G);
          if (B instanceof Promise) (U.push(B), (J = !0));
          else {
            if (B.issues.length === 0) return B;
            U.push(B);
          }
        }
        if (!J) return AE(U, Q, X, G);
        return Promise.all(U).then(($) => {
          return AE($, Q, X, G);
        });
      }));
  }),
  Sm = R0("$ZodDiscriminatedUnion", (X, Y) => {
    bO.init(X, Y);
    let Q = X._zod.parse;
    Q5(X._zod, "propValues", () => {
      let J = {};
      for (let U of Y.options) {
        let $ = U._zod.propValues;
        if (!$ || Object.keys($).length === 0)
          throw Error(
            `Invalid discriminated union option at index "${Y.options.indexOf(U)}"`
          );
        for (let [B, K] of Object.entries($)) {
          if (!J[B]) J[B] = new Set();
          for (let V of K) J[B].add(V);
        }
      }
      return J;
    });
    let G = NJ(() => {
      let J = Y.options,
        U = new Map();
      for (let $ of J) {
        let B = $._zod.propValues[Y.discriminator];
        if (!B || B.size === 0)
          throw Error(
            `Invalid discriminated union option at index "${Y.options.indexOf($)}"`
          );
        for (let K of B) {
          if (U.has(K))
            throw Error(`Duplicate discriminator value "${String(K)}"`);
          U.set(K, $);
        }
      }
      return U;
    });
    X._zod.parse = (J, U) => {
      let $ = J.value;
      if (!nY($))
        return (
          J.issues.push({
            code: "invalid_type",
            expected: "object",
            input: $,
            inst: X,
          }),
          J
        );
      let B = G.value.get($?.[Y.discriminator]);
      if (B) return B._zod.run(J, U);
      if (Y.unionFallback) return Q(J, U);
      return (
        J.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          input: $,
          path: [Y.discriminator],
          inst: X,
        }),
        J
      );
    };
  }),
  Tm = R0("$ZodIntersection", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.parse = (Q, G) => {
        let J = Q.value,
          U = Y.left._zod.run({ value: J, issues: [] }, G),
          $ = Y.right._zod.run({ value: J, issues: [] }, G);
        if (U instanceof Promise || $ instanceof Promise)
          return Promise.all([U, $]).then(([K, V]) => {
            return qE(Q, K, V);
          });
        return qE(Q, U, $);
      }));
  });
function kU(X, Y) {
  if (X === Y) return { valid: !0, data: X };
  if (X instanceof Date && Y instanceof Date && +X === +Y)
    return { valid: !0, data: X };
  if (aY(X) && aY(Y)) {
    let Q = Object.keys(Y),
      G = Object.keys(X).filter((U) => Q.indexOf(U) !== -1),
      J = { ...X, ...Y };
    for (let U of G) {
      let $ = kU(X[U], Y[U]);
      if (!$.valid)
        return { valid: !1, mergeErrorPath: [U, ...$.mergeErrorPath] };
      J[U] = $.data;
    }
    return { valid: !0, data: J };
  }
  if (Array.isArray(X) && Array.isArray(Y)) {
    if (X.length !== Y.length) return { valid: !1, mergeErrorPath: [] };
    let Q = [];
    for (let G = 0; G < X.length; G++) {
      let J = X[G],
        U = Y[G],
        $ = kU(J, U);
      if (!$.valid)
        return { valid: !1, mergeErrorPath: [G, ...$.mergeErrorPath] };
      Q.push($.data);
    }
    return { valid: !0, data: Q };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function qE(X, Y, Q) {
  if (Y.issues.length) X.issues.push(...Y.issues);
  if (Q.issues.length) X.issues.push(...Q.issues);
  if (X7(X)) return X;
  let G = kU(Y.value, Q.value);
  if (!G.valid)
    throw Error(
      `Unmergable intersection. Error path: ${JSON.stringify(G.mergeErrorPath)}`
    );
  return ((X.value = G.data), X);
}
var bm = R0("$ZodRecord", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.parse = (Q, G) => {
        let J = Q.value;
        if (!aY(J))
          return (
            Q.issues.push({
              expected: "record",
              code: "invalid_type",
              input: J,
              inst: X,
            }),
            Q
          );
        let U = [];
        if (Y.keyType._zod.values) {
          let $ = Y.keyType._zod.values;
          Q.value = {};
          for (let K of $)
            if (
              typeof K === "string" ||
              typeof K === "number" ||
              typeof K === "symbol"
            ) {
              let V = Y.valueType._zod.run({ value: J[K], issues: [] }, G);
              if (V instanceof Promise)
                U.push(
                  V.then((W) => {
                    if (W.issues.length) Q.issues.push(...x4(K, W.issues));
                    Q.value[K] = W.value;
                  })
                );
              else {
                if (V.issues.length) Q.issues.push(...x4(K, V.issues));
                Q.value[K] = V.value;
              }
            }
          let B;
          for (let K in J) if (!$.has(K)) ((B = B ?? []), B.push(K));
          if (B && B.length > 0)
            Q.issues.push({
              code: "unrecognized_keys",
              input: J,
              inst: X,
              keys: B,
            });
        } else {
          Q.value = {};
          for (let $ of Reflect.ownKeys(J)) {
            if ($ === "__proto__") continue;
            let B = Y.keyType._zod.run({ value: $, issues: [] }, G);
            if (B instanceof Promise)
              throw Error(
                "Async schemas not supported in object keys currently"
              );
            if (B.issues.length) {
              (Q.issues.push({
                origin: "record",
                code: "invalid_key",
                issues: B.issues.map((V) => L4(V, G, U4())),
                input: $,
                path: [$],
                inst: X,
              }),
                (Q.value[B.value] = B.value));
              continue;
            }
            let K = Y.valueType._zod.run({ value: J[$], issues: [] }, G);
            if (K instanceof Promise)
              U.push(
                K.then((V) => {
                  if (V.issues.length) Q.issues.push(...x4($, V.issues));
                  Q.value[B.value] = V.value;
                })
              );
            else {
              if (K.issues.length) Q.issues.push(...x4($, K.issues));
              Q.value[B.value] = K.value;
            }
          }
        }
        if (U.length) return Promise.all(U).then(() => Q);
        return Q;
      }));
  }),
  vm = R0("$ZodEnum", (X, Y) => {
    G5.init(X, Y);
    let Q = UO(Y.entries);
    ((X._zod.values = new Set(Q)),
      (X._zod.pattern = new RegExp(
        `^(${Q.filter((G) => VO.has(typeof G))
          .map((G) => (typeof G === "string" ? K7(G) : G.toString()))
          .join("|")})$`
      )),
      (X._zod.parse = (G, J) => {
        let U = G.value;
        if (X._zod.values.has(U)) return G;
        return (
          G.issues.push({
            code: "invalid_value",
            values: Q,
            input: U,
            inst: X,
          }),
          G
        );
      }));
  }),
  km = R0("$ZodLiteral", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.values = new Set(Y.values)),
      (X._zod.pattern = new RegExp(
        `^(${Y.values.map((Q) => (typeof Q === "string" ? K7(Q) : Q ? Q.toString() : String(Q))).join("|")})$`
      )),
      (X._zod.parse = (Q, G) => {
        let J = Q.value;
        if (X._zod.values.has(J)) return Q;
        return (
          Q.issues.push({
            code: "invalid_value",
            values: Y.values,
            input: J,
            inst: X,
          }),
          Q
        );
      }));
  }),
  ym = R0("$ZodTransform", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.parse = (Q, G) => {
        let J = Y.transform(Q.value, Q);
        if (G.async)
          return (J instanceof Promise ? J : Promise.resolve(J)).then(($) => {
            return ((Q.value = $), Q);
          });
        if (J instanceof Promise) throw new H7();
        return ((Q.value = J), Q);
      }));
  }),
  _m = R0("$ZodOptional", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.optin = "optional"),
      (X._zod.optout = "optional"),
      Q5(X._zod, "values", () => {
        return Y.innerType._zod.values
          ? new Set([...Y.innerType._zod.values, void 0])
          : void 0;
      }),
      Q5(X._zod, "pattern", () => {
        let Q = Y.innerType._zod.pattern;
        return Q ? new RegExp(`^(${AJ(Q.source)})?$`) : void 0;
      }),
      (X._zod.parse = (Q, G) => {
        if (Y.innerType._zod.optin === "optional")
          return Y.innerType._zod.run(Q, G);
        if (Q.value === void 0) return Q;
        return Y.innerType._zod.run(Q, G);
      }));
  }),
  fm = R0("$ZodNullable", (X, Y) => {
    (G5.init(X, Y),
      Q5(X._zod, "optin", () => Y.innerType._zod.optin),
      Q5(X._zod, "optout", () => Y.innerType._zod.optout),
      Q5(X._zod, "pattern", () => {
        let Q = Y.innerType._zod.pattern;
        return Q ? new RegExp(`^(${AJ(Q.source)}|null)$`) : void 0;
      }),
      Q5(X._zod, "values", () => {
        return Y.innerType._zod.values
          ? new Set([...Y.innerType._zod.values, null])
          : void 0;
      }),
      (X._zod.parse = (Q, G) => {
        if (Q.value === null) return Q;
        return Y.innerType._zod.run(Q, G);
      }));
  }),
  xm = R0("$ZodDefault", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.optin = "optional"),
      Q5(X._zod, "values", () => Y.innerType._zod.values),
      (X._zod.parse = (Q, G) => {
        if (Q.value === void 0) return ((Q.value = Y.defaultValue), Q);
        let J = Y.innerType._zod.run(Q, G);
        if (J instanceof Promise) return J.then((U) => RE(U, Y));
        return RE(J, Y);
      }));
  });
function RE(X, Y) {
  if (X.value === void 0) X.value = Y.defaultValue;
  return X;
}
var hm = R0("$ZodPrefault", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.optin = "optional"),
      Q5(X._zod, "values", () => Y.innerType._zod.values),
      (X._zod.parse = (Q, G) => {
        if (Q.value === void 0) Q.value = Y.defaultValue;
        return Y.innerType._zod.run(Q, G);
      }));
  }),
  gm = R0("$ZodNonOptional", (X, Y) => {
    (G5.init(X, Y),
      Q5(X._zod, "values", () => {
        let Q = Y.innerType._zod.values;
        return Q ? new Set([...Q].filter((G) => G !== void 0)) : void 0;
      }),
      (X._zod.parse = (Q, G) => {
        let J = Y.innerType._zod.run(Q, G);
        if (J instanceof Promise) return J.then((U) => DE(U, X));
        return DE(J, X);
      }));
  });
function DE(X, Y) {
  if (!X.issues.length && X.value === void 0)
    X.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: X.value,
      inst: Y,
    });
  return X;
}
var um = R0("$ZodCatch", (X, Y) => {
    (G5.init(X, Y),
      (X._zod.optin = "optional"),
      Q5(X._zod, "optout", () => Y.innerType._zod.optout),
      Q5(X._zod, "values", () => Y.innerType._zod.values),
      (X._zod.parse = (Q, G) => {
        let J = Y.innerType._zod.run(Q, G);
        if (J instanceof Promise)
          return J.then((U) => {
            if (((Q.value = U.value), U.issues.length))
              ((Q.value = Y.catchValue({
                ...Q,
                error: { issues: U.issues.map(($) => L4($, G, U4())) },
                input: Q.value,
              })),
                (Q.issues = []));
            return Q;
          });
        if (((Q.value = J.value), J.issues.length))
          ((Q.value = Y.catchValue({
            ...Q,
            error: { issues: J.issues.map((U) => L4(U, G, U4())) },
            input: Q.value,
          })),
            (Q.issues = []));
        return Q;
      }));
  }),
  lm = R0("$ZodPipe", (X, Y) => {
    (G5.init(X, Y),
      Q5(X._zod, "values", () => Y.in._zod.values),
      Q5(X._zod, "optin", () => Y.in._zod.optin),
      Q5(X._zod, "optout", () => Y.out._zod.optout),
      (X._zod.parse = (Q, G) => {
        let J = Y.in._zod.run(Q, G);
        if (J instanceof Promise) return J.then((U) => zE(U, Y, G));
        return zE(J, Y, G);
      }));
  });
function zE(X, Y, Q) {
  if (X7(X)) return X;
  return Y.out._zod.run({ value: X.value, issues: X.issues }, Q);
}
var mm = R0("$ZodReadonly", (X, Y) => {
  (G5.init(X, Y),
    Q5(X._zod, "propValues", () => Y.innerType._zod.propValues),
    Q5(X._zod, "values", () => Y.innerType._zod.values),
    Q5(X._zod, "optin", () => Y.innerType._zod.optin),
    Q5(X._zod, "optout", () => Y.innerType._zod.optout),
    (X._zod.parse = (Q, G) => {
      let J = Y.innerType._zod.run(Q, G);
      if (J instanceof Promise) return J.then(EE);
      return EE(J);
    }));
});
function EE(X) {
  return ((X.value = Object.freeze(X.value)), X);
}
var cm = R0("$ZodCustom", (X, Y) => {
  (B8.init(X, Y),
    G5.init(X, Y),
    (X._zod.parse = (Q, G) => {
      return Q;
    }),
    (X._zod.check = (Q) => {
      let G = Q.value,
        J = Y.fn(G);
      if (J instanceof Promise) return J.then((U) => OE(U, Q, G, X));
      OE(J, Q, G, X);
      return;
    }));
});
function OE(X, Y, Q, G) {
  if (!X) {
    let J = {
      code: "custom",
      input: Q,
      inst: G,
      path: [...(G._zod.def.path ?? [])],
      continue: !G._zod.def.abort,
    };
    if (G._zod.def.params) J.params = G._zod.def.params;
    Y.issues.push(MO(J));
  }
}
var dm = (X) => {
    let Y = typeof X;
    switch (Y) {
      case "number":
        return Number.isNaN(X) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(X)) return "array";
        if (X === null) return "null";
        if (Object.getPrototypeOf(X) !== Object.prototype && X.constructor)
          return X.constructor.name;
      }
    }
    return Y;
  },
  pm = () => {
    let X = {
      string: { unit: "characters", verb: "to have" },
      file: { unit: "bytes", verb: "to have" },
      array: { unit: "items", verb: "to have" },
      set: { unit: "items", verb: "to have" },
    };
    function Y(G) {
      return X[G] ?? null;
    }
    let Q = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input",
    };
    return (G) => {
      switch (G.code) {
        case "invalid_type":
          return `Invalid input: expected ${G.expected}, received ${dm(G.input)}`;
        case "invalid_value":
          if (G.values.length === 1)
            return `Invalid input: expected ${aU(G.values[0])}`;
          return `Invalid option: expected one of ${vU(G.values, "|")}`;
        case "too_big": {
          let J = G.inclusive ? "<=" : "<",
            U = Y(G.origin);
          if (U)
            return `Too big: expected ${G.origin ?? "value"} to have ${J}${G.maximum.toString()} ${U.unit ?? "elements"}`;
          return `Too big: expected ${G.origin ?? "value"} to be ${J}${G.maximum.toString()}`;
        }
        case "too_small": {
          let J = G.inclusive ? ">=" : ">",
            U = Y(G.origin);
          if (U)
            return `Too small: expected ${G.origin} to have ${J}${G.minimum.toString()} ${U.unit}`;
          return `Too small: expected ${G.origin} to be ${J}${G.minimum.toString()}`;
        }
        case "invalid_format": {
          let J = G;
          if (J.format === "starts_with")
            return `Invalid string: must start with "${J.prefix}"`;
          if (J.format === "ends_with")
            return `Invalid string: must end with "${J.suffix}"`;
          if (J.format === "includes")
            return `Invalid string: must include "${J.includes}"`;
          if (J.format === "regex")
            return `Invalid string: must match pattern ${J.pattern}`;
          return `Invalid ${Q[J.format] ?? G.format}`;
        }
        case "not_multiple_of":
          return `Invalid number: must be a multiple of ${G.divisor}`;
        case "unrecognized_keys":
          return `Unrecognized key${G.keys.length > 1 ? "s" : ""}: ${vU(G.keys, ", ")}`;
        case "invalid_key":
          return `Invalid key in ${G.origin}`;
        case "invalid_union":
          return "Invalid input";
        case "invalid_element":
          return `Invalid value in ${G.origin}`;
        default:
          return "Invalid input";
      }
    };
  };
function im() {
  return { localeError: pm() };
}
var XW0 = Symbol("ZodOutput"),
  YW0 = Symbol("ZodInput");
class vO {
  constructor() {
    ((this._map = new WeakMap()), (this._idmap = new Map()));
  }
  add(X, ...Y) {
    let Q = Y[0];
    if ((this._map.set(X, Q), Q && typeof Q === "object" && "id" in Q)) {
      if (this._idmap.has(Q.id))
        throw Error(`ID ${Q.id} already exists in the registry`);
      this._idmap.set(Q.id, X);
    }
    return this;
  }
  remove(X) {
    return (this._map.delete(X), this);
  }
  get(X) {
    let Y = X._zod.parent;
    if (Y) {
      let Q = { ...(this.get(Y) ?? {}) };
      return (delete Q.id, { ...Q, ...this._map.get(X) });
    }
    return this._map.get(X);
  }
  has(X) {
    return this._map.has(X);
  }
}
function nm() {
  return new vO();
}
var gG = nm();
function am(X, Y) {
  return new X({ type: "string", ...a0(Y) });
}
function rm(X, Y) {
  return new X({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function ZE(X, Y) {
  return new X({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function om(X, Y) {
  return new X({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function sm(X, Y) {
  return new X({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...a0(Y),
  });
}
function tm(X, Y) {
  return new X({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...a0(Y),
  });
}
function em(X, Y) {
  return new X({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...a0(Y),
  });
}
function Xc(X, Y) {
  return new X({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Yc(X, Y) {
  return new X({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Qc(X, Y) {
  return new X({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Gc(X, Y) {
  return new X({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Jc(X, Y) {
  return new X({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Wc(X, Y) {
  return new X({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Hc(X, Y) {
  return new X({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function $c(X, Y) {
  return new X({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Uc(X, Y) {
  return new X({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Lc(X, Y) {
  return new X({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Bc(X, Y) {
  return new X({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Kc(X, Y) {
  return new X({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Vc(X, Y) {
  return new X({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Fc(X, Y) {
  return new X({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Nc(X, Y) {
  return new X({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Mc(X, Y) {
  return new X({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...a0(Y),
  });
}
function Ac(X, Y) {
  return new X({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...a0(Y),
  });
}
function qc(X, Y) {
  return new X({
    type: "string",
    format: "date",
    check: "string_format",
    ...a0(Y),
  });
}
function Rc(X, Y) {
  return new X({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...a0(Y),
  });
}
function Dc(X, Y) {
  return new X({
    type: "string",
    format: "duration",
    check: "string_format",
    ...a0(Y),
  });
}
function zc(X, Y) {
  return new X({ type: "number", checks: [], ...a0(Y) });
}
function Ec(X, Y) {
  return new X({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...a0(Y),
  });
}
function Oc(X, Y) {
  return new X({ type: "boolean", ...a0(Y) });
}
function Zc(X, Y) {
  return new X({ type: "null", ...a0(Y) });
}
function jc(X) {
  return new X({ type: "unknown" });
}
function wc(X, Y) {
  return new X({ type: "never", ...a0(Y) });
}
function jE(X, Y) {
  return new CO({ check: "less_than", ...a0(Y), value: X, inclusive: !1 });
}
function jU(X, Y) {
  return new CO({ check: "less_than", ...a0(Y), value: X, inclusive: !0 });
}
function wE(X, Y) {
  return new IO({ check: "greater_than", ...a0(Y), value: X, inclusive: !1 });
}
function wU(X, Y) {
  return new IO({ check: "greater_than", ...a0(Y), value: X, inclusive: !0 });
}
function CE(X, Y) {
  return new hl({ check: "multiple_of", ...a0(Y), value: X });
}
function kO(X, Y) {
  return new ul({ check: "max_length", ...a0(Y), maximum: X });
}
function XJ(X, Y) {
  return new ll({ check: "min_length", ...a0(Y), minimum: X });
}
function yO(X, Y) {
  return new ml({ check: "length_equals", ...a0(Y), length: X });
}
function Cc(X, Y) {
  return new cl({
    check: "string_format",
    format: "regex",
    ...a0(Y),
    pattern: X,
  });
}
function Ic(X) {
  return new dl({ check: "string_format", format: "lowercase", ...a0(X) });
}
function Pc(X) {
  return new pl({ check: "string_format", format: "uppercase", ...a0(X) });
}
function Sc(X, Y) {
  return new il({
    check: "string_format",
    format: "includes",
    ...a0(Y),
    includes: X,
  });
}
function Tc(X, Y) {
  return new nl({
    check: "string_format",
    format: "starts_with",
    ...a0(Y),
    prefix: X,
  });
}
function bc(X, Y) {
  return new al({
    check: "string_format",
    format: "ends_with",
    ...a0(Y),
    suffix: X,
  });
}
function oY(X) {
  return new rl({ check: "overwrite", tx: X });
}
function vc(X) {
  return oY((Y) => Y.normalize(X));
}
function kc() {
  return oY((X) => X.trim());
}
function yc() {
  return oY((X) => X.toLowerCase());
}
function _c() {
  return oY((X) => X.toUpperCase());
}
function fc(X, Y, Q) {
  return new X({ type: "array", element: Y, ...a0(Q) });
}
function xc(X, Y, Q) {
  let G = a0(Q);
  return (
    G.abort ?? (G.abort = !0),
    new X({ type: "custom", check: "custom", fn: Y, ...G })
  );
}
function hc(X, Y, Q) {
  return new X({ type: "custom", check: "custom", fn: Y, ...a0(Q) });
}
var _O = {};
kE(_O, {
  time: () => lO,
  duration: () => cO,
  datetime: () => xO,
  date: () => gO,
  ZodISOTime: () => uO,
  ZodISODuration: () => mO,
  ZodISODateTime: () => fO,
  ZodISODate: () => hO,
});
var fO = R0("ZodISODateTime", (X, Y) => {
  (Um.init(X, Y), F5.init(X, Y));
});
function xO(X) {
  return Ac(fO, X);
}
var hO = R0("ZodISODate", (X, Y) => {
  (Lm.init(X, Y), F5.init(X, Y));
});
function gO(X) {
  return qc(hO, X);
}
var uO = R0("ZodISOTime", (X, Y) => {
  (Bm.init(X, Y), F5.init(X, Y));
});
function lO(X) {
  return Rc(uO, X);
}
var mO = R0("ZodISODuration", (X, Y) => {
  (Km.init(X, Y), F5.init(X, Y));
});
function cO(X) {
  return Dc(mO, X);
}
var dO = (X, Y) => {
    (RO.init(X, Y),
      (X.name = "ZodError"),
      Object.defineProperties(X, {
        format: { value: (Q) => Wl(X, Q) },
        flatten: { value: (Q) => Jl(X, Q) },
        addIssue: { value: (Q) => X.issues.push(Q) },
        addIssues: { value: (Q) => X.issues.push(...Q) },
        isEmpty: {
          get() {
            return X.issues.length === 0;
          },
        },
      }));
  },
  QW0 = R0("ZodError", dO),
  DJ = R0("ZodError", dO, { Parent: Error }),
  gc = Hl(DJ),
  uc = $l(DJ),
  lc = zO(DJ),
  mc = EO(DJ),
  V5 = R0("ZodType", (X, Y) => {
    return (
      G5.init(X, Y),
      (X.def = Y),
      Object.defineProperty(X, "_def", { value: Y }),
      (X.check = (...Q) => {
        return X.clone({
          ...Y,
          checks: [
            ...(Y.checks ?? []),
            ...Q.map((G) =>
              typeof G === "function"
                ? { _zod: { check: G, def: { check: "custom" }, onattach: [] } }
                : G
            ),
          ],
        });
      }),
      (X.clone = (Q, G) => l4(X, Q, G)),
      (X.brand = () => X),
      (X.register = (Q, G) => {
        return (Q.add(X, G), X);
      }),
      (X.parse = (Q, G) => gc(X, Q, G, { callee: X.parse })),
      (X.safeParse = (Q, G) => lc(X, Q, G)),
      (X.parseAsync = async (Q, G) => uc(X, Q, G, { callee: X.parseAsync })),
      (X.safeParseAsync = async (Q, G) => mc(X, Q, G)),
      (X.spa = X.safeParseAsync),
      (X.refine = (Q, G) => X.check(vd(Q, G))),
      (X.superRefine = (Q) => X.check(kd(Q))),
      (X.overwrite = (Q) => X.check(oY(Q))),
      (X.optional = () => d0(X)),
      (X.nullable = () => SE(X)),
      (X.nullish = () => d0(SE(X))),
      (X.nonoptional = (Q) => jd(X, Q)),
      (X.array = () => y1(X)),
      (X.or = (Q) => $5([X, Q])),
      (X.and = (Q) => oU(X, Q)),
      (X.transform = (Q) => _U(X, sO(Q))),
      (X.default = (Q) => Ed(X, Q)),
      (X.prefault = (Q) => Zd(X, Q)),
      (X.catch = (Q) => Cd(X, Q)),
      (X.pipe = (Q) => _U(X, Q)),
      (X.readonly = () => Sd(X)),
      (X.describe = (Q) => {
        let G = X.clone();
        return (gG.add(G, { description: Q }), G);
      }),
      Object.defineProperty(X, "description", {
        get() {
          return gG.get(X)?.description;
        },
        configurable: !0,
      }),
      (X.meta = (...Q) => {
        if (Q.length === 0) return gG.get(X);
        let G = X.clone();
        return (gG.add(G, Q[0]), G);
      }),
      (X.isOptional = () => X.safeParse(void 0).success),
      (X.isNullable = () => X.safeParse(null).success),
      X
    );
  }),
  pO = R0("_ZodString", (X, Y) => {
    (rU.init(X, Y), V5.init(X, Y));
    let Q = X._zod.bag;
    ((X.format = Q.format ?? null),
      (X.minLength = Q.minimum ?? null),
      (X.maxLength = Q.maximum ?? null),
      (X.regex = (...G) => X.check(Cc(...G))),
      (X.includes = (...G) => X.check(Sc(...G))),
      (X.startsWith = (...G) => X.check(Tc(...G))),
      (X.endsWith = (...G) => X.check(bc(...G))),
      (X.min = (...G) => X.check(XJ(...G))),
      (X.max = (...G) => X.check(kO(...G))),
      (X.length = (...G) => X.check(yO(...G))),
      (X.nonempty = (...G) => X.check(XJ(1, ...G))),
      (X.lowercase = (G) => X.check(Ic(G))),
      (X.uppercase = (G) => X.check(Pc(G))),
      (X.trim = () => X.check(kc())),
      (X.normalize = (...G) => X.check(vc(...G))),
      (X.toLowerCase = () => X.check(yc())),
      (X.toUpperCase = () => X.check(_c())));
  }),
  cc = R0("ZodString", (X, Y) => {
    (rU.init(X, Y),
      pO.init(X, Y),
      (X.email = (Q) => X.check(rm(dc, Q))),
      (X.url = (Q) => X.check(Xc(pc, Q))),
      (X.jwt = (Q) => X.check(Mc(Hd, Q))),
      (X.emoji = (Q) => X.check(Yc(ic, Q))),
      (X.guid = (Q) => X.check(ZE(IE, Q))),
      (X.uuid = (Q) => X.check(om(uG, Q))),
      (X.uuidv4 = (Q) => X.check(sm(uG, Q))),
      (X.uuidv6 = (Q) => X.check(tm(uG, Q))),
      (X.uuidv7 = (Q) => X.check(em(uG, Q))),
      (X.nanoid = (Q) => X.check(Qc(nc, Q))),
      (X.guid = (Q) => X.check(ZE(IE, Q))),
      (X.cuid = (Q) => X.check(Gc(ac, Q))),
      (X.cuid2 = (Q) => X.check(Jc(rc, Q))),
      (X.ulid = (Q) => X.check(Wc(oc, Q))),
      (X.base64 = (Q) => X.check(Vc(Gd, Q))),
      (X.base64url = (Q) => X.check(Fc(Jd, Q))),
      (X.xid = (Q) => X.check(Hc(sc, Q))),
      (X.ksuid = (Q) => X.check($c(tc, Q))),
      (X.ipv4 = (Q) => X.check(Uc(ec, Q))),
      (X.ipv6 = (Q) => X.check(Lc(Xd, Q))),
      (X.cidrv4 = (Q) => X.check(Bc(Yd, Q))),
      (X.cidrv6 = (Q) => X.check(Kc(Qd, Q))),
      (X.e164 = (Q) => X.check(Nc(Wd, Q))),
      (X.datetime = (Q) => X.check(xO(Q))),
      (X.date = (Q) => X.check(gO(Q))),
      (X.time = (Q) => X.check(lO(Q))),
      (X.duration = (Q) => X.check(cO(Q))));
  });
function F0(X) {
  return am(cc, X);
}
var F5 = R0("ZodStringFormat", (X, Y) => {
    (H5.init(X, Y), pO.init(X, Y));
  }),
  dc = R0("ZodEmail", (X, Y) => {
    (el.init(X, Y), F5.init(X, Y));
  }),
  IE = R0("ZodGUID", (X, Y) => {
    (sl.init(X, Y), F5.init(X, Y));
  }),
  uG = R0("ZodUUID", (X, Y) => {
    (tl.init(X, Y), F5.init(X, Y));
  }),
  pc = R0("ZodURL", (X, Y) => {
    (Xm.init(X, Y), F5.init(X, Y));
  }),
  ic = R0("ZodEmoji", (X, Y) => {
    (Ym.init(X, Y), F5.init(X, Y));
  }),
  nc = R0("ZodNanoID", (X, Y) => {
    (Qm.init(X, Y), F5.init(X, Y));
  }),
  ac = R0("ZodCUID", (X, Y) => {
    (Gm.init(X, Y), F5.init(X, Y));
  }),
  rc = R0("ZodCUID2", (X, Y) => {
    (Jm.init(X, Y), F5.init(X, Y));
  }),
  oc = R0("ZodULID", (X, Y) => {
    (Wm.init(X, Y), F5.init(X, Y));
  }),
  sc = R0("ZodXID", (X, Y) => {
    (Hm.init(X, Y), F5.init(X, Y));
  }),
  tc = R0("ZodKSUID", (X, Y) => {
    ($m.init(X, Y), F5.init(X, Y));
  }),
  ec = R0("ZodIPv4", (X, Y) => {
    (Vm.init(X, Y), F5.init(X, Y));
  }),
  Xd = R0("ZodIPv6", (X, Y) => {
    (Fm.init(X, Y), F5.init(X, Y));
  }),
  Yd = R0("ZodCIDRv4", (X, Y) => {
    (Nm.init(X, Y), F5.init(X, Y));
  }),
  Qd = R0("ZodCIDRv6", (X, Y) => {
    (Mm.init(X, Y), F5.init(X, Y));
  }),
  Gd = R0("ZodBase64", (X, Y) => {
    (Am.init(X, Y), F5.init(X, Y));
  }),
  Jd = R0("ZodBase64URL", (X, Y) => {
    (Rm.init(X, Y), F5.init(X, Y));
  }),
  Wd = R0("ZodE164", (X, Y) => {
    (Dm.init(X, Y), F5.init(X, Y));
  }),
  Hd = R0("ZodJWT", (X, Y) => {
    (Em.init(X, Y), F5.init(X, Y));
  }),
  iO = R0("ZodNumber", (X, Y) => {
    (TO.init(X, Y),
      V5.init(X, Y),
      (X.gt = (G, J) => X.check(wE(G, J))),
      (X.gte = (G, J) => X.check(wU(G, J))),
      (X.min = (G, J) => X.check(wU(G, J))),
      (X.lt = (G, J) => X.check(jE(G, J))),
      (X.lte = (G, J) => X.check(jU(G, J))),
      (X.max = (G, J) => X.check(jU(G, J))),
      (X.int = (G) => X.check(PE(G))),
      (X.safe = (G) => X.check(PE(G))),
      (X.positive = (G) => X.check(wE(0, G))),
      (X.nonnegative = (G) => X.check(wU(0, G))),
      (X.negative = (G) => X.check(jE(0, G))),
      (X.nonpositive = (G) => X.check(jU(0, G))),
      (X.multipleOf = (G, J) => X.check(CE(G, J))),
      (X.step = (G, J) => X.check(CE(G, J))),
      (X.finite = () => X));
    let Q = X._zod.bag;
    ((X.minValue =
      Math.max(
        Q.minimum ?? Number.NEGATIVE_INFINITY,
        Q.exclusiveMinimum ?? Number.NEGATIVE_INFINITY
      ) ?? null),
      (X.maxValue =
        Math.min(
          Q.maximum ?? Number.POSITIVE_INFINITY,
          Q.exclusiveMaximum ?? Number.POSITIVE_INFINITY
        ) ?? null),
      (X.isInt =
        (Q.format ?? "").includes("int") ||
        Number.isSafeInteger(Q.multipleOf ?? 0.5)),
      (X.isFinite = !0),
      (X.format = Q.format ?? null));
  });
function e1(X) {
  return zc(iO, X);
}
var $d = R0("ZodNumberFormat", (X, Y) => {
  (Om.init(X, Y), iO.init(X, Y));
});
function PE(X) {
  return Ec($d, X);
}
var Ud = R0("ZodBoolean", (X, Y) => {
  (Zm.init(X, Y), V5.init(X, Y));
});
function X8(X) {
  return Oc(Ud, X);
}
var Ld = R0("ZodNull", (X, Y) => {
  (jm.init(X, Y), V5.init(X, Y));
});
function nO(X) {
  return Zc(Ld, X);
}
var Bd = R0("ZodUnknown", (X, Y) => {
  (wm.init(X, Y), V5.init(X, Y));
});
function C5() {
  return jc(Bd);
}
var Kd = R0("ZodNever", (X, Y) => {
  (Cm.init(X, Y), V5.init(X, Y));
});
function Vd(X) {
  return wc(Kd, X);
}
var Fd = R0("ZodArray", (X, Y) => {
  (Im.init(X, Y),
    V5.init(X, Y),
    (X.element = Y.element),
    (X.min = (Q, G) => X.check(XJ(Q, G))),
    (X.nonempty = (Q) => X.check(XJ(1, Q))),
    (X.max = (Q, G) => X.check(kO(Q, G))),
    (X.length = (Q, G) => X.check(yO(Q, G))),
    (X.unwrap = () => X.element));
});
function y1(X, Y) {
  return fc(Fd, X, Y);
}
var aO = R0("ZodObject", (X, Y) => {
  (Pm.init(X, Y),
    V5.init(X, Y),
    Y5.defineLazy(X, "shape", () => Y.shape),
    (X.keyof = () => Y8(Object.keys(X._zod.def.shape))),
    (X.catchall = (Q) => X.clone({ ...X._zod.def, catchall: Q })),
    (X.passthrough = () => X.clone({ ...X._zod.def, catchall: C5() })),
    (X.loose = () => X.clone({ ...X._zod.def, catchall: C5() })),
    (X.strict = () => X.clone({ ...X._zod.def, catchall: Vd() })),
    (X.strip = () => X.clone({ ...X._zod.def, catchall: void 0 })),
    (X.extend = (Q) => {
      return Y5.extend(X, Q);
    }),
    (X.merge = (Q) => Y5.merge(X, Q)),
    (X.pick = (Q) => Y5.pick(X, Q)),
    (X.omit = (Q) => Y5.omit(X, Q)),
    (X.partial = (...Q) => Y5.partial(tO, X, Q[0])),
    (X.required = (...Q) => Y5.required(eO, X, Q[0])));
});
function T0(X, Y) {
  let Q = {
    type: "object",
    get shape() {
      return (Y5.assignProp(this, "shape", { ...X }), this.shape);
    },
    ...Y5.normalizeParams(Y),
  };
  return new aO(Q);
}
function c8(X, Y) {
  return new aO({
    type: "object",
    get shape() {
      return (Y5.assignProp(this, "shape", { ...X }), this.shape);
    },
    catchall: C5(),
    ...Y5.normalizeParams(Y),
  });
}
var rO = R0("ZodUnion", (X, Y) => {
  (bO.init(X, Y), V5.init(X, Y), (X.options = Y.options));
});
function $5(X, Y) {
  return new rO({ type: "union", options: X, ...Y5.normalizeParams(Y) });
}
var Nd = R0("ZodDiscriminatedUnion", (X, Y) => {
  (rO.init(X, Y), Sm.init(X, Y));
});
function oO(X, Y, Q) {
  return new Nd({
    type: "union",
    options: Y,
    discriminator: X,
    ...Y5.normalizeParams(Q),
  });
}
var Md = R0("ZodIntersection", (X, Y) => {
  (Tm.init(X, Y), V5.init(X, Y));
});
function oU(X, Y) {
  return new Md({ type: "intersection", left: X, right: Y });
}
var Ad = R0("ZodRecord", (X, Y) => {
  (bm.init(X, Y),
    V5.init(X, Y),
    (X.keyType = Y.keyType),
    (X.valueType = Y.valueType));
});
function I5(X, Y, Q) {
  return new Ad({
    type: "record",
    keyType: X,
    valueType: Y,
    ...Y5.normalizeParams(Q),
  });
}
var yU = R0("ZodEnum", (X, Y) => {
  (vm.init(X, Y),
    V5.init(X, Y),
    (X.enum = Y.entries),
    (X.options = Object.values(Y.entries)));
  let Q = new Set(Object.keys(Y.entries));
  ((X.extract = (G, J) => {
    let U = {};
    for (let $ of G)
      if (Q.has($)) U[$] = Y.entries[$];
      else throw Error(`Key ${$} not found in enum`);
    return new yU({ ...Y, checks: [], ...Y5.normalizeParams(J), entries: U });
  }),
    (X.exclude = (G, J) => {
      let U = { ...Y.entries };
      for (let $ of G)
        if (Q.has($)) delete U[$];
        else throw Error(`Key ${$} not found in enum`);
      return new yU({ ...Y, checks: [], ...Y5.normalizeParams(J), entries: U });
    }));
});
function Y8(X, Y) {
  let Q = Array.isArray(X) ? Object.fromEntries(X.map((G) => [G, G])) : X;
  return new yU({ type: "enum", entries: Q, ...Y5.normalizeParams(Y) });
}
var qd = R0("ZodLiteral", (X, Y) => {
  (km.init(X, Y),
    V5.init(X, Y),
    (X.values = new Set(Y.values)),
    Object.defineProperty(X, "value", {
      get() {
        if (Y.values.length > 1)
          throw Error(
            "This schema contains multiple valid literal values. Use `.values` instead."
          );
        return Y.values[0];
      },
    }));
});
function p0(X, Y) {
  return new qd({
    type: "literal",
    values: Array.isArray(X) ? X : [X],
    ...Y5.normalizeParams(Y),
  });
}
var Rd = R0("ZodTransform", (X, Y) => {
  (ym.init(X, Y),
    V5.init(X, Y),
    (X._zod.parse = (Q, G) => {
      Q.addIssue = (U) => {
        if (typeof U === "string") Q.issues.push(Y5.issue(U, Q.value, Y));
        else {
          let $ = U;
          if ($.fatal) $.continue = !1;
          ($.code ?? ($.code = "custom"),
            $.input ?? ($.input = Q.value),
            $.inst ?? ($.inst = X),
            $.continue ?? ($.continue = !0),
            Q.issues.push(Y5.issue($)));
        }
      };
      let J = Y.transform(Q.value, Q);
      if (J instanceof Promise)
        return J.then((U) => {
          return ((Q.value = U), Q);
        });
      return ((Q.value = J), Q);
    }));
});
function sO(X) {
  return new Rd({ type: "transform", transform: X });
}
var tO = R0("ZodOptional", (X, Y) => {
  (_m.init(X, Y), V5.init(X, Y), (X.unwrap = () => X._zod.def.innerType));
});
function d0(X) {
  return new tO({ type: "optional", innerType: X });
}
var Dd = R0("ZodNullable", (X, Y) => {
  (fm.init(X, Y), V5.init(X, Y), (X.unwrap = () => X._zod.def.innerType));
});
function SE(X) {
  return new Dd({ type: "nullable", innerType: X });
}
var zd = R0("ZodDefault", (X, Y) => {
  (xm.init(X, Y),
    V5.init(X, Y),
    (X.unwrap = () => X._zod.def.innerType),
    (X.removeDefault = X.unwrap));
});
function Ed(X, Y) {
  return new zd({
    type: "default",
    innerType: X,
    get defaultValue() {
      return typeof Y === "function" ? Y() : Y;
    },
  });
}
var Od = R0("ZodPrefault", (X, Y) => {
  (hm.init(X, Y), V5.init(X, Y), (X.unwrap = () => X._zod.def.innerType));
});
function Zd(X, Y) {
  return new Od({
    type: "prefault",
    innerType: X,
    get defaultValue() {
      return typeof Y === "function" ? Y() : Y;
    },
  });
}
var eO = R0("ZodNonOptional", (X, Y) => {
  (gm.init(X, Y), V5.init(X, Y), (X.unwrap = () => X._zod.def.innerType));
});
function jd(X, Y) {
  return new eO({
    type: "nonoptional",
    innerType: X,
    ...Y5.normalizeParams(Y),
  });
}
var wd = R0("ZodCatch", (X, Y) => {
  (um.init(X, Y),
    V5.init(X, Y),
    (X.unwrap = () => X._zod.def.innerType),
    (X.removeCatch = X.unwrap));
});
function Cd(X, Y) {
  return new wd({
    type: "catch",
    innerType: X,
    catchValue: typeof Y === "function" ? Y : () => Y,
  });
}
var Id = R0("ZodPipe", (X, Y) => {
  (lm.init(X, Y), V5.init(X, Y), (X.in = Y.in), (X.out = Y.out));
});
function _U(X, Y) {
  return new Id({ type: "pipe", in: X, out: Y });
}
var Pd = R0("ZodReadonly", (X, Y) => {
  (mm.init(X, Y), V5.init(X, Y));
});
function Sd(X) {
  return new Pd({ type: "readonly", innerType: X });
}
var XZ = R0("ZodCustom", (X, Y) => {
  (cm.init(X, Y), V5.init(X, Y));
});
function Td(X, Y) {
  let Q = new B8({ check: "custom", ...Y5.normalizeParams(Y) });
  return ((Q._zod.check = X), Q);
}
function bd(X, Y) {
  return xc(XZ, X ?? (() => !0), Y);
}
function vd(X, Y = {}) {
  return hc(XZ, X, Y);
}
function kd(X, Y) {
  let Q = Td((G) => {
    return (
      (G.addIssue = (J) => {
        if (typeof J === "string")
          G.issues.push(Y5.issue(J, G.value, Q._zod.def));
        else {
          let U = J;
          if (U.fatal) U.continue = !1;
          (U.code ?? (U.code = "custom"),
            U.input ?? (U.input = G.value),
            U.inst ?? (U.inst = Q),
            U.continue ?? (U.continue = !Q._zod.def.abort),
            G.issues.push(Y5.issue(U)));
        }
      }),
      X(G.value, G)
    );
  }, Y);
  return Q;
}
function YZ(X, Y) {
  return _U(sO(X), Y);
}
U4(im());
var sU = "io.modelcontextprotocol/related-task",
  zJ = "2.0",
  L6 = bd(
    (X) => X !== null && (typeof X === "object" || typeof X === "function")
  ),
  QZ = $5([F0(), e1().int()]),
  GZ = F0(),
  yd = c8({ ttl: $5([e1(), nO()]).optional(), pollInterval: e1().optional() }),
  tU = c8({ taskId: F0() }),
  _d = c8({ progressToken: QZ.optional(), [sU]: tU.optional() }),
  K8 = c8({ task: yd.optional(), _meta: _d.optional() }),
  d5 = T0({ method: F0(), params: K8.optional() }),
  f9 = c8({
    _meta: T0({ [sU]: d0(tU) })
      .passthrough()
      .optional(),
  }),
  T8 = T0({ method: F0(), params: f9.optional() }),
  Q8 = c8({ _meta: c8({ [sU]: tU.optional() }).optional() }),
  EJ = $5([F0(), e1().int()]),
  fd = T0({ jsonrpc: p0(zJ), id: EJ, ...d5.shape }).strict();
var xd = T0({ jsonrpc: p0(zJ), ...T8.shape }).strict();
var hd = T0({ jsonrpc: p0(zJ), id: EJ, result: Q8 }).strict();
var TE;
(function (X) {
  ((X[(X.ConnectionClosed = -32000)] = "ConnectionClosed"),
    (X[(X.RequestTimeout = -32001)] = "RequestTimeout"),
    (X[(X.ParseError = -32700)] = "ParseError"),
    (X[(X.InvalidRequest = -32600)] = "InvalidRequest"),
    (X[(X.MethodNotFound = -32601)] = "MethodNotFound"),
    (X[(X.InvalidParams = -32602)] = "InvalidParams"),
    (X[(X.InternalError = -32603)] = "InternalError"),
    (X[(X.UrlElicitationRequired = -32042)] = "UrlElicitationRequired"));
})(TE || (TE = {}));
var gd = T0({
  jsonrpc: p0(zJ),
  id: EJ,
  error: T0({ code: e1().int(), message: F0(), data: d0(C5()) }),
}).strict();
var GW0 = $5([fd, xd, hd, gd]),
  JZ = Q8.strict(),
  ud = f9.extend({ requestId: EJ, reason: F0().optional() }),
  WZ = T8.extend({ method: p0("notifications/cancelled"), params: ud }),
  ld = T0({ src: F0(), mimeType: F0().optional(), sizes: y1(F0()).optional() }),
  sY = T0({ icons: y1(ld).optional() }),
  $7 = T0({ name: F0(), title: F0().optional() }),
  HZ = $7.extend({
    ...$7.shape,
    ...sY.shape,
    version: F0(),
    websiteUrl: F0().optional(),
  }),
  md = oU(T0({ applyDefaults: X8().optional() }), I5(F0(), C5())),
  cd = YZ(
    (X) => {
      if (X && typeof X === "object" && !Array.isArray(X)) {
        if (Object.keys(X).length === 0) return { form: {} };
      }
      return X;
    },
    oU(
      T0({ form: md.optional(), url: L6.optional() }),
      I5(F0(), C5()).optional()
    )
  ),
  dd = T0({
    list: d0(T0({}).passthrough()),
    cancel: d0(T0({}).passthrough()),
    requests: d0(
      T0({
        sampling: d0(
          T0({ createMessage: d0(T0({}).passthrough()) }).passthrough()
        ),
        elicitation: d0(T0({ create: d0(T0({}).passthrough()) }).passthrough()),
      }).passthrough()
    ),
  }).passthrough(),
  pd = T0({
    list: d0(T0({}).passthrough()),
    cancel: d0(T0({}).passthrough()),
    requests: d0(
      T0({
        tools: d0(T0({ call: d0(T0({}).passthrough()) }).passthrough()),
      }).passthrough()
    ),
  }).passthrough(),
  id = T0({
    experimental: I5(F0(), L6).optional(),
    sampling: T0({ context: L6.optional(), tools: L6.optional() }).optional(),
    elicitation: cd.optional(),
    roots: T0({ listChanged: X8().optional() }).optional(),
    tasks: d0(dd),
  }),
  nd = K8.extend({ protocolVersion: F0(), capabilities: id, clientInfo: HZ }),
  ad = d5.extend({ method: p0("initialize"), params: nd }),
  rd = T0({
    experimental: I5(F0(), L6).optional(),
    logging: L6.optional(),
    completions: L6.optional(),
    prompts: d0(T0({ listChanged: d0(X8()) })),
    resources: T0({
      subscribe: X8().optional(),
      listChanged: X8().optional(),
    }).optional(),
    tools: T0({ listChanged: X8().optional() }).optional(),
    tasks: d0(pd),
  }).passthrough(),
  od = Q8.extend({
    protocolVersion: F0(),
    capabilities: rd,
    serverInfo: HZ,
    instructions: F0().optional(),
  }),
  sd = T8.extend({ method: p0("notifications/initialized") }),
  $Z = d5.extend({ method: p0("ping") }),
  td = T0({ progress: e1(), total: d0(e1()), message: d0(F0()) }),
  ed = T0({ ...f9.shape, ...td.shape, progressToken: QZ }),
  UZ = T8.extend({ method: p0("notifications/progress"), params: ed }),
  Xp = K8.extend({ cursor: GZ.optional() }),
  tY = d5.extend({ params: Xp.optional() }),
  eY = Q8.extend({ nextCursor: d0(GZ) }),
  XQ = T0({
    taskId: F0(),
    status: Y8([
      "working",
      "input_required",
      "completed",
      "failed",
      "cancelled",
    ]),
    ttl: $5([e1(), nO()]),
    createdAt: F0(),
    lastUpdatedAt: F0(),
    pollInterval: d0(e1()),
    statusMessage: d0(F0()),
  }),
  LZ = Q8.extend({ task: XQ }),
  Yp = f9.merge(XQ),
  BZ = T8.extend({ method: p0("notifications/tasks/status"), params: Yp }),
  KZ = d5.extend({
    method: p0("tasks/get"),
    params: K8.extend({ taskId: F0() }),
  }),
  VZ = Q8.merge(XQ),
  FZ = d5.extend({
    method: p0("tasks/result"),
    params: K8.extend({ taskId: F0() }),
  }),
  NZ = tY.extend({ method: p0("tasks/list") }),
  MZ = eY.extend({ tasks: y1(XQ) }),
  JW0 = d5.extend({
    method: p0("tasks/cancel"),
    params: K8.extend({ taskId: F0() }),
  }),
  WW0 = Q8.merge(XQ),
  AZ = T0({ uri: F0(), mimeType: d0(F0()), _meta: I5(F0(), C5()).optional() }),
  qZ = AZ.extend({ text: F0() }),
  eU = F0().refine(
    (X) => {
      try {
        return (atob(X), !0);
      } catch (Y) {
        return !1;
      }
    },
    { message: "Invalid Base64 string" }
  ),
  RZ = AZ.extend({ blob: eU }),
  V7 = T0({
    audience: y1(Y8(["user", "assistant"])).optional(),
    priority: e1().min(0).max(1).optional(),
    lastModified: _O.datetime({ offset: !0 }).optional(),
  }),
  DZ = T0({
    ...$7.shape,
    ...sY.shape,
    uri: F0(),
    description: d0(F0()),
    mimeType: d0(F0()),
    annotations: V7.optional(),
    _meta: d0(c8({})),
  }),
  Qp = T0({
    ...$7.shape,
    ...sY.shape,
    uriTemplate: F0(),
    description: d0(F0()),
    mimeType: d0(F0()),
    annotations: V7.optional(),
    _meta: d0(c8({})),
  }),
  Gp = tY.extend({ method: p0("resources/list") }),
  Jp = eY.extend({ resources: y1(DZ) }),
  Wp = tY.extend({ method: p0("resources/templates/list") }),
  Hp = eY.extend({ resourceTemplates: y1(Qp) }),
  XL = K8.extend({ uri: F0() }),
  $p = XL,
  Up = d5.extend({ method: p0("resources/read"), params: $p }),
  Lp = Q8.extend({ contents: y1($5([qZ, RZ])) }),
  Bp = T8.extend({ method: p0("notifications/resources/list_changed") }),
  Kp = XL,
  Vp = d5.extend({ method: p0("resources/subscribe"), params: Kp }),
  Fp = XL,
  Np = d5.extend({ method: p0("resources/unsubscribe"), params: Fp }),
  Mp = f9.extend({ uri: F0() }),
  Ap = T8.extend({ method: p0("notifications/resources/updated"), params: Mp }),
  qp = T0({ name: F0(), description: d0(F0()), required: d0(X8()) }),
  Rp = T0({
    ...$7.shape,
    ...sY.shape,
    description: d0(F0()),
    arguments: d0(y1(qp)),
    _meta: d0(c8({})),
  }),
  Dp = tY.extend({ method: p0("prompts/list") }),
  zp = eY.extend({ prompts: y1(Rp) }),
  Ep = K8.extend({ name: F0(), arguments: I5(F0(), F0()).optional() }),
  Op = d5.extend({ method: p0("prompts/get"), params: Ep }),
  YL = T0({
    type: p0("text"),
    text: F0(),
    annotations: V7.optional(),
    _meta: I5(F0(), C5()).optional(),
  }),
  QL = T0({
    type: p0("image"),
    data: eU,
    mimeType: F0(),
    annotations: V7.optional(),
    _meta: I5(F0(), C5()).optional(),
  }),
  GL = T0({
    type: p0("audio"),
    data: eU,
    mimeType: F0(),
    annotations: V7.optional(),
    _meta: I5(F0(), C5()).optional(),
  }),
  Zp = T0({
    type: p0("tool_use"),
    name: F0(),
    id: F0(),
    input: T0({}).passthrough(),
    _meta: d0(T0({}).passthrough()),
  }).passthrough(),
  jp = T0({
    type: p0("resource"),
    resource: $5([qZ, RZ]),
    annotations: V7.optional(),
    _meta: I5(F0(), C5()).optional(),
  }),
  wp = DZ.extend({ type: p0("resource_link") }),
  JL = $5([YL, QL, GL, wp, jp]),
  Cp = T0({ role: Y8(["user", "assistant"]), content: JL }),
  Ip = Q8.extend({ description: d0(F0()), messages: y1(Cp) }),
  Pp = T8.extend({ method: p0("notifications/prompts/list_changed") }),
  Sp = T0({
    title: F0().optional(),
    readOnlyHint: X8().optional(),
    destructiveHint: X8().optional(),
    idempotentHint: X8().optional(),
    openWorldHint: X8().optional(),
  }),
  Tp = T0({
    taskSupport: Y8(["required", "optional", "forbidden"]).optional(),
  }),
  zZ = T0({
    ...$7.shape,
    ...sY.shape,
    description: F0().optional(),
    inputSchema: T0({
      type: p0("object"),
      properties: I5(F0(), L6).optional(),
      required: y1(F0()).optional(),
    }).catchall(C5()),
    outputSchema: T0({
      type: p0("object"),
      properties: I5(F0(), L6).optional(),
      required: y1(F0()).optional(),
    })
      .catchall(C5())
      .optional(),
    annotations: d0(Sp),
    execution: d0(Tp),
    _meta: I5(F0(), C5()).optional(),
  }),
  bp = tY.extend({ method: p0("tools/list") }),
  vp = eY.extend({ tools: y1(zZ) }),
  EZ = Q8.extend({
    content: y1(JL).default([]),
    structuredContent: I5(F0(), C5()).optional(),
    isError: d0(X8()),
  }),
  HW0 = EZ.or(Q8.extend({ toolResult: C5() })),
  kp = K8.extend({ name: F0(), arguments: d0(I5(F0(), C5())) }),
  yp = d5.extend({ method: p0("tools/call"), params: kp }),
  _p = T8.extend({ method: p0("notifications/tools/list_changed") }),
  OZ = Y8([
    "debug",
    "info",
    "notice",
    "warning",
    "error",
    "critical",
    "alert",
    "emergency",
  ]),
  fp = K8.extend({ level: OZ }),
  xp = d5.extend({ method: p0("logging/setLevel"), params: fp }),
  hp = f9.extend({ level: OZ, logger: F0().optional(), data: C5() }),
  gp = T8.extend({ method: p0("notifications/message"), params: hp }),
  up = T0({ name: F0().optional() }),
  lp = T0({
    hints: d0(y1(up)),
    costPriority: d0(e1().min(0).max(1)),
    speedPriority: d0(e1().min(0).max(1)),
    intelligencePriority: d0(e1().min(0).max(1)),
  }),
  mp = T0({ mode: d0(Y8(["auto", "required", "none"])) }),
  cp = T0({
    type: p0("tool_result"),
    toolUseId: F0().describe(
      "The unique identifier for the corresponding tool call."
    ),
    content: y1(JL).default([]),
    structuredContent: T0({}).passthrough().optional(),
    isError: d0(X8()),
    _meta: d0(T0({}).passthrough()),
  }).passthrough(),
  dp = oO("type", [YL, QL, GL]),
  YJ = oO("type", [YL, QL, GL, Zp, cp]),
  pp = T0({
    role: Y8(["user", "assistant"]),
    content: $5([YJ, y1(YJ)]),
    _meta: d0(T0({}).passthrough()),
  }).passthrough(),
  ip = K8.extend({
    messages: y1(pp),
    modelPreferences: lp.optional(),
    systemPrompt: F0().optional(),
    includeContext: Y8(["none", "thisServer", "allServers"]).optional(),
    temperature: e1().optional(),
    maxTokens: e1().int(),
    stopSequences: y1(F0()).optional(),
    metadata: L6.optional(),
    tools: d0(y1(zZ)),
    toolChoice: d0(mp),
  }),
  np = d5.extend({ method: p0("sampling/createMessage"), params: ip }),
  ap = Q8.extend({
    model: F0(),
    stopReason: d0(Y8(["endTurn", "stopSequence", "maxTokens"]).or(F0())),
    role: Y8(["user", "assistant"]),
    content: dp,
  }),
  rp = Q8.extend({
    model: F0(),
    stopReason: d0(
      Y8(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(F0())
    ),
    role: Y8(["user", "assistant"]),
    content: $5([YJ, y1(YJ)]),
  }),
  op = T0({
    type: p0("boolean"),
    title: F0().optional(),
    description: F0().optional(),
    default: X8().optional(),
  }),
  sp = T0({
    type: p0("string"),
    title: F0().optional(),
    description: F0().optional(),
    minLength: e1().optional(),
    maxLength: e1().optional(),
    format: Y8(["email", "uri", "date", "date-time"]).optional(),
    default: F0().optional(),
  }),
  tp = T0({
    type: Y8(["number", "integer"]),
    title: F0().optional(),
    description: F0().optional(),
    minimum: e1().optional(),
    maximum: e1().optional(),
    default: e1().optional(),
  }),
  ep = T0({
    type: p0("string"),
    title: F0().optional(),
    description: F0().optional(),
    enum: y1(F0()),
    default: F0().optional(),
  }),
  Xi = T0({
    type: p0("string"),
    title: F0().optional(),
    description: F0().optional(),
    oneOf: y1(T0({ const: F0(), title: F0() })),
    default: F0().optional(),
  }),
  Yi = T0({
    type: p0("string"),
    title: F0().optional(),
    description: F0().optional(),
    enum: y1(F0()),
    enumNames: y1(F0()).optional(),
    default: F0().optional(),
  }),
  Qi = $5([ep, Xi]),
  Gi = T0({
    type: p0("array"),
    title: F0().optional(),
    description: F0().optional(),
    minItems: e1().optional(),
    maxItems: e1().optional(),
    items: T0({ type: p0("string"), enum: y1(F0()) }),
    default: y1(F0()).optional(),
  }),
  Ji = T0({
    type: p0("array"),
    title: F0().optional(),
    description: F0().optional(),
    minItems: e1().optional(),
    maxItems: e1().optional(),
    items: T0({ anyOf: y1(T0({ const: F0(), title: F0() })) }),
    default: y1(F0()).optional(),
  }),
  Wi = $5([Gi, Ji]),
  Hi = $5([Yi, Qi, Wi]),
  $i = $5([Hi, op, sp, tp]),
  Ui = K8.extend({
    mode: p0("form").optional(),
    message: F0(),
    requestedSchema: T0({
      type: p0("object"),
      properties: I5(F0(), $i),
      required: y1(F0()).optional(),
    }),
  }),
  Li = K8.extend({
    mode: p0("url"),
    message: F0(),
    elicitationId: F0(),
    url: F0().url(),
  }),
  Bi = $5([Ui, Li]),
  Ki = d5.extend({ method: p0("elicitation/create"), params: Bi }),
  Vi = f9.extend({ elicitationId: F0() }),
  Fi = T8.extend({
    method: p0("notifications/elicitation/complete"),
    params: Vi,
  }),
  Ni = Q8.extend({
    action: Y8(["accept", "decline", "cancel"]),
    content: YZ(
      (X) => (X === null ? void 0 : X),
      I5(F0(), $5([F0(), e1(), X8(), y1(F0())])).optional()
    ),
  }),
  Mi = T0({ type: p0("ref/resource"), uri: F0() }),
  Ai = T0({ type: p0("ref/prompt"), name: F0() }),
  qi = K8.extend({
    ref: $5([Ai, Mi]),
    argument: T0({ name: F0(), value: F0() }),
    context: T0({ arguments: I5(F0(), F0()).optional() }).optional(),
  }),
  Ri = d5.extend({ method: p0("completion/complete"), params: qi });
var Di = Q8.extend({
    completion: c8({
      values: y1(F0()).max(100),
      total: d0(e1().int()),
      hasMore: d0(X8()),
    }),
  }),
  zi = T0({
    uri: F0().startsWith("file://"),
    name: F0().optional(),
    _meta: I5(F0(), C5()).optional(),
  }),
  Ei = d5.extend({ method: p0("roots/list") }),
  Oi = Q8.extend({ roots: y1(zi) }),
  Zi = T8.extend({ method: p0("notifications/roots/list_changed") }),
  $W0 = $5([$Z, ad, Ri, xp, Op, Dp, Gp, Wp, Up, Vp, Np, yp, bp, KZ, FZ, NZ]),
  UW0 = $5([WZ, UZ, sd, Zi, BZ]),
  LW0 = $5([JZ, ap, rp, Ni, Oi, VZ, MZ, LZ]),
  BW0 = $5([$Z, np, Ki, Ei, KZ, FZ, NZ]),
  KW0 = $5([WZ, UZ, gp, Ap, Bp, _p, Pp, BZ, Fi]),
  VW0 = $5([JZ, od, Di, Ip, zp, Jp, Hp, Lp, EZ, vp, VZ, MZ, LZ]);
var FW0 = Symbol("Let zodToJsonSchema decide on which parser to use");
var NW0 = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
var MW0 = vE(af(), 1),
  AW0 = vE(mx(), 1);
var bE;
(function (X) {
  X.Completable = "McpCompletable";
})(bE || (bE = {}));
function m4({ prompt: X, options: Y }) {
  let { systemPrompt: Q, settingSources: G, sandbox: J, ...U } = Y ?? {},
    $,
    B;
  if (Q === void 0) $ = "";
  else if (typeof Q === "string") $ = Q;
  else if (Q.type === "preset") B = Q.append;
  let K = U.pathToClaudeCodeExecutable;
  if (!K) {
    let M0 = cx(import.meta.url),
      D0 = XE(M0, "..");
    K = XE(D0, "cli.js");
  }
  process.env.CLAUDE_AGENT_SDK_VERSION = "0.1.76";
  let {
      abortController: V = pE(),
      additionalDirectories: W = [],
      agents: L,
      allowedTools: H = [],
      betas: F,
      canUseTool: N,
      continue: q,
      cwd: M,
      disallowedTools: A = [],
      tools: D,
      env: R,
      executable: z = XO() ? "bun" : "node",
      executableArgs: E = [],
      extraArgs: O = {},
      fallbackModel: Z,
      enableFileCheckpointing: j,
      forkSession: w,
      hooks: I,
      includePartialMessages: T,
      persistSession: y,
      maxThinkingTokens: _,
      maxTurns: f,
      maxBudgetUsd: l,
      mcpServers: h,
      model: p,
      outputFormat: N0,
      permissionMode: e = "default",
      allowDangerouslySkipPermissions: P = !1,
      permissionPromptToolName: x,
      plugins: r,
      resume: C,
      resumeSessionAt: v,
      stderr: k,
      strictMcpConfig: o,
    } = U,
    J0 = N0?.type === "json_schema" ? N0.schema : void 0,
    z0 = R;
  if (!z0) z0 = { ...process.env };
  if (!z0.CLAUDE_CODE_ENTRYPOINT) z0.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
  if (j) z0.CLAUDE_CODE_ENABLE_SDK_FILE_CHECKPOINTING = "true";
  if (!K) throw Error("pathToClaudeCodeExecutable is required");
  let A0 = {},
    w0 = new Map();
  if (h)
    for (let [M0, D0] of Object.entries(h))
      if (D0.type === "sdk" && "instance" in D0)
        (w0.set(M0, D0.instance), (A0[M0] = { type: "sdk", name: M0 }));
      else A0[M0] = D0;
  let Y1 = typeof X === "string",
    b = new YO({
      abortController: V,
      additionalDirectories: W,
      betas: F,
      cwd: M,
      executable: z,
      executableArgs: E,
      extraArgs: O,
      pathToClaudeCodeExecutable: K,
      env: z0,
      forkSession: w,
      stderr: k,
      maxThinkingTokens: _,
      maxTurns: f,
      maxBudgetUsd: l,
      model: p,
      fallbackModel: Z,
      jsonSchema: J0,
      permissionMode: e,
      allowDangerouslySkipPermissions: P,
      permissionPromptToolName: x,
      continueConversation: q,
      resume: C,
      resumeSessionAt: v,
      settingSources: G ?? [],
      allowedTools: H,
      disallowedTools: A,
      tools: D,
      mcpServers: A0,
      strictMcpConfig: o,
      canUseTool: !!N,
      hooks: !!I,
      includePartialMessages: T,
      persistSession: y,
      plugins: r,
      sandbox: J,
      spawnClaudeCodeProcess: U.spawnClaudeCodeProcess,
    }),
    n = new JO(b, Y1, N, I, V, w0, J0, {
      systemPrompt: $,
      appendSystemPrompt: B,
      agents: L,
    });
  if (typeof X === "string")
    b.write(
      JSON.stringify({
        type: "user",
        session_id: "",
        message: { role: "user", content: [{ type: "text", text: X }] },
        parent_tool_use_id: null,
      }) +
        `
`
    );
  else n.streamInput(X);
  return n;
}
function ZZ(X) {
  return X.replace(/[^\w\s\-\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, "")
    .replace(/\s+/g, " ")
    .trim();
}
function jZ(X) {
  if (!X) return X;
  return X.charAt(0).toUpperCase() + X.slice(1);
}
function wZ(X, Y) {
  if (X.length <= Y) return X;
  let Q = X.substring(0, Y),
    G = Q.lastIndexOf(" ");
  if (G > Y * 0.6) return Q.substring(0, G).trim();
  return Q.trim();
}
function ji(X) {
  return (
    X.replace(/```[\s\S]*?```/g, "")
      .trim()
      .split(
        `
`
      )
      .map((J) => J.trim())
      .find((J) => J.length > 0) || ""
  );
}
function WL(X, Y = {}) {
  let { maxLength: Q = 15 } = Y,
    G = X.trim();
  if (!G) return "Untitled Session";
  let J = ji(G);
  if (!J) return "Untitled Session";
  let U = ZZ(J);
  if (!U) return "Untitled Session";
  return jZ(wZ(U, Q));
}
function wi(X) {
  return `\u4EE5\u4E0B\u306E\u30E6\u30FC\u30B6\u30FC\u30E1\u30C3\u30BB\u30FC\u30B8\u304B\u3089\u3001\u7C21\u6F54\u306A\u30BB\u30C3\u30B7\u30E7\u30F3\u540D\u30921\u3064\u751F\u6210\u3057\u3066\u304F\u3060\u3055\u3044\u3002

## \u30E6\u30FC\u30B6\u30FC\u30E1\u30C3\u30BB\u30FC\u30B8
${X}

## \u30EB\u30FC\u30EB
- 15\u6587\u5B57\u4EE5\u5185\u3067\u7C21\u6F54\u306B
- \u30E1\u30C3\u30BB\u30FC\u30B8\u304C\u65E5\u672C\u8A9E\u306A\u3089\u65E5\u672C\u8A9E\u3001\u82F1\u8A9E\u306A\u3089\u82F1\u8A9E\u3067
- \u4E3B\u8981\u306A\u610F\u56F3\u3092\u7AEF\u7684\u306B\u8868\u73FE\uFF08\u4F8B: \u300C\u8A8D\u8A3C\u5B9F\u88C5\u300D\u300C\u30D0\u30B0\u4FEE\u6B63\u300D\u300CUI\u6539\u5584\u300D\uFF09
- \u7279\u6B8A\u6587\u5B57\u306F\u4F7F\u308F\u306A\u3044
- \u540D\u8A5E\u5F62\u3067\u51FA\u529B

\u30BB\u30C3\u30B7\u30E7\u30F3\u540D:`;
}
function Ci(X, Y) {
  let Q =
      X.split(
        `
`
      )[0]?.trim() || "",
    G = ZZ(Q);
  if (G.length === 0) return "";
  return jZ(wZ(G, Y));
}
async function CZ(X, Y = {}) {
  let { maxLength: Q = 15, useAI: G = !0 } = Y,
    J = X.trim();
  if (!J) return "Untitled Session";
  if (!G) return WL(X, { maxLength: Q });
  try {
    let U = wi(J),
      $ = "";
    for await (let K of m4({
      prompt: U,
      options: { allowedTools: [], maxTurns: 1 },
    }))
      if (K.type === "assistant" && K.message?.content) {
        for (let V of K.message.content) if ("text" in V) $ += V.text;
      }
    let B = Ci($, Q);
    if (B.length < 3) return WL(X, { maxLength: Q });
    return B;
  } catch {
    return WL(X, { maxLength: Q });
  }
}
function IZ(X) {
  let Y = y4(X, ["timestamp"]);
  if (
    ((Y.compressed = Y.compressed ?? !1),
    typeof X.metadata === "string" && X.metadata)
  )
    try {
      Y.metadata = JSON.parse(X.metadata);
    } catch {
      Y.metadata = void 0;
    }
  return Y;
}
function OJ(X) {
  try {
    let Y = H6("msg"),
      Q = K5();
    return (
      f1(
        `INSERT INTO messages (
        message_id, session_id, type, content, compressed,
        original_size, compressed_size, metadata, timestamp
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        Y,
        X.sessionId,
        X.type,
        X.content,
        X.compressed ? 1 : 0,
        X.originalSize ?? null,
        X.compressedSize ?? null,
        X.metadata ? JSON.stringify(X.metadata) : null,
        Q
      ),
      Ii(Y)
    );
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to create message: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function Ii(X) {
  try {
    let Y = b1("SELECT * FROM messages WHERE message_id = ?", X);
    return Y ? IZ(Y) : null;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to get message: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
function HL(X, Y = {}) {
  try {
    let { page: Q = 1, limit: G = 50, type: J, from: U, to: $ } = Y,
      B = ["session_id = ?"],
      K = [X];
    if (J) (B.push("type = ?"), K.push(J));
    if (U) (B.push("timestamp >= ?"), K.push(U.toISOString()));
    if ($) (B.push("timestamp <= ?"), K.push($.toISOString()));
    let V = `WHERE ${B.join(" AND ")}`,
      L = b1(`SELECT COUNT(*) as count FROM messages ${V}`, ...K)?.count ?? 0,
      H = (Q - 1) * G;
    return {
      items: X5(
        `SELECT * FROM messages ${V} ORDER BY timestamp ASC LIMIT ? OFFSET ?`,
        ...K,
        G,
        H
      ).map(IZ),
      pagination: g8(L, Q, G),
    };
  } catch (Q) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to list messages: ${Q instanceof Error ? Q.message : "Unknown error"}`,
      500
    );
  }
}
function ZJ(X, Y = {}) {
  return HL(X, Y);
}
function PZ(X) {
  try {
    return f1("DELETE FROM messages WHERE message_id = ?", X).changes > 0;
  } catch (Y) {
    throw new R1(
      N1.DATABASE_ERROR,
      `Failed to delete message: ${Y instanceof Error ? Y.message : "Unknown error"}`,
      500
    );
  }
}
var Pi = X0.object({
    content: X0.string().min(
      1,
      "\u30E1\u30C3\u30BB\u30FC\u30B8\u5185\u5BB9\u306F\u5FC5\u9808\u3067\u3059"
    ),
    type: X0.enum([
      "user",
      "assistant",
      "system",
      "tool_use",
      "tool_result",
      "thinking",
      "error",
    ]).optional(),
    metadata: X0.record(X0.unknown()).optional(),
  }),
  Si = X0.object({
    type: X0.enum([
      "user",
      "assistant",
      "system",
      "tool_use",
      "tool_result",
      "thinking",
      "error",
    ]).optional(),
    page: X0.coerce.number().int().min(1).optional(),
    limit: X0.coerce.number().int().min(1).max(100).optional(),
  }),
  F7 = new c1();
F7.use("/*", async (X, Y) => {
  let Q = X.req.param("sessionId");
  if (!Q) return X.json({ error: "Session ID is required" }, 400);
  let G = u8(Q);
  if (!G) return X.json({ error: "Session not found", sessionId: Q }, 404);
  (X.set("session", G), X.set("sessionId", Q), await Y());
});
F7.post(
  "/",
  s0("json", Pi, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.get("sessionId"),
      Q = X.req.valid("json"),
      G = OJ({
        sessionId: Y,
        type: Q.type ?? "user",
        content: Q.content,
        metadata: Q.metadata,
      });
    return X.json(G, 201);
  }
);
F7.get(
  "/",
  s0("query", Si, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.get("sessionId"),
      { type: Q, page: G, limit: J } = X.req.valid("query"),
      U = HL(Y, { type: Q, page: G ?? 1, limit: J ?? 50 });
    return X.json(U);
  }
);
F7.delete("/:messageId", async (X) => {
  let Y = X.req.param("messageId");
  if (!PZ(Y)) return X.json({ error: "Message not found", messageId: Y }, 404);
  return X.body(null, 204);
});
function $L(X) {
  return {
    summaryId: X.summary_id,
    sessionId: X.session_id,
    shortSummary: X.short_summary,
    detailedSummary: X.detailed_summary,
    keyDecisions: JSON.parse(X.key_decisions),
    filesModified: JSON.parse(X.files_modified),
    toolsUsed: JSON.parse(X.tools_used),
    topics: JSON.parse(X.topics),
    originalTokenCount: X.original_token_count,
    summaryTokenCount: X.summary_token_count,
    compressionRatio: X.compression_ratio,
    createdAt: new Date(X.created_at),
    updatedAt: new Date(X.updated_at),
  };
}
function x9(X) {
  let Y = H6(),
    Q = K5();
  return (
    f1("DELETE FROM summaries WHERE session_id = ?", X.sessionId),
    f1(
      `INSERT INTO summaries (
      summary_id, session_id, short_summary, detailed_summary,
      key_decisions, files_modified, tools_used, topics,
      original_token_count, summary_token_count, compression_ratio,
      created_at, updated_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      Y,
      X.sessionId,
      X.shortSummary,
      X.detailedSummary,
      JSON.stringify(X.keyDecisions),
      JSON.stringify(X.filesModified),
      JSON.stringify(X.toolsUsed),
      JSON.stringify(X.topics),
      X.originalTokenCount,
      X.summaryTokenCount,
      X.compressionRatio,
      Q,
      Q
    ),
    {
      summaryId: Y,
      sessionId: X.sessionId,
      shortSummary: X.shortSummary,
      detailedSummary: X.detailedSummary,
      keyDecisions: X.keyDecisions,
      filesModified: X.filesModified,
      toolsUsed: X.toolsUsed,
      topics: X.topics,
      originalTokenCount: X.originalTokenCount,
      summaryTokenCount: X.summaryTokenCount,
      compressionRatio: X.compressionRatio,
      createdAt: new Date(Q),
      updatedAt: new Date(Q),
    }
  );
}
function jJ(X) {
  let Y = b1("SELECT * FROM summaries WHERE session_id = ?", X);
  if (!Y) return null;
  return $L(Y);
}
function wJ(X) {
  if (X.length === 0) return new Map();
  let Y = X.map(() => "?").join(", "),
    Q = X5(`SELECT * FROM summaries WHERE session_id IN (${Y})`, ...X),
    G = new Map();
  for (let J of Q) G.set(J.session_id, $L(J));
  return G;
}
function SZ(X) {
  let Y = X?.page ?? 1,
    Q = X?.limit ?? 20,
    G = (Y - 1) * Q,
    U = b1("SELECT COUNT(*) as count FROM summaries")?.count ?? 0;
  return {
    items: X5(
      "SELECT * FROM summaries ORDER BY created_at DESC LIMIT ? OFFSET ?",
      Q,
      G
    ).map($L),
    pagination: g8(U, Y, Q),
  };
}
async function h9(X, Y, Q = {}) {
  let { maxTurns: G = 1 } = Q;
  if (Y.length === 0) return ki(X);
  let J = Ti(Y),
    U = YQ(J),
    $ = QQ(Y);
  try {
    let B = bi(J),
      K = "";
    for await (let q of m4({
      prompt: B,
      options: { allowedTools: [], maxTurns: G },
    }))
      if (q.type === "assistant" && q.message?.content) {
        for (let M of q.message.content) if ("text" in M) K += M.text;
      }
    let {
        shortSummary: V,
        detailedSummary: W,
        keyDecisions: L,
      } = vi(K, $.keyDecisions),
      H = YQ(V + W),
      F = U > 0 ? U / H : 0,
      N = new Date(K5());
    return {
      summaryId: H6(),
      sessionId: X,
      shortSummary: V,
      detailedSummary: W,
      keyDecisions: L,
      filesModified: $.filesModified,
      toolsUsed: $.toolsUsed,
      topics: $.topics,
      originalTokenCount: U,
      summaryTokenCount: H,
      compressionRatio: F,
      createdAt: N,
      updatedAt: N,
    };
  } catch {
    return yi(X, Y, $);
  }
}
function QQ(X) {
  let Y = new Set(),
    Q = new Set(),
    G = new Set(),
    J = [];
  for (let U of X) {
    if (U.type === "tool_use")
      try {
        let $ = JSON.parse(U.content);
        if ($.tool) Y.add($.tool);
        if ($.input?.file_path) Q.add($.input.file_path);
      } catch {}
    if (U.type === "assistant") {
      let $ = [
        /(.+)\u306B\u8A2D\u5B9A\u3057\u307E\u3057\u305F/g,
        /(.+)\u3092\u63A1\u7528\u3057\u307E\u3057\u305F/g,
        /(.+)\u3067\u5B9F\u88C5\u3057\u307E\u3059/g,
      ];
      for (let K of $) {
        let V = U.content.matchAll(K);
        for (let W of V) J.push(W[0]);
      }
      let B = U.content.match(
        /\b(JWT|OAuth|API|REST|GraphQL|SQL|Redis|\u8A8D\u8A3C|\u30BB\u30AD\u30E5\u30EA\u30C6\u30A3|\u30DF\u30C9\u30EB\u30A6\u30A7\u30A2)\b/gi
      );
      if (B) B.forEach((K) => G.add(K));
    }
  }
  return {
    toolsUsed: Array.from(Y),
    filesModified: Array.from(Q),
    topics: Array.from(G),
    keyDecisions: J,
  };
}
function YQ(X) {
  if (!X) return 0;
  let Y = X.match(/[\u3000-\u9fff]/g) || [],
    Q = X.length - Y.length,
    G = Y.length / 1.5,
    J = Q / 4;
  return Math.ceil(G + J);
}
function Ti(X) {
  return X.map((Y) => {
    let Q = Y.type === "user" ? "User" : "Assistant";
    if (Y.type === "tool_use" || Y.type === "tool_result")
      return `[Tool: ${Y.type}]
${Y.content}`;
    return `${Q}: ${Y.content}`;
  }).join(`

`);
}
function bi(X) {
  return `\u4EE5\u4E0B\u306E\u4F1A\u8A71\u3092\u8981\u7D04\u3057\u3066\u304F\u3060\u3055\u3044\u3002

## \u51FA\u529B\u5F62\u5F0F
SHORT_SUMMARY:\uFF081-2\u6587\u3067\u7C21\u6F54\u306B\uFF09
DETAILED_SUMMARY:\uFF083-5\u6587\u3067\u8A73\u7D30\u306B\uFF09
KEY_DECISIONS:\uFF08\u91CD\u8981\u306A\u6C7A\u5B9A\u4E8B\u9805\u3092\u30EA\u30B9\u30C8\u5F62\u5F0F\u3067\uFF09

## \u4F1A\u8A71\u5185\u5BB9
${X}`;
}
function vi(X, Y) {
  let Q = X.match(/SHORT_SUMMARY:\s*(.+?)(?=DETAILED_SUMMARY:|$)/s),
    G = X.match(/DETAILED_SUMMARY:\s*(.+?)(?=KEY_DECISIONS:|$)/s),
    J = X.match(/KEY_DECISIONS:\s*(.+)$/s),
    U = Q?.[1]?.trim() || "",
    $ = G?.[1]?.trim() || "",
    B = Y;
  if (J)
    B = J[1]
      .trim()
      .split(/[\n\u30FB\-]/)
      .map((V) => V.trim())
      .filter((V) => V.length > 0);
  return { shortSummary: U, detailedSummary: $, keyDecisions: B };
}
function ki(X) {
  let Y = new Date(K5());
  return {
    summaryId: H6(),
    sessionId: X,
    shortSummary: "",
    detailedSummary: "",
    keyDecisions: [],
    filesModified: [],
    toolsUsed: [],
    topics: [],
    originalTokenCount: 0,
    summaryTokenCount: 0,
    compressionRatio: 0,
    createdAt: Y,
    updatedAt: Y,
  };
}
function yi(X, Y, Q) {
  let G = new Date(K5()),
    U = Y.find((K) => K.type === "user")?.content.slice(0, 100) || "",
    $ = `\u8981\u7D04\u751F\u6210\u306B\u5931\u6557\u3057\u307E\u3057\u305F\u3002\u30E1\u30C3\u30BB\u30FC\u30B8\u6570: ${Y.length}\u4EF6\u3001\u4F7F\u7528\u30C4\u30FC\u30EB: ${Q.toolsUsed.join(", ") || "\u306A\u3057"}`,
    B = YQ(
      Y.map((K) => K.content).join(`
`)
    );
  return {
    summaryId: H6(),
    sessionId: X,
    shortSummary: U,
    detailedSummary: $,
    keyDecisions: Q.keyDecisions,
    filesModified: Q.filesModified,
    toolsUsed: Q.toolsUsed,
    topics: Q.topics,
    originalTokenCount: B,
    summaryTokenCount: YQ(U + $),
    compressionRatio: 0,
    createdAt: G,
    updatedAt: G,
  };
}
function TZ(X, Y) {
  let Q = _i(X, Y),
    G = fi(X, Y);
  return { importance: Q, category: G };
}
function _i(X, Y) {
  let Q = Y.filesModified.length,
    G = Y.keyDecisions.length,
    J = YQ(
      X.map((U) => U.content).join(`
`)
    );
  if (Q >= 10 || G >= 5 || J >= 1e4) return "high";
  if (Q === 0 && G === 0 && J < 1000) return "low";
  return "medium";
}
function fi(X, Y) {
  let Q = X.map((B) => B.content)
    .join(
      `
`
    )
    .toLowerCase();
  if (
    [
      /fix(ed|ing)?\s+(bug|error|issue)/i,
      /\u30D0\u30B0(\u4FEE\u6B63|\u30D5\u30A3\u30C3\u30AF\u30B9)/i,
      /\u30A8\u30E9\u30FC(\u4FEE\u6B63|\u5BFE\u5FDC)/i,
      /issue\s*#?\d+/i,
      /hotfix/i,
    ].some((B) => B.test(Q))
  )
    return "bugfix";
  if (
    [
      /add(ed|ing)?\s+new/i,
      /implement(ed|ing)?/i,
      /\u65B0\u6A5F\u80FD/i,
      /\u6A5F\u80FD\u8FFD\u52A0/i,
      /feature/i,
    ].some((B) => B.test(Q))
  )
    return "feature";
  if (
    [
      /refactor(ed|ing)?/i,
      /\u30EA\u30D5\u30A1\u30AF\u30BF(\u30EA\u30F3\u30B0)?/i,
      /\u6574\u7406/i,
      /cleanup/i,
      /restructure/i,
    ].some((B) => B.test(Q))
  )
    return "refactor";
  if (
    [
      /\u8ABF\u67FB/i,
      /\u8A66\u884C\u932F\u8AA4/i,
      /investigate/i,
      /explore/i,
      /research/i,
      /\u691C\u8A0E/i,
    ].some((B) => B.test(Q)) ||
    Y.toolsUsed.length <= 2
  )
    return "exploration";
  if (Y.filesModified.length > 0) return "feature";
  return "other";
}
var CJ = {
  feature: "\u65B0\u6A5F\u80FD",
  bugfix: "\u30D0\u30B0\u4FEE\u6B63",
  refactor: "\u30EA\u30D5\u30A1\u30AF\u30BF\u30EA\u30F3\u30B0",
  docs: "\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8",
  test: "\u30C6\u30B9\u30C8",
  config: "\u8A2D\u5B9A\u30FB\u74B0\u5883",
  exploration: "\u8ABF\u67FB\u30FB\u8A66\u884C\u932F\u8AA4",
};
function N7(X) {
  if (!X) return 0;
  let Y = X.match(/[\u3000-\u9fff]/g) || [],
    Q = X.length - Y.length,
    G = Y.length / 1.5,
    J = Q / 4;
  return Math.ceil(G + J);
}
function xi(X) {
  return `\u4EE5\u4E0B\u306E observations \u3092\u5206\u6790\u3057\u3001\u4F5C\u696D\u5185\u5BB9\u306B\u57FA\u3065\u3044\u3066\u30B0\u30EB\u30FC\u30D7\u5206\u3051\u3057\u3066\u304F\u3060\u3055\u3044\u3002

## \u30AB\u30C6\u30B4\u30EA
- feature: \u65B0\u6A5F\u80FD\u306E\u5B9F\u88C5
- bugfix: \u30D0\u30B0\u4FEE\u6B63
- refactor: \u30EA\u30D5\u30A1\u30AF\u30BF\u30EA\u30F3\u30B0
- docs: \u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u66F4\u65B0
- test: \u30C6\u30B9\u30C8\u8FFD\u52A0\u30FB\u4FEE\u6B63
- config: \u8A2D\u5B9A\u30FB\u74B0\u5883\u69CB\u7BC9
- exploration: \u8ABF\u67FB\u30FB\u8A66\u884C\u932F\u8AA4

## \u51FA\u529B\u5F62\u5F0F\uFF08JSON\uFF09
{
  "groups": [
    {
      "category": "feature",
      "description": "\u8A8D\u8A3C\u6A5F\u80FD\u306E\u5B9F\u88C5",
      "observationIds": ["ch_ob_0001", "ch_ob_0002"]
    }
  ]
}

## \u6CE8\u610F\u4E8B\u9805
- \u95A2\u9023\u3059\u308B observations \u306F\u540C\u3058\u30B0\u30EB\u30FC\u30D7\u306B\u307E\u3068\u3081\u308B
- 1\u3064\u306E observation \u306F1\u3064\u306E\u30B0\u30EB\u30FC\u30D7\u306B\u306E\u307F\u5C5E\u3059\u308B
- \u7A7A\u306E\u30B0\u30EB\u30FC\u30D7\u306F\u4F5C\u6210\u3057\u306A\u3044
- description \u306F\u65E5\u672C\u8A9E\u3067\u7C21\u6F54\u306B\uFF0820\u6587\u5B57\u4EE5\u5185\uFF09

## Observations
${X.map((Q, G) => {
  let J = Q.metadata ? JSON.stringify(Q.metadata) : "";
  return `[${G + 1}] ID: ${Q.observationId}
Type: ${Q.type}
Title: ${Q.title}
Content: ${Q.content.slice(0, 200)}${Q.content.length > 200 ? "..." : ""}
${J ? `Metadata: ${J.slice(0, 100)}` : ""}`;
}).join(`

`)}`;
}
function hi(X, Y) {
  let Q = X.match(/\{[\s\S]*\}/);
  if (!Q) return UL(Y);
  try {
    let G = JSON.parse(Q[0]),
      J = [],
      U = new Map();
    for (let V of Y) {
      let W = N7(V.title) + N7(V.content);
      U.set(V.observationId, W);
    }
    let $ = new Set(Y.map((V) => V.observationId));
    for (let V of G.groups || []) {
      let W = V.category;
      if (!CJ[W]) continue;
      let L = (V.observationIds || []).filter((F) => $.has(F));
      if (L.length === 0) continue;
      let H = L.reduce((F, N) => F + (U.get(N) || 0), 0);
      J.push({
        category: W,
        categoryLabel: CJ[W],
        description: V.description || "",
        observationIds: L,
        estimatedTokens: H,
      });
    }
    let B = new Set(J.flatMap((V) => V.observationIds)),
      K = Y.filter((V) => !B.has(V.observationId));
    if (K.length > 0) {
      let V = K.reduce((W, L) => W + (U.get(L.observationId) || 0), 0);
      J.push({
        category: "exploration",
        categoryLabel: CJ.exploration,
        description: "\u305D\u306E\u4ED6\u306E\u4F5C\u696D",
        observationIds: K.map((W) => W.observationId),
        estimatedTokens: V,
      });
    }
    return J;
  } catch {
    return UL(Y);
  }
}
function UL(X) {
  let Y = new Map();
  for (let J of X) {
    let U = Y.get(J.type) || [];
    (U.push(J), Y.set(J.type, U));
  }
  let Q = [],
    G = {
      tool_use: "feature",
      decision: "feature",
      error: "bugfix",
      learning: "exploration",
      note: "docs",
      file_change: "feature",
    };
  for (let [J, U] of Y) {
    let $ = G[J] || "exploration",
      B = U.reduce((K, V) => K + N7(V.title) + N7(V.content), 0);
    Q.push({
      category: $,
      categoryLabel: CJ[$],
      description: `${J} \u30BF\u30A4\u30D7\u306E\u8A18\u9332`,
      observationIds: U.map((K) => K.observationId),
      estimatedTokens: B,
    });
  }
  return Q;
}
async function bZ(X) {
  let Y = Date.now();
  if (X.length === 0)
    return {
      groups: [],
      analysisTimeMs: 0,
      totalObservations: 0,
      totalEstimatedTokens: 0,
    };
  let Q = X.reduce((G, J) => G + N7(J.title) + N7(J.content), 0);
  try {
    let G = xi(X),
      J = "";
    for await (let $ of m4({
      prompt: G,
      options: { allowedTools: [], maxTurns: 1 },
    }))
      if ($.type === "assistant" && $.message?.content) {
        for (let B of $.message.content) if ("text" in B) J += B.text;
      }
    return {
      groups: hi(J, X),
      analysisTimeMs: Date.now() - Y,
      totalObservations: X.length,
      totalEstimatedTokens: Q,
    };
  } catch (G) {
    return (
      console.error(
        "[observation-analyzer] Agent SDK error, using fallback:",
        G
      ),
      {
        groups: UL(X),
        analysisTimeMs: Date.now() - Y,
        totalObservations: X.length,
        totalEstimatedTokens: Q,
      }
    );
  }
}
function vZ(X) {
  if (X.length === 0) return { hasIssues: !1 };
  let Y = gi(X);
  if (Y.hasIssues) return Y;
  let Q = ui(X);
  if (Q.hasIssues) return Q;
  let G = li(X);
  if (G.hasIssues) return G;
  let J = mi(X);
  if (J.hasIssues) return J;
  return { hasIssues: !1 };
}
function gi(X) {
  let Y = X.filter((G) => G.type === "error");
  if (Y.length < 3) return { hasIssues: !1 };
  let Q = new Map();
  for (let G of Y) {
    let J = G.content.slice(0, 100).toLowerCase();
    Q.set(J, (Q.get(J) || 0) + 1);
  }
  for (let [G, J] of Q)
    if (J >= 3)
      return {
        hasIssues: !0,
        issueType: "error_loop",
        details: `\u540C\u3058\u30A8\u30E9\u30FC\u304C${J}\u56DE\u7E70\u308A\u8FD4\u3055\u308C\u307E\u3057\u305F: "${G.slice(0, 50)}..."`,
      };
  return { hasIssues: !1 };
}
function ui(X) {
  let Y = X.filter((G) => {
    if (G.type === "file_change") return !0;
    if (G.type === "tool_use") {
      let J = G.content.toLowerCase();
      return J.includes("edit") || J.includes("write");
    }
    return !1;
  });
  if (Y.length < 5) return { hasIssues: !1 };
  let Q = new Map();
  for (let G of Y) {
    let J = G.metadata,
      U = J?.file_path || J?.path || ci(G.content);
    if (U) Q.set(U, (Q.get(U) || 0) + 1);
  }
  for (let [G, J] of Q)
    if (J >= 5)
      return {
        hasIssues: !0,
        issueType: "edit_loop",
        details: `\u540C\u3058\u30D5\u30A1\u30A4\u30EB\u304C${J}\u56DE\u7DE8\u96C6\u3055\u308C\u307E\u3057\u305F: "${G}"`,
      };
  return { hasIssues: !1 };
}
function li(X) {
  let Y = ["test", "jest", "vitest", "mocha", "fail", "error"],
    Q = [];
  for (let G = 0; G < X.length; G++) {
    let J = X[G],
      U = J.content.toLowerCase();
    if (
      J.type === "error" ||
      (U.includes("fail") && Y.some(($) => U.includes($)))
    )
      Q.push(G);
  }
  if (Q.length >= 3) {
    let G = !1;
    for (let J = 0; J < Q.length - 1; J++) {
      let U = Q[J],
        $ = Q[J + 1];
      for (let B = U + 1; B < $; B++) {
        let K = X[B];
        if (K.type === "file_change" || K.type === "tool_use") {
          G = !0;
          break;
        }
      }
      if (G) break;
    }
    if (G)
      return {
        hasIssues: !0,
        issueType: "test_failure_loop",
        details: `\u30C6\u30B9\u30C8\u5931\u6557\u2192\u4FEE\u6B63\u2192\u518D\u5931\u6557\u306E\u30EB\u30FC\u30D7\u304C${Q.length}\u56DE\u691C\u51FA\u3055\u308C\u307E\u3057\u305F`,
      };
  }
  return { hasIssues: !1 };
}
function mi(X) {
  let Y = [
    "git reset",
    "git revert",
    "git checkout --",
    "undo",
    "rollback",
    "\u5143\u306B\u623B",
    "\u53D6\u308A\u6D88",
  ];
  for (let Q of X) {
    let G = Q.content.toLowerCase();
    for (let J of Y)
      if (G.includes(J))
        return {
          hasIssues: !0,
          issueType: "rollback",
          details: `\u30ED\u30FC\u30EB\u30D0\u30C3\u30AF\u64CD\u4F5C\u304C\u691C\u51FA\u3055\u308C\u307E\u3057\u305F: "${J}"`,
        };
  }
  return { hasIssues: !1 };
}
function ci(X) {
  let Y = [
    /"file_path":\s*"([^"]+)"/,
    /"path":\s*"([^"]+)"/,
    /file:\s*([^\s,]+)/i,
    /editing\s+([^\s,]+)/i,
    /writing\s+to\s+([^\s,]+)/i,
  ];
  for (let Q of Y) {
    let G = X.match(Q);
    if (G?.[1]) return G[1];
  }
  return null;
}
var kZ = { debug: 0, info: 1, warn: 2, error: 3 },
  di = process.env.LOG_LEVEL || "info";
function IJ(X) {
  return kZ[X] >= kZ[di];
}
function pi() {
  return new Date().toISOString();
}
function PJ(X, Y, Q, G) {
  let J = pi(),
    U = G ? ` ${JSON.stringify(G)}` : "";
  return `[${J}] [${X.toUpperCase()}] [${Y}] ${Q}${U}`;
}
function ii(X) {
  if (X instanceof Error)
    return `${X.message}${
      X.stack
        ? `
${X.stack}`
        : ""
    }`;
  return String(X);
}
function LL(X) {
  return {
    debug: (Y, Q) => {
      if (IJ("debug")) console.error(PJ("debug", X, Y, Q));
    },
    info: (Y, Q) => {
      if (IJ("info")) console.error(PJ("info", X, Y, Q));
    },
    warn: (Y, Q) => {
      if (IJ("warn")) console.error(PJ("warn", X, Y, Q));
    },
    error: (Y, Q, G) => {
      if (IJ("error")) {
        let J = Q ? `: ${ii(Q)}` : "";
        console.error(PJ("error", X, Y + J, G));
      }
    },
  };
}
var gW0 = LL("API"),
  t0 = LL("Hook"),
  uW0 = LL("Session");
function GQ(X, Y, Q = "session") {
  try {
    let G = QQ(Y),
      J = TZ(Y, G),
      U = v9({ sessionId: X, limit: 100 }),
      $ = vZ(U.items);
    pz(X, {
      importance: J.importance,
      category: J.category,
      hasIssues: $.hasIssues,
      issueType: $.issueType,
    });
    let B = {
      importance: J.importance,
      category: J.category,
      hasIssues: $.hasIssues,
      issueType: $.issueType,
    };
    return (t0.info(`${Q} classification updated`, { sessionId: X, ...B }), B);
  } catch (G) {
    return (
      t0.warn(`${Q} classification failed`, {
        sessionId: X,
        error: G instanceof Error ? G.message : String(G),
      }),
      null
    );
  }
}
var c4 = new c1(),
  SJ = 1000,
  ni = X0.object({
    type: X0.enum([
      "tool_use",
      "decision",
      "error",
      "learning",
      "note",
      "file_change",
    ]).optional(),
    limit: X0.coerce.number().min(1).max(500).default(100),
    page: X0.coerce.number().min(1).default(1),
  }),
  ai = X0.object({
    type: X0.enum([
      "tool_use",
      "decision",
      "error",
      "learning",
      "note",
      "file_change",
    ]),
    title: X0.string().min(1).max(500),
    content: X0.string().max(1e4).default(""),
    metadata: X0.record(X0.unknown()).optional(),
  }),
  ri = X0.object({
    observationIds: X0.array(X0.string()).min(1),
    groupName: X0.string().min(1).max(200),
  }),
  oi = X0.object({
    observationIds: X0.array(X0.string()).min(1),
    groupName: X0.string().min(1).max(200),
    deleteAfterExport: X0.boolean().default(!0),
  });
c4.get(
  "/",
  s0("query", ni, (X, Y) => {
    if (!X.success)
      return Y.json(
        {
          error: {
            code: "VALIDATION_ERROR",
            message: "Validation Error",
            details: X.error.flatten().fieldErrors,
          },
        },
        400
      );
  }),
  async (X) => {
    let Y = X.req.param("sessionId");
    if (!Y)
      return X.json(
        { error: { code: "MISSING_PARAM", message: "Session ID is required" } },
        400
      );
    let Q = X.req.valid("query");
    if (!a1(Y))
      return X.json(
        { error: { code: "SESSION_NOT_FOUND", message: "Session not found" } },
        404
      );
    let J = v9({ sessionId: Y, type: Q.type, page: Q.page, limit: Q.limit });
    return X.json(J);
  }
);
c4.post(
  "/",
  s0("json", ai, (X, Y) => {
    if (!X.success)
      return Y.json(
        {
          error: {
            code: "VALIDATION_ERROR",
            message: "Validation Error",
            details: X.error.flatten().fieldErrors,
          },
        },
        400
      );
  }),
  async (X) => {
    let Y = X.req.param("sessionId");
    if (!Y)
      return X.json(
        { error: { code: "MISSING_PARAM", message: "Session ID is required" } },
        400
      );
    let Q = X.req.valid("json");
    if (!a1(Y))
      return X.json(
        { error: { code: "SESSION_NOT_FOUND", message: "Session not found" } },
        404
      );
    let J = Q4({
      sessionId: Y,
      type: Q.type,
      title: Q.title,
      content: Q.content ?? "",
      metadata: Q.metadata,
    });
    return X.json(J, 201);
  }
);
c4.post("/analyze", async (X) => {
  let Y = X.req.param("sessionId");
  if (!Y)
    return X.json(
      { error: { code: "MISSING_PARAM", message: "Session ID is required" } },
      400
    );
  if (!a1(Y))
    return X.json(
      { error: { code: "SESSION_NOT_FOUND", message: "Session not found" } },
      404
    );
  let G = v9({ sessionId: Y, limit: 500, page: 1 });
  try {
    let J = await bZ(G.items);
    return X.json({ sessionId: Y, ...J });
  } catch (J) {
    return (
      t0.error("Observation analysis failed", {
        sessionId: Y,
        error: J instanceof Error ? J.message : String(J),
      }),
      X.json(
        {
          error: {
            code: "ANALYSIS_FAILED",
            message: "Failed to analyze observations",
          },
        },
        500
      )
    );
  }
});
async function si(X, Y) {
  try {
    t0.info("Starting background summary generation", { sessionId: X });
    let Q = await h9(X, Y);
    x9({
      sessionId: X,
      shortSummary: Q.shortSummary,
      detailedSummary: Q.detailedSummary,
      keyDecisions: Q.keyDecisions,
      filesModified: Q.filesModified,
      toolsUsed: Q.toolsUsed,
      topics: Q.topics,
      originalTokenCount: Q.originalTokenCount,
      summaryTokenCount: Q.summaryTokenCount,
      compressionRatio: Q.compressionRatio,
    });
    let G = [
      `## \u77ED\u3044\u8981\u7D04
${Q.shortSummary}`,
      `
## \u8A73\u7D30\u306A\u8981\u7D04
${Q.detailedSummary}`,
      Q.keyDecisions.length > 0
        ? `
## \u91CD\u8981\u306A\u6C7A\u5B9A\u4E8B\u9805
${Q.keyDecisions.map((J) => `- ${J}`).join(`
`)}`
        : "",
      Q.filesModified.length > 0
        ? `
## \u5909\u66F4\u30D5\u30A1\u30A4\u30EB
${Q.filesModified.map((J) => `- ${J}`).join(`
`)}`
        : "",
    ].filter(Boolean).join(`
`);
    (Q4({
      sessionId: X,
      type: "note",
      title: `Export Summary (${Q.originalTokenCount} \u2192 ${Q.summaryTokenCount} tokens)`,
      content: G,
      metadata: {
        originalTokenCount: Q.originalTokenCount,
        summaryTokenCount: Q.summaryTokenCount,
        compressionRatio: Q.compressionRatio,
        toolsUsed: Q.toolsUsed,
        topics: Q.topics,
      },
    }),
      GQ(X, Y, "Export"),
      l8(X, { status: "completed" }),
      t0.info("Background summary generation completed", { sessionId: X }));
  } catch (Q) {
    (t0.warn("Background summary generation failed (graceful degradation)", {
      sessionId: X,
      error: Q instanceof Error ? Q.message : String(Q),
    }),
      l8(X, { status: "completed" }));
  }
}
c4.post(
  "/export",
  s0("json", ri, (X, Y) => {
    if (!X.success)
      return Y.json(
        {
          error: {
            code: "VALIDATION_ERROR",
            message: "Validation Error",
            details: X.error.flatten().fieldErrors,
          },
        },
        400
      );
  }),
  async (X) => {
    let Y = X.req.param("sessionId");
    if (!Y)
      return X.json(
        { error: { code: "MISSING_PARAM", message: "Session ID is required" } },
        400
      );
    let { observationIds: Q, groupName: G } = X.req.valid("json");
    if (Q.length > SJ)
      return X.json(
        {
          error: {
            code: "TOO_MANY_OBSERVATIONS",
            message: `Cannot export more than ${SJ} observations at once`,
          },
        },
        400
      );
    let J = a1(Y);
    if (!J)
      return X.json(
        { error: { code: "SESSION_NOT_FOUND", message: "Session not found" } },
        404
      );
    let U = Q.map((W) => b9(W)).filter((W) => W !== null && W.sessionId === Y);
    if (U.length === 0)
      return X.json(
        {
          error: {
            code: "NO_MATCHING_OBSERVATIONS",
            message: "No matching observations found for the specified IDs",
          },
        },
        400
      );
    let $ = new Date().toISOString().slice(0, 16).replace("T", " "),
      B = `${G} (${$})`,
      K = T9({
        name: B,
        workingDir: J.workingDir,
        projectId: J.projectId ?? void 0,
      }),
      V = U.map((W) => ({
        messageId: W.observationId,
        sessionId: K.sessionId,
        type: W.type === "tool_use" ? "tool_use" : "assistant",
        content: `[${W.type}] ${W.title}

${W.content}`,
        compressed: !1,
        timestamp: W.createdAt,
      }));
    return (
      setImmediate(() => {
        si(K.sessionId, V);
      }),
      X.json(
        {
          session: K,
          summary: null,
          summaryStatus: "generating",
          observations: [],
          observationCount: U.length,
        },
        201
      )
    );
  }
);
async function ti(X, Y, Q) {
  try {
    t0.info("Starting background smart-export summary generation", {
      sessionId: X,
    });
    let G = await h9(X, Q);
    x9({
      sessionId: X,
      shortSummary: G.shortSummary,
      detailedSummary: G.detailedSummary,
      keyDecisions: G.keyDecisions,
      filesModified: G.filesModified,
      toolsUsed: G.toolsUsed,
      topics: G.topics,
      originalTokenCount: G.originalTokenCount,
      summaryTokenCount: G.summaryTokenCount,
      compressionRatio: G.compressionRatio,
    });
    let J = [
      `## \u77ED\u3044\u8981\u7D04
${G.shortSummary}`,
      `
## \u8A73\u7D30\u306A\u8981\u7D04
${G.detailedSummary}`,
      G.keyDecisions.length > 0
        ? `
## \u91CD\u8981\u306A\u6C7A\u5B9A\u4E8B\u9805
${G.keyDecisions.map((U) => `- ${U}`).join(`
`)}`
        : "",
      G.filesModified.length > 0
        ? `
## \u5909\u66F4\u30D5\u30A1\u30A4\u30EB
${G.filesModified.map((U) => `- ${U}`).join(`
`)}`
        : "",
    ].filter(Boolean).join(`
`);
    (Q4({
      sessionId: X,
      type: "note",
      title: `Smart Export Summary (${G.originalTokenCount} \u2192 ${G.summaryTokenCount} tokens)`,
      content: J,
      metadata: {
        originalTokenCount: G.originalTokenCount,
        summaryTokenCount: G.summaryTokenCount,
        compressionRatio: G.compressionRatio,
        toolsUsed: G.toolsUsed,
        topics: G.topics,
        sourceSessionId: Y,
      },
    }),
      GQ(X, Q, "Smart export"),
      l8(X, { status: "completed" }),
      t0.info("Background smart-export summary generation completed", {
        sessionId: X,
      }));
  } catch (G) {
    (t0.warn(
      "Background smart-export summary generation failed (graceful degradation)",
      { sessionId: X, error: G instanceof Error ? G.message : String(G) }
    ),
      l8(X, { status: "completed" }));
  }
}
c4.post(
  "/smart-export",
  s0("json", oi, (X, Y) => {
    if (!X.success)
      return Y.json(
        {
          error: {
            code: "VALIDATION_ERROR",
            message: "Validation Error",
            details: X.error.flatten().fieldErrors,
          },
        },
        400
      );
  }),
  async (X) => {
    let Y = X.req.param("sessionId");
    if (!Y)
      return X.json(
        { error: { code: "MISSING_PARAM", message: "Session ID is required" } },
        400
      );
    let {
      observationIds: Q,
      groupName: G,
      deleteAfterExport: J,
    } = X.req.valid("json");
    if (Q.length > SJ)
      return X.json(
        {
          error: {
            code: "TOO_MANY_OBSERVATIONS",
            message: `Cannot export more than ${SJ} observations at once`,
          },
        },
        400
      );
    let U = a1(Y);
    if (!U)
      return X.json(
        { error: { code: "SESSION_NOT_FOUND", message: "Session not found" } },
        404
      );
    let $ = Q.map((H) => b9(H)).filter((H) => H !== null && H.sessionId === Y);
    if ($.length === 0)
      return X.json(
        {
          error: {
            code: "NO_MATCHING_OBSERVATIONS",
            message: "No matching observations found for the specified IDs",
          },
        },
        400
      );
    let B = new Date().toISOString().slice(0, 16).replace("T", " "),
      K = `${G} (${B})`,
      V = T9({
        name: K,
        workingDir: U.workingDir,
        projectId: U.projectId ?? void 0,
      }),
      W = $.map((H) => ({
        messageId: H.observationId,
        sessionId: V.sessionId,
        type: H.type === "tool_use" ? "tool_use" : "assistant",
        content: `[${H.type}] ${H.title}

${H.content}`,
        compressed: !1,
        timestamp: H.createdAt,
      })),
      L = 0;
    if (J) {
      for (let H of $) if (_G(H.observationId)) L++;
      t0.info("Smart Export: Deleted observations from source session", {
        sourceSessionId: Y,
        deletedCount: L,
        newSessionId: V.sessionId,
      });
    }
    return (
      setImmediate(() => {
        ti(V.sessionId, Y, W);
      }),
      X.json(
        {
          session: V,
          summary: null,
          summaryStatus: "generating",
          observationCount: $.length,
          deletedCount: L,
          deleteAfterExport: J,
        },
        201
      )
    );
  }
);
var V8 = new c1();
V8.get(
  "/index",
  s0("query", BU, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("query"),
      Q = lz({
        page: Y.page,
        limit: Y.limit,
        status: Y.status,
        projectId: Y.projectId,
        workItemId: Y.workItemId,
      });
    return X.json(Q);
  }
);
V8.post(
  "/",
  s0("json", Mz, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("json"),
      Q = Y.projectId;
    if (!Q && Y.workingDir) Q = RU(Y.workingDir)?.projectId ?? void 0;
    let G = T9({
      name: Y.name,
      workingDir: Y.workingDir,
      task: Y.task,
      workItemId: Y.workItemId,
      projectId: Q,
      continueChat: Y.continueChat,
      dangerouslySkipPermissions: Y.dangerouslySkipPermissions,
    });
    return X.json(G, 201);
  }
);
V8.get(
  "/",
  s0("query", BU, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("query"),
      Q = SY({
        page: Y.page,
        limit: Y.limit,
        status: Y.status,
        projectId: Y.projectId,
        workItemId: Y.workItemId,
        includeDeleted: Y.includeDeleted,
      }),
      G = Q.items.map(($) => $.sessionId),
      J = EU(G),
      U = Q.items.map(($) => ({ ...$, tokenCount: J.get($.sessionId) || 0 }));
    return X.json({ ...Q, items: U });
  }
);
V8.post(
  "/bulk-delete",
  s0("json", Rz, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let { sessionIds: Y } = X.req.valid("json"),
      Q = [],
      G = 0,
      J = 0;
    for (let U of Y) {
      let $ = FU(U);
      if ((Q.push({ id: U, deleted: $ }), $)) G++;
      else J++;
    }
    return X.json({
      success: !0,
      totalRequested: Y.length,
      successCount: G,
      failCount: J,
      results: Q,
    });
  }
);
V8.get("/:id", async (X) => {
  let Y = X.req.param("id"),
    Q = a1(Y);
  if (!Q) return X.json({ error: "Session not found", sessionId: Y }, 404);
  let J = EU([Q.sessionId]).get(Q.sessionId) || 0;
  return X.json({ ...Q, tokenCount: J });
});
V8.patch(
  "/:id",
  s0("json", Az, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.param("id"),
      Q = X.req.valid("json");
    if (!a1(Y))
      return X.json({ error: "Session not found", sessionId: Y }, 404);
    let J = l8(Y, Q);
    return X.json(J);
  }
);
V8.delete("/:id", async (X) => {
  let Y = X.req.param("id");
  if (!FU(Y)) return X.json({ error: "Session not found", sessionId: Y }, 404);
  return X.body(null, 204);
});
V8.get("/:id/summary", async (X) => {
  let Y = X.req.param("id");
  if (!a1(Y)) return X.json({ error: "Session not found", sessionId: Y }, 404);
  let G = cz(Y);
  if (!G) return X.json({ error: "Summary not found", sessionId: Y }, 404);
  return X.json(G);
});
V8.post(
  "/:id/generate-name",
  s0("json", qz, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.param("id"),
      Q = X.req.valid("json"),
      G = a1(Y);
    if (!G) G = oX(Y);
    if (!G) return X.json({ error: "Session not found", sessionId: Y }, 404);
    let J = await CZ(Q.message);
    return X.json({ name: J, sessionId: G.sessionId });
  }
);
V8.route("/:sessionId/messages", F7);
V8.route("/:sessionId/observations", c4);
V8.route("/:sessionId", c4);
var _v = AY(KP(), 1),
  XY = { voyage: 1024, local: 384 };
var OF0 = XY.voyage,
  E$ = null,
  O$ = null,
  XG = null;
function a40() {
  if (E$) return E$;
  let X = process.env.VOYAGE_API_KEY;
  if (!X) return null;
  return ((E$ = new _v.VoyageAIClient({ apiKey: X })), E$);
}
async function r40() {
  if (O$) return O$;
  if (XG) return XG;
  return (
    (XG = (async () => {
      try {
        console.log("[Embeddings] Loading local model (all-MiniLM-L6-v2)...");
        let { pipeline: X } = await Promise.resolve().then(() => (tA(), yv));
        return (
          (O$ = await X("feature-extraction", "Xenova/all-MiniLM-L6-v2")),
          console.log("[Embeddings] Local model loaded successfully"),
          O$
        );
      } catch (X) {
        return (
          console.error("[Embeddings] Failed to load local model:", X),
          (XG = null),
          null
        );
      }
    })()),
    XG
  );
}
async function fv(X, Y) {
  let Q = a40();
  if (!Q) return null;
  try {
    let G = await Q.embed({ input: [X], model: "voyage-3.5", inputType: Y });
    if (!G.data || G.data.length === 0)
      return (
        console.error("[Embeddings] No embedding data in Voyage response"),
        null
      );
    return {
      embedding: G.data[0].embedding ?? [],
      totalTokens: G.usage?.totalTokens ?? 0,
      provider: "voyage",
      dimension: XY.voyage,
    };
  } catch (G) {
    return (console.error("[Embeddings] Voyage API failed:", G), null);
  }
}
async function xv(X) {
  try {
    let Y = await r40();
    if (!Y) return null;
    let Q = await Y(X, { pooling: "mean", normalize: !0 });
    return {
      embedding: Array.from(Q.data),
      totalTokens: Math.ceil(X.length / 4),
      provider: "local",
      dimension: XY.local,
    };
  } catch (Y) {
    return (console.error("[Embeddings] Local embedding failed:", Y), null);
  }
}
async function N9(X) {
  if (!X || X.trim().length === 0) return null;
  if (process.env.VOYAGE_API_KEY) {
    let Y = await fv(X, "document");
    if (Y) return Y;
    console.warn("[Embeddings] Voyage failed, falling back to local model");
  }
  return xv(X);
}
async function Z$(X) {
  if (!X || X.trim().length === 0) return null;
  if (process.env.VOYAGE_API_KEY) {
    let Y = await fv(X, "query");
    if (Y) return Y;
    console.warn("[Embeddings] Voyage failed, falling back to local model");
  }
  return xv(X);
}
function H8() {
  return !0;
}
var j$ = null;
function w$(X) {
  if (X === XY.local) return "vec_embeddings_local";
  return "vec_embeddings";
}
function vR() {
  if (j$ !== null) return j$;
  let X = P8();
  try {
    return (TG().load(X), (j$ = !0), !0);
  } catch {
    return (
      (j$ = !1),
      console.warn(
        "[Embedding] sqlite-vec not available. Vector operations disabled."
      ),
      !1
    );
  }
}
function EX(X, Y, Q, G = null, J = null, U = "voyage") {
  if (!vR()) return -1;
  let $ = P8(),
    B = Q.length,
    K = w$(B);
  o40(X, Y);
  let W = $.prepare(`INSERT INTO ${K} (embedding) VALUES (?)`).run(
      new Float32Array(Q)
    ),
    L = Number(W.lastInsertRowid);
  return (
    f1(
      `INSERT INTO embedding_index
      (embedding_id, source_type, source_id, session_id, content_preview, dimension, provider)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
      L,
      X,
      Y,
      G,
      J,
      B,
      U
    ),
    L
  );
}
function o40(X, Y) {
  let Q = b1(
    "SELECT embedding_id, dimension FROM embedding_index WHERE source_type = ? AND source_id = ?",
    X,
    Y
  );
  if (!Q) return !1;
  let G = w$(Q.dimension ?? XY.voyage);
  try {
    f1(`DELETE FROM ${G} WHERE rowid = ?`, Q.embedding_id);
  } catch {}
  return (
    f1(
      "DELETE FROM embedding_index WHERE source_type = ? AND source_id = ?",
      X,
      Y
    ),
    !0
  );
}
function YG(X, Y = 10, Q) {
  if (!vR()) return [];
  let G = P8(),
    J = X.length,
    $ = `
    SELECT
      ei.embedding_id,
      ei.source_type,
      ei.source_id,
      ei.session_id,
      ei.content_preview,
      ve.distance
    FROM ${w$(J)} ve
    INNER JOIN embedding_index ei ON ve.rowid = ei.embedding_id
    WHERE ve.embedding MATCH ?
      AND ei.dimension = ?
  `,
    B = [new Float32Array(X), J];
  if (Q && Q.length > 0) {
    let K = Q.map(() => "?").join(", ");
    (($ += ` AND ei.source_type IN (${K})`), B.push(...Q));
  }
  (($ += " AND k = ? ORDER BY ve.distance"), B.push(Y));
  try {
    return G.prepare($)
      .all(...B)
      .map((W) => ({
        embeddingId: W.embedding_id,
        sourceType: W.source_type,
        sourceId: W.source_id,
        sessionId: W.session_id,
        contentPreview: W.content_preview,
        distance: W.distance,
      }));
  } catch (K) {
    return (console.error("[Embedding] Search failed:", K), []);
  }
}
function C$(X, Y = 10) {
  if (!vR()) return [];
  let Q = P8(),
    G = X.length,
    U = `
    SELECT
      s.session_id,
      s.name as session_name,
      sm.short_summary,
      ve.distance
    FROM ${w$(G)} ve
    INNER JOIN embedding_index ei ON ve.rowid = ei.embedding_id
    INNER JOIN sessions s ON ei.session_id = s.session_id
    LEFT JOIN summaries sm ON s.session_id = sm.session_id
    WHERE ve.embedding MATCH ?
      AND ei.source_type = 'summary'
      AND ei.dimension = ?
      AND s.deleted_at IS NULL
      AND k = ?
    ORDER BY ve.distance
  `;
  try {
    return Q.prepare(U)
      .all(new Float32Array(X), G, Y)
      .map((K) => ({
        sessionId: K.session_id,
        sessionName: K.session_name,
        shortSummary: K.short_summary ?? "",
        distance: K.distance,
      }));
  } catch ($) {
    return (console.error("[Embedding] Session search failed:", $), []);
  }
}
function hv() {
  return b1("SELECT COUNT(*) as count FROM embedding_index")?.count ?? 0;
}
var QG = new c1();
QG.post("/sessions/:id/summarize", async (X) => {
  let Y = X.req.param("id");
  if (!u8(Y))
    return X.json(
      { error: { code: "SESSION_NOT_FOUND", message: "Session not found" } },
      404
    );
  let { items: G } = ZJ(Y),
    J = await h9(Y, G),
    U = x9({
      sessionId: J.sessionId,
      shortSummary: J.shortSummary,
      detailedSummary: J.detailedSummary,
      keyDecisions: J.keyDecisions,
      filesModified: J.filesModified,
      toolsUsed: J.toolsUsed,
      topics: J.topics,
      originalTokenCount: J.originalTokenCount,
      summaryTokenCount: J.summaryTokenCount,
      compressionRatio: J.compressionRatio,
    });
  if (H8()) {
    let $ = [U.shortSummary, U.detailedSummary, U.topics.join(" ")].join(`
`),
      B = await N9($);
    if (B)
      EX("summary", U.summaryId, B.embedding, Y, U.shortSummary.slice(0, 200));
  }
  return X.json(U, 200);
});
QG.get("/sessions/:id/summary", async (X) => {
  let Y = X.req.param("id");
  if (!u8(Y))
    return X.json(
      { error: { code: "SESSION_NOT_FOUND", message: "Session not found" } },
      404
    );
  let G = jJ(Y);
  if (!G)
    return X.json(
      {
        error: {
          code: "SUMMARY_NOT_FOUND",
          message: "Summary not found for this session",
        },
      },
      404
    );
  return X.json(G, 200);
});
QG.get("/summaries", async (X) => {
  let Y = Dz.parse({ page: X.req.query("page"), limit: X.req.query("limit") }),
    Q = SZ({ page: Y.page, limit: Y.limit });
  return X.json(Q, 200);
});
function I$(X) {
  let Y = 1 - X / 2;
  return Math.max(0, Math.min(1, Y));
}
var s40 = 5,
  t40 = 4000,
  e40 = 0.3,
  X90 = 3,
  Y90 = 5,
  Q90 = 2,
  G90 = 1.5,
  J90 = 4;
async function W90(X, Y = {}) {
  let { maxSessions: Q = s40, minRelevanceScore: G = e40 } = Y;
  if (!H8()) return [];
  let J = await Z$(X);
  if (!J) return [];
  let $ = C$(J.embedding, Q * Q90)
    .map((V) => ({ ...V, relevanceScore: I$(V.distance) }))
    .filter((V) => V.relevanceScore >= G)
    .slice(0, Q);
  if ($.length === 0) return [];
  let B = $.map((V) => V.sessionId),
    K = wJ(B);
  return $.map((V) => {
    let W = K.get(V.sessionId);
    return {
      sessionId: V.sessionId,
      sessionName: V.sessionName,
      shortSummary: V.shortSummary,
      detailedSummary: W?.detailedSummary,
      keyDecisions: W?.keyDecisions,
      filesModified: W?.filesModified,
      relevanceScore: V.relevanceScore,
    };
  });
}
async function P$(X, Y = {}) {
  let { maxTokens: Q = t40 } = Y,
    G = await W90(X, Y);
  if (G.length === 0)
    return { sessions: [], contextText: "", estimatedTokens: 0, query: X };
  let J = [],
    U = 0,
    $ = `## \u95A2\u9023\u3059\u308B\u904E\u53BB\u306E\u30BB\u30C3\u30B7\u30E7\u30F3

\u4EE5\u4E0B\u306F\u985E\u4F3C\u3057\u305F\u4F5C\u696D\u306E\u5C65\u6B74\u3067\u3059\uFF1A
`;
  (J.push($), (U += gv($)));
  for (let K of G) {
    let V = H90(K),
      W = gv(V);
    if (U + W > Q) break;
    (J.push(V), (U += W));
  }
  let B = J.join(`
`);
  return { sessions: G, contextText: B, estimatedTokens: U, query: X };
}
function H90(X) {
  let Y = [];
  if (
    (Y.push(`### ${X.sessionName}`),
    Y.push(`\u95A2\u9023\u5EA6: ${Math.round(X.relevanceScore * 100)}%`),
    Y.push(""),
    Y.push(X.detailedSummary || X.shortSummary),
    X.keyDecisions && X.keyDecisions.length > 0)
  ) {
    (Y.push(""), Y.push("**\u6C7A\u5B9A\u4E8B\u9805:**"));
    for (let Q of X.keyDecisions.slice(0, X90)) Y.push(`- ${Q}`);
  }
  if (X.filesModified && X.filesModified.length > 0) {
    (Y.push(""), Y.push("**\u95A2\u9023\u30D5\u30A1\u30A4\u30EB:**"));
    for (let Q of X.filesModified.slice(0, Y90)) Y.push(`- \`${Q}\``);
  }
  return (
    Y.push(""),
    Y.push("---"),
    Y.join(`
`)
  );
}
function gv(X) {
  if (!X) return 0;
  let Y = X.match(/[\u3000-\u9fff]/g) || [],
    Q = X.length - Y.length,
    G = Y.length / G90,
    J = Q / J90;
  return Math.ceil(G + J);
}
function S$() {
  return H8();
}
var GG = new Map();
var uv = null;
function $90(X) {
  if (uv) return;
  uv = setInterval(() => {
    let Y = Date.now();
    for (let [Q, G] of GG.entries()) {
      let J = G.filter((U) => Y - U < X);
      if (J.length === 0) GG.delete(Q);
      else GG.set(Q, J);
    }
  }, 300000);
}
function lv(X = {}) {
  let {
    windowMs: Y = 60000,
    maxRequests: Q = 30,
    message: G = "Too many requests, please try again later",
  } = X;
  return (
    $90(Y),
    async (J, U) => {
      let $ =
          J.req.header("x-forwarded-for") ||
          J.req.header("x-real-ip") ||
          "localhost",
        B = Date.now(),
        V = (GG.get($) || []).filter((W) => B - W < Y);
      if (V.length >= Q) {
        let W = Math.min(...V),
          L = Math.ceil((W + Y - B) / 1000);
        return (
          J.header("Retry-After", String(L)),
          J.header("X-RateLimit-Limit", String(Q)),
          J.header("X-RateLimit-Remaining", "0"),
          J.header("X-RateLimit-Reset", String(Math.ceil((W + Y) / 1000))),
          J.json(
            { error: "Rate limit exceeded", message: G, retryAfter: L },
            429
          )
        );
      }
      (V.push(B),
        GG.set($, V),
        J.header("X-RateLimit-Limit", String(Q)),
        J.header("X-RateLimit-Remaining", String(Q - V.length)),
        await U());
    }
  );
}
var kR = lv({
    windowMs: 60000,
    maxRequests: 20,
    message:
      "Search rate limit exceeded. Please wait before making more requests.",
  }),
  U90 = X0.object({
    query: X0.string().min(1).max(1000),
    limit: X0.number().int().min(1).max(50).optional().default(10),
  }),
  JG = new c1();
async function mv(X, Y) {
  if (!H8())
    return {
      error: "Semantic search is not available",
      message: "VOYAGE_API_KEY is not configured",
      status: 503,
    };
  let Q = await Z$(X);
  if (!Q)
    return {
      error: "Failed to process query",
      message: "Could not generate embedding for the query",
      status: 500,
    };
  let J = C$(Q.embedding, Y).map((U) => ({
    sessionId: U.sessionId,
    sessionName: U.sessionName,
    shortSummary: U.shortSummary,
    relevanceScore: I$(U.distance),
  }));
  return { results: J, totalResults: J.length, queryTokens: Q.totalTokens };
}
JG.get("/", kR, async (X) => {
  let Y = X.req.query("query") || X.req.query("q"),
    Q = X.req.query("limit");
  if (!Y)
    return X.json({ error: "Query parameter 'query' or 'q' is required" }, 400);
  let G = Q ? Math.min(Math.max(parseInt(Q, 10), 1), 50) : 10,
    J = await mv(Y, G);
  if ("status" in J)
    return X.json({ error: J.error, message: J.message }, J.status);
  return X.json(J);
});
JG.post("/", kR, s0("json", U90), async (X) => {
  let { query: Y, limit: Q } = X.req.valid("json"),
    G = await mv(Y, Q);
  if ("status" in G)
    return X.json({ error: G.error, message: G.message }, G.status);
  return X.json(G);
});
JG.get("/status", async (X) => {
  let Y = H8(),
    Q = Y ? hv() : 0,
    G = {
      available: Y,
      indexedCount: Q,
      message: Y
        ? `Semantic search is ready with ${Q} indexed items`
        : "Semantic search is not available. Set VOYAGE_API_KEY to enable.",
    };
  return X.json(G);
});
var L90 = X0.object({
  query: X0.string().min(1).max(2000),
  maxSessions: X0.number().int().min(1).max(10).optional().default(5),
  maxTokens: X0.number().int().min(100).max(16000).optional().default(4000),
  minRelevanceScore: X0.number().min(0).max(1).optional().default(0.3),
});
JG.post("/context", kR, s0("json", L90), async (X) => {
  let {
    query: Y,
    maxSessions: Q,
    maxTokens: G,
    minRelevanceScore: J,
  } = X.req.valid("json");
  if (!S$())
    return X.json(
      {
        error: "Context injection is not available",
        message: "VOYAGE_API_KEY is not configured",
      },
      503
    );
  let U = await P$(Y, { maxSessions: Q, maxTokens: G, minRelevanceScore: J });
  return X.json({
    contextText: U.contextText,
    estimatedTokens: U.estimatedTokens,
    sessionsUsed: U.sessions.length,
    sessions: U.sessions.map(($) => ({
      sessionId: $.sessionId,
      sessionName: $.sessionName,
      relevanceScore: $.relevanceScore,
    })),
  });
});
var cv = JG;
var eF0 = class {
  initApp;
  #X;
  constructor(X) {
    ((this.initApp = X?.initApp), (this.#X = X?.defaultAppOptions));
  }
  createApp = (X) => {
    let Y = new c1(X && this.#X ? { ...this.#X, ...X } : (X ?? this.#X));
    if (this.initApp) this.initApp(Y);
    return Y;
  };
  createMiddleware = (X) => X;
  createHandlers = (...X) => {
    return X.filter((Y) => Y !== void 0);
  };
};
var T$ = (X) => X;
import { readFileSync as B90, existsSync as dv, realpathSync as pv } from "fs";
import { resolve as K90, join as V90, sep as iv } from "path";
function yR(X) {
  if (!X || typeof X !== "string")
    return { valid: !1, error: "Invalid file path" };
  let Y = process.env.HOME || process.env.USERPROFILE || "";
  if (!Y) return { valid: !1, error: "HOME directory not defined" };
  let Q = V90(Y, ".claude"),
    G = K90(X);
  if (!G.startsWith(Q + iv) && G !== Q)
    return { valid: !1, error: "Path outside allowed directory" };
  if (!G.endsWith(".jsonl"))
    return { valid: !1, error: "Invalid file extension" };
  if (!dv(G)) return { valid: !1, error: "File does not exist" };
  try {
    let J = pv(G),
      U = dv(Q) ? pv(Q) : Q;
    if (!J.startsWith(U + iv) && J !== U)
      return { valid: !1, error: "Symlink points outside allowed directory" };
    return { valid: !0, resolvedPath: J };
  } catch {
    return { valid: !1, error: "Failed to resolve path" };
  }
}
function F90(X) {
  if (typeof X === "string") return X;
  return X.map((Y) => {
    if (Y.type === "text" && Y.text) return Y.text;
    if (Y.type === "tool_use" && Y.name)
      return JSON.stringify({ tool: Y.name, input: Y.input });
    if (Y.type === "tool_result" && Y.content) return Y.content;
    return "";
  }).filter(Boolean).join(`
`);
}
function N90(X, Y) {
  if (X.type === "error") return "error";
  if (X.type === "system") return "system";
  if (X.message?.role === "user") return "user";
  if (X.message?.role === "assistant") {
    if (Array.isArray(Y)) {
      if (Y.some((G) => G.type === "tool_use")) return "tool_use";
    }
    return "assistant";
  }
  if (X.toolUseResult) return "tool_result";
  return "assistant";
}
function nv(X, Y) {
  let Q = yR(X);
  if (!Q.valid || !Q.resolvedPath)
    return (t0.warn("Invalid transcript path", { error: Q.error }), []);
  try {
    let J = B90(Q.resolvedPath, "utf-8")
        .split(
          `
`
        )
        .filter(($) => $.trim()),
      U = [];
    for (let $ of J)
      try {
        let B = JSON.parse($);
        if (B.isSidechain) continue;
        if (!B.message && !B.toolUseResult && B.type !== "error") continue;
        let K = B.message?.content ?? B.toolUseResult?.content ?? "",
          V = F90(K);
        if (!V.trim()) continue;
        let W = N90(B, K),
          L = H6("msg");
        U.push({
          messageId: L,
          sessionId: Y,
          type: W,
          content: V,
          compressed: !1,
          timestamp: B.timestamp ? new Date(B.timestamp) : new Date(),
        });
      } catch {
        continue;
      }
    return U;
  } catch (G) {
    return (
      t0.error("Failed to read transcript", {
        error: G instanceof Error ? G.message : String(G),
      }),
      []
    );
  }
}
async function av(X) {
  let Y = {
    success: !1,
    sessionId: X.sessionId,
    steps: {
      transcriptParsed: !1,
      summaryGenerated: !1,
      titleGenerated: !1,
      embeddingGenerated: !1,
      classificationUpdated: !1,
      dbSaved: !1,
    },
    errors: [],
  };
  if (
    (t0.info("Starting session end processing", {
      sessionId: X.sessionId,
      hasTranscript: !!X.transcriptPath,
    }),
    !a1(X.sessionId))
  )
    return (
      Y.errors.push("Session not found"),
      t0.warn("Session not found for processing", { sessionId: X.sessionId }),
      Y
    );
  let G = [];
  if (X.transcriptPath) {
    let $ = yR(X.transcriptPath);
    if ($.valid)
      ((G = nv(X.transcriptPath, X.sessionId)),
        (Y.steps.transcriptParsed = G.length > 0),
        t0.info("Transcript parsed", {
          sessionId: X.sessionId,
          messageCount: G.length,
        }));
    else
      (Y.errors.push(`Transcript validation failed: ${$.error}`),
        t0.warn("Transcript validation failed", {
          sessionId: X.sessionId,
          error: $.error,
        }));
  }
  if (G.length === 0)
    return (
      t0.info("No messages to process, skipping summary generation", {
        sessionId: X.sessionId,
      }),
      (Y.success = !0),
      Y
    );
  let J = null;
  try {
    ((J = await h9(X.sessionId, G)),
      (Y.steps.summaryGenerated = !0),
      t0.info("Summary generated", {
        sessionId: X.sessionId,
        shortSummaryLength: J.shortSummary.length,
      }));
  } catch ($) {
    let B = $ instanceof Error ? $.message : String($);
    (Y.errors.push(`Summary generation failed: ${B}`),
      t0.error("Summary generation failed", Error(B), {
        sessionId: X.sessionId,
      }));
    try {
      let K = QQ(G);
      J = {
        summaryId: "",
        sessionId: X.sessionId,
        shortSummary: G[0]?.content.slice(0, 100) || "",
        detailedSummary: "",
        keyDecisions: K.keyDecisions,
        filesModified: K.filesModified,
        toolsUsed: K.toolsUsed,
        topics: K.topics,
        originalTokenCount: 0,
        summaryTokenCount: 0,
        compressionRatio: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      };
    } catch {}
  }
  ((Y.steps.titleGenerated = !0),
    t0.info("Title generation skipped (handled by UserPromptSubmit Hook)", {
      sessionId: X.sessionId,
    }));
  let U = null;
  if (J && J.shortSummary)
    try {
      let $ = [
        J.shortSummary,
        J.detailedSummary,
        J.keyDecisions.join(". "),
      ].filter(Boolean).join(`

`);
      if (((U = await N9($)), U))
        ((Y.steps.embeddingGenerated = !0),
          t0.info("Embedding generated", {
            sessionId: X.sessionId,
            provider: U.provider,
            dimension: U.dimension,
          }));
    } catch ($) {
      let B = $ instanceof Error ? $.message : String($);
      (Y.errors.push(`Embedding generation failed: ${B}`),
        t0.warn("Embedding generation failed", {
          sessionId: X.sessionId,
          error: B,
        }));
    }
  if (J)
    if (GQ(X.sessionId, G, "Session end")) Y.steps.classificationUpdated = !0;
    else Y.errors.push("Classification failed");
  try {
    if (J) {
      let $ = x9({
        sessionId: X.sessionId,
        shortSummary: J.shortSummary,
        detailedSummary: J.detailedSummary,
        keyDecisions: J.keyDecisions,
        filesModified: J.filesModified,
        toolsUsed: J.toolsUsed,
        topics: J.topics,
        originalTokenCount: J.originalTokenCount,
        summaryTokenCount: J.summaryTokenCount,
        compressionRatio: J.compressionRatio,
      });
      ((Y.summaryId = $.summaryId),
        t0.info("Summary saved to DB", {
          sessionId: X.sessionId,
          summaryId: $.summaryId,
        }));
    }
    if (U && J) {
      let $ = EX(
        "summary",
        Y.summaryId || X.sessionId,
        U.embedding,
        X.sessionId,
        J.shortSummary.slice(0, 200),
        U.provider
      );
      if ($ > 0)
        ((Y.embeddingId = $),
          t0.info("Embedding saved to DB", {
            sessionId: X.sessionId,
            embeddingId: $,
          }));
    }
    Y.steps.dbSaved = !0;
  } catch ($) {
    let B = $ instanceof Error ? $.message : String($);
    (Y.errors.push(`DB save failed: ${B}`),
      t0.error("DB save failed", Error(B), { sessionId: X.sessionId }));
  }
  return (
    (Y.success =
      Y.steps.dbSaved || (!X.transcriptPath && Y.errors.length === 0)),
    t0.info("Session end processing completed", {
      sessionId: X.sessionId,
      success: Y.success,
      steps: Y.steps,
      errorCount: Y.errors.length,
    }),
    Y
  );
}
var M90 = X0.object({
  api: X0.object({
    port: X0.coerce.number().default(3048),
    nodeEnv: X0.enum(["development", "production", "test"]).default(
      "development"
    ),
  }),
  database: X0.object({ path: X0.string().default(":memory:") }),
  websocket: X0.object({
    allowedOrigins: X0.string()
      .default(
        "http://localhost:5173,http://localhost:3000,http://127.0.0.1:5173,http://127.0.0.1:3000"
      )
      .transform((X) => X.split(",")),
    maxPayloadSize: X0.coerce.number().default(1048576),
    maxMessageLength: X0.coerce.number().default(1e5),
    rateLimitWindowMs: X0.coerce.number().default(60000),
    maxMessagesPerWindow: X0.coerce.number().default(100),
  }),
  logging: X0.object({
    level: X0.enum(["debug", "info", "warn", "error"]).default("info"),
    enabled: X0.coerce.boolean().default(!0),
  }),
});
function A90() {
  return M90.parse({
    api: { port: process.env.API_PORT, nodeEnv: "development" },
    database: { path: process.env.DATABASE_PATH },
    websocket: {
      allowedOrigins: process.env.WS_ALLOWED_ORIGINS,
      maxPayloadSize: process.env.WS_MAX_PAYLOAD_SIZE,
      maxMessageLength: process.env.WS_MAX_MESSAGE_LENGTH,
      rateLimitWindowMs: process.env.WS_RATE_LIMIT_WINDOW_MS,
      maxMessagesPerWindow: process.env.WS_MAX_MESSAGES_PER_WINDOW,
    },
    logging: { level: process.env.LOG_LEVEL, enabled: process.env.LOG_ENABLED },
  });
}
var a6 = A90();
var WG = {
  MAX_PAYLOAD_SIZE: a6.websocket.maxPayloadSize,
  MAX_MESSAGE_LENGTH: a6.websocket.maxMessageLength,
  MAX_SESSION_ID_LENGTH: 100,
  RATE_LIMIT_WINDOW_MS: a6.websocket.rateLimitWindowMs,
  MAX_MESSAGES_PER_WINDOW: a6.websocket.maxMessagesPerWindow,
};
function ov(X) {
  if (typeof X !== "string") return !1;
  if (X.length === 0 || X.length > WG.MAX_SESSION_ID_LENGTH) return !1;
  return /^(sess-)?[a-f0-9-]{36}$/i.test(X);
}
function q90(X) {
  if (typeof X !== "string") return !1;
  if (X.length === 0) return !1;
  if (X.length > WG.MAX_MESSAGE_LENGTH) return !1;
  return !0;
}
var rv = new Map();
function R90(X) {
  let Y = Date.now(),
    Q = rv.get(X);
  if (!Q || Y > Q.resetAt)
    return (rv.set(X, { count: 1, resetAt: Y + WG.RATE_LIMIT_WINDOW_MS }), !0);
  if (Q.count >= WG.MAX_MESSAGES_PER_WINDOW) return !1;
  return (Q.count++, !0);
}
var HG = new Map(),
  _R = new Set(),
  D90 = 0,
  sv = {
    open(X) {
      ((X.data.clientId = `ws_${++D90}`),
        _R.add(X),
        console.log(`[WebSocket] Client connected: ${X.data.clientId}`));
    },
    message(X, Y) {
      let Q = typeof Y === "string" ? Y.length : Y.length;
      if (Q > WG.MAX_PAYLOAD_SIZE) {
        (console.warn(`[WebSocket] Rejected oversized message: ${Q} bytes`),
          e8(X, "Message too large"));
        return;
      }
      if (!R90(X.data.clientId)) {
        e8(X, "Rate limit exceeded");
        return;
      }
      try {
        let G = JSON.parse(typeof Y === "string" ? Y : Y.toString());
        switch (G.type) {
          case "join":
            z90(X, G.sessionId);
            break;
          case "leave":
            E90(X, G.sessionId);
            break;
          case "message":
            O90(X, G.sessionId, G.content);
            break;
          case "typing":
            Z90(X, G.sessionId, G.isTyping);
            break;
          default:
            e8(X, "Unknown message type");
        }
      } catch (G) {
        (console.error("[WebSocket] Error parsing message:", G),
          e8(X, "Invalid message format"));
      }
    },
    close(X) {
      if (X.data.sessionId) fR(X, X.data.sessionId);
      (_R.delete(X),
        console.log(`[WebSocket] Client disconnected: ${X.data.clientId}`));
    },
  };
function z90(X, Y) {
  if (!ov(Y)) {
    e8(X, "Invalid session ID format");
    return;
  }
  try {
    if (!u8(Y)) {
      (e8(X, "Unable to join session"),
        console.warn(`[WebSocket] Session not found: ${Y}`));
      return;
    }
    if (X.data.sessionId && X.data.sessionId !== Y) fR(X, X.data.sessionId);
    ((X.data.sessionId = Y), j90(X, Y));
    let { items: G } = ZJ(Y),
      J = { type: "joined", sessionId: Y, messages: G };
    (X.send(JSON.stringify(J)),
      console.log(`[WebSocket] ${X.data.clientId} joined session ${Y}`));
  } catch (Q) {
    (console.error("[WebSocket] Error in handleJoin:", Q),
      e8(X, "Internal server error"));
  }
}
function E90(X, Y) {
  (fR(X, Y), (X.data.sessionId = void 0));
  let Q = { type: "left", sessionId: Y };
  (X.send(JSON.stringify(Q)),
    console.log(`[WebSocket] ${X.data.clientId} left session ${Y}`));
}
function O90(X, Y, Q) {
  if (!ov(Y)) {
    e8(X, "Invalid session ID format");
    return;
  }
  if (!q90(Q)) {
    e8(X, "Invalid message content (empty or too long)");
    return;
  }
  try {
    if (!u8(Y)) {
      (e8(X, "Unable to send message"),
        console.warn(`[WebSocket] Session not found: ${Y}`));
      return;
    }
    let J = OJ({ sessionId: Y, type: "user", content: Q });
    (tv(Y, { type: "new-message", message: J }),
      console.log(`[WebSocket] Message sent to ${Y}: ${Q.slice(0, 50)}...`));
  } catch (G) {
    (console.error("[WebSocket] Error in handleMessage:", G),
      e8(X, "Failed to send message"));
  }
}
function Z90(X, Y, Q) {
  tv(Y, { type: "typing", sessionId: Y, isTyping: Q }, X);
}
function j90(X, Y) {
  let Q = HG.get(Y);
  if (!Q) ((Q = new Set()), HG.set(Y, Q));
  Q.add(X);
}
function fR(X, Y) {
  let Q = HG.get(Y);
  if (Q) {
    if ((Q.delete(X), Q.size === 0)) HG.delete(Y);
  }
}
function tv(X, Y, Q) {
  let G = HG.get(X);
  if (!G) return;
  let J = JSON.stringify(Y);
  for (let U of G) if (U !== Q) U.send(J);
}
function e8(X, Y) {
  let Q = { type: "error", message: Y };
  X.send(JSON.stringify(Q));
}
function xR(X) {
  let Y = JSON.stringify(X);
  for (let Q of _R)
    try {
      Q.send(Y);
    } catch (G) {
      console.error("[WebSocket] Failed to send to client:", G);
    }
}
function ev(X) {
  let Y = {
    edgeId: X.edgeId,
    sourceSessionId: X.sourceSessionId,
    targetClaudeSessionId: X.targetClaudeSessionId,
    createdAt: X.createdAt.toISOString(),
  };
  (xR({ type: "edge_created", edge: Y }),
    console.log(
      `[WebSocket] Edge created: ${X.sourceSessionId} -> ${X.targetClaudeSessionId}`
    ));
}
function Xk(X, Y) {
  (xR({ type: "edge_deleted", edgeId: X, remainingContext: Y }),
    console.log(`[WebSocket] Edge deleted: ${X}`));
}
function hR(X, Y, Q) {
  xR({
    type: "tokens_updated",
    tokens: { sessionId: X, inputTokens: Y, outputTokens: Q },
  });
}
var OX = new c1(),
  w90 = T$(async (X, Y) => {
    let Q = X.req.header("x-forwarded-for"),
      G = X.req.header("x-real-ip");
    if (Q || G)
      return (
        t0.warn("Rejected: Request through proxy"),
        X.json({ error: "Forbidden" }, 403)
      );
    let J = X.req.header("host") || "";
    if (
      !(
        J.startsWith("localhost") ||
        J.startsWith("127.0.0.1") ||
        J.startsWith("[::1]")
      )
    )
      return (
        t0.warn("Rejected: Non-localhost host", { host: J }),
        X.json({ error: "Forbidden" }, 403)
      );
    await Y();
  });
OX.use("/*", w90);
function gR(X, Y) {
  if (!X.success && X.error)
    return Y.json(
      { error: "Validation Error", details: X.error.flatten().fieldErrors },
      400
    );
  return;
}
var uR = X0.string()
    .min(1)
    .max(256)
    .regex(/^[a-zA-Z0-9_-]+$/, "Invalid session ID format"),
  C90 = X0.object({
    sessionId: uR,
    workingDirectory: X0.string().max(1024).optional(),
    startedAt: X0.string().optional(),
    metadata: X0.record(X0.string(), X0.string()).optional(),
    requestContext: X0.boolean().optional().default(!1),
    contextQuery: X0.string().max(2000).optional(),
  }),
  Qk = X0.object({
    inputTokens: X0.number().int().min(0),
    outputTokens: X0.number().int().min(0),
  }),
  I90 = X0.object({
    sessionId: uR,
    transcriptPath: X0.string().max(2048).optional(),
    endedAt: X0.string().optional(),
    status: X0.enum(["completed", "error", "cancelled"]).optional(),
    metadata: X0.record(X0.string(), X0.string()).optional(),
    usage: Qk.optional(),
  }),
  P90 = X0.object({
    sessionId: uR,
    toolName: X0.string().min(1).max(100),
    title: X0.string().min(1).max(500),
    content: X0.string().max(1e4).optional().default(""),
    metadata: X0.record(X0.string(), X0.unknown()).optional(),
    usage: Qk.optional(),
  });
OX.get("/health", (X) => {
  return X.json({ status: "ok", timestamp: new Date().toISOString() });
});
OX.post("/session-start", s0("json", C90, gR), async (X) => {
  let Y = X.req.valid("json"),
    Q = oX(Y.sessionId);
  if (Q) {
    let K = l8(Q.sessionId, { status: "processing" }),
      V = null;
    if (Y.requestContext) V = await Yk(Y.contextQuery, Y.workingDirectory);
    return X.json({ id: K?.sessionId, action: "resumed", contextText: V });
  }
  let G = Y.workingDirectory || process.cwd(),
    J = oz(G),
    U = T9({
      name: `Session ${Y.sessionId}`,
      workingDir: G,
      projectId: J?.projectId,
    });
  l8(U.sessionId, { claudeSessionId: Y.sessionId, status: "processing" });
  let $ = mz(J?.projectId, U.sessionId);
  if ($ > 0)
    t0.info("Cleaned up stale processing sessions", {
      count: $,
      projectId: J?.projectId,
    });
  if (J)
    t0.info("Session linked to project", {
      sessionId: U.sessionId,
      projectId: J.projectId,
      projectName: J.name,
    });
  t0.info("Session started", {
    sessionId: U.sessionId,
    claudeSessionId: Y.sessionId,
  });
  let B = null;
  if (Y.requestContext) B = await Yk(Y.contextQuery, Y.workingDirectory);
  return X.json({ id: U.sessionId, action: "created", contextText: B }, 201);
});
async function Yk(X, Y) {
  if (!S$()) return (t0.debug("Context injection not available"), null);
  let Q = X;
  if (!Q && Y) {
    let G = Y.split(/[/\\]/),
      J = G[G.length - 1];
    if (J) Q = `Project: ${J}`;
  }
  if (!Q) return (t0.debug("No context query available"), null);
  try {
    let G = await P$(Q, {
      maxSessions: 3,
      maxTokens: 2000,
      minRelevanceScore: 0.3,
    });
    if (G.sessions.length === 0)
      return (t0.debug("No related sessions found", { query: Q }), null);
    return (
      t0.info("Context injection prepared", {
        query: Q,
        sessionsCount: G.sessions.length,
        estimatedTokens: G.estimatedTokens,
      }),
      G.contextText
    );
  } catch (G) {
    return (t0.error("Failed to build context", G, { query: Q }), null);
  }
}
OX.post("/session-end", s0("json", I90, gR), async (X) => {
  let Y = X.req.valid("json"),
    Q = oX(Y.sessionId);
  if (!Q)
    return (
      t0.warn("Session not found", { claudeSessionId: Y.sessionId }),
      X.json({ error: "Session not found" }, 404)
    );
  let G = Y.status === "error" ? "error" : "completed";
  if (!l8(Q.sessionId, { status: G }))
    return (
      t0.error("Failed to update session", void 0, { sessionId: Q.sessionId }),
      X.json({ error: "Failed to update session" }, 500)
    );
  t0.info("Session ended", { sessionId: Q.sessionId, status: G });
  let U;
  if (Y.usage)
    (MU(Q.sessionId, {
      inputTokens: Y.usage.inputTokens,
      outputTokens: Y.usage.outputTokens,
    }),
      (U = !0),
      hR(Q.sessionId, Y.usage.inputTokens, Y.usage.outputTokens),
      t0.info("Session tokens set", {
        sessionId: Q.sessionId,
        inputTokens: Y.usage.inputTokens,
        outputTokens: Y.usage.outputTokens,
      }));
  let $ = Y.transcriptPath || Y.metadata?.transcriptPath;
  if ($)
    av({
      sessionId: Q.sessionId,
      transcriptPath: $,
      cwd: Y.metadata?.cwd,
    }).catch((B) => {
      t0.error("Session end processing failed", B, { sessionId: Q.sessionId });
    });
  return X.json({
    sessionId: Q.sessionId,
    status: G,
    processingStarted: !!$,
    ...(U && { tokensUpdated: U }),
  });
});
OX.post("/post-tooluse", s0("json", P90, gR), async (X) => {
  let Y = X.req.valid("json"),
    Q = oX(Y.sessionId);
  if (!Q)
    return (
      t0.debug("Session not found, skipping observation", {
        claudeSessionId: Y.sessionId,
      }),
      X.json({ status: "skipped", reason: "session_not_found" })
    );
  let G = Q4({
    sessionId: Q.sessionId,
    type: "tool_use",
    title: Y.title,
    content: Y.content || "",
    metadata: { toolName: Y.toolName, ...Y.metadata },
  });
  dz(Q.sessionId);
  let J;
  if (Y.usage)
    (MU(Q.sessionId, {
      inputTokens: Y.usage.inputTokens,
      outputTokens: Y.usage.outputTokens,
    }),
      (J = !0),
      hR(Q.sessionId, Y.usage.inputTokens, Y.usage.outputTokens),
      t0.debug("Session tokens set", {
        sessionId: Q.sessionId,
        inputTokens: Y.usage.inputTokens,
        outputTokens: Y.usage.outputTokens,
      }));
  return (
    t0.debug("Tool use recorded", {
      observationId: G.observationId,
      toolName: Y.toolName,
    }),
    X.json({
      observationId: G.observationId,
      status: "recorded",
      ...(J && { tokensUpdated: J }),
    })
  );
});
function Gk(X) {
  return {
    mergeId: X.merge_id,
    sourceSessionIds: JSON.parse(X.source_session_ids),
    resultSummary: X.result_summary,
    resultDetailedSummary: X.result_detailed_summary ?? void 0,
    status: X.status,
    projectId: X.project_id ?? void 0,
    error: X.error ?? void 0,
    createdAt: new Date(X.created_at),
    updatedAt: new Date(X.updated_at),
  };
}
function S90() {
  return (
    (b1(`SELECT MAX(
      CAST(SUBSTR(merge_id, 7) AS INTEGER)
    ) as max_seq
    FROM merges
    WHERE merge_id LIKE 'ch_mg_%'
      AND LENGTH(merge_id) = 10`)?.max_seq ?? 0) + 1
  );
}
function T90() {
  let X = S90();
  return k4("MERGE", X);
}
function lR(X) {
  let Y = T90(),
    Q = new Date().toISOString(),
    G = JSON.stringify(X.sourceSessionIds);
  f1(
    `INSERT INTO merges (merge_id, source_session_ids, status, project_id, created_at, updated_at)
     VALUES (?, ?, 'pending', ?, ?, ?)`,
    Y,
    G,
    X.projectId ?? null,
    Q,
    Q
  );
  let U = P8()
    .prepare(`INSERT INTO merge_sessions (merge_id, session_id, display_order)
     VALUES (?, ?, ?)`);
  return (
    X.sourceSessionIds.forEach(($, B) => {
      U.run(Y, $, B);
    }),
    b$(Y)
  );
}
function b$(X) {
  let Y = b1("SELECT * FROM merges WHERE merge_id = ?", X);
  return Y ? Gk(Y) : null;
}
function Jk(X) {
  let Y = X.page ?? 1,
    Q = X.limit ?? 20,
    G = (Y - 1) * Q,
    J = [],
    U = [];
  if (X.status) (J.push("status = ?"), U.push(X.status));
  if (X.projectId) (J.push("project_id = ?"), U.push(X.projectId));
  let $ = J.length > 0 ? `WHERE ${J.join(" AND ")}` : "",
    K = b1(`SELECT COUNT(*) as count FROM merges ${$}`, ...U)?.count ?? 0,
    V = Math.ceil(K / Q);
  return {
    items: X5(
      `SELECT * FROM merges ${$} ORDER BY created_at DESC LIMIT ? OFFSET ?`,
      ...U,
      Q,
      G
    ).map(Gk),
    pagination: {
      total: K,
      page: Y,
      totalPages: V,
      hasNext: Y < V,
      hasPrev: Y > 1,
    },
  };
}
function mR(X, Y, Q) {
  let G = new Date().toISOString(),
    J = ["status = ?", "updated_at = ?"],
    U = [Y, G];
  if (Q?.resultSummary !== void 0)
    (J.push("result_summary = ?"), U.push(Q.resultSummary));
  if (Q?.resultDetailedSummary !== void 0)
    (J.push("result_detailed_summary = ?"), U.push(Q.resultDetailedSummary));
  if (Q?.error !== void 0) (J.push("error = ?"), U.push(Q.error));
  if (
    (U.push(X),
    f1(`UPDATE merges SET ${J.join(", ")} WHERE merge_id = ?`, ...U).changes ===
      0)
  )
    return null;
  return b$(X);
}
function Wk(X) {
  return f1("DELETE FROM merges WHERE merge_id = ?", X).changes > 0;
}
var b90 = /SHORT_SUMMARY:\s*(.+?)(?=DETAILED_SUMMARY:|$)/s,
  v90 = /DETAILED_SUMMARY:\s*(.+?)(?=KEY_DECISIONS:|$)/s,
  k90 = /KEY_DECISIONS:\s*(.+?)(?=TOPICS:|$)/s,
  y90 = /TOPICS:\s*(.+)$/s;
function _90(X) {
  if (X.length === 0) return [];
  let Y = X.map(() => "?").join(",");
  return X5(
    `SELECT session_id, short_summary, detailed_summary, topics, key_decisions
     FROM summaries
     WHERE session_id IN (${Y})`,
    ...X
  ).map((G) => ({
    sessionId: G.session_id,
    shortSummary: G.short_summary || "",
    detailedSummary: G.detailed_summary || "",
    topics: Hk(G.topics, [], `sessionId:${G.session_id}:topics`),
    keyDecisions: Hk(
      G.key_decisions,
      [],
      `sessionId:${G.session_id}:keyDecisions`
    ),
  }));
}
function Hk(X, Y, Q = "unknown") {
  if (!X) return Y;
  try {
    return JSON.parse(X);
  } catch (G) {
    return (
      console.warn(
        `[Merge Summarizer] JSON parse failed - context: ${Q}, value: ${X.substring(0, 100)}`
      ),
      Y
    );
  }
}
async function Uk(X) {
  if (X.length === 0) return { success: !1, error: "No session IDs provided" };
  let Y = _90(X);
  if (Y.length === 0)
    return {
      success: !1,
      error: "No summaries found for the provided session IDs",
    };
  if (Y.length === 1) {
    let G = Y[0];
    return {
      success: !0,
      shortSummary: G.shortSummary,
      detailedSummary: G.detailedSummary,
      topics: G.topics,
      keyDecisions: G.keyDecisions,
    };
  }
  if (process.env.DATABASE_PATH === ":memory:") return $k(Y);
  try {
    let G = f90(Y),
      J = [];
    for await (let B of m4({
      prompt: G,
      options: { allowedTools: [], maxTurns: 1 },
    }))
      if (B.type === "assistant" && B.message?.content) {
        for (let K of B.message.content) if ("text" in K) J.push(K.text);
      }
    let U = J.join(""),
      $ = x90(U);
    return {
      success: !0,
      shortSummary: $.shortSummary,
      detailedSummary: $.detailedSummary,
      topics: $.topics,
      keyDecisions: $.keyDecisions,
    };
  } catch (G) {
    return (
      console.error("[Merge Summarizer] AI query failed, using fallback:", {
        error: G instanceof Error ? G.message : String(G),
        sessionIds: X,
        timestamp: new Date().toISOString(),
      }),
      $k(Y)
    );
  }
}
function f90(X) {
  return `\u4EE5\u4E0B\u306E\u8907\u6570\u30BB\u30C3\u30B7\u30E7\u30F3\u306E\u8981\u7D04\u30921\u3064\u306B\u7D71\u5408\u3057\u3066\u304F\u3060\u3055\u3044\u3002

## \u5165\u529B\u30BB\u30C3\u30B7\u30E7\u30F3
${X.map(
  (Q, G) => `
### \u30BB\u30C3\u30B7\u30E7\u30F3 ${G + 1} (${Q.sessionId})
**\u6982\u8981**: ${Q.shortSummary}
**\u8A73\u7D30**: ${Q.detailedSummary}
**\u30C8\u30D4\u30C3\u30AF**: ${Q.topics.join(", ") || "\u306A\u3057"}
**\u6C7A\u5B9A\u4E8B\u9805**: ${Q.keyDecisions.join(", ") || "\u306A\u3057"}
`
).join("")}

## \u51FA\u529B\u5F62\u5F0F
SHORT_SUMMARY:\uFF08\u7D71\u5408\u3055\u308C\u305F1-2\u6587\u306E\u8981\u7D04\uFF09
DETAILED_SUMMARY:\uFF08\u7D71\u5408\u3055\u308C\u305F3-5\u6587\u306E\u8A73\u7D30\u8981\u7D04\uFF09
KEY_DECISIONS:\uFF08\u91CD\u8981\u306A\u6C7A\u5B9A\u4E8B\u9805\u3092\u30EA\u30B9\u30C8\u5F62\u5F0F\u3067\uFF09
TOPICS:\uFF08\u95A2\u9023\u30C8\u30D4\u30C3\u30AF\u3092\u30AB\u30F3\u30DE\u533A\u5207\u308A\u3067\uFF09

## \u6CE8\u610F
- \u91CD\u8907\u3059\u308B\u5185\u5BB9\u306F\u7D71\u5408\u3057\u3066\u304F\u3060\u3055\u3044
- \u5404\u30BB\u30C3\u30B7\u30E7\u30F3\u306E\u91CD\u8981\u306A\u30DD\u30A4\u30F3\u30C8\u3092\u6F0F\u3089\u3055\u306A\u3044\u3067\u304F\u3060\u3055\u3044
- \u81EA\u7136\u306A\u65E5\u672C\u8A9E\u3067\u51FA\u529B\u3057\u3066\u304F\u3060\u3055\u3044`;
}
function x90(X) {
  let Y = {
    shortSummary: "",
    detailedSummary: "",
    topics: [],
    keyDecisions: [],
  };
  if (!X) return Y;
  let Q = X.match(b90);
  if (Q) Y.shortSummary = Q[1].trim();
  let G = X.match(v90);
  if (G) Y.detailedSummary = G[1].trim();
  let J = X.match(k90);
  if (J) {
    let $ = J[1].trim();
    Y.keyDecisions = $.split(/[\n\u30FB\-]/)
      .map((B) => B.trim())
      .filter((B) => B.length > 0);
  }
  let U = X.match(y90);
  if (U) {
    let $ = U[1].trim();
    Y.topics = $.split(/[,\u3001]/)
      .map((B) => B.trim())
      .filter((B) => B.length > 0);
  }
  return Y;
}
function $k(X) {
  if (X.length === 0)
    return {
      success: !0,
      shortSummary: "",
      detailedSummary: "",
      topics: [],
      keyDecisions: [],
    };
  let Y = X.map((U) => U.shortSummary).join(" / "),
    Q = X.map((U) => U.detailedSummary).join(`

`),
    G = [...new Set(X.flatMap((U) => U.topics))],
    J = [...new Set(X.flatMap((U) => U.keyDecisions))];
  return {
    success: !0,
    shortSummary: Y,
    detailedSummary: Q,
    topics: G,
    keyDecisions: J,
  };
}
var ZX = new c1();
ZX.post(
  "/",
  s0("json", KU, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("json"),
      Q = lR({ sourceSessionIds: Y.sourceSessionIds, projectId: Y.projectId });
    return X.json(Q, 201);
  }
);
ZX.post(
  "/with-summary",
  s0("json", KU, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("json"),
      Q = lR({ sourceSessionIds: Y.sourceSessionIds, projectId: Y.projectId });
    try {
      let G = await Uk(Y.sourceSessionIds),
        J = mR(Q.mergeId, "completed", {
          resultSummary: G.shortSummary,
          resultDetailedSummary: G.detailedSummary,
        });
      return X.json({
        ...J,
        summary: {
          shortSummary: G.shortSummary,
          detailedSummary: G.detailedSummary,
          keyDecisions: G.keyDecisions,
          topics: G.topics,
          sessionCount: G.sessionCount,
          totalOriginalTokens: G.totalOriginalTokens,
          mergedTokens: G.mergedTokens,
          compressionRatio: G.compressionRatio,
        },
      });
    } catch (G) {
      return (
        mR(Q.mergeId, "error"),
        console.error("[Merge] Summary generation failed:", G),
        X.json(
          {
            error: "Summary generation failed",
            mergeId: Q.mergeId,
            message: G instanceof Error ? G.message : String(G),
          },
          500
        )
      );
    }
  }
);
ZX.get(
  "/",
  s0("query", Oz, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("query"),
      Q = Jk({
        page: Y.page,
        limit: Y.limit,
        status: Y.status,
        projectId: Y.projectId,
      });
    return X.json(Q);
  }
);
ZX.get("/:id", async (X) => {
  let Y = X.req.param("id"),
    Q = b$(Y);
  if (!Q) return X.json({ error: "Merge not found", mergeId: Y }, 404);
  return X.json(Q);
});
ZX.delete("/:id", async (X) => {
  let Y = X.req.param("id");
  if (!Wk(Y)) return X.json({ error: "Merge not found", mergeId: Y }, 404);
  return X.body(null, 204);
});
var h90 = 3000;
async function v$(X, Y = h90) {
  let Q = N9(X),
    G = new Promise((J) =>
      setTimeout(() => {
        (console.warn(`[Memories] Embedding generation timed out after ${Y}ms`),
          J(null));
      }, Y)
    );
  return Promise.race([Q, G]);
}
function Lk(X) {
  return {
    id: X.observationId,
    sessionId: X.sessionId,
    type: X.type,
    title: X.title,
    content: X.content,
    metadata: X.metadata,
    createdAt: X.createdAt.toISOString(),
  };
}
var k$ = X0.enum([
    "tool_use",
    "decision",
    "error",
    "learning",
    "note",
    "file_change",
  ]),
  Bk = X0.object({
    sessionId: X0.string().min(1),
    type: k$,
    title: X0.string().min(1),
    content: X0.string().min(1),
    metadata: X0.record(X0.unknown()).optional(),
  }),
  g90 = X0.object({
    page: X0.coerce.number().min(1).default(1),
    limit: X0.coerce.number().min(1).max(100).default(20),
    sessionId: X0.string().optional(),
    type: k$.optional(),
  }),
  u90 = X0.object({
    query: X0.string().min(1),
    limit: X0.coerce.number().min(1).max(100).default(10),
    projectId: X0.string().optional(),
    type: k$.optional(),
  }),
  l90 = X0.object({
    q: X0.string().min(1),
    limit: X0.coerce.number().min(1).max(100).default(10),
    projectId: X0.string().optional(),
    type: k$.optional(),
  }),
  Kk = X0.object({
    projectPath: X0.string().min(1),
    query: X0.string().optional(),
    level: X0.coerce.number().min(0).max(1).default(0),
  });
function jX(X) {
  return (Y, Q) => {
    if (!Y.success)
      return Q.json(
        {
          error: {
            code: "VALIDATION_ERROR",
            message: X,
            details: Y.error?.flatten().fieldErrors,
          },
        },
        400
      );
  };
}
var M9 = new c1();
M9.post("/", s0("json", Bk, jX("Invalid request body")), async (X) => {
  let Y = X.req.valid("json");
  if (!u8(Y.sessionId))
    return X.json(
      {
        error: {
          code: "SESSION_NOT_FOUND",
          message: `Session with id '${Y.sessionId}' not found`,
        },
      },
      404
    );
  let G = Q4({
    sessionId: Y.sessionId,
    type: Y.type,
    title: Y.title,
    content: Y.content,
    metadata: Y.metadata,
  });
  if (H8()) {
    let J = [Y.title, Y.content].join(`
`);
    try {
      let U = await N9(J);
      if (U)
        EX(
          "observation",
          G.observationId,
          U.embedding,
          Y.sessionId,
          Y.title.slice(0, 200)
        );
    } catch (U) {
      console.error("[Memories] Embedding generation failed:", U);
    }
  }
  return X.json(
    {
      id: G.observationId,
      sessionId: G.sessionId,
      type: G.type,
      title: G.title,
      createdAt: G.createdAt.toISOString(),
    },
    201
  );
});
M9.get("/", s0("query", g90, jX("Invalid query parameters")), async (X) => {
  let { page: Y, limit: Q, sessionId: G, type: J } = X.req.valid("query"),
    U = v9({ page: Y, limit: Q, sessionId: G, type: J });
  return X.json({ items: U.items.map(Lk), pagination: U.pagination });
});
M9.post("/search", s0("json", u90, jX("Invalid request body")), async (X) => {
  let { query: Y, limit: Q, type: G } = X.req.valid("json"),
    J = [];
  if (H8())
    try {
      let U = await v$(Y);
      if (U)
        J = YG(U.embedding, Q, ["observation"]).map((B) => ({
          id: B.sourceId,
          sessionId: B.sessionId || "",
          type: "observation",
          title: B.contentPreview || "",
          content: B.contentPreview || "",
          relevanceScore: 1 - B.distance,
          createdAt: B.createdAt?.toISOString() || "",
        }));
    } catch (U) {
      console.error("[Memories] Semantic search failed:", U);
    }
  if (J.length === 0)
    J = zU(Y, { limit: Q, type: G }).map(($) => ({
      id: $.observationId,
      sessionId: $.sessionId,
      type: $.type,
      title: $.title,
      content: $.content,
      relevanceScore: 1,
      createdAt: $.createdAt.toISOString(),
    }));
  if (G && J.length > 0) J = J.filter((U) => U.type === G);
  return X.json({ results: J, totalCount: J.length, query: Y });
});
M9.get(
  "/context",
  s0("query", Kk, jX("Invalid query parameters")),
  async (X) => {
    let { projectPath: Y, query: Q, level: G } = X.req.valid("query"),
      { items: J } = SY({ limit: 10 }),
      U = [];
    if (Q && H8())
      try {
        let B = await v$(Q);
        if (B)
          U = YG(B.embedding, 5, ["observation"]).map((V) => ({
            id: V.sourceId,
            type: "observation",
            title: V.contentPreview || "",
            summary: V.contentPreview?.slice(0, 100),
          }));
      } catch (B) {
        console.error("[Memories] Context search failed:", B);
      }
    let $ = {
      recentSessions: J.map((B) => ({
        id: B.sessionId,
        name: B.name,
        status: B.status,
        tags: [],
      })),
      relevantMemories: U,
    };
    if (G >= 1)
      (($.project = { path: Y }),
        ($.dynamicFacts = { lastUpdated: new Date().toISOString() }));
    return X.json($);
  }
);
M9.get("/:id", async (X) => {
  let Y = X.req.param("id"),
    Q = b9(Y);
  if (!Q)
    return X.json(
      {
        error: {
          code: "MEMORY_NOT_FOUND",
          message: `Memory with id '${Y}' not found`,
        },
      },
      404
    );
  return X.json(Lk(Q));
});
M9.delete("/:id", async (X) => {
  let Y = X.req.param("id");
  if (!b9(Y))
    return X.json(
      {
        error: {
          code: "MEMORY_NOT_FOUND",
          message: `Memory with id '${Y}' not found`,
        },
      },
      404
    );
  return (_G(Y), new Response(null, { status: 204 }));
});
var $G = new c1();
$G.post("/add", s0("json", Bk, jX("Invalid request body")), async (X) => {
  let Y = X.req.valid("json");
  if (!u8(Y.sessionId))
    return X.json(
      {
        error: {
          code: "SESSION_NOT_FOUND",
          message: `Session with id '${Y.sessionId}' not found`,
        },
      },
      404
    );
  let G = Q4({
    sessionId: Y.sessionId,
    type: Y.type,
    title: Y.title,
    content: Y.content,
    metadata: Y.metadata,
  });
  if (H8()) {
    let J = [Y.title, Y.content].join(`
`);
    try {
      let U = await N9(J);
      if (U)
        EX(
          "observation",
          G.observationId,
          U.embedding,
          Y.sessionId,
          Y.title.slice(0, 200)
        );
    } catch (U) {
      console.error("[Memories] Embedding generation failed:", U);
    }
  }
  return X.json(
    {
      id: G.observationId,
      sessionId: G.sessionId,
      type: G.type,
      title: G.title,
      createdAt: G.createdAt.toISOString(),
    },
    201
  );
});
$G.get(
  "/search",
  s0("query", l90, jX("Invalid query parameters")),
  async (X) => {
    let { q: Y, limit: Q, type: G } = X.req.valid("query"),
      J = [];
    if (H8())
      try {
        let U = await v$(Y);
        if (U)
          J = YG(U.embedding, Q, ["observation"]).map((B) => ({
            id: B.sourceId,
            sessionId: B.sessionId || "",
            type: "observation",
            title: B.contentPreview || "",
            content: B.contentPreview || "",
            relevanceScore: 1 - B.distance,
            createdAt: B.createdAt?.toISOString() || "",
          }));
      } catch (U) {
        console.error("[Memories] Semantic search failed:", U);
      }
    if (J.length === 0)
      J = zU(Y, { limit: Q, type: G }).map(($) => ({
        id: $.observationId,
        sessionId: $.sessionId,
        type: $.type,
        title: $.title,
        content: $.content,
        relevanceScore: 1,
        createdAt: $.createdAt.toISOString(),
      }));
    if (G && J.length > 0) J = J.filter((U) => U.type === G);
    return X.json({ results: J, totalCount: J.length, query: Y });
  }
);
$G.get(
  "/context",
  s0("query", Kk, jX("Invalid query parameters")),
  async (X) => {
    let { projectPath: Y, query: Q, level: G } = X.req.valid("query"),
      { items: J } = SY({ limit: 10 }),
      U = [];
    if (Q && H8())
      try {
        let B = await v$(Q);
        if (B)
          U = YG(B.embedding, 5, ["observation"]).map((V) => ({
            id: V.sourceId,
            type: "observation",
            title: V.contentPreview || "",
            summary: V.contentPreview?.slice(0, 100),
          }));
      } catch (B) {
        console.error("[Memories] Context search failed:", B);
      }
    let $ = {
      recentSessions: J.map((B) => ({
        id: B.sessionId,
        name: B.name,
        status: B.status,
        tags: [],
      })),
      relevantMemories: U,
    };
    if (G >= 1)
      (($.project = { path: Y }),
        ($.dynamicFacts = { lastUpdated: new Date().toISOString() }));
    return X.json($);
  }
);
var wX = new c1();
wX.get(
  "/",
  s0("query", S9, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("query"),
      Q = iz({ page: Y.page, limit: Y.limit }),
      G = { projects: Q.items, pagination: Q.pagination };
    return X.json(G);
  }
);
wX.post(
  "/",
  s0("json", zz, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("json");
    try {
      let Q = yG({ name: Y.name, path: Y.path, description: Y.description });
      return X.json(Q, 201);
    } catch (Q) {
      if (
        Q instanceof Error &&
        Q.message === "Project with this path already exists"
      )
        return X.json({ error: "Project with this path already exists" }, 409);
      throw Q;
    }
  }
);
wX.get("/:id", async (X) => {
  let Y = X.req.param("id"),
    Q = kG(Y);
  if (!Q) return X.json({ error: "Project not found", projectId: Y }, 404);
  return X.json(Q);
});
wX.put(
  "/:id",
  s0("json", Ez, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.param("id"),
      Q = X.req.valid("json"),
      G = nz(Y, Q);
    if (!G) return X.json({ error: "Project not found", projectId: Y }, 404);
    return X.json(G);
  }
);
wX.delete("/:id", async (X) => {
  let Y = X.req.param("id");
  if (!az(Y)) return X.json({ error: "Project not found", projectId: Y }, 404);
  return X.body(null, 204);
});
function cR(X) {
  return {
    edgeId: X.edge_id,
    sourceSessionId: X.source_session_id,
    targetClaudeSessionId: X.target_claude_session_id,
    createdAt: new Date(X.created_at),
  };
}
function m90() {
  return (
    (b1(`SELECT MAX(
      CAST(SUBSTR(edge_id, 7) AS INTEGER)
    ) as max_seq
    FROM session_edges
    WHERE edge_id LIKE 'ch_ed_%'
      AND LENGTH(edge_id) = 10`)?.max_seq ?? 0) + 1
  );
}
function c90() {
  let X = m90();
  return k4("EDGE", X);
}
function Vk(X) {
  let Y = c90(),
    Q = new Date().toISOString();
  return (
    f1(
      `INSERT INTO session_edges (edge_id, source_session_id, target_claude_session_id, created_at)
     VALUES (?, ?, ?, ?)`,
      Y,
      X.sourceSessionId,
      X.targetClaudeSessionId,
      Q
    ),
    y$(Y)
  );
}
function y$(X) {
  let Y = b1("SELECT * FROM session_edges WHERE edge_id = ?", X);
  return Y ? cR(Y) : null;
}
function Fk(X) {
  return f1("DELETE FROM session_edges WHERE edge_id = ?", X).changes > 0;
}
function dR(X) {
  return X5(
    `SELECT * FROM session_edges
     WHERE target_claude_session_id = ?
     ORDER BY created_at DESC`,
    X
  ).map(cR);
}
function Nk(X) {
  return X5(
    `SELECT source_session_id FROM session_edges
     WHERE target_claude_session_id = ?
     ORDER BY created_at DESC`,
    X
  ).map((Q) => Q.source_session_id);
}
function Mk(X) {
  return X5(
    `SELECT * FROM session_edges
     WHERE source_session_id = ?
     ORDER BY created_at DESC`,
    X
  ).map(cR);
}
function Ak(X, Y) {
  return (
    (b1(
      `SELECT COUNT(*) as count FROM session_edges
     WHERE source_session_id = ? AND target_claude_session_id = ?`,
      X,
      Y
    )?.count ?? 0) > 0
  );
}
var CX = new c1(),
  X6 = new Map(),
  qk = 3600000;
function d90() {
  let X = new Date();
  for (let [Y, Q] of X6.entries()) if (Q.expiresAt <= X) X6.delete(Y);
}
var p90 = T$(async (X, Y) => {
  let Q = X.req.header("x-forwarded-for"),
    G = X.req.header("x-real-ip");
  if (Q || G) return X.json({ error: "Forbidden" }, 403);
  let J = X.req.header("host") || "";
  if (
    !(
      J.startsWith("localhost") ||
      J.startsWith("127.0.0.1") ||
      J.startsWith("[::1]")
    )
  )
    return X.json({ error: "Forbidden" }, 403);
  await Y();
});
CX.use("/*", p90);
function i90(X, Y) {
  if (!X.success && X.error)
    return Y.json(
      { error: "Validation Error", details: X.error.flatten().fieldErrors },
      400
    );
  return;
}
var n90 = X0.string()
    .min(1)
    .max(256)
    .regex(/^[a-zA-Z0-9_-]+$/, "Invalid session ID format"),
  a90 = X0.object({ sessionId: n90, context: X0.string().min(1).max(1e5) });
CX.post("/pending", s0("json", a90, i90), async (X) => {
  let Y = X.req.valid("json"),
    Q = new Date(),
    G = new Date(Q.getTime() + qk),
    J = {
      sessionId: Y.sessionId,
      context: Y.context,
      createdAt: Q,
      expiresAt: G,
    };
  return (
    X6.set(Y.sessionId, J),
    X.json(
      {
        sessionId: J.sessionId,
        createdAt: J.createdAt.toISOString(),
        expiresAt: J.expiresAt.toISOString(),
      },
      201
    )
  );
});
CX.get("/pending/:sessionId", async (X) => {
  let Y = X.req.param("sessionId"),
    Q = X6.get(Y);
  if (!Q) return X.json({ error: "Pending inject not found" }, 404);
  let G = new Date();
  if (Q.expiresAt <= G)
    return (X6.delete(Y), X.json({ error: "Pending inject not found" }, 404));
  return X.json({
    sessionId: Q.sessionId,
    context: Q.context,
    createdAt: Q.createdAt.toISOString(),
    expiresAt: Q.expiresAt.toISOString(),
  });
});
CX.delete("/pending/:sessionId", async (X) => {
  let Y = X.req.param("sessionId"),
    Q = X6.get(Y);
  if (!Q) return X.json({ error: "Pending inject not found" }, 404);
  let G = new Date();
  if (Q.expiresAt <= G)
    return (X6.delete(Y), X.json({ error: "Pending inject not found" }, 404));
  return (X6.delete(Y), X.body(null, 204));
});
CX.get("/connected/:claudeSessionId", async (X) => {
  let Y = X.req.param("claudeSessionId"),
    Q = Nk(Y);
  if (Q.length === 0)
    return X.json({
      claudeSessionId: Y,
      connected: !1,
      sourceSessionIds: [],
      context: null,
    });
  let G = wJ(Q),
    J = [];
  for (let $ of Q) {
    let B = a1($),
      K = G.get($);
    if (B) {
      let V = B.name || $,
        W =
          K?.shortSummary || K?.detailedSummary || "(\u8981\u7D04\u306A\u3057)",
        L = K?.keyDecisions || [],
        H = K?.filesModified || [],
        F = `## ${V} (${$})
`;
      if (
        ((F += `
${W}
`),
        L.length > 0)
      ) {
        F += `
**\u6C7A\u5B9A\u4E8B\u9805:**
`;
        for (let N of L)
          F += `- ${N}
`;
      }
      if (H.length > 0) {
        F += `
**\u5909\u66F4\u30D5\u30A1\u30A4\u30EB:**
`;
        for (let N of H)
          F += `- \`${N}\`
`;
      }
      J.push(F);
    }
  }
  let U =
    J.length > 0
      ? `# UI\u3067\u63A5\u7D9A\u3055\u308C\u305F\u30BB\u30C3\u30B7\u30E7\u30F3\u306E\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8

${J.join(`
---

`)}`
      : null;
  return X.json({
    claudeSessionId: Y,
    connected: !0,
    sourceSessionIds: Q,
    sessionCount: Q.length,
    context: U,
  });
});
setInterval(d90, 300000);
function pR(X, Y, Q = !0) {
  let G = new Date(),
    J = new Date(G.getTime() + qk),
    U = X6.get(X);
  if (U && U.expiresAt <= G) X6.delete(X);
  let $ = U && U.expiresAt > G ? U.context : "",
    B =
      Q && $
        ? `${$}

---

${Y}`
        : Y,
    K = {
      sessionId: X,
      context: B,
      createdAt: U?.createdAt || G,
      expiresAt: J,
    };
  X6.set(X, K);
}
var IX = new c1();
function Rk(X) {
  let Y = a1(X);
  if (!Y) return null;
  let Q = jJ(X),
    G = Y.name || X,
    J = Q?.shortSummary || Q?.detailedSummary || "(\u8981\u7D04\u306A\u3057)",
    U = Q?.keyDecisions || [],
    $ = Q?.filesModified || [],
    B = `## ${G} (${X})

${J}
`;
  if (U.length > 0) {
    B += `
**\u6C7A\u5B9A\u4E8B\u9805:**
`;
    for (let K of U)
      B += `- ${K}
`;
  }
  if ($.length > 0) {
    B += `
**\u5909\u66F4\u30D5\u30A1\u30A4\u30EB:**
`;
    for (let K of $)
      B += `- \`${K}\`
`;
  }
  return B;
}
IX.post(
  "/",
  s0("json", Zz, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("json");
    if (Ak(Y.sourceSessionId, Y.targetClaudeSessionId))
      return X.json(
        {
          error: "Edge already exists",
          sourceSessionId: Y.sourceSessionId,
          targetClaudeSessionId: Y.targetClaudeSessionId,
        },
        409
      );
    let Q = Vk({
      sourceSessionId: Y.sourceSessionId,
      targetClaudeSessionId: Y.targetClaudeSessionId,
    });
    try {
      let G = Rk(Y.sourceSessionId);
      if (G) {
        let J = `# \u63A5\u7D9A\u30BB\u30C3\u30B7\u30E7\u30F3\u306E\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8

${G}`;
        pR(Y.targetClaudeSessionId, J, !0);
      }
    } catch (G) {
      console.error("[edges] Failed to add pending inject:", G);
    }
    try {
      ev(Q);
    } catch (G) {
      console.error("[edges] Failed to emit edge_created event:", G);
    }
    return X.json(Q, 201);
  }
);
IX.get("/:id", async (X) => {
  let Y = X.req.param("id"),
    Q = y$(Y);
  if (!Q) return X.json({ error: "Edge not found", edgeId: Y }, 404);
  return X.json(Q);
});
IX.delete("/:id", async (X) => {
  let Y = X.req.param("id"),
    Q = y$(Y);
  if (!Q) return X.json({ error: "Edge not found", edgeId: Y }, 404);
  let { targetClaudeSessionId: G } = Q;
  if (!Fk(Y)) return X.json({ error: "Failed to delete edge", edgeId: Y }, 500);
  let U;
  try {
    let B = dR(G)
      .map((K) => Rk(K.sourceSessionId))
      .filter((K) => K !== null);
    if (B.length > 0)
      ((U = `# \u63A5\u7D9A\u30BB\u30C3\u30B7\u30E7\u30F3\u306E\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\uFF08\u5FA9\u5143\u7528\uFF09

**\u6CE8\u610F**: \u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u304C\u5909\u66F4\u3055\u308C\u307E\u3057\u305F\u3002/clear \u3092\u5B9F\u884C\u5F8C\u3001\u3053\u306E\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u304C\u81EA\u52D5\u7684\u306B\u5FA9\u5143\u3055\u308C\u307E\u3059\u3002

${B.join(`
---

`)}`),
        pR(G, U, !1));
  } catch ($) {
    console.error("[edges] Failed to save remaining context:", $);
  }
  try {
    Xk(Y, U);
  } catch ($) {
    console.error("[edges] Failed to emit edge_deleted event:", $);
  }
  return X.body(null, 204);
});
IX.get("/by-target/:claudeSessionId", async (X) => {
  let Y = X.req.param("claudeSessionId"),
    Q = dR(Y);
  return X.json({
    targetClaudeSessionId: Y,
    edges: Q,
    sourceSessionIds: Q.map((G) => G.sourceSessionId),
  });
});
IX.get("/by-source/:sessionId", async (X) => {
  let Y = X.req.param("sessionId"),
    Q = Mk(Y);
  return X.json({
    sourceSessionId: Y,
    edges: Q,
    targetClaudeSessionIds: Q.map((G) => G.targetClaudeSessionId),
  });
});
import { existsSync as A9, mkdirSync as Ok, copyFileSync as s90 } from "fs";
import { join as l5, basename as t90 } from "path";
import { homedir as e90 } from "os";
import {
  existsSync as YY,
  readFileSync as UG,
  readdirSync as Dk,
  statSync as zk,
} from "fs";
import { join as iR, basename as r90 } from "path";
function o90(X) {
  let Y = { name: "", description: "", allowedTools: [] },
    Q = X.match(/^---\s*\n([\s\S]*?)\n---/);
  if (!Q) return Y;
  let G = Q[1],
    J = G.match(/^name:\s*(.+)$/m);
  if (J) Y.name = J[1].trim();
  let U = G.match(/^description:\s*(.+)$/m);
  if (U) Y.description = U[1].trim();
  let $ = G.match(/^allowed-tools:\s*(.+)$/m);
  if ($)
    Y.allowedTools = $[1]
      .split(",")
      .map((B) => B.trim())
      .filter((B) => B.length > 0);
  return Y;
}
async function _$(X, Y) {
  let Q = [];
  try {
    if (!YY(X)) return Q;
    let G = Dk(X);
    for (let J of G) {
      let U = iR(X, J);
      if (!zk(U).isDirectory()) continue;
      let $ = iR(U, "SKILL.md");
      if (!YY($)) continue;
      try {
        let B = UG($, "utf-8"),
          K = o90(B);
        Q.push({
          name: K.name || J,
          description: K.description,
          source: Y,
          path: $,
          allowedTools: K.allowedTools.length > 0 ? K.allowedTools : void 0,
        });
      } catch (B) {
        console.warn(`Failed to read skill at ${$}:`, B);
      }
    }
  } catch (G) {
    console.warn(`Failed to read skills from ${X}:`, G);
  }
  return Q;
}
async function nR(X, Y) {
  let Q = [];
  try {
    if (!YY(X)) return Q;
    let G = UG(X, "utf-8"),
      J = JSON.parse(G);
    if (!J.hooks) return Q;
    for (let [U, $] of Object.entries(J.hooks)) {
      if (!Array.isArray($)) continue;
      for (let B of $) {
        let K = B;
        if (!K.hooks || !Array.isArray(K.hooks)) continue;
        for (let V of K.hooks)
          if (V.type === "command" && V.command)
            Q.push({
              event: U,
              source: Y,
              matcher: K.matcher,
              command: V.command,
              timeout: V.timeout,
            });
      }
    }
  } catch (G) {
    console.warn(`Failed to read hooks from ${X}:`, G);
  }
  return Q;
}
async function Ek(X, Y) {
  let Q = [];
  try {
    if (!YY(X)) return Q;
    let G = UG(X, "utf-8"),
      J = JSON.parse(G);
    if (!J.hooks) return Q;
    for (let [U, $] of Object.entries(J.hooks)) {
      if (!Array.isArray($)) continue;
      for (let B of $) {
        let K = B;
        if (!K.hooks || !Array.isArray(K.hooks)) continue;
        for (let V of K.hooks)
          if (V.type === "command" && V.command)
            Q.push({
              event: U,
              source: Y,
              matcher: K.matcher,
              command: V.command,
              timeout: V.timeout,
            });
      }
    }
  } catch (G) {
    console.warn(`Failed to read hooks from ${X}:`, G);
  }
  return Q;
}
async function aR(X, Y) {
  let Q = [];
  try {
    if (!YY(X)) return Q;
    let G = UG(X, "utf-8"),
      J = JSON.parse(G);
    if (!J.mcpServers || typeof J.mcpServers !== "object") return Q;
    for (let [U, $] of Object.entries(J.mcpServers)) {
      let B = $;
      if (B.command)
        Q.push({
          name: U,
          source: Y,
          command: B.command,
          args: B.args,
          env: B.env,
        });
    }
  } catch (G) {
    console.warn(`Failed to read MCP servers from ${X}:`, G);
  }
  return Q;
}
async function rR(X, Y) {
  let Q = [],
    G = 1000;
  try {
    if (!YY(X)) return Q;
    let J = Dk(X);
    for (let U of J) {
      if (!U.endsWith(".md")) continue;
      let $ = iR(X, U);
      if (!zk($).isFile()) continue;
      try {
        let B = UG($, "utf-8");
        if (B.length > 1000) B = B.substring(0, 1000) + "...";
        Q.push({ name: r90($), source: Y, path: $, content: B });
      } catch (B) {
        console.warn(`Failed to read rule at ${$}:`, B);
      }
    }
  } catch (J) {
    console.warn(`Failed to read rules from ${X}:`, J);
  }
  return Q;
}
function LG() {
  return l5(e90(), ".claude");
}
function f$(X) {
  let Y = l5(X, ".claude");
  if (A9(Y)) return Y;
  return null;
}
function x$(X) {
  let Y = l5(X, "plugin", ".claude-plugin");
  if (A9(Y)) return Y;
  return null;
}
function r6(X, Y) {
  if (!Y || Y === "all") return !0;
  return X === Y;
}
async function Zk(X = {}) {
  let Y = X.projectPath || process.cwd(),
    Q = X.source || "all",
    G = LG(),
    J = f$(Y),
    U = x$(Y),
    [$, B, K, V] = await Promise.all([
      oR({ projectPath: Y, source: Q }),
      sR({ projectPath: Y, source: Q }),
      tR({ projectPath: Y, source: Q }),
      eR({ projectPath: Y, source: Q }),
    ]),
    W = {
      globalPath: G,
      projectPath: J,
      pluginPath: U,
      scannedAt: new Date().toISOString(),
    };
  return { skills: $, hooks: B, mcpServers: K, rules: V, metadata: W };
}
async function oR(X = {}) {
  let Y = X.projectPath || process.cwd(),
    Q = X.source || "all",
    G = [];
  if (r6("global", Q)) {
    let J = LG(),
      U = l5(J, "skills"),
      $ = await _$(U, "global");
    G.push(...$);
  }
  if (r6("project", Q)) {
    let J = f$(Y);
    if (J) {
      let U = l5(J, "skills"),
        $ = await _$(U, "project");
      G.push(...$);
    }
  }
  if (r6("plugin", Q)) {
    let J = x$(Y);
    if (J) {
      let U = l5(J, "..", "skills");
      if (A9(U)) {
        let $ = await _$(U, "plugin");
        G.push(...$);
      }
    }
  }
  return G;
}
async function sR(X = {}) {
  let Y = X.projectPath || process.cwd(),
    Q = X.source || "all",
    G = [];
  if (r6("global", Q)) {
    let J = LG(),
      U = l5(J, "settings.json"),
      $ = await nR(U, "global");
    G.push(...$);
  }
  if (r6("project", Q)) {
    let J = f$(Y);
    if (J) {
      let U = l5(J, "settings.json"),
        $ = await nR(U, "project");
      G.push(...$);
    }
  }
  if (r6("plugin", Q)) {
    let J = x$(Y);
    if (J) {
      let U = l5(J, "hooks", "hooks.json"),
        $ = await Ek(U, "plugin");
      G.push(...$);
    }
  }
  return G;
}
async function tR(X = {}) {
  let Y = X.projectPath || process.cwd(),
    Q = X.source || "all",
    G = [];
  if (Q === "project") return G;
  if (r6("global", Q)) {
    let J = LG(),
      U = l5(J, "mcp.json"),
      $ = await aR(U, "global");
    G.push(...$);
  }
  if (r6("plugin", Q)) {
    let J = x$(Y);
    if (J) {
      let U = l5(J, "plugin.json"),
        $ = await aR(U, "plugin");
      G.push(...$);
    }
  }
  return G;
}
async function eR(X = {}) {
  let Y = X.projectPath || process.cwd(),
    Q = X.source || "all",
    G = [];
  if (Q === "plugin") return G;
  if (r6("global", Q)) {
    let J = LG(),
      U = l5(J, "rules"),
      $ = await rR(U, "global");
    G.push(...$);
    let B = l5(J, "CLAUDE.md");
    if (A9(B))
      try {
        let { readFileSync: K } = await import("fs"),
          V = K(B, "utf-8");
        if (V.length > 1000) V = V.substring(0, 1000) + "...";
        G.push({ name: "CLAUDE.md", source: "global", path: B, content: V });
      } catch {}
  }
  if (r6("project", Q)) {
    let J = f$(Y);
    if (J) {
      let U = l5(J, "rules"),
        $ = await rR(U, "project");
      G.push(...$);
    }
  }
  return G;
}
async function jk(X) {
  let { items: Y, targetProjectPath: Q } = X,
    G = [],
    J = 0,
    U = 0,
    $ = l5(Q, ".claude");
  if (!A9($)) Ok($, { recursive: !0 });
  for (let B of Y)
    try {
      if (!A9(B.sourcePath)) {
        (G.push({
          name: B.name,
          success: !1,
          error:
            "\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093",
        }),
          U++);
        continue;
      }
      let K;
      switch (B.type) {
        case "skills":
          K = l5($, "skills");
          break;
        case "rules":
          K = l5($, "rules");
          break;
        case "hooks":
        case "mcp":
          (G.push({
            name: B.name,
            success: !1,
            error: `${B.type} \u306E\u30B3\u30D4\u30FC\u306F\u73FE\u5728\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093`,
          }),
            U++);
          continue;
        default:
          (G.push({
            name: B.name,
            success: !1,
            error: "\u4E0D\u660E\u306A\u30BF\u30A4\u30D7\u3067\u3059",
          }),
            U++);
          continue;
      }
      if (!A9(K)) Ok(K, { recursive: !0 });
      let V = t90(B.sourcePath),
        W = l5(K, V);
      if (A9(W)) {
        (G.push({
          name: B.name,
          success: !1,
          error:
            "\u540C\u540D\u306E\u30D5\u30A1\u30A4\u30EB\u304C\u65E2\u306B\u5B58\u5728\u3057\u307E\u3059",
        }),
          U++);
        continue;
      }
      (s90(B.sourcePath, W), G.push({ name: B.name, success: !0 }), J++);
    } catch (K) {
      (G.push({
        name: B.name,
        success: !1,
        error:
          K instanceof Error
            ? K.message
            : "\u30B3\u30D4\u30FC\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
      }),
        U++);
    }
  return { copied: J, failed: U, details: G };
}
var XX0 = X0.object({
    items: X0.array(
      X0.object({
        type: X0.enum(["skills", "hooks", "mcp", "rules"]),
        sourcePath: X0.string(),
        name: X0.string(),
      })
    ),
    targetProjectPath: X0.string(),
  }),
  q9 = new c1();
q9.get(
  "/",
  s0("query", rX, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("query"),
      Q = await Zk({ projectPath: Y.projectPath, source: Y.source });
    return X.json(Q);
  }
);
q9.get(
  "/skills",
  s0("query", rX, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("query"),
      Q = await oR({ projectPath: Y.projectPath, source: Y.source });
    return X.json({ skills: Q });
  }
);
q9.get(
  "/hooks",
  s0("query", rX, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("query"),
      Q = await sR({ projectPath: Y.projectPath, source: Y.source });
    return X.json({ hooks: Q });
  }
);
q9.get(
  "/mcp",
  s0("query", rX, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("query"),
      Q = await tR({ projectPath: Y.projectPath, source: Y.source });
    return X.json({ mcpServers: Q });
  }
);
q9.get(
  "/rules",
  s0("query", rX, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("query"),
      Q = await eR({ projectPath: Y.projectPath, source: Y.source });
    return X.json({ rules: Q });
  }
);
q9.post(
  "/copy",
  s0("json", XX0, (X, Y) => {
    if (!X.success)
      return Y.json(
        { error: "Validation Error", details: X.error.flatten().fieldErrors },
        400
      );
  }),
  async (X) => {
    let Y = X.req.valid("json");
    try {
      let Q = await jk({
        items: Y.items,
        targetProjectPath: Y.targetProjectPath,
      });
      return X.json(Q);
    } catch (Q) {
      return X.json(
        {
          error:
            Q instanceof Error
              ? Q.message
              : "\u30B3\u30D4\u30FC\u306B\u5931\u6557\u3057\u307E\u3057\u305F",
        },
        500
      );
    }
  }
);
var __dirname = "/Users/kazuto/Desktop/claude-cnthub/packages/api/src",
  h$ = (() => {
    if (process.env.CLAUDE_PLUGIN_ROOT)
      return BG(g$(process.env.CLAUDE_PLUGIN_ROOT, "ui"));
    let X = BG(g$(__dirname, "../ui"));
    if (XD(X)) return X;
    return BG(g$(__dirname, "../../../plugin/ui"));
  })();
function YX0() {
  let X = new c1();
  if (
    (X.use(
      "*",
      iD({
        origin: ["http://localhost:5173", "http://localhost:3000"],
        credentials: !0,
      })
    ),
    X.use("*", Vz({ enabled: !0, timestamp: !0 })),
    X.use("*", Lz()),
    X.get("/health", (Y) => {
      return Y.json({ status: "ok", timestamp: new Date().toISOString() });
    }),
    X.route("/api/sessions", V8),
    X.route("/api/memory", QG),
    X.route("/api/search", cv),
    X.route("/hook", OX),
    X.route("/api/merges", ZX),
    X.route("/api/memories", M9),
    X.route("/memories", $G),
    X.route("/api/projects", wX),
    X.route("/api/inject", CX),
    X.route("/api/edges", IX),
    X.route("/api/system-context", q9),
    XD(h$))
  )
    (X.use(
      "/viewer/assets/*",
      QU({ root: h$, rewriteRequestPath: (Y) => Y.replace(/^\/viewer/, "") })
    ),
      X.get("/viewer", (Y) => {
        return Y.redirect("/viewer/");
      }),
      X.get("/viewer/*", async (Y) => {
        let Q = g$(h$, "index.html"),
          G = BG(Q);
        if (!G.startsWith(BG(h$))) return Y.notFound();
        if (XD(G)) {
          let J = Bun.file(G);
          return new Response(J, { headers: { "Content-Type": "text/html" } });
        }
        return Y.notFound();
      }));
  return (X.notFound(Bz), X);
}
var wk = YX0();
try {
  (uz(), console.log("[Database] Migrations completed successfully"));
} catch (X) {
  (console.error("[Database] Migration failed:", X),
    console.error("Server cannot start without valid database"),
    process.exit(1));
}
var Ck = 2,
  QX0 = 900000;
try {
  let X = NU(Ck);
  if (X > 0) console.log(`[Cleanup] Cleaned up ${X} timed out sessions`);
} catch (X) {
  console.warn("[Cleanup] Initial cleanup failed:", X);
}
setInterval(() => {
  try {
    let X = NU(Ck);
    if (X > 0) console.log(`[Cleanup] Cleaned up ${X} timed out sessions`);
  } catch (X) {
    console.warn("[Cleanup] Periodic cleanup failed:", X);
  }
}, QX0);
console.log(`
\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557
\u2551       claude-cnthub API Server            \u2551
\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563
\u2551  Status:    Running                       \u2551
\u2551  Port:      ${String(a6.api.port).padEnd(27)}\u2551
\u2551  Health:    http://localhost:${a6.api.port}/health  \u2551
\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D
`);
var KA0 = {
  port: a6.api.port,
  idleTimeout: 120,
  fetch(X, Y) {
    if (new URL(X.url).pathname === "/ws") {
      let G = X.headers.get("origin");
      if (G && !a6.websocket.allowedOrigins.includes(G))
        return (
          console.warn(
            `[WebSocket] Rejected connection from unauthorized origin: ${G}`
          ),
          new Response("Forbidden: Invalid origin", { status: 403 })
        );
      if (Y.upgrade(X, { data: { clientId: "" } })) return;
      return new Response("WebSocket upgrade failed", { status: 500 });
    }
    return wk.fetch(X, Y);
  },
  websocket: sv,
};
export { KA0 as default };
